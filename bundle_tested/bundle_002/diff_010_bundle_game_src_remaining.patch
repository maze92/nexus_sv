diff --git a/server/metin2/Source/Server/game/src/DragonSoul.cpp b/server/metin2/Source/Server/game/src/DragonSoul.cpp
index 134bb4e..3d9a660 100644
--- a/server/metin2/Source/Server/game/src/DragonSoul.cpp
+++ b/server/metin2/Source/Server/game/src/DragonSoul.cpp
@@ -1,1420 +1,1420 @@
-#include "stdafx.h"
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-#include "constants.h"
-#include "item.h"
-#include "item_manager.h"
-#include "unique_item.h"
-#include "packet.h"
-#include "desc.h"
-#include "char.h"
-#include "dragon_soul_table.h"
-#include "log.h"
-#include "DragonSoul.h"
-
-typedef std::vector<std::string> TTokenVector;
-
-template <typename T> T MINMAX(T min, T value, T max)
-{
-	T tv;
-
-	tv = (min > value ? min : value);
-	return (max < tv) ? max : tv;
-}
-
-int Gamble(std::vector<float>& vec_probs)
-{
-	float range = 0.f;
-	for (int i = 0; i < vec_probs.size(); i++)
-	{
-		range += vec_probs[i];
-	}
-	float fProb = fnumber(0.f, range);
-	float sum = 0.f;
-	for (int idx = 0; idx < vec_probs.size(); idx++)
-	{
-		sum += vec_probs[idx];
-		if (sum >= fProb)
-			return idx;
-	}
-	return -1;
-}
-
-// 가중치 테이블(prob_lst)을 받아 random_set.size()개의 index를 선택하여 random_set을 return
-bool MakeDistinctRandomNumberSet(std::list <float> prob_lst, OUT std::vector<int>& random_set)
-{
-	int size = prob_lst.size();
-	int n = random_set.size();
-	if (size < n)
-		return false;
-
-	std::vector <int> select_bit(size, 0);
-	for (int i = 0; i < n; i++)
-	{
-		float range = 0.f;
-		for (std::list <float>::iterator it = prob_lst.begin(); it != prob_lst.end(); ++it)
-		{
-			range += *it;
-		}
-		float r = fnumber(0.f, range);
-		float sum = 0.f;
-		int idx = 0;
-		for (std::list <float>::iterator it = prob_lst.begin(); it != prob_lst.end(); ++it)
-		{
-			while (select_bit[idx++]);
-
-			sum += *it;
-			if (sum >= r)
-			{
-				select_bit[idx - 1] = 1;
-				random_set[i] = idx - 1;
-				prob_lst.erase(it);
-				break;
-			}
-		}
-	}
-	return true;
-}
-
-/* 용혼석 Vnum에 대한 comment
- * ITEM VNUM을 10만 자리부터, FEDCBA라고 한다면
- * FE : 용혼석 종류.	D : 등급
- * C : 단계			B : 강화
- * A : 여벌의 번호들...
- */
-
-BYTE GetType(DWORD dwVnum)
-{
-	return BYTE(dwVnum / 10000);
-}
-
-BYTE GetGradeIdx(DWORD dwVnum)
-{
-	return (dwVnum / 1000) % 10;
-}
-
-BYTE GetStepIdx(DWORD dwVnum)
-{
-	return (dwVnum / 100) % 10;
-}
-
-BYTE GetStrengthIdx(DWORD dwVnum)
-{
-	return (dwVnum / 10) % 10;
-}
-
-bool DSManager::HasActivedAllSlotsByPage(const LPCHARACTER ch, const BYTE bPageIndex) const
-{
-	if (!ch || bPageIndex >= DRAGON_SOUL_DECK_MAX_NUM)
-		return false;
-
-	const WORD wDragonSoulDeckAffectType = AFFECT_DRAGON_SOUL_DECK_0 + bPageIndex; // 540 + [0 or 1]
-	if (!ch->FindAffect(wDragonSoulDeckAffectType))
-		return false;
-
-	// start : 32 + ([0 or 1] * 6) = [32 or 38]
-	// end : start + 6
-	const BYTE iStartIndex = WEAR_MAX_NUM + (bPageIndex * DS_SLOT_MAX);
-	const BYTE iEndIndex = iStartIndex + DS_SLOT_MAX;
-
-	BYTE bSlotActive = 0;
-	for (BYTE bCell = iStartIndex; bCell < iEndIndex; ++bCell) // {0: 32-38, 1: 38-44}
-	{
-		const LPITEM pkItem = ch->GetWear(bCell);
-		if (pkItem && pkItem->IsDragonSoul())
-		{
-			if (IsTimeLeftDragonSoul(pkItem) && IsActiveDragonSoul(pkItem))
-				++bSlotActive;
-		}
-	}
-
-	return (bSlotActive == DS_SLOT_MAX);
-}
-
-bool DSManager::ReadDragonSoulTableFile(const char* c_pszFileName)
-{
-	m_pTable = new DragonSoulTable();
-	return m_pTable->ReadDragonSoulTableFile(c_pszFileName);
-}
-
-void DSManager::GetDragonSoulInfo(DWORD dwVnum, BYTE& bType, BYTE& bGrade, BYTE& bStep, BYTE& bStrength) const
-{
-	bType = GetType(dwVnum);
-	bGrade = GetGradeIdx(dwVnum);
-	bStep = GetStepIdx(dwVnum);
-	bStrength = GetStrengthIdx(dwVnum);
-}
-
-bool DSManager::IsValidCellForThisItem(const LPITEM pItem, const TItemPos& Cell) const
-{
-	if (NULL == pItem)
-		return false;
-
-	WORD wBaseCell = GetBasePosition(pItem);
-	if (WORD_MAX == wBaseCell)
-		return false;
-
-	if (Cell.window_type != DRAGON_SOUL_INVENTORY
-		|| (Cell.cell < wBaseCell || Cell.cell >= wBaseCell + DRAGON_SOUL_BOX_SIZE))
-	{
-		return false;
-	}
-	else
-		return true;
-
-}
-
-WORD DSManager::GetBasePosition(const LPITEM pItem) const
-{
-	if (NULL == pItem)
-		return WORD_MAX;
-
-	BYTE type, grade_idx, step_idx, strength_idx;
-	GetDragonSoulInfo(pItem->GetVnum(), type, grade_idx, step_idx, strength_idx);
-
-	BYTE col_type = pItem->GetSubType();
-	BYTE row_type = grade_idx;
-	if (row_type > DRAGON_SOUL_GRADE_MAX)
-		return WORD_MAX;
-
-#if defined(__DS_GRADE_MYTH__)
-	return col_type * DRAGON_SOUL_GRADE_MAX * DRAGON_SOUL_BOX_SIZE + row_type * DRAGON_SOUL_BOX_SIZE;
-#else
-	return col_type * DRAGON_SOUL_STEP_MAX * DRAGON_SOUL_BOX_SIZE + row_type * DRAGON_SOUL_BOX_SIZE;
-#endif
-}
-
-bool DSManager::RefreshItemAttributes(LPITEM pDS)
-{
-	if (!pDS->IsDragonSoul())
-	{
-		sys_err("This item(ID : %d) is not DragonSoul.", pDS->GetID());
-		return false;
-	}
-
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	GetDragonSoulInfo(pDS->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
-
-	DragonSoulTable::TVecApplys vec_basic_applys;
-	DragonSoulTable::TVecApplys vec_addtional_applys;
-
-	if (!m_pTable->GetBasicApplys(ds_type, vec_basic_applys))
-	{
-		sys_err("There is no BasicApply about %d type dragon soul.", ds_type);
-		return false;
-	}
-
-	if (!m_pTable->GetAdditionalApplys(ds_type, vec_addtional_applys))
-	{
-		sys_err("There is no AdditionalApply about %d type dragon soul.", ds_type);
-		return false;
-	}
-
-	// add_min과 add_max는 더미로 읽음.
-	int basic_apply_num, add_min, add_max;
-	if (!m_pTable->GetApplyNumSettings(ds_type, grade_idx, basic_apply_num, add_min, add_max))
-	{
-		sys_err("In ApplyNumSettings, INVALID VALUES Group type(%d), GRADE idx(%d)", ds_type, grade_idx);
-		return false;
-	}
-
-	float fWeight = 0.f;
-	if (!m_pTable->GetWeight(ds_type, grade_idx, step_idx, strength_idx, fWeight))
-	{
-		return false;
-	}
-	fWeight /= 100.f;
-
-	int n = MIN(basic_apply_num, vec_basic_applys.size());
-	for (int i = 0; i < n; i++)
-	{
-		const SApply& basic_apply = vec_basic_applys[i];
-		BYTE bType = basic_apply.apply_type;
-		short sValue = (short)(ceil((float)basic_apply.apply_value * fWeight - 0.01f));
-
-		pDS->SetForceAttribute(i, bType, sValue);
-	}
-
-	for (int i = DRAGON_SOUL_ADDITIONAL_ATTR_START_IDX; i < ITEM_ATTRIBUTE_MAX_NUM; i++)
-	{
-		BYTE bType = pDS->GetAttributeType(i);
-		short sValue = 0;
-		if (APPLY_NONE == bType)
-			continue;
-		for (int j = 0; j < vec_addtional_applys.size(); j++)
-		{
-			if (vec_addtional_applys[j].apply_type == bType)
-			{
-				sValue = vec_addtional_applys[j].apply_value;
-				break;
-			}
-		}
-		pDS->SetForceAttribute(i, bType, (short)(ceil((float)sValue * fWeight - 0.01f)));
-	}
-	return true;
-}
-
-bool DSManager::PutAttributes(LPITEM pDS)
-{
-	if (!pDS->IsDragonSoul())
-	{
-		sys_err("This item(ID : %d) is not DragonSoul.", pDS->GetID());
-		return false;
-	}
-
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	GetDragonSoulInfo(pDS->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
-
-	DragonSoulTable::TVecApplys vec_basic_applys;
-	DragonSoulTable::TVecApplys vec_addtional_applys;
-
-	if (!m_pTable->GetBasicApplys(ds_type, vec_basic_applys))
-	{
-		sys_err("There is no BasicApply about %d type dragon soul.", ds_type);
-		return false;
-	}
-	if (!m_pTable->GetAdditionalApplys(ds_type, vec_addtional_applys))
-	{
-		sys_err("There is no AdditionalApply about %d type dragon soul.", ds_type);
-		return false;
-	}
-
-	int basic_apply_num, add_min, add_max;
-	if (!m_pTable->GetApplyNumSettings(ds_type, grade_idx, basic_apply_num, add_min, add_max))
-	{
-		sys_err("In ApplyNumSettings, INVALID VALUES Group type(%d), GRADE idx(%d)", ds_type, grade_idx);
-		return false;
-	}
-
-	float fWeight = 0.f;
-	if (!m_pTable->GetWeight(ds_type, grade_idx, step_idx, strength_idx, fWeight))
-	{
-		return false;
-	}
-	fWeight /= 100.f;
-
-	int n = MIN(basic_apply_num, vec_basic_applys.size());
-	for (int i = 0; i < n; i++)
-	{
-		const SApply& basic_apply = vec_basic_applys[i];
-		BYTE bType = basic_apply.apply_type;
-		short sValue = (short)(ceil((float)basic_apply.apply_value * fWeight - 0.01f));
-
-		pDS->SetForceAttribute(i, bType, sValue);
-	}
-
-	BYTE additional_attr_num = MIN(number(add_min, add_max), 3);
-
-	std::vector <int> random_set;
-	if (additional_attr_num > 0)
-	{
-		random_set.resize(additional_attr_num);
-		std::list <float> list_probs;
-		for (int i = 0; i < vec_addtional_applys.size(); i++)
-		{
-			list_probs.push_back(vec_addtional_applys[i].prob);
-		}
-		if (!MakeDistinctRandomNumberSet(list_probs, random_set))
-		{
-			sys_err("MakeDistinctRandomNumberSet error.");
-			return false;
-		}
-
-		for (int i = 0; i < additional_attr_num; i++)
-		{
-			int r = random_set[i];
-			const SApply& additional_attr = vec_addtional_applys[r];
-			BYTE bType = additional_attr.apply_type;
-			short sValue = (short)(ceil((float)additional_attr.apply_value * fWeight - 0.01f));
-
-			pDS->SetForceAttribute(DRAGON_SOUL_ADDITIONAL_ATTR_START_IDX + i, bType, sValue);
-		}
-	}
-
-	return true;
-}
-
-bool DSManager::DragonSoulItemInitialize(LPITEM pItem)
-{
-	if (NULL == pItem || !pItem->IsDragonSoul())
-		return false;
-	PutAttributes(pItem);
-	int time = DSManager::instance().GetDuration(pItem);
-	if (time > 0)
-		pItem->SetSocket(ITEM_SOCKET_REMAIN_SEC, time);
-	return true;
-}
-
-DWORD DSManager::MakeDragonSoulVnum(BYTE bType, BYTE grade, BYTE step, BYTE refine)
-{
-	return bType * 10000 + grade * 1000 + step * 100 + refine * 10;
-}
-
-int DSManager::GetDuration(const LPITEM pItem) const
-{
-	return pItem->GetDuration();
-}
-
-// 용혼석을 받아서 용심을 추출하는 함수
-bool DSManager::ExtractDragonHeart(LPCHARACTER ch, LPITEM pItem, LPITEM pExtractor)
-{
-	if (NULL == ch || NULL == pItem)
-		return false;
-
-	if (pItem->IsEquipped())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("착용 중인 용혼석은 추출할 수 없습니다."));
-		return false;
-	}
-
-	DWORD dwVnum = pItem->GetVnum();
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
-
-	int iBonus = 0;
-
-	if (NULL != pExtractor)
-	{
-		iBonus = pExtractor->GetValue(0);
-	}
-
-	std::vector <float> vec_chargings;
-	std::vector <float> vec_probs;
-
-	if (!m_pTable->GetDragonHeartExtValues(ds_type, grade_idx, vec_chargings, vec_probs))
-	{
-		return false;
-	}
-
-	int idx = Gamble(vec_probs);
-
-	float sum = 0.f;
-	if (-1 == idx)
-	{
-		sys_err("Gamble is failed. ds_type(%d), grade_idx(%d)", ds_type, grade_idx);
-		return false;
-	}
-
-	float fCharge = vec_chargings[idx] * (100 + iBonus) / 100.f;
-	fCharge = MINMAX <float>(0.f, fCharge, 100.f);
-
-	if (fCharge < FLT_EPSILON)
-	{
-		pItem->SetCount(pItem->GetCount() - 1);
-		if (NULL != pExtractor)
-		{
-			pExtractor->SetCount(pExtractor->GetCount() - 1);
-		}
-		LogManager::instance().ItemLog(ch, pItem, "DS_HEART_EXTRACT_FAIL", "");
-
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("용심 추출에 실패하였습니다."));
-		return false;
-	}
-	else
-	{
-		LPITEM pDH = ITEM_MANAGER::instance().CreateItem(ITEM_DRAGON_HEART_VNUM);
-
-		if (NULL == pDH)
-		{
-			sys_err("Cannot create DRAGON_HEART(%d).", ITEM_DRAGON_HEART_VNUM);
-			return false;
-		}
-
-		pItem->SetCount(pItem->GetCount() - 1);
-		if (NULL != pExtractor)
-		{
-			pExtractor->SetCount(pExtractor->GetCount() - 1);
-		}
-
-		int iCharge = (int)(fCharge + 0.5f);
-		pDH->SetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX, iCharge);
-		ch->AutoGiveItem(pDH, true);
-
-		std::string s = std::to_string(iCharge);
-		s += "%s";
-		LogManager::instance().ItemLog(ch, pItem, "DS_HEART_EXTRACT_SUCCESS", s.c_str());
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("용심 추출에 성공하였습니다."));
-		return true;
-	}
-}
-
-// 특정 용혼석을 장비창에서 제거할 때에 성공 여부를 결정하고, 실패시 부산물을 주는 함수.
-bool DSManager::PullOut(LPCHARACTER ch, TItemPos DestCell, LPITEM& pItem, LPITEM pExtractor)
-{
-	if (NULL == ch || NULL == pItem)
-	{
-		sys_err("NULL POINTER. ch(%p) or pItem(%p)", ch, pItem);
-		return false;
-	}
-
-	// 목표 위치가 valid한지 검사 후, valid하지 않다면 임의의 빈 공간을 찾는다.
-	if (!IsValidCellForThisItem(pItem, DestCell) || ch->GetItem(DestCell))
-	{
-		int iEmptyCell = ch->GetEmptyDragonSoulInventory(pItem);
-		if (iEmptyCell < 0)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-			return false;
-		}
-		else
-		{
-			DestCell.window_type = DRAGON_SOUL_INVENTORY;
-			DestCell.cell = iEmptyCell;
-		}
-	}
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (pItem->IsSealed())
-		return false;
-#endif
-
-	if (!pItem->IsEquipped() || !pItem->RemoveFromCharacter())
-		return false;
-
-	bool bSuccess;
-	DWORD dwByProduct = 0;
-	int iBonus = 0;
-	float fProb;
-	float fDice;
-
-	// 용혼석 추출 성공 여부 결정.
-	{
-		// DWORD dwVnum = pItem->GetVnum();
-
-		BYTE ds_type, grade_idx, step_idx, strength_idx;
-		GetDragonSoulInfo(pItem->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
-
-		// 추출 정보가 없다면 일단 무조건 성공하는 것이라 생각하자.
-		if (!m_pTable->GetDragonSoulExtValues(ds_type, grade_idx, fProb, dwByProduct))
-		{
-			pItem->AddToCharacter(ch, DestCell);
-			return true;
-		}
-
-		if (NULL != pExtractor)
-		{
-			iBonus = pExtractor->GetValue(ITEM_VALUE_DRAGON_SOUL_POLL_OUT_BONUS_IDX);
-			pExtractor->SetCount(pExtractor->GetCount() - 1);
-		}
-
-		fDice = fnumber(0.f, 100.f);
-		bSuccess = fDice <= (fProb * (100 + iBonus) / 100.f);
-	}
-
-	// 캐릭터의 용혼석 추출 및 추가 혹은 제거. 부산물 제공.
-	{
-		char buf[128];
-		if (bSuccess)
-		{
-			if (pExtractor)
-				sprintf(buf, "dice(%d) prob(%d + %d) EXTR(VN:%d)", (int)fDice, (int)fProb, iBonus, pExtractor->GetVnum());
-			else
-				sprintf(buf, "dice(%d) prob(%d)", (int)fDice, (int)fProb);
-
-			LogManager::instance().ItemLog(ch, pItem, "DS_PULL_OUT_SUCCESS", buf);
-
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("용혼석 추출에 성공하였습니다."));
-			pItem->AddToCharacter(ch, DestCell);
-
-			return true;
-		}
-		else
-		{
-			if (pExtractor)
-				sprintf(buf, "dice(%d) prob(%d + %d) EXTR(VN:%d) ByProd(VN:%d)", (int)fDice, (int)fProb, iBonus, pExtractor->GetVnum(), dwByProduct);
-			else
-				sprintf(buf, "dice(%d) prob(%d) ByProd(VNUM:%d)", (int)fDice, (int)fProb, dwByProduct);
-
-			LogManager::instance().ItemLog(ch, pItem, "DS_PULL_OUT_FAILED", buf);
-
-			M2_DESTROY_ITEM(pItem);
-			pItem = NULL;
-
-			if (dwByProduct)
-			{
-				LPITEM pByProduct = ch->AutoGiveItem(dwByProduct, true);
-				if (pByProduct)
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("용혼석 추출에 실패하여 %s를 얻었습니다.", LC_ITEM(pByProduct->GetVnum())));
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("용혼석 추출에 실패하였습니다."));
-			}
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("용혼석 추출에 실패하였습니다."));
-		}
-	}
-
-	return bSuccess;
-}
-
-bool DSManager::DoRefineGrade(LPCHARACTER ch, TItemPos(&aItemPoses)[DRAGON_SOUL_REFINE_GRID_SIZE])
-{
-	if (NULL == ch)
-		return false;
-
-	if (NULL == aItemPoses)
-		return false;
-
-	if (!ch->DragonSoul_RefineWindow_CanRefine())
-	{
-		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", ch->GetName());
-		ch->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot upgrade dragon soul without refine window.");
-		return false;
-	}
-
-	// 혹시나 모를 중복되는 item pointer 없애기 위해서 set 사용
-	// 이상한 패킷을 보낼 경우, 중복된 TItemPos가 있을 수도 있고, 잘못된 TItemPos가 있을 수도 있다.
-	std::set <LPITEM> set_items;
-	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
-	{
-		if (aItemPoses[i].IsEquipPosition())
-			return false;
-
-		LPITEM pItem = ch->GetItem(aItemPoses[i]);
-		if (NULL != pItem)
-		{
-			// 용혼석이 아닌 아이템이 개량창에 있을 수 없다.
-			if (!pItem->IsDragonSoul())
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("등급 개량에 필요한 재료가 아닙니다."));
-				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-
-				return false;
-			}
-
-			set_items.insert(pItem);
-		}
-	}
-
-	if (set_items.empty())
-	{
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
-		return false;
-	}
-
-	int count = set_items.size();
-	int need_count = 0;
-	int fee = 0;
-	std::vector <float> vec_probs;
-	//float prob_sum;
-
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	int result_grade;
-
-	// 가장 처음 것을 강화의 기준으로 삼는다.
-	std::set <LPITEM>::iterator it = set_items.begin();
-	{
-		LPITEM pItem = *it;
-
-		GetDragonSoulInfo(pItem->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
-
-		if (!m_pTable->GetRefineGradeValues(ds_type, grade_idx, need_count, fee, vec_probs))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("등급 개량할 수 없는 용혼석입니다."));
-			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-
-			return false;
-		}
-	}
-	while (++it != set_items.end())
-	{
-		LPITEM pItem = *it;
-
-		// 클라 ui에서 장착한 아이템은 개량창에 올릴 수 없도록 막았기 때문에,
-		// 별도의 알림 처리는 안함.
-		if (pItem->IsEquipped())
-		{
-			return false;
-		}
-
-		if (ds_type != GetType(pItem->GetVnum()) || grade_idx != GetGradeIdx(pItem->GetVnum()))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("등급 개량에 필요한 재료가 아닙니다."));
-			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-
-			return false;
-		}
-	}
-
-	// 클라에서 한번 갯수 체크를 하기 때문에 count != need_count라면 invalid 클라일 가능성이 크다.
-	if (count != need_count)
-	{
-		sys_err("Possiblity of invalid client. Name %s", ch->GetName());
-		BYTE bSubHeader = count < need_count ? DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL : DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL;
-		SendRefineResultPacket(ch, bSubHeader, NPOS);
-		return false;
-	}
-
-	if (ch->GetGold() < fee)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 돈이 부족합니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
-		return false;
-	}
-
-	if (-1 == (result_grade = Gamble(vec_probs)))
-	{
-		sys_err("Gamble failed. See RefineGardeTables' probabilities");
-		return false;
-	}
-
-	LPITEM pResultItem = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(ds_type, (BYTE)result_grade, 0, 0));
-
-	if (NULL == pResultItem)
-	{
-		sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(ds_type, (BYTE)result_grade, 0, 0));
-		return false;
-	}
-
-	ch->PointChange(POINT_GOLD, -fee);
-	int left_count = need_count;
-
-	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
-	{
-		LPITEM pItem = *it;
-		int n = pItem->GetCount();
-		if (left_count > n)
-		{
-			pItem->RemoveFromCharacter();
-			M2_DESTROY_ITEM(pItem);
-			left_count -= n;
-		}
-		else
-		{
-			pItem->SetCount(n - left_count);
-		}
-	}
-
-	ch->AutoGiveItem(pResultItem, true);
-
-	if (result_grade > grade_idx)
-	{
-		char buf[128];
-		sprintf(buf, "GRADE : %d -> %d", grade_idx, result_grade);
-		LogManager::instance().ItemLog(ch, pResultItem, "DS_GRADE_REFINE_SUCCESS", buf);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("등급 개량에 성공했습니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_SUCCEED, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
-		return true;
-	}
-	else
-	{
-		char buf[128];
-		sprintf(buf, "GRADE : %d -> %d", grade_idx, result_grade);
-		LogManager::instance().ItemLog(ch, pResultItem, "DS_GRADE_REFINE_FAIL", buf);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("등급 개량에 실패했습니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
-		return false;
-	}
-}
-
-bool DSManager::DoRefineStep(LPCHARACTER ch, TItemPos(&aItemPoses)[DRAGON_SOUL_REFINE_GRID_SIZE])
-{
-	if (NULL == ch)
-		return false;
-	if (NULL == aItemPoses)
-	{
-		return false;
-	}
-
-	if (!ch->DragonSoul_RefineWindow_CanRefine())
-	{
-		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", ch->GetName());
-		ch->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot use dragon soul refine window.");
-		return false;
-	}
-
-	// 혹시나 모를 중복되는 item pointer 없애기 위해서 set 사용
-	// 이상한 패킷을 보낼 경우, 중복된 TItemPos가 있을 수도 있고, 잘못된 TItemPos가 있을 수도 있다.
-	std::set <LPITEM> set_items;
-	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
-	{
-		LPITEM pItem = ch->GetItem(aItemPoses[i]);
-		if (NULL != pItem)
-		{
-			// 용혼석이 아닌 아이템이 개량창에 있을 수 없다.
-			if (!pItem->IsDragonSoul())
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("단계 개량에 필요한 재료가 아닙니다."));
-				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-				return false;
-			}
-			set_items.insert(pItem);
-		}
-	}
-
-	if (set_items.empty())
-	{
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
-		return false;
-	}
-
-	//std::string stGroupName;
-	int count = set_items.size();
-	int need_count = 0;
-	int fee = 0;
-	std::vector <float> vec_probs;
-
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	int result_step;
-
-	// 가장 처음 것을 강화의 기준으로 삼는다.
-	std::set <LPITEM>::iterator it = set_items.begin();
-	{
-		LPITEM pItem = *it;
-		GetDragonSoulInfo(pItem->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
-
-		if (!m_pTable->GetRefineStepValues(ds_type, step_idx, need_count, fee, vec_probs))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("단계 개량할 수 없는 용혼석입니다."));
-			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-			return false;
-		}
-	}
-
-	while (++it != set_items.end())
-	{
-		LPITEM pItem = *it;
-		// 클라 ui에서 장착한 아이템은 개량창에 올릴 수 없도록 막았기 때문에,
-		// 별도의 알림 처리는 안함.
-		if (pItem->IsEquipped())
-		{
-			return false;
-		}
-		if (ds_type != GetType(pItem->GetVnum()) || grade_idx != GetGradeIdx(pItem->GetVnum()) || step_idx != GetStepIdx(pItem->GetVnum()))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("단계 개량에 필요한 재료가 아닙니다."));
-			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-			return false;
-		}
-	}
-
-	// 클라에서 한번 갯수 체크를 하기 때문에 count != need_count라면 invalid 클라일 가능성이 크다.
-	if (count != need_count)
-	{
-		sys_err("Possiblity of invalid client. Name %s", ch->GetName());
-		BYTE bSubHeader = count < need_count ? DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL : DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL;
-		SendRefineResultPacket(ch, bSubHeader, NPOS);
-		return false;
-	}
-
-	if (ch->GetGold() < fee)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 돈이 부족합니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
-		return false;
-	}
-
-	float sum = 0.f;
-
-	if (-1 == (result_step = Gamble(vec_probs)))
-	{
-		sys_err("Gamble failed. See RefineStepTables' probabilities");
-		return false;
-	}
-
-	LPITEM pResultItem = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(ds_type, grade_idx, (BYTE)result_step, 0));
-
-	if (NULL == pResultItem)
-	{
-		sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(ds_type, grade_idx, (BYTE)result_step, 0));
-		return false;
-	}
-
-	ch->PointChange(POINT_GOLD, -fee);
-	int left_count = need_count;
-	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
-	{
-		LPITEM pItem = *it;
-		int n = pItem->GetCount();
-		if (left_count > n)
-		{
-			pItem->RemoveFromCharacter();
-			M2_DESTROY_ITEM(pItem);
-			left_count -= n;
-		}
-		else
-		{
-			pItem->SetCount(n - left_count);
-		}
-	}
-
-	ch->AutoGiveItem(pResultItem, true);
-	if (result_step > step_idx)
-	{
-		char buf[128];
-		sprintf(buf, "STEP : %d -> %d", step_idx, result_step);
-		LogManager::instance().ItemLog(ch, pResultItem, "DS_STEP_REFINE_SUCCESS", buf);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("단계 개량에 성공했습니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_SUCCEED, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
-		return true;
-	}
-	else
-	{
-		char buf[128];
-		sprintf(buf, "STEP : %d -> %d", step_idx, result_step);
-		LogManager::instance().ItemLog(ch, pResultItem, "DS_STEP_REFINE_FAIL", buf);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("단계 개량에 실패했습니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
-		return false;
-	}
-}
-
-bool IsDragonSoulRefineMaterial(LPITEM pItem)
-{
-	if (pItem->GetType() != ITEM_MATERIAL)
-		return false;
-
-	return (pItem->GetSubType() == MATERIAL_DS_REFINE_NORMAL ||
-		pItem->GetSubType() == MATERIAL_DS_REFINE_BLESSED ||
-		pItem->GetSubType() == MATERIAL_DS_REFINE_HOLLY
-#if defined(__DS_CHANGE_ATTR__)
-		|| pItem->GetSubType() == MATERIAL_DS_CHANGE_ATTR
-#endif
-		);
-}
-
-bool DSManager::DoRefineStrength(LPCHARACTER ch, TItemPos(&aItemPoses)[DRAGON_SOUL_REFINE_GRID_SIZE])
-{
-	if (NULL == ch)
-		return false;
-
-	if (NULL == aItemPoses)
-		return false;
-
-	if (!ch->DragonSoul_RefineWindow_CanRefine())
-	{
-		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", ch->GetName());
-		ch->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot use dragon soul refine window.");
-		return false;
-	}
-
-	// 혹시나 모를 중복되는 item pointer 없애기 위해서 set 사용
-	// 이상한 패킷을 보낼 경우, 중복된 TItemPos가 있을 수도 있고, 잘못된 TItemPos가 있을 수도 있다.
-	std::set<LPITEM> set_items;
-	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
-	{
-		LPITEM pItem = ch->GetItem(aItemPoses[i]);
-		if (pItem)
-			set_items.insert(pItem);
-	}
-
-	if (set_items.empty())
-		return false;
-
-	int fee;
-
-	LPITEM pRefineStone = NULL;
-	LPITEM pDragonSoul = NULL;
-	for (std::set<LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
-	{
-		LPITEM pItem = *it;
-		// 클라 ui에서 장착한 아이템은 개량창에 올릴 수 없도록 막았기 때문에,
-		// 별도의 알림 처리는 안함.
-		if (pItem->IsEquipped())
-			return false;
-
-		// 용혼석과 강화석만이 개량창에 있을 수 있다.
-		// 그리고 하나씩만 있어야한다.
-		if (pItem->IsDragonSoul())
-		{
-			if (pDragonSoul != NULL)
-			{
-				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-				return false;
-			}
-			pDragonSoul = pItem;
-		}
-		else if (IsDragonSoulRefineMaterial(pItem))
-		{
-			if (pRefineStone != NULL)
-			{
-				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-				return false;
-			}
-			pRefineStone = pItem;
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화에 필요한 재료가 아닙니다."));
-			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
-			return false;
-		}
-	}
-
-	BYTE bType, bGrade, bStep, bStrength;
-	if (!pDragonSoul || !pRefineStone)
-	{
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
-		return false;
-	}
-
-	if (NULL != pDragonSoul)
-	{
-		GetDragonSoulInfo(pDragonSoul->GetVnum(), bType, bGrade, bStep, bStrength);
-
-		float fWeight = 0.f;
-		// 가중치 값이 없다면 강화할 수 없는 용혼석
-		if (!m_pTable->GetWeight(bType, bGrade, bStep, bStrength + 1, fWeight))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화할 수 없는 용혼석입니다."));
-			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE, TItemPos(pDragonSoul->GetWindow(), pDragonSoul->GetCell()));
-			return false;
-		}
-		// 강화했을 때 가중치가 0이라면 더 이상 강화되서는 안된다.
-		if (fWeight < FLT_EPSILON)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화할 수 없는 용혼석입니다."));
-			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE, TItemPos(pDragonSoul->GetWindow(), pDragonSoul->GetCell()));
-			return false;
-		}
-	}
-
-	float fProb;
-	if (!m_pTable->GetRefineStrengthValues(bType, pRefineStone->GetSubType(), bStrength, fee, fProb))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화할 수 없는 용혼석입니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pDragonSoul->GetWindow(), pDragonSoul->GetCell()));
-		return false;
-	}
-
-	if (ch->GetGold() < fee)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 돈이 부족합니다."));
-		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
-		return false;
-	}
-
-	ch->PointChange(POINT_GOLD, -fee);
-
-	LPITEM pResult = NULL;
-	BYTE bSubHeader;
-
-	if (fnumber(0.f, 100.f) <= fProb)
-	{
-		pResult = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(bType, bGrade, bStep, bStrength + 1));
-		if (NULL == pResult)
-		{
-			sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(bType, bGrade, bStep, bStrength + 1));
-			return false;
-		}
-
-		char buf[128];
-		sprintf(buf, "STRENGTH : %d -> %d", bStrength, bStrength + 1);
-		LogManager::instance().ItemLog(ch, pDragonSoul, "DS_STRENGTH_REFINE_SUCCESS", buf);
-
-		pDragonSoul->CopyAttributeTo(pResult);
-		RefreshItemAttributes(pResult);
-
-		ITEM_MANAGER::instance().RemoveItem(pDragonSoul, "REMOVE (DS_STRENGTH_REFINE_SUCCESS)");
-		pRefineStone->SetCount(pRefineStone->GetCount() - 1);
-
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화에 성공했습니다."));
-		ch->AutoGiveItem(pResult, true);
-
-		bSubHeader = DS_SUB_HEADER_REFINE_SUCCEED;
-	}
-	else
-	{
-		if (bStrength != 0)
-		{
-			pResult = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(bType, bGrade, bStep, bStrength - 1));
-			if (NULL == pResult)
-			{
-				sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(bType, bGrade, bStep, bStrength - 1));
-				return false;
-			}
-			pDragonSoul->CopyAttributeTo(pResult);
-			RefreshItemAttributes(pResult);
-		}
-		bSubHeader = DS_SUB_HEADER_REFINE_FAIL;
-
-		char buf[128];
-		sprintf(buf, "STRENGTH : %d -> %d", bStrength, bStrength - 1);
-		// strength강화는 실패시 깨질 수도 있어, 원본 아이템을 바탕으로 로그를 남김.
-		LogManager::instance().ItemLog(ch, pDragonSoul, "DS_STRENGTH_REFINE_FAIL", buf);
-
-		ITEM_MANAGER::instance().RemoveItem(pDragonSoul, "REMOVE (DS_STRENGTH_REFINE_FAIL)");
-		pRefineStone->SetCount(pRefineStone->GetCount() - 1);
-
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화에 실패했습니다."));
-
-		if (NULL != pResult)
-			ch->AutoGiveItem(pResult, true);
-	}
-
-	SendRefineResultPacket(ch, bSubHeader, NULL == pResult ? NPOS : TItemPos(pResult->GetWindow(), pResult->GetCell()));
-
-	return true;
-}
-
-#if defined(__DS_CHANGE_ATTR__)
-bool DSManager::DoChangeAttribute(LPCHARACTER lpCh, TItemPos(&arItemPos)[DRAGON_SOUL_REFINE_GRID_SIZE])
-{
-	if (lpCh == nullptr)
-		return false;
-
-	if (arItemPos == nullptr)
-		return false;
-
-	if (!lpCh->DragonSoul_RefineWindow_CanRefine())
-	{
-		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", lpCh->GetName());
-		lpCh->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot use dragon soul refine window.");
-		return false;
-	}
-
-	std::set<LPITEM> setItems;
-	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
-	{
-		LPITEM lpItem = lpCh->GetItem(arItemPos[i]);
-		if (lpItem)
-			setItems.insert(lpItem);
-	}
-	if (setItems.empty())
-		return false;
-
-	LPITEM lpRefineMaterial = nullptr;
-	LPITEM lpDragonSoul = nullptr;
-	for (auto lpItem : setItems)
-	{
-		if (lpItem->IsEquipped())
-			return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		if (lpItem->IsSealed())
-		{
-			lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-			return false;
-		}
-#endif
-
-		if (lpItem->IsDragonSoul())
-		{
-			if (lpDragonSoul != nullptr)
-			{
-				SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(lpItem->GetWindow(), lpItem->GetCell()));
-				return false;
-			}
-			lpDragonSoul = lpItem;
-		}
-		else if (IsDragonSoulRefineMaterial(lpItem))
-		{
-			if (lpRefineMaterial != nullptr)
-			{
-				SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(lpItem->GetWindow(), lpItem->GetCell()));
-				return false;
-			}
-			lpRefineMaterial = lpItem;
-		}
-		else
-		{
-			lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화에 필요한 재료가 아닙니다."));
-			SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(lpItem->GetWindow(), lpItem->GetCell()));
-			return false;
-		}
-	}
-
-	BYTE bType, bGrade, bStep, bStrength;
-	if (!lpDragonSoul || !lpRefineMaterial)
-	{
-		SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
-		return false;
-	}
-
-	if (lpDragonSoul != nullptr)
-	{
-		GetDragonSoulInfo(lpDragonSoul->GetVnum(), bType, bGrade, bStep, bStrength);
-		if (bGrade < DRAGON_SOUL_GRADE_MYTH)
-		{
-			lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화할 수 없는 용혼석입니다."));
-			SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE, TItemPos(lpDragonSoul->GetWindow(), lpDragonSoul->GetCell()));
-			return false;
-		}
-	}
-
-	int64_t iFee = lpRefineMaterial->GetValue(0);
-	if (lpCh->GetGold() < iFee)
-	{
-		lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 돈이 부족합니다."));
-		SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
-		return false;
-	}
-
-	WORD wNeedMaterialCount = 1;
-	switch (bStep)
-	{
-		case DRAGON_SOUL_STEP_LOWEST:
-			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_LOWEST;
-			break;
-		case DRAGON_SOUL_STEP_LOW:
-			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_LOW;
-			break;
-		case DRAGON_SOUL_STEP_MID:
-			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_MID;
-			break;
-		case DRAGON_SOUL_STEP_HIGH:
-			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_HIGH;
-			break;
-		case DRAGON_SOUL_STEP_HIGHEST:
-			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_HIGHEST;
-			break;
-	}
-
-	if (lpCh->CountSpecifyItem(lpRefineMaterial->GetVnum()) < wNeedMaterialCount)
-	{
-		SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
-		return false;
-	}
-
-	lpCh->RemoveSpecifyItem(lpRefineMaterial->GetVnum(), wNeedMaterialCount);
-	lpCh->PointChange(POINT_GOLD, -iFee);
-
-	lpDragonSoul->ClearAllAttribute();
-	PutAttributes(lpDragonSoul);
-
-	SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_SUCCEED, TItemPos(lpDragonSoul->GetWindow(), lpDragonSoul->GetCell()));
-
-	return true;
-}
-#endif
-
-void DSManager::SendRefineResultPacket(LPCHARACTER ch, BYTE bSubHeader, const TItemPos& pos)
-{
-	TPacketGCDragonSoulRefine pack;
-	pack.bSubType = bSubHeader;
-
-	if (pos.IsValidItemPosition())
-	{
-		pack.Pos = pos;
-	}
-	LPDESC d = ch->GetDesc();
-	if (NULL == d)
-	{
-		return;
-	}
-	else
-	{
-		d->Packet(&pack, sizeof(pack));
-	}
-}
-
-int DSManager::LeftTime(LPITEM pItem) const
-{
-	if (pItem == NULL)
-		return false;
-
-	// 일단은 timer based on wear인 용혼석만 시간 다 되어도 안 없어진다.
-	if (pItem->GetProto()->cLimitTimerBasedOnWearIndex >= 0)
-	{
-		return pItem->GetSocket(ITEM_SOCKET_REMAIN_SEC);
-	}
-	// 다른 limit type인 용혼석들은 시간 되면 모두 사라지기 때문에 여기 들어온 아이템은 일단 시간이 남았다고 판단.
-	else
-	{
-		return INT_MAX;
-	}
-}
-
-bool DSManager::IsTimeLeftDragonSoul(LPITEM pItem) const
-{
-	if (pItem == NULL)
-		return false;
-
-	// 일단은 timer based on wear인 용혼석만 시간 다 되어도 안 없어진다.
-	if (pItem->GetProto()->cLimitTimerBasedOnWearIndex >= 0)
-	{
-		return pItem->GetSocket(ITEM_SOCKET_REMAIN_SEC) > 0;
-	}
-	// 다른 limit type인 용혼석들은 시간 되면 모두 사라지기 때문에 여기 들어온 아이템은 일단 시간이 남았다고 판단.
-	else
-	{
-		return true;
-	}
-}
-
-bool DSManager::IsActiveDragonSoul(LPITEM pItem) const
-{
-	return pItem->GetSocket(ITEM_SOCKET_DRAGON_SOUL_ACTIVE_IDX);
-}
-
-bool DSManager::ActivateDragonSoul(LPITEM pItem)
-{
-	if (NULL == pItem)
-		return false;
-
-	LPCHARACTER pOwner = pItem->GetOwner();
-	if (NULL == pOwner)
-		return false;
-
-	int deck_idx = pOwner->DragonSoul_GetActiveDeck();
-
-	if (deck_idx < 0)
-		return false;
-
-	if (WEAR_MAX_NUM + DS_SLOT_MAX * deck_idx <= pItem->GetCell() &&
-		pItem->GetCell() < WEAR_MAX_NUM + DS_SLOT_MAX * (deck_idx + 1))
-	{
-		if (IsTimeLeftDragonSoul(pItem) && !IsActiveDragonSoul(pItem))
-		{
-			char buf[128];
-			sprintf(buf, "LEFT TIME(%d)", LeftTime(pItem));
-			LogManager::instance().ItemLog(pOwner, pItem, "DS_ACTIVATE", buf);
-			pItem->ModifyPoints(true);
-			pItem->SetSocket(ITEM_SOCKET_DRAGON_SOUL_ACTIVE_IDX, 1);
-
-			pItem->StartTimerBasedOnWearExpireEvent();
-		}
-		return true;
-	}
-	else
-		return false;
-}
-
-bool DSManager::DeactivateDragonSoul(LPITEM pItem, bool bSkipRefreshOwnerActiveState)
-{
-	if (NULL == pItem)
-		return false;
-
-	LPCHARACTER pOwner = pItem->GetOwner();
-	if (NULL == pOwner)
-		return false;
-
-	if (!IsActiveDragonSoul(pItem))
-		return false;
-
-	char buf[128];
-	pItem->StopTimerBasedOnWearExpireEvent();
-	pItem->SetSocket(ITEM_SOCKET_DRAGON_SOUL_ACTIVE_IDX, 0);
-	pItem->ModifyPoints(false);
-
-	sprintf(buf, "LEFT TIME(%d)", LeftTime(pItem));
-	LogManager::instance().ItemLog(pOwner, pItem, "DS_DEACTIVATE", buf);
-
-	if (false == bSkipRefreshOwnerActiveState)
-		RefreshDragonSoulState(pOwner);
-
-	return true;
-}
-
-void DSManager::RefreshDragonSoulState(LPCHARACTER ch)
-{
-	if (NULL == ch)
-		return;
-
-	for (BYTE bSlotIdx = WEAR_MAX_NUM; bSlotIdx < DRAGON_SOUL_EQUIP_SLOT_END; bSlotIdx++)
-	{
-		LPITEM pItem = ch->GetWear(bSlotIdx);
-		if (pItem != NULL)
-		{
-			if (IsActiveDragonSoul(pItem))
-			{
-				return;
-			}
-		}
-	}
-
-	ch->DragonSoul_DeactivateAll();
-}
-
-#if defined(__DS_SET__)
-float DSManager::GetWeight(DWORD dwVnum)
-{
-	BYTE bType, bGrade, bStep, bStrength;
-	GetDragonSoulInfo(dwVnum, bType, bGrade, bStep, bStrength);
-
-	float fWeight = 0.f;
-	if (!m_pTable->GetWeight(bType, bGrade - 1, 0, 0, fWeight))
-		return 0.f;
-
-	return fWeight;
-}
-
-int DSManager::GetApplyCount(DWORD dwVnum)
-{
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
-
-	int basic_apply_num, add_min, add_max;
-	if (!m_pTable->GetApplyNumSettings(ds_type, grade_idx, basic_apply_num, add_min, add_max))
-		return 0;
-
-	return basic_apply_num;
-}
-
-int DSManager::GetBasicApplyValue(DWORD dwVnum, int iType, bool bAttr)
-{
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
-
-	int ret = 0;
-
-	DragonSoulTable::TVecApplys vec_basic_applys;
-	if (!m_pTable->GetBasicApplys(ds_type, vec_basic_applys))
-		return ret;
-
-	for (size_t i = 0; i < vec_basic_applys.size(); i++)
-	{
-		if (vec_basic_applys[i].apply_type == iType)
-		{
-			if (!bAttr)
-				ret = vec_basic_applys[i].apply_value;
-			else
-			{
-				float fWeight = 0.f;
-				if (!m_pTable->GetWeight(ds_type, grade_idx - 1, 0, 0, fWeight))
-					return 0;
-
-				fWeight /= 100.f;
-				ret = (short)(ceil((float)vec_basic_applys[i].apply_value * fWeight - 0.01f));
-			}
-			break;
-		}
-	}
-
-	return ret;
-}
-
-int DSManager::GetAdditionalApplyValue(DWORD dwVnum, int iType, bool bAttr)
-{
-	BYTE ds_type, grade_idx, step_idx, strength_idx;
-	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
-
-	int ret = 0;
-
-	DragonSoulTable::TVecApplys vec_addtional_applys;
-	if (!m_pTable->GetAdditionalApplys(ds_type, vec_addtional_applys))
-		return ret;
-
-	for (size_t i = 0; i < vec_addtional_applys.size(); i++)
-	{
-		if (vec_addtional_applys[i].apply_type == iType)
-		{
-			if (!bAttr)
-				ret = vec_addtional_applys[i].apply_value;
-			else
-			{
-				float fWeight = 0.f;
-				if (!m_pTable->GetWeight(ds_type, grade_idx - 1, 0, 0, fWeight))
-					return 0;
-
-				fWeight /= 100.f;
-				ret = (short)(ceil((float)vec_addtional_applys[i].apply_value * fWeight - 0.01f));
-			}
-			break;
-		}
-	}
-
-	return ret;
-}
-#endif
-
-DSManager::DSManager()
-{
-	m_pTable = NULL;
-}
-
-DSManager::~DSManager()
-{
-	if (m_pTable)
-		delete m_pTable;
-}
-#endif
+#include "stdafx.h"
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+#include "constants.h"
+#include "item.h"
+#include "item_manager.h"
+#include "unique_item.h"
+#include "packet.h"
+#include "desc.h"
+#include "char.h"
+#include "dragon_soul_table.h"
+#include "log.h"
+#include "DragonSoul.h"
+
+typedef std::vector<std::string> TTokenVector;
+
+template <typename T> T MINMAX(T min, T value, T max)
+{
+	T tv;
+
+	tv = (min > value ? min : value);
+	return (max < tv) ? max : tv;
+}
+
+int Gamble(std::vector<float>& vec_probs)
+{
+	float range = 0.f;
+	for (int i = 0; i < vec_probs.size(); i++)
+	{
+		range += vec_probs[i];
+	}
+	float fProb = fnumber(0.f, range);
+	float sum = 0.f;
+	for (int idx = 0; idx < vec_probs.size(); idx++)
+	{
+		sum += vec_probs[idx];
+		if (sum >= fProb)
+			return idx;
+	}
+	return -1;
+}
+
+// 치 遣(prob_lst) 騁 random_set.size() index 臼 random_set return
+bool MakeDistinctRandomNumberSet(std::list <float> prob_lst, OUT std::vector<int>& random_set)
+{
+	int size = prob_lst.size();
+	int n = random_set.size();
+	if (size < n)
+		return false;
+
+	std::vector <int> select_bit(size, 0);
+	for (int i = 0; i < n; i++)
+	{
+		float range = 0.f;
+		for (std::list <float>::iterator it = prob_lst.begin(); it != prob_lst.end(); ++it)
+		{
+			range += *it;
+		}
+		float r = fnumber(0.f, range);
+		float sum = 0.f;
+		int idx = 0;
+		for (std::list <float>::iterator it = prob_lst.begin(); it != prob_lst.end(); ++it)
+		{
+			while (select_bit[idx++]);
+
+			sum += *it;
+			if (sum >= r)
+			{
+				select_bit[idx - 1] = 1;
+				random_set[i] = idx - 1;
+				prob_lst.erase(it);
+				break;
+			}
+		}
+	}
+	return true;
+}
+
+/* 혼 Vnum  comment
+ * ITEM VNUM 10 美, FEDCBA 磯摸
+ * FE : 혼 .	D : 
+ * C : 丙			B : 화
+ * A :  호...
+ */
+
+BYTE GetType(DWORD dwVnum)
+{
+	return BYTE(dwVnum / 10000);
+}
+
+BYTE GetGradeIdx(DWORD dwVnum)
+{
+	return (dwVnum / 1000) % 10;
+}
+
+BYTE GetStepIdx(DWORD dwVnum)
+{
+	return (dwVnum / 100) % 10;
+}
+
+BYTE GetStrengthIdx(DWORD dwVnum)
+{
+	return (dwVnum / 10) % 10;
+}
+
+bool DSManager::HasActivedAllSlotsByPage(const LPCHARACTER ch, const BYTE bPageIndex) const
+{
+	if (!ch || bPageIndex >= DRAGON_SOUL_DECK_MAX_NUM)
+		return false;
+
+	const WORD wDragonSoulDeckAffectType = AFFECT_DRAGON_SOUL_DECK_0 + bPageIndex; // 540 + [0 or 1]
+	if (!ch->FindAffect(wDragonSoulDeckAffectType))
+		return false;
+
+	// start : 32 + ([0 or 1] * 6) = [32 or 38]
+	// end : start + 6
+	const BYTE iStartIndex = WEAR_MAX_NUM + (bPageIndex * DS_SLOT_MAX);
+	const BYTE iEndIndex = iStartIndex + DS_SLOT_MAX;
+
+	BYTE bSlotActive = 0;
+	for (BYTE bCell = iStartIndex; bCell < iEndIndex; ++bCell) // {0: 32-38, 1: 38-44}
+	{
+		const LPITEM pkItem = ch->GetWear(bCell);
+		if (pkItem && pkItem->IsDragonSoul())
+		{
+			if (IsTimeLeftDragonSoul(pkItem) && IsActiveDragonSoul(pkItem))
+				++bSlotActive;
+		}
+	}
+
+	return (bSlotActive == DS_SLOT_MAX);
+}
+
+bool DSManager::ReadDragonSoulTableFile(const char* c_pszFileName)
+{
+	m_pTable = new DragonSoulTable();
+	return m_pTable->ReadDragonSoulTableFile(c_pszFileName);
+}
+
+void DSManager::GetDragonSoulInfo(DWORD dwVnum, BYTE& bType, BYTE& bGrade, BYTE& bStep, BYTE& bStrength) const
+{
+	bType = GetType(dwVnum);
+	bGrade = GetGradeIdx(dwVnum);
+	bStep = GetStepIdx(dwVnum);
+	bStrength = GetStrengthIdx(dwVnum);
+}
+
+bool DSManager::IsValidCellForThisItem(const LPITEM pItem, const TItemPos& Cell) const
+{
+	if (NULL == pItem)
+		return false;
+
+	WORD wBaseCell = GetBasePosition(pItem);
+	if (WORD_MAX == wBaseCell)
+		return false;
+
+	if (Cell.window_type != DRAGON_SOUL_INVENTORY
+		|| (Cell.cell < wBaseCell || Cell.cell >= wBaseCell + DRAGON_SOUL_BOX_SIZE))
+	{
+		return false;
+	}
+	else
+		return true;
+
+}
+
+WORD DSManager::GetBasePosition(const LPITEM pItem) const
+{
+	if (NULL == pItem)
+		return WORD_MAX;
+
+	BYTE type, grade_idx, step_idx, strength_idx;
+	GetDragonSoulInfo(pItem->GetVnum(), type, grade_idx, step_idx, strength_idx);
+
+	BYTE col_type = pItem->GetSubType();
+	BYTE row_type = grade_idx;
+	if (row_type > DRAGON_SOUL_GRADE_MAX)
+		return WORD_MAX;
+
+#if defined(__DS_GRADE_MYTH__)
+	return col_type * DRAGON_SOUL_GRADE_MAX * DRAGON_SOUL_BOX_SIZE + row_type * DRAGON_SOUL_BOX_SIZE;
+#else
+	return col_type * DRAGON_SOUL_STEP_MAX * DRAGON_SOUL_BOX_SIZE + row_type * DRAGON_SOUL_BOX_SIZE;
+#endif
+}
+
+bool DSManager::RefreshItemAttributes(LPITEM pDS)
+{
+	if (!pDS->IsDragonSoul())
+	{
+		sys_err("This item(ID : %d) is not DragonSoul.", pDS->GetID());
+		return false;
+	}
+
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	GetDragonSoulInfo(pDS->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
+
+	DragonSoulTable::TVecApplys vec_basic_applys;
+	DragonSoulTable::TVecApplys vec_addtional_applys;
+
+	if (!m_pTable->GetBasicApplys(ds_type, vec_basic_applys))
+	{
+		sys_err("There is no BasicApply about %d type dragon soul.", ds_type);
+		return false;
+	}
+
+	if (!m_pTable->GetAdditionalApplys(ds_type, vec_addtional_applys))
+	{
+		sys_err("There is no AdditionalApply about %d type dragon soul.", ds_type);
+		return false;
+	}
+
+	// add_min add_max 肩 .
+	int basic_apply_num, add_min, add_max;
+	if (!m_pTable->GetApplyNumSettings(ds_type, grade_idx, basic_apply_num, add_min, add_max))
+	{
+		sys_err("In ApplyNumSettings, INVALID VALUES Group type(%d), GRADE idx(%d)", ds_type, grade_idx);
+		return false;
+	}
+
+	float fWeight = 0.f;
+	if (!m_pTable->GetWeight(ds_type, grade_idx, step_idx, strength_idx, fWeight))
+	{
+		return false;
+	}
+	fWeight /= 100.f;
+
+	int n = MIN(basic_apply_num, vec_basic_applys.size());
+	for (int i = 0; i < n; i++)
+	{
+		const SApply& basic_apply = vec_basic_applys[i];
+		BYTE bType = basic_apply.apply_type;
+		short sValue = (short)(ceil((float)basic_apply.apply_value * fWeight - 0.01f));
+
+		pDS->SetForceAttribute(i, bType, sValue);
+	}
+
+	for (int i = DRAGON_SOUL_ADDITIONAL_ATTR_START_IDX; i < ITEM_ATTRIBUTE_MAX_NUM; i++)
+	{
+		BYTE bType = pDS->GetAttributeType(i);
+		short sValue = 0;
+		if (APPLY_NONE == bType)
+			continue;
+		for (int j = 0; j < vec_addtional_applys.size(); j++)
+		{
+			if (vec_addtional_applys[j].apply_type == bType)
+			{
+				sValue = vec_addtional_applys[j].apply_value;
+				break;
+			}
+		}
+		pDS->SetForceAttribute(i, bType, (short)(ceil((float)sValue * fWeight - 0.01f)));
+	}
+	return true;
+}
+
+bool DSManager::PutAttributes(LPITEM pDS)
+{
+	if (!pDS->IsDragonSoul())
+	{
+		sys_err("This item(ID : %d) is not DragonSoul.", pDS->GetID());
+		return false;
+	}
+
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	GetDragonSoulInfo(pDS->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
+
+	DragonSoulTable::TVecApplys vec_basic_applys;
+	DragonSoulTable::TVecApplys vec_addtional_applys;
+
+	if (!m_pTable->GetBasicApplys(ds_type, vec_basic_applys))
+	{
+		sys_err("There is no BasicApply about %d type dragon soul.", ds_type);
+		return false;
+	}
+	if (!m_pTable->GetAdditionalApplys(ds_type, vec_addtional_applys))
+	{
+		sys_err("There is no AdditionalApply about %d type dragon soul.", ds_type);
+		return false;
+	}
+
+	int basic_apply_num, add_min, add_max;
+	if (!m_pTable->GetApplyNumSettings(ds_type, grade_idx, basic_apply_num, add_min, add_max))
+	{
+		sys_err("In ApplyNumSettings, INVALID VALUES Group type(%d), GRADE idx(%d)", ds_type, grade_idx);
+		return false;
+	}
+
+	float fWeight = 0.f;
+	if (!m_pTable->GetWeight(ds_type, grade_idx, step_idx, strength_idx, fWeight))
+	{
+		return false;
+	}
+	fWeight /= 100.f;
+
+	int n = MIN(basic_apply_num, vec_basic_applys.size());
+	for (int i = 0; i < n; i++)
+	{
+		const SApply& basic_apply = vec_basic_applys[i];
+		BYTE bType = basic_apply.apply_type;
+		short sValue = (short)(ceil((float)basic_apply.apply_value * fWeight - 0.01f));
+
+		pDS->SetForceAttribute(i, bType, sValue);
+	}
+
+	BYTE additional_attr_num = MIN(number(add_min, add_max), 3);
+
+	std::vector <int> random_set;
+	if (additional_attr_num > 0)
+	{
+		random_set.resize(additional_attr_num);
+		std::list <float> list_probs;
+		for (int i = 0; i < vec_addtional_applys.size(); i++)
+		{
+			list_probs.push_back(vec_addtional_applys[i].prob);
+		}
+		if (!MakeDistinctRandomNumberSet(list_probs, random_set))
+		{
+			sys_err("MakeDistinctRandomNumberSet error.");
+			return false;
+		}
+
+		for (int i = 0; i < additional_attr_num; i++)
+		{
+			int r = random_set[i];
+			const SApply& additional_attr = vec_addtional_applys[r];
+			BYTE bType = additional_attr.apply_type;
+			short sValue = (short)(ceil((float)additional_attr.apply_value * fWeight - 0.01f));
+
+			pDS->SetForceAttribute(DRAGON_SOUL_ADDITIONAL_ATTR_START_IDX + i, bType, sValue);
+		}
+	}
+
+	return true;
+}
+
+bool DSManager::DragonSoulItemInitialize(LPITEM pItem)
+{
+	if (NULL == pItem || !pItem->IsDragonSoul())
+		return false;
+	PutAttributes(pItem);
+	int time = DSManager::instance().GetDuration(pItem);
+	if (time > 0)
+		pItem->SetSocket(ITEM_SOCKET_REMAIN_SEC, time);
+	return true;
+}
+
+DWORD DSManager::MakeDragonSoulVnum(BYTE bType, BYTE grade, BYTE step, BYTE refine)
+{
+	return bType * 10000 + grade * 1000 + step * 100 + refine * 10;
+}
+
+int DSManager::GetDuration(const LPITEM pItem) const
+{
+	return pItem->GetDuration();
+}
+
+// 혼 騁티  求 獨
+bool DSManager::ExtractDragonHeart(LPCHARACTER ch, LPITEM pItem, LPITEM pExtractor)
+{
+	if (NULL == ch || NULL == pItem)
+		return false;
+
+	if (pItem->IsEquipped())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  혼   求."));
+		return false;
+	}
+
+	DWORD dwVnum = pItem->GetVnum();
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
+
+	int iBonus = 0;
+
+	if (NULL != pExtractor)
+	{
+		iBonus = pExtractor->GetValue(0);
+	}
+
+	std::vector <float> vec_chargings;
+	std::vector <float> vec_probs;
+
+	if (!m_pTable->GetDragonHeartExtValues(ds_type, grade_idx, vec_chargings, vec_probs))
+	{
+		return false;
+	}
+
+	int idx = Gamble(vec_probs);
+
+	float sum = 0.f;
+	if (-1 == idx)
+	{
+		sys_err("Gamble is failed. ds_type(%d), grade_idx(%d)", ds_type, grade_idx);
+		return false;
+	}
+
+	float fCharge = vec_chargings[idx] * (100 + iBonus) / 100.f;
+	fCharge = MINMAX <float>(0.f, fCharge, 100.f);
+
+	if (fCharge < FLT_EPSILON)
+	{
+		pItem->SetCount(pItem->GetCount() - 1);
+		if (NULL != pExtractor)
+		{
+			pExtractor->SetCount(pExtractor->GetCount() - 1);
+		}
+		LogManager::instance().ItemLog(ch, pItem, "DS_HEART_EXTRACT_FAIL", "");
+
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 藪 臼求."));
+		return false;
+	}
+	else
+	{
+		LPITEM pDH = ITEM_MANAGER::instance().CreateItem(ITEM_DRAGON_HEART_VNUM);
+
+		if (NULL == pDH)
+		{
+			sys_err("Cannot create DRAGON_HEART(%d).", ITEM_DRAGON_HEART_VNUM);
+			return false;
+		}
+
+		pItem->SetCount(pItem->GetCount() - 1);
+		if (NULL != pExtractor)
+		{
+			pExtractor->SetCount(pExtractor->GetCount() - 1);
+		}
+
+		int iCharge = (int)(fCharge + 0.5f);
+		pDH->SetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX, iCharge);
+		ch->AutoGiveItem(pDH, true);
+
+		std::string s = std::to_string(iCharge);
+		s += "%s";
+		LogManager::instance().ItemLog(ch, pItem, "DS_HEART_EXTRACT_SUCCESS", s.c_str());
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 藪 臼求."));
+		return true;
+	}
+}
+
+// 특 혼 창    罐 構, 戟 貫源 獵 獨.
+bool DSManager::PullOut(LPCHARACTER ch, TItemPos DestCell, LPITEM& pItem, LPITEM pExtractor)
+{
+	if (NULL == ch || NULL == pItem)
+	{
+		sys_err("NULL POINTER. ch(%p) or pItem(%p)", ch, pItem);
+		return false;
+	}
+
+	// 표 치 valid 講 , valid 苛摸    찾쨈.
+	if (!IsValidCellForThisItem(pItem, DestCell) || ch->GetItem(DestCell))
+	{
+		int iEmptyCell = ch->GetEmptyDragonSoulInventory(pItem);
+		if (iEmptyCell < 0)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+			return false;
+		}
+		else
+		{
+			DestCell.window_type = DRAGON_SOUL_INVENTORY;
+			DestCell.cell = iEmptyCell;
+		}
+	}
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (pItem->IsSealed())
+		return false;
+#endif
+
+	if (!pItem->IsEquipped() || !pItem->RemoveFromCharacter())
+		return false;
+
+	bool bSuccess;
+	DWORD dwByProduct = 0;
+	int iBonus = 0;
+	float fProb;
+	float fDice;
+
+	// 혼    .
+	{
+		// DWORD dwVnum = pItem->GetVnum();
+
+		BYTE ds_type, grade_idx, step_idx, strength_idx;
+		GetDragonSoulInfo(pItem->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
+
+		//   摸 求  求 繭 .
+		if (!m_pTable->GetDragonSoulExtValues(ds_type, grade_idx, fProb, dwByProduct))
+		{
+			pItem->AddToCharacter(ch, DestCell);
+			return true;
+		}
+
+		if (NULL != pExtractor)
+		{
+			iBonus = pExtractor->GetValue(ITEM_VALUE_DRAGON_SOUL_POLL_OUT_BONUS_IDX);
+			pExtractor->SetCount(pExtractor->GetCount() - 1);
+		}
+
+		fDice = fnumber(0.f, 100.f);
+		bSuccess = fDice <= (fProb * (100 + iBonus) / 100.f);
+	}
+
+	// 캐 혼   煞 혹 . 貫源 .
+	{
+		char buf[128];
+		if (bSuccess)
+		{
+			if (pExtractor)
+				snprintf(buf, sizeof(buf), "dice(%d) prob(%d + %d) EXTR(VN:%d)", (int)fDice, (int)fProb, iBonus, pExtractor->GetVnum());
+			else
+				snprintf(buf, sizeof(buf), "dice(%d) prob(%d)", (int)fDice, (int)fProb);
+
+			LogManager::instance().ItemLog(ch, pItem, "DS_PULL_OUT_SUCCESS", buf);
+
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("혼 藪 臼求."));
+			pItem->AddToCharacter(ch, DestCell);
+
+			return true;
+		}
+		else
+		{
+			if (pExtractor)
+				snprintf(buf, sizeof(buf), "dice(%d) prob(%d + %d) EXTR(VN:%d) ByProd(VN:%d)", (int)fDice, (int)fProb, iBonus, pExtractor->GetVnum(), dwByProduct);
+			else
+				snprintf(buf, sizeof(buf), "dice(%d) prob(%d) ByProd(VNUM:%d)", (int)fDice, (int)fProb, dwByProduct);
+
+			LogManager::instance().ItemLog(ch, pItem, "DS_PULL_OUT_FAILED", buf);
+
+			M2_DESTROY_ITEM(pItem);
+			pItem = NULL;
+
+			if (dwByProduct)
+			{
+				LPITEM pByProduct = ch->AutoGiveItem(dwByProduct, true);
+				if (pByProduct)
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("혼 藪 臼 %s 求.", LC_ITEM(pByProduct->GetVnum())));
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("혼 藪 臼求."));
+			}
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("혼 藪 臼求."));
+		}
+	}
+
+	return bSuccess;
+}
+
+bool DSManager::DoRefineGrade(LPCHARACTER ch, TItemPos(&aItemPoses)[DRAGON_SOUL_REFINE_GRID_SIZE])
+{
+	if (NULL == ch)
+		return false;
+
+	if (NULL == aItemPoses)
+		return false;
+
+	if (!ch->DragonSoul_RefineWindow_CanRefine())
+	{
+		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", ch->GetName());
+		ch->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot upgrade dragon soul without refine window.");
+		return false;
+	}
+
+	// 혹처  揷풔 item pointer 殮 漫 set 
+	// 鵑 킷  , 揷 TItemPos   斂, 蔘 TItemPos   獵.
+	std::set <LPITEM> set_items;
+	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
+	{
+		if (aItemPoses[i].IsEquipPosition())
+			return false;
+
+		LPITEM pItem = ch->GetItem(aItemPoses[i]);
+		if (NULL != pItem)
+		{
+			// 혼 틈  창   .
+			if (!pItem->IsDragonSoul())
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  却 嘯 틈爛求."));
+				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+
+				return false;
+			}
+
+			set_items.insert(pItem);
+		}
+	}
+
+	if (set_items.empty())
+	{
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
+		return false;
+	}
+
+	int count = set_items.size();
+	int need_count = 0;
+	int fee = 0;
+	std::vector <float> vec_probs;
+	//float prob_sum;
+
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	int result_grade;
+
+	//  처  화  쨈.
+	std::set <LPITEM>::iterator it = set_items.begin();
+	{
+		LPITEM pItem = *it;
+
+		GetDragonSoulInfo(pItem->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
+
+		if (!m_pTable->GetRefineGradeValues(ds_type, grade_idx, need_count, fee, vec_probs))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("    혼都求."));
+			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+
+			return false;
+		}
+	}
+	while (++it != set_items.end())
+	{
+		LPITEM pItem = *it;
+
+		// 클 ui   창 첩   耐 ,
+		//  舡 처 .
+		if (pItem->IsEquipped())
+		{
+			return false;
+		}
+
+		if (ds_type != GetType(pItem->GetVnum()) || grade_idx != GetGradeIdx(pItem->GetVnum()))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  却 嘯 틈爛求."));
+			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+
+			return false;
+		}
+	}
+
+	// 클璨【 箕  체크 歐  count != need_count invalid 클  크.
+	if (count != need_count)
+	{
+		sys_err("Possiblity of invalid client. Name %s", ch->GetName());
+		BYTE bSubHeader = count < need_count ? DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL : DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL;
+		SendRefineResultPacket(ch, bSubHeader, NPOS);
+		return false;
+	}
+
+	if (ch->GetGold() < fee)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐   爛求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
+		return false;
+	}
+
+	if (-1 == (result_grade = Gamble(vec_probs)))
+	{
+		sys_err("Gamble failed. See RefineGardeTables' probabilities");
+		return false;
+	}
+
+	LPITEM pResultItem = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(ds_type, (BYTE)result_grade, 0, 0));
+
+	if (NULL == pResultItem)
+	{
+		sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(ds_type, (BYTE)result_grade, 0, 0));
+		return false;
+	}
+
+	ch->PointChange(POINT_GOLD, -fee);
+	int left_count = need_count;
+
+	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
+	{
+		LPITEM pItem = *it;
+		int n = pItem->GetCount();
+		if (left_count > n)
+		{
+			pItem->RemoveFromCharacter();
+			M2_DESTROY_ITEM(pItem);
+			left_count -= n;
+		}
+		else
+		{
+			pItem->SetCount(n - left_count);
+		}
+	}
+
+	ch->AutoGiveItem(pResultItem, true);
+
+	if (result_grade > grade_idx)
+	{
+		char buf[128];
+		snprintf(buf, sizeof(buf), "GRADE : %d -> %d", grade_idx, result_grade);
+		LogManager::instance().ItemLog(ch, pResultItem, "DS_GRADE_REFINE_SUCCESS", buf);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  颯求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_SUCCEED, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
+		return true;
+	}
+	else
+	{
+		char buf[128];
+		snprintf(buf, sizeof(buf), "GRADE : %d -> %d", grade_idx, result_grade);
+		LogManager::instance().ItemLog(ch, pResultItem, "DS_GRADE_REFINE_FAIL", buf);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  颯求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
+		return false;
+	}
+}
+
+bool DSManager::DoRefineStep(LPCHARACTER ch, TItemPos(&aItemPoses)[DRAGON_SOUL_REFINE_GRID_SIZE])
+{
+	if (NULL == ch)
+		return false;
+	if (NULL == aItemPoses)
+	{
+		return false;
+	}
+
+	if (!ch->DragonSoul_RefineWindow_CanRefine())
+	{
+		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", ch->GetName());
+		ch->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot use dragon soul refine window.");
+		return false;
+	}
+
+	// 혹처  揷풔 item pointer 殮 漫 set 
+	// 鵑 킷  , 揷 TItemPos   斂, 蔘 TItemPos   獵.
+	std::set <LPITEM> set_items;
+	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
+	{
+		LPITEM pItem = ch->GetItem(aItemPoses[i]);
+		if (NULL != pItem)
+		{
+			// 혼 틈  창   .
+			if (!pItem->IsDragonSoul())
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("丙  却 嘯 틈爛求."));
+				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+				return false;
+			}
+			set_items.insert(pItem);
+		}
+	}
+
+	if (set_items.empty())
+	{
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
+		return false;
+	}
+
+	//std::string stGroupName;
+	int count = set_items.size();
+	int need_count = 0;
+	int fee = 0;
+	std::vector <float> vec_probs;
+
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	int result_step;
+
+	//  처  화  쨈.
+	std::set <LPITEM>::iterator it = set_items.begin();
+	{
+		LPITEM pItem = *it;
+		GetDragonSoulInfo(pItem->GetVnum(), ds_type, grade_idx, step_idx, strength_idx);
+
+		if (!m_pTable->GetRefineStepValues(ds_type, step_idx, need_count, fee, vec_probs))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("丙    혼都求."));
+			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+			return false;
+		}
+	}
+
+	while (++it != set_items.end())
+	{
+		LPITEM pItem = *it;
+		// 클 ui   창 첩   耐 ,
+		//  舡 처 .
+		if (pItem->IsEquipped())
+		{
+			return false;
+		}
+		if (ds_type != GetType(pItem->GetVnum()) || grade_idx != GetGradeIdx(pItem->GetVnum()) || step_idx != GetStepIdx(pItem->GetVnum()))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("丙  却 嘯 틈爛求."));
+			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+			return false;
+		}
+	}
+
+	// 클璨【 箕  체크 歐  count != need_count invalid 클  크.
+	if (count != need_count)
+	{
+		sys_err("Possiblity of invalid client. Name %s", ch->GetName());
+		BYTE bSubHeader = count < need_count ? DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL : DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL;
+		SendRefineResultPacket(ch, bSubHeader, NPOS);
+		return false;
+	}
+
+	if (ch->GetGold() < fee)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐   爛求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
+		return false;
+	}
+
+	float sum = 0.f;
+
+	if (-1 == (result_step = Gamble(vec_probs)))
+	{
+		sys_err("Gamble failed. See RefineStepTables' probabilities");
+		return false;
+	}
+
+	LPITEM pResultItem = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(ds_type, grade_idx, (BYTE)result_step, 0));
+
+	if (NULL == pResultItem)
+	{
+		sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(ds_type, grade_idx, (BYTE)result_step, 0));
+		return false;
+	}
+
+	ch->PointChange(POINT_GOLD, -fee);
+	int left_count = need_count;
+	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
+	{
+		LPITEM pItem = *it;
+		int n = pItem->GetCount();
+		if (left_count > n)
+		{
+			pItem->RemoveFromCharacter();
+			M2_DESTROY_ITEM(pItem);
+			left_count -= n;
+		}
+		else
+		{
+			pItem->SetCount(n - left_count);
+		}
+	}
+
+	ch->AutoGiveItem(pResultItem, true);
+	if (result_step > step_idx)
+	{
+		char buf[128];
+		snprintf(buf, sizeof(buf), "STEP : %d -> %d", step_idx, result_step);
+		LogManager::instance().ItemLog(ch, pResultItem, "DS_STEP_REFINE_SUCCESS", buf);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("丙  颯求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_SUCCEED, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
+		return true;
+	}
+	else
+	{
+		char buf[128];
+		snprintf(buf, sizeof(buf), "STEP : %d -> %d", step_idx, result_step);
+		LogManager::instance().ItemLog(ch, pResultItem, "DS_STEP_REFINE_FAIL", buf);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("丙  颯求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL, TItemPos(pResultItem->GetWindow(), pResultItem->GetCell()));
+		return false;
+	}
+}
+
+bool IsDragonSoulRefineMaterial(LPITEM pItem)
+{
+	if (pItem->GetType() != ITEM_MATERIAL)
+		return false;
+
+	return (pItem->GetSubType() == MATERIAL_DS_REFINE_NORMAL ||
+		pItem->GetSubType() == MATERIAL_DS_REFINE_BLESSED ||
+		pItem->GetSubType() == MATERIAL_DS_REFINE_HOLLY
+#if defined(__DS_CHANGE_ATTR__)
+		|| pItem->GetSubType() == MATERIAL_DS_CHANGE_ATTR
+#endif
+		);
+}
+
+bool DSManager::DoRefineStrength(LPCHARACTER ch, TItemPos(&aItemPoses)[DRAGON_SOUL_REFINE_GRID_SIZE])
+{
+	if (NULL == ch)
+		return false;
+
+	if (NULL == aItemPoses)
+		return false;
+
+	if (!ch->DragonSoul_RefineWindow_CanRefine())
+	{
+		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", ch->GetName());
+		ch->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot use dragon soul refine window.");
+		return false;
+	}
+
+	// 혹처  揷풔 item pointer 殮 漫 set 
+	// 鵑 킷  , 揷 TItemPos   斂, 蔘 TItemPos   獵.
+	std::set<LPITEM> set_items;
+	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
+	{
+		LPITEM pItem = ch->GetItem(aItemPoses[i]);
+		if (pItem)
+			set_items.insert(pItem);
+	}
+
+	if (set_items.empty())
+		return false;
+
+	int fee;
+
+	LPITEM pRefineStone = NULL;
+	LPITEM pDragonSoul = NULL;
+	for (std::set<LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
+	{
+		LPITEM pItem = *it;
+		// 클 ui   창 첩   耐 ,
+		//  舡 처 .
+		if (pItem->IsEquipped())
+			return false;
+
+		// 혼 화 창   獵.
+		// 琉 毬 羚磯.
+		if (pItem->IsDragonSoul())
+		{
+			if (pDragonSoul != NULL)
+			{
+				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+				return false;
+			}
+			pDragonSoul = pItem;
+		}
+		else if (IsDragonSoulRefineMaterial(pItem))
+		{
+			if (pRefineStone != NULL)
+			{
+				SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+				return false;
+			}
+			pRefineStone = pItem;
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화 却 嘯 틈爛求."));
+			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pItem->GetWindow(), pItem->GetCell()));
+			return false;
+		}
+	}
+
+	BYTE bType, bGrade, bStep, bStrength;
+	if (!pDragonSoul || !pRefineStone)
+	{
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
+		return false;
+	}
+
+	if (NULL != pDragonSoul)
+	{
+		GetDragonSoulInfo(pDragonSoul->GetVnum(), bType, bGrade, bStep, bStrength);
+
+		float fWeight = 0.f;
+		// 치  摸 화   혼
+		if (!m_pTable->GetWeight(bType, bGrade, bStep, bStrength + 1, fWeight))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화   혼都求."));
+			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE, TItemPos(pDragonSoul->GetWindow(), pDragonSoul->GetCell()));
+			return false;
+		}
+		// 화  치 0繭  鵑 화퓬 홴홱.
+		if (fWeight < FLT_EPSILON)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화   혼都求."));
+			SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE, TItemPos(pDragonSoul->GetWindow(), pDragonSoul->GetCell()));
+			return false;
+		}
+	}
+
+	float fProb;
+	if (!m_pTable->GetRefineStrengthValues(bType, pRefineStone->GetSubType(), bStrength, fee, fProb))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화   혼都求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(pDragonSoul->GetWindow(), pDragonSoul->GetCell()));
+		return false;
+	}
+
+	if (ch->GetGold() < fee)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐   爛求."));
+		SendRefineResultPacket(ch, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
+		return false;
+	}
+
+	ch->PointChange(POINT_GOLD, -fee);
+
+	LPITEM pResult = NULL;
+	BYTE bSubHeader;
+
+	if (fnumber(0.f, 100.f) <= fProb)
+	{
+		pResult = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(bType, bGrade, bStep, bStrength + 1));
+		if (NULL == pResult)
+		{
+			sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(bType, bGrade, bStep, bStrength + 1));
+			return false;
+		}
+
+		char buf[128];
+		snprintf(buf, sizeof(buf), "STRENGTH : %d -> %d", bStrength, bStrength + 1);
+		LogManager::instance().ItemLog(ch, pDragonSoul, "DS_STRENGTH_REFINE_SUCCESS", buf);
+
+		pDragonSoul->CopyAttributeTo(pResult);
+		RefreshItemAttributes(pResult);
+
+		ITEM_MANAGER::instance().RemoveItem(pDragonSoul, "REMOVE (DS_STRENGTH_REFINE_SUCCESS)");
+		pRefineStone->SetCount(pRefineStone->GetCount() - 1);
+
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화 颯求."));
+		ch->AutoGiveItem(pResult, true);
+
+		bSubHeader = DS_SUB_HEADER_REFINE_SUCCEED;
+	}
+	else
+	{
+		if (bStrength != 0)
+		{
+			pResult = ITEM_MANAGER::instance().CreateItem(MakeDragonSoulVnum(bType, bGrade, bStep, bStrength - 1));
+			if (NULL == pResult)
+			{
+				sys_err("INVALID DRAGON SOUL(%d)", MakeDragonSoulVnum(bType, bGrade, bStep, bStrength - 1));
+				return false;
+			}
+			pDragonSoul->CopyAttributeTo(pResult);
+			RefreshItemAttributes(pResult);
+		}
+		bSubHeader = DS_SUB_HEADER_REFINE_FAIL;
+
+		char buf[128];
+		snprintf(buf, sizeof(buf), "STRENGTH : %d -> %d", bStrength, bStrength - 1);
+		// strength화 戟   羚,    慣琉 .
+		LogManager::instance().ItemLog(ch, pDragonSoul, "DS_STRENGTH_REFINE_FAIL", buf);
+
+		ITEM_MANAGER::instance().RemoveItem(pDragonSoul, "REMOVE (DS_STRENGTH_REFINE_FAIL)");
+		pRefineStone->SetCount(pRefineStone->GetCount() - 1);
+
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화 颯求."));
+
+		if (NULL != pResult)
+			ch->AutoGiveItem(pResult, true);
+	}
+
+	SendRefineResultPacket(ch, bSubHeader, NULL == pResult ? NPOS : TItemPos(pResult->GetWindow(), pResult->GetCell()));
+
+	return true;
+}
+
+#if defined(__DS_CHANGE_ATTR__)
+bool DSManager::DoChangeAttribute(LPCHARACTER lpCh, TItemPos(&arItemPos)[DRAGON_SOUL_REFINE_GRID_SIZE])
+{
+	if (lpCh == nullptr)
+		return false;
+
+	if (arItemPos == nullptr)
+		return false;
+
+	if (!lpCh->DragonSoul_RefineWindow_CanRefine())
+	{
+		sys_err("%s do not activate DragonSoulRefineWindow. But how can he come here?", lpCh->GetName());
+		lpCh->ChatPacket(CHAT_TYPE_INFO, "[SYSTEM ERROR]You cannot use dragon soul refine window.");
+		return false;
+	}
+
+	std::set<LPITEM> setItems;
+	for (int i = 0; i < DRAGON_SOUL_REFINE_GRID_SIZE; i++)
+	{
+		LPITEM lpItem = lpCh->GetItem(arItemPos[i]);
+		if (lpItem)
+			setItems.insert(lpItem);
+	}
+	if (setItems.empty())
+		return false;
+
+	LPITEM lpRefineMaterial = nullptr;
+	LPITEM lpDragonSoul = nullptr;
+	for (auto lpItem : setItems)
+	{
+		if (lpItem->IsEquipped())
+			return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		if (lpItem->IsSealed())
+		{
+			lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+			return false;
+		}
+#endif
+
+		if (lpItem->IsDragonSoul())
+		{
+			if (lpDragonSoul != nullptr)
+			{
+				SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(lpItem->GetWindow(), lpItem->GetCell()));
+				return false;
+			}
+			lpDragonSoul = lpItem;
+		}
+		else if (IsDragonSoulRefineMaterial(lpItem))
+		{
+			if (lpRefineMaterial != nullptr)
+			{
+				SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL, TItemPos(lpItem->GetWindow(), lpItem->GetCell()));
+				return false;
+			}
+			lpRefineMaterial = lpItem;
+		}
+		else
+		{
+			lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화 却 嘯 틈爛求."));
+			SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL, TItemPos(lpItem->GetWindow(), lpItem->GetCell()));
+			return false;
+		}
+	}
+
+	BYTE bType, bGrade, bStep, bStrength;
+	if (!lpDragonSoul || !lpRefineMaterial)
+	{
+		SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
+		return false;
+	}
+
+	if (lpDragonSoul != nullptr)
+	{
+		GetDragonSoulInfo(lpDragonSoul->GetVnum(), bType, bGrade, bStep, bStrength);
+		if (bGrade < DRAGON_SOUL_GRADE_MYTH)
+		{
+			lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING("화   혼都求."));
+			SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE, TItemPos(lpDragonSoul->GetWindow(), lpDragonSoul->GetCell()));
+			return false;
+		}
+	}
+
+	int64_t iFee = lpRefineMaterial->GetValue(0);
+	if (lpCh->GetGold() < iFee)
+	{
+		lpCh->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐   爛求."));
+		SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY, NPOS);
+		return false;
+	}
+
+	WORD wNeedMaterialCount = 1;
+	switch (bStep)
+	{
+		case DRAGON_SOUL_STEP_LOWEST:
+			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_LOWEST;
+			break;
+		case DRAGON_SOUL_STEP_LOW:
+			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_LOW;
+			break;
+		case DRAGON_SOUL_STEP_MID:
+			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_MID;
+			break;
+		case DRAGON_SOUL_STEP_HIGH:
+			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_HIGH;
+			break;
+		case DRAGON_SOUL_STEP_HIGHEST:
+			wNeedMaterialCount = DRAGON_SOUL_CHANGE_ATTR_STEP_HIGHEST;
+			break;
+	}
+
+	if (lpCh->CountSpecifyItem(lpRefineMaterial->GetVnum()) < wNeedMaterialCount)
+	{
+		SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL, NPOS);
+		return false;
+	}
+
+	lpCh->RemoveSpecifyItem(lpRefineMaterial->GetVnum(), wNeedMaterialCount);
+	lpCh->PointChange(POINT_GOLD, -iFee);
+
+	lpDragonSoul->ClearAllAttribute();
+	PutAttributes(lpDragonSoul);
+
+	SendRefineResultPacket(lpCh, DS_SUB_HEADER_REFINE_SUCCEED, TItemPos(lpDragonSoul->GetWindow(), lpDragonSoul->GetCell()));
+
+	return true;
+}
+#endif
+
+void DSManager::SendRefineResultPacket(LPCHARACTER ch, BYTE bSubHeader, const TItemPos& pos)
+{
+	TPacketGCDragonSoulRefine pack;
+	pack.bSubType = bSubHeader;
+
+	if (pos.IsValidItemPosition())
+	{
+		pack.Pos = pos;
+	}
+	LPDESC d = ch->GetDesc();
+	if (NULL == d)
+	{
+		return;
+	}
+	else
+	{
+		d->Packet(&pack, sizeof(pack));
+	}
+}
+
+int DSManager::LeftTime(LPITEM pItem) const
+{
+	if (pItem == NULL)
+		return false;
+
+	// 求 timer based on wear 혼 챨  퓸諍  .
+	if (pItem->GetProto()->cLimitTimerBasedOnWearIndex >= 0)
+	{
+		return pItem->GetSocket(ITEM_SOCKET_REMAIN_SEC);
+	}
+	// 摸 limit type 혼 챨 퓔       求 챨 年鳴 풔.
+	else
+	{
+		return INT_MAX;
+	}
+}
+
+bool DSManager::IsTimeLeftDragonSoul(LPITEM pItem) const
+{
+	if (pItem == NULL)
+		return false;
+
+	// 求 timer based on wear 혼 챨  퓸諍  .
+	if (pItem->GetProto()->cLimitTimerBasedOnWearIndex >= 0)
+	{
+		return pItem->GetSocket(ITEM_SOCKET_REMAIN_SEC) > 0;
+	}
+	// 摸 limit type 혼 챨 퓔       求 챨 年鳴 풔.
+	else
+	{
+		return true;
+	}
+}
+
+bool DSManager::IsActiveDragonSoul(LPITEM pItem) const
+{
+	return pItem->GetSocket(ITEM_SOCKET_DRAGON_SOUL_ACTIVE_IDX);
+}
+
+bool DSManager::ActivateDragonSoul(LPITEM pItem)
+{
+	if (NULL == pItem)
+		return false;
+
+	LPCHARACTER pOwner = pItem->GetOwner();
+	if (NULL == pOwner)
+		return false;
+
+	int deck_idx = pOwner->DragonSoul_GetActiveDeck();
+
+	if (deck_idx < 0)
+		return false;
+
+	if (WEAR_MAX_NUM + DS_SLOT_MAX * deck_idx <= pItem->GetCell() &&
+		pItem->GetCell() < WEAR_MAX_NUM + DS_SLOT_MAX * (deck_idx + 1))
+	{
+		if (IsTimeLeftDragonSoul(pItem) && !IsActiveDragonSoul(pItem))
+		{
+			char buf[128];
+			snprintf(buf, sizeof(buf), "LEFT TIME(%d)", LeftTime(pItem));
+			LogManager::instance().ItemLog(pOwner, pItem, "DS_ACTIVATE", buf);
+			pItem->ModifyPoints(true);
+			pItem->SetSocket(ITEM_SOCKET_DRAGON_SOUL_ACTIVE_IDX, 1);
+
+			pItem->StartTimerBasedOnWearExpireEvent();
+		}
+		return true;
+	}
+	else
+		return false;
+}
+
+bool DSManager::DeactivateDragonSoul(LPITEM pItem, bool bSkipRefreshOwnerActiveState)
+{
+	if (NULL == pItem)
+		return false;
+
+	LPCHARACTER pOwner = pItem->GetOwner();
+	if (NULL == pOwner)
+		return false;
+
+	if (!IsActiveDragonSoul(pItem))
+		return false;
+
+	char buf[128];
+	pItem->StopTimerBasedOnWearExpireEvent();
+	pItem->SetSocket(ITEM_SOCKET_DRAGON_SOUL_ACTIVE_IDX, 0);
+	pItem->ModifyPoints(false);
+
+	snprintf(buf, sizeof(buf), "LEFT TIME(%d)", LeftTime(pItem));
+	LogManager::instance().ItemLog(pOwner, pItem, "DS_DEACTIVATE", buf);
+
+	if (false == bSkipRefreshOwnerActiveState)
+		RefreshDragonSoulState(pOwner);
+
+	return true;
+}
+
+void DSManager::RefreshDragonSoulState(LPCHARACTER ch)
+{
+	if (NULL == ch)
+		return;
+
+	for (BYTE bSlotIdx = WEAR_MAX_NUM; bSlotIdx < DRAGON_SOUL_EQUIP_SLOT_END; bSlotIdx++)
+	{
+		LPITEM pItem = ch->GetWear(bSlotIdx);
+		if (pItem != NULL)
+		{
+			if (IsActiveDragonSoul(pItem))
+			{
+				return;
+			}
+		}
+	}
+
+	ch->DragonSoul_DeactivateAll();
+}
+
+#if defined(__DS_SET__)
+float DSManager::GetWeight(DWORD dwVnum)
+{
+	BYTE bType, bGrade, bStep, bStrength;
+	GetDragonSoulInfo(dwVnum, bType, bGrade, bStep, bStrength);
+
+	float fWeight = 0.f;
+	if (!m_pTable->GetWeight(bType, bGrade - 1, 0, 0, fWeight))
+		return 0.f;
+
+	return fWeight;
+}
+
+int DSManager::GetApplyCount(DWORD dwVnum)
+{
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
+
+	int basic_apply_num, add_min, add_max;
+	if (!m_pTable->GetApplyNumSettings(ds_type, grade_idx, basic_apply_num, add_min, add_max))
+		return 0;
+
+	return basic_apply_num;
+}
+
+int DSManager::GetBasicApplyValue(DWORD dwVnum, int iType, bool bAttr)
+{
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
+
+	int ret = 0;
+
+	DragonSoulTable::TVecApplys vec_basic_applys;
+	if (!m_pTable->GetBasicApplys(ds_type, vec_basic_applys))
+		return ret;
+
+	for (size_t i = 0; i < vec_basic_applys.size(); i++)
+	{
+		if (vec_basic_applys[i].apply_type == iType)
+		{
+			if (!bAttr)
+				ret = vec_basic_applys[i].apply_value;
+			else
+			{
+				float fWeight = 0.f;
+				if (!m_pTable->GetWeight(ds_type, grade_idx - 1, 0, 0, fWeight))
+					return 0;
+
+				fWeight /= 100.f;
+				ret = (short)(ceil((float)vec_basic_applys[i].apply_value * fWeight - 0.01f));
+			}
+			break;
+		}
+	}
+
+	return ret;
+}
+
+int DSManager::GetAdditionalApplyValue(DWORD dwVnum, int iType, bool bAttr)
+{
+	BYTE ds_type, grade_idx, step_idx, strength_idx;
+	GetDragonSoulInfo(dwVnum, ds_type, grade_idx, step_idx, strength_idx);
+
+	int ret = 0;
+
+	DragonSoulTable::TVecApplys vec_addtional_applys;
+	if (!m_pTable->GetAdditionalApplys(ds_type, vec_addtional_applys))
+		return ret;
+
+	for (size_t i = 0; i < vec_addtional_applys.size(); i++)
+	{
+		if (vec_addtional_applys[i].apply_type == iType)
+		{
+			if (!bAttr)
+				ret = vec_addtional_applys[i].apply_value;
+			else
+			{
+				float fWeight = 0.f;
+				if (!m_pTable->GetWeight(ds_type, grade_idx - 1, 0, 0, fWeight))
+					return 0;
+
+				fWeight /= 100.f;
+				ret = (short)(ceil((float)vec_addtional_applys[i].apply_value * fWeight - 0.01f));
+			}
+			break;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+DSManager::DSManager()
+{
+	m_pTable = NULL;
+}
+
+DSManager::~DSManager()
+{
+	if (m_pTable)
+		delete m_pTable;
+}
+#endif
diff --git a/server/metin2/Source/Server/game/src/ShopSearchManager.cpp b/server/metin2/Source/Server/game/src/ShopSearchManager.cpp
index 478accb..35d0203 100644
--- a/server/metin2/Source/Server/game/src/ShopSearchManager.cpp
+++ b/server/metin2/Source/Server/game/src/ShopSearchManager.cpp
@@ -32,7 +32,7 @@ void CShopSearchManager::UnregisterShopItem(DWORD ownerID, const TOfflineShopIte
 
 void CShopSearchManager::OnBuyShopItem(DWORD itemVnum, DWORD itemCount, uint64_t price)
 {
-	TPacketGDShopSearchSoldItem pack;
+	TPacketGDShopSearchSoldItem pack{};
 	pack.itemVnum = itemVnum;
 	pack.itemCount = itemCount;
 	pack.price = price;
@@ -47,7 +47,10 @@ void CShopSearchManager::ReloadAverageData()
 
 void CShopSearchManager::PC_RequestSearch(LPCHARACTER ch, const std::string& itemName, WORD page, BYTE entryCountIdx, BYTE sortType)
 {
-	TPacketGDShopSearchByName pack;
+	if (!ch || !ch->GetDesc())
+		return;
+
+	TPacketGDShopSearchByName pack{};
 //	BYTE bLocale = ch->GetDesc() ? ch->GetDesc()->GetLanguage() : LOCALE_EN;
 //	pack.langID = bLocale; 
 	strlcpy(pack.itemName, itemName.c_str(), sizeof(pack.itemName));
@@ -60,7 +63,10 @@ void CShopSearchManager::PC_RequestSearch(LPCHARACTER ch, const std::string& ite
 
 void CShopSearchManager::PC_RequestSearch(LPCHARACTER ch, const TShopSearchOptions* options, const TShopSearchItemType* itemTypeFlags, const DWORD* vnumList, WORD page, BYTE entryCountIdx, BYTE sortType)
 {
-	TPacketGDShopSearchByOptions pack;
+	if (!ch || !ch->GetDesc())
+		return;
+
+	TPacketGDShopSearchByOptions pack{};
 	pack.options = *options;
 	pack.page = page;
 	pack.entryCountIdx = entryCountIdx;
@@ -78,6 +84,9 @@ void CShopSearchManager::PC_RequestSearch(LPCHARACTER ch, const TShopSearchOptio
 
 void CShopSearchManager::PC_RequestBuy(LPCHARACTER ch, TOfflineItemID itemID, DWORD itemVnum, int64_t itemPrice)
 {
+	if (!ch || !ch->GetDesc())
+		return;
+
 	if (ch->GetGold() < itemPrice)
 		return;
 
@@ -86,7 +95,7 @@ void CShopSearchManager::PC_RequestBuy(LPCHARACTER ch, TOfflineItemID itemID, DW
 
 	ch->PointChange(POINT_GOLD, -itemPrice);
 
-	TPacketGDShopSearchRequestBuy pack;
+	TPacketGDShopSearchRequestBuy pack{};
 	pack.ownerID = ch->GetPlayerID();
 	pack.offlineID = itemID;
 	pack.itemVnum = itemVnum;
@@ -98,6 +107,9 @@ void CShopSearchManager::PC_RequestBuy(LPCHARACTER ch, TOfflineItemID itemID, DW
 
 void CShopSearchManager::PC_RequestSoldInfo(LPCHARACTER ch, DWORD itemVnum)
 {
+	if (!ch || !ch->GetDesc())
+		return;
+
 	db_clientdesc->DBPacket(HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO, ch->GetDesc()->GetHandle(), &itemVnum, sizeof(DWORD));
 }
 
@@ -107,14 +119,28 @@ void CShopSearchManager::PC_RequestSoldInfo(LPCHARACTER ch, DWORD itemVnum)
 
 void CShopSearchManager::DB_ResultSearch(LPCHARACTER ch, WORD maxPageNum, const TShopSearchClientItem* items, WORD itemCount)
 {
-	TPacketGCShopSearchResult pack;
+	if (!ch || !ch->GetDesc())
+		return;
+
+	if (itemCount > 0 && items == NULL)
+		return;
+
+	const size_t maxCount = (0xFFFF - sizeof(TPacketGCShopSearchResult)) / sizeof(TShopSearchClientItem);
+	if (itemCount > maxCount)
+	{
+		sys_err("DB_ResultSearch: itemCount overflow (%u)", itemCount);
+		return;
+	}
+
+	TPacketGCShopSearchResult pack{};
 	pack.header = HEADER_GC_SHOP_SEARCH_RESULT;
 	pack.size = sizeof(pack) + sizeof(TShopSearchClientItem) * itemCount;
 	pack.itemCount = itemCount;
 	pack.maxPageNum = maxPageNum;
 
 	ch->GetDesc()->BufferedPacket(&pack, sizeof(pack));
-	ch->GetDesc()->Packet(items, sizeof(TShopSearchClientItem) * itemCount);
+	if (itemCount > 0)
+		ch->GetDesc()->Packet(items, sizeof(TShopSearchClientItem) * itemCount);
 }
 
 void CShopSearchManager::DB_BuyFromShop(const TPacketDGShopSearchBuyFromShop* data)
@@ -156,7 +182,7 @@ void CShopSearchManager::DB_BuyFromShop(const TPacketDGShopSearchBuyFromShop* da
 #else
 		data->itemPrice, item->GetSockets(), item->GetAttributes(), item->GetTransmutationVnum());
 #endif
-	TPacketGDShopSearchBoughtFromShop pack;
+	TPacketGDShopSearchBoughtFromShop pack{};
 	pack.buyerDBHandle = data->buyerDBHandle;
 	ITEM_MANAGER::Instance().GetPlayerItem(item, &pack.item);
 	pack.item.dwOwner = data->buyerPID;
@@ -183,6 +209,11 @@ void CShopSearchManager::DB_BuyResult(LPDESC desc, const char* data)
 		TPlayerItem* itemData = (TPlayerItem*) data;
 
 		LPITEM item = ITEM_MANAGER::instance().CreateItem(itemData->dwVnum, itemData->dwCount);
+		if (!item)
+		{
+			sys_err("DB_BuyResult: cannot create item");
+			return;
+		}
 		item->SetAttributes(itemData->aAttr);
 #if defined(__ITEM_APPLY_RANDOM__)
 		item->SetRandomApplies(itemData->aApplyRandom);
@@ -221,7 +252,7 @@ void CShopSearchManager::DB_BuyResult(LPDESC desc, const char* data)
 
 	if (ch)
 	{
-		TPacketGCShopSearchBuyResult pack;
+		TPacketGCShopSearchBuyResult pack{};
 		pack.header = HEADER_GC_SHOP_SEARCH_BUY_RESULT;
 		pack.result = resultType;
 
@@ -231,7 +262,7 @@ void CShopSearchManager::DB_BuyResult(LPDESC desc, const char* data)
 
 void CShopSearchManager::DB_SoldInfo(LPCHARACTER ch, bool hasResults, const TShopSearchSoldItemInfo* results)
 {
-	TPacketGCShopSearchSoldInfo pack;
+	TPacketGCShopSearchSoldInfo pack{};
 	pack.header = HEADER_GC_SHOP_SEARCH_SOLD_INFO;
 	pack.size = sizeof(pack);
 	pack.results = hasResults;
diff --git a/server/metin2/Source/Server/game/src/auth_brazil.cpp b/server/metin2/Source/Server/game/src/auth_brazil.cpp
index 50c84e9..eae9893 100644
--- a/server/metin2/Source/Server/game/src/auth_brazil.cpp
+++ b/server/metin2/Source/Server/game/src/auth_brazil.cpp
@@ -1,178 +1,180 @@
-/**
-* File : auth_brazil.c
-* Date : 2010.4.7
-* Author : mhh
-* Description :
-**/
-
-#include "stdafx.h"
-
-#ifndef __WIN32__
-#include <unistd.h>
-#	include <stdint.h>
-#endif
-
-#include <stdio.h>
-#include <string.h>
-#ifdef __FreeBSD__
-#	include <md5.h>
-#else
-#	include "../../libthecore/include/xmd5.h"
-#endif
-
-#include "auth_brazil.h"
-
-static const char* FN_md5(const char* src)
-{
-	static char s_buffer[512];
-
-	memset(s_buffer, 0x00, sizeof(s_buffer));
-
-	unsigned char digest[16] = { 0 };
-	MD5_CTX md5;
-	MD5Init(&md5);
-	MD5Update(&md5, (const unsigned char*)src, strlen(src));
-	MD5Final(digest, &md5);
-
-	int offset = 0;
-	for (int i = 0; i < 16; ++i)
-	{
-		offset += sprintf(s_buffer + offset, "%02x", digest[i]);
-	}
-	return s_buffer;
-}
-
-static int FN_make_request(const char* login, const char* password, /*out*/ char* dst, int dst_size)
-{
-	int len = snprintf(dst, dst_size,
-		//"GET /metin2/game_auth.php?ID=%s&PW=%s HTTP/1.1\r\n"
-		"GET /metin2/?ID=%s&PW=%s HTTP/1.1\r\n"
-		"Host: auth.ongame.com.br\r\n"
-		"Connection: Close\r\n\r\n",
-		login, FN_md5(password));
-
-	return len;
-}
-
-static int FN_parse_reply(char* reply)
-{
-	char buffer[2048];
-	strlcpy(buffer, reply, sizeof(buffer));
-
-	const char* delim = "\r\n";
-	char* last = 0;
-	char* v = strtok_r(buffer, delim, &last);
-	char* result = 0;
-
-	while (v)
-	{
-		result = v;
-		v = strtok_r(NULL, delim, &last);
-	}
-
-	if (result)
-	{
-		if (0 == strcasecmp("true", result))
-			return AUTH_BRAZIL_SUCC;
-		else if (0 == strcasecmp("false", result))
-			return AUTH_BRAZIL_WRONGPWD;
-		else if (0 == strcasecmp("unknown", result))
-			return AUTH_BRAZIL_NOID;
-		else if (0 == strcasecmp("flash", result))
-			return AUTH_BRAZIL_FLASHUSER;
-	}
-
-	return AUTH_BRAZIL_SERVER_ERR;
-}
-
-extern void socket_timeout(socket_t s, long sec, long usec);
-
-int auth_brazil(const char* login, const char* pwd)
-{
-	const char* host = "auth.ongame.com.br";
-	int port = 80;
-
-	socket_t fd = socket_connect(host, port);
-	if (fd < 0)
-	{
-		sys_err("[AUTH_BRAZIL] : could not connect to gsp server(%s)", host);
-		return AUTH_BRAZIL_SERVER_ERR;
-	}
-
-	socket_block(fd);
-	socket_timeout(fd, 3, 0);
-
-	// send request
-	{
-		char request[512];
-		int len = FN_make_request(login, pwd, request, sizeof(request));
-
-#ifndef __WIN32__
-		if (write(fd, request, len) < 0)
-#else
-		if (_write(fd, request, len) < 0)
-#endif
-		{
-			sys_err("[AUTH_BRAZIL] : could not send auth-request (%s)", login);
-			close(fd);
-			return AUTH_BRAZIL_SERVER_ERR;
-		}
-	}
-
-	// read reply
-	{
-		char reply[1024] = { 0 };
-		int len = read(fd, reply, sizeof(reply));
-		close(fd);
-
-		if (len <= 0)
-		{
-			sys_err("[AUTH_BRAZIL] : could not recv auth-reply (%s)", login);
-			return AUTH_BRAZIL_SERVER_ERR;
-		}
-
-		// 응답받은 경우에만 query count를 늘린다.
-		auth_brazil_inc_query_count();
-
-		return FN_parse_reply(reply);
-	}
-}
-
-static int s_query_count = 0;
-
-int auth_brazil_inc_query_count()
-{
-	return ++s_query_count;
-}
-
-void auth_brazil_log()
-{
-	FILE* fp = 0;
-
-	// open and try backup
-	{
-		fp = fopen("AUTH_COUNT.log", "a");
-
-		if (0 == fp)
-			return;
-
-		struct stat sb;
-		fstat(fileno(fp), &sb);
-		if (sb.st_size > 1024 * 1024)
-		{
-			fclose(fp);
-			rename("AUTH_COUNT.log", "AUTH_COUNT.log.old");
-
-			fp = fopen("AUTH_COUNT.log", "a");
-		}
-	}
-
-	// write log
-	{
-		fprintf(fp, "%d\n", s_query_count);
-		fclose(fp);
-	}
-
-	// reset query count
-	s_query_count = 0;
-}
+/**
+* File : auth_brazil.c
+* Date : 2010.4.7
+* Author : mhh
+* Description :
+**/
+
+#include "stdafx.h"
+
+#ifndef __WIN32__
+#include <unistd.h>
+#	include <stdint.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#ifdef __FreeBSD__
+#	include <md5.h>
+#else
+#	include "../../libthecore/include/xmd5.h"
+#endif
+
+#include "auth_brazil.h"
+
+static const char* FN_md5(const char* src)
+{
+	static char s_buffer[512];
+
+	memset(s_buffer, 0x00, sizeof(s_buffer));
+
+	unsigned char digest[16] = { 0 };
+	MD5_CTX md5;
+	MD5Init(&md5);
+	MD5Update(&md5, (const unsigned char*)src, strlen(src));
+	MD5Final(digest, &md5);
+
+	int offset = 0;
+	for (int i = 0; i < 16; ++i)
+	{
+		if (offset + 2 >= (int)sizeof(s_buffer))
+			break;
+		offset += snprintf(s_buffer + offset, sizeof(s_buffer) - offset, "%02x", digest[i]);
+	}
+	return s_buffer;
+}
+
+static int FN_make_request(const char* login, const char* password, /*out*/ char* dst, int dst_size)
+{
+	int len = snprintf(dst, dst_size,
+		//"GET /metin2/game_auth.php?ID=%s&PW=%s HTTP/1.1\r\n"
+		"GET /metin2/?ID=%s&PW=%s HTTP/1.1\r\n"
+		"Host: auth.ongame.com.br\r\n"
+		"Connection: Close\r\n\r\n",
+		login, FN_md5(password));
+
+	return len;
+}
+
+static int FN_parse_reply(char* reply)
+{
+	char buffer[2048];
+	strlcpy(buffer, reply, sizeof(buffer));
+
+	const char* delim = "\r\n";
+	char* last = 0;
+	char* v = strtok_r(buffer, delim, &last);
+	char* result = 0;
+
+	while (v)
+	{
+		result = v;
+		v = strtok_r(NULL, delim, &last);
+	}
+
+	if (result)
+	{
+		if (0 == strcasecmp("true", result))
+			return AUTH_BRAZIL_SUCC;
+		else if (0 == strcasecmp("false", result))
+			return AUTH_BRAZIL_WRONGPWD;
+		else if (0 == strcasecmp("unknown", result))
+			return AUTH_BRAZIL_NOID;
+		else if (0 == strcasecmp("flash", result))
+			return AUTH_BRAZIL_FLASHUSER;
+	}
+
+	return AUTH_BRAZIL_SERVER_ERR;
+}
+
+extern void socket_timeout(socket_t s, long sec, long usec);
+
+int auth_brazil(const char* login, const char* pwd)
+{
+	const char* host = "auth.ongame.com.br";
+	int port = 80;
+
+	socket_t fd = socket_connect(host, port);
+	if (fd < 0)
+	{
+		sys_err("[AUTH_BRAZIL] : could not connect to gsp server(%s)", host);
+		return AUTH_BRAZIL_SERVER_ERR;
+	}
+
+	socket_block(fd);
+	socket_timeout(fd, 3, 0);
+
+	// send request
+	{
+		char request[512];
+		int len = FN_make_request(login, pwd, request, sizeof(request));
+
+#ifndef __WIN32__
+		if (write(fd, request, len) < 0)
+#else
+		if (_write(fd, request, len) < 0)
+#endif
+		{
+			sys_err("[AUTH_BRAZIL] : could not send auth-request (%s)", login);
+			close(fd);
+			return AUTH_BRAZIL_SERVER_ERR;
+		}
+	}
+
+	// read reply
+	{
+		char reply[1024] = { 0 };
+		int len = read(fd, reply, sizeof(reply));
+		close(fd);
+
+		if (len <= 0)
+		{
+			sys_err("[AUTH_BRAZIL] : could not recv auth-reply (%s)", login);
+			return AUTH_BRAZIL_SERVER_ERR;
+		}
+
+		//  荑 query count 첩.
+		auth_brazil_inc_query_count();
+
+		return FN_parse_reply(reply);
+	}
+}
+
+static int s_query_count = 0;
+
+int auth_brazil_inc_query_count()
+{
+	return ++s_query_count;
+}
+
+void auth_brazil_log()
+{
+	FILE* fp = 0;
+
+	// open and try backup
+	{
+		fp = fopen("AUTH_COUNT.log", "a");
+
+		if (0 == fp)
+			return;
+
+		struct stat sb;
+		fstat(fileno(fp), &sb);
+		if (sb.st_size > 1024 * 1024)
+		{
+			fclose(fp);
+			rename("AUTH_COUNT.log", "AUTH_COUNT.log.old");
+
+			fp = fopen("AUTH_COUNT.log", "a");
+		}
+	}
+
+	// write log
+	{
+		fprintf(fp, "%d\n", s_query_count);
+		fclose(fp);
+	}
+
+	// reset query count
+	s_query_count = 0;
+}
diff --git a/server/metin2/Source/Server/game/src/battle.cpp b/server/metin2/Source/Server/game/src/battle.cpp
index d4d1542..bcaeeaf 100644
--- a/server/metin2/Source/Server/game/src/battle.cpp
+++ b/server/metin2/Source/Server/game/src/battle.cpp
@@ -1,1125 +1,1161 @@
-#include "stdafx.h"
-#include "utils.h"
-#include "config.h"
-#include "desc.h"
-#include "char.h"
-#include "char_manager.h"
-#include "battle.h"
-#include "item.h"
-#include "item_manager.h"
-#include "mob_manager.h"
-#include "vector.h"
-#include "packet.h"
-#include "pvp.h"
-#include "profiler.h"
-#include "guild.h"
-#include "affect.h"
-#include "unique_item.h"
-#include "lua_incl.h"
-#include "arena.h"
-#include "castle.h"
-#include "sectree.h"
-#include "ani.h"
-#include "locale_service.h"
-
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-int battle_hit(LPCHARACTER ch, LPCHARACTER victim, int& iRetDam);
-
-//bool battle_distance_valid_by_xy(long x, long y, long tx, long ty)
-//{
-//	long distance = DISTANCE_APPROX(x - tx, y - ty);
-//
-//	if (distance > 170)
-//		return false;
-//
-//	return true;
-//}
-
-bool battle_distance_valid(LPCHARACTER ch, LPCHARACTER victim)
-{
-	//return battle_distance_valid_by_xy(ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY());
-
-	const int iDistance = DISTANCE_APPROX(ch->GetX() - victim->GetX(), ch->GetY() - victim->GetY());
-	float fHitRange = 300 + static_cast<int>(victim->GetMonsterHitRange());
-
-	if (iDistance > fHitRange)
-		return false;
-
-	return true;
-}
-
-int battle_get_max_distance(LPCHARACTER ch, LPCHARACTER victim)
-{
-	int max = 300;
-
-	if (!ch || !victim)
-		return max;
-
-	if (victim->IsMonster() || victim->IsStone())
-		max = (max / 100) * static_cast<int>(victim->GetMonsterHitRange());
-
-	if (ch->IsRiding())
-		max += 100;
-
-	return max;
-}
-
-bool timed_event_cancel(LPCHARACTER ch)
-{
-	if (ch->m_pkTimedEvent)
-	{
-		event_cancel(&ch->m_pkTimedEvent);
-		return true;
-	}
-
-	// RECALL_DELAY
-	// 차후 전투로 인해 귀환부 딜레이가 취소 되어야 할 경우 주석 해제
-	/*
-	if (ch->m_pk_RecallEvent)
-	{
-		event_cancel(&ch->m_pkRecallEvent);
-		return true;
-	}
-	*/
-	// END_OF_RECALL_DELAY
-
-	return false;
-}
-
-bool battle_is_attackable(LPCHARACTER ch, LPCHARACTER victim)
-{
-	// 상대방이 죽었으면 중단한다.
-	if (victim->IsDead() || victim->IsObserverMode())
-		return false;
-
-	// 안전지대면 중단
-	{
-		SECTREE* sectree = NULL;
-
-		sectree = ch->GetSectree();
-		if (sectree && sectree->IsAttr(ch->GetX(), ch->GetY(), ATTR_BANPK))
-			return false;
-
-		sectree = victim->GetSectree();
-		if (sectree && sectree->IsAttr(victim->GetX(), victim->GetY(), ATTR_BANPK))
-			return false;
-	}
-
-	// 내가 죽었으면 중단한다.
-	if (ch->IsStun() || ch->IsDead() || ch->IsObserverMode())
-		return false;
-
-	if (ch->IsPC() && victim->IsPC())
-	{
-		CGuild* g1 = ch->GetGuild();
-		CGuild* g2 = victim->GetGuild();
-
-		if (g1 && g2)
-		{
-			if (g1->UnderWar(g2->GetID()))
-				return true;
-		}
-	}
-
-	if (IS_CASTLE_MAP(ch->GetMapIndex()) && false == castle_can_attack(ch, victim))
-		return false;
-
-	if (CArenaManager::instance().CanAttack(ch, victim) == true)
-		return true;
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (CGuildDragonLairManager::Instance().IsKing(ch->GetRaceNum()) && ch->GetGuildDragonLair())
-		return false;
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-	if (ch->GetDefenseWave())
-	{
-		if (CDefenseWaveManager::Instance().CanAttack(ch, victim) == false)
-			return false;
-
-		if (ch->IsMonster() && CDefenseWaveManager::Instance().IsShipMast(victim->GetRaceNum()))
-			return true;
-	}
-#endif
-
-#if defined(__CONQUEROR_LEVEL__)
-	if (ch->IsPC() && ch->IsNewWorldMapIndex() && !(victim->IsPC()))
-		if (ch->GetConquerorLevel() == 0)
-			return false;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (victim->IsInvincible())
-		return false;
-#endif
-
-	return CPVPManager::instance().CanAttack(ch, victim);
-}
-
-int battle_melee_attack(LPCHARACTER ch, LPCHARACTER victim)
-{
-	if (test_server && ch->IsPC())
-		sys_log(0, "battle_melee_attack : [%s] attack to [%s]", ch->GetName(), victim->GetName());
-
-	if (!victim || ch == victim)
-		return BATTLE_NONE;
-
-	if (test_server && ch->IsPC())
-		sys_log(0, "battle_melee_attack : [%s] attack to [%s]", ch->GetName(), victim->GetName());
-
-	if (!battle_is_attackable(ch, victim))
-		return BATTLE_NONE;
-
-	if (test_server && ch->IsPC())
-		sys_log(0, "battle_melee_attack : [%s] attack to [%s]", ch->GetName(), victim->GetName());
-
-	// 거리 체크
-	int distance = DISTANCE_APPROX(ch->GetX() - victim->GetX(), ch->GetY() - victim->GetY());
-
-	if (!victim->IsBuilding())
-	{
-		int max = battle_get_max_distance(ch, victim);
-
-		if (false == ch->IsPC())
-		{
-			// 몬스터의 경우 몬스터 공격 거리를 사용
-			max = (int)(ch->GetMobAttackRange() * 1.15f);
-		}
-		else
-		{
-			// PC일 경우 상대가 melee 몹일 경우 몹의 공격 거리가 최대 공격 거리
-			if (false == victim->IsPC() && BATTLE_TYPE_MELEE == victim->GetMobBattleType())
-				max = MAX(max, (int)(victim->GetMobAttackRange() * 1.15f));
-		}
-
-		if (distance > max)
-		{
-			if (test_server)
-				sys_log(0, "VICTIM_FAR: %s distance: %d max: %d", ch->GetName(), distance, max);
-
-			return BATTLE_NONE;
-		}
-	}
-
-	if (timed_event_cancel(ch))
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("전투가 시작 되어 취소 되었습니다."));
-
-	if (timed_event_cancel(victim))
-		victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("전투가 시작 되어 취소 되었습니다."));
-
-	ch->SetPosition(POS_FIGHTING);
-	ch->SetVictim(victim);
-
-	const PIXEL_POSITION& vpos = victim->GetXYZ();
-	ch->SetRotationToXY(vpos.x, vpos.y);
-
-	int dam;
-	int ret = battle_hit(ch, victim, dam);
-	return (ret);
-}
-
-// 실제 GET_BATTLE_VICTIM을 NULL로 만들고 이벤트를 캔슬 시킨다.
-void battle_end_ex(LPCHARACTER ch)
-{
-	if (ch->IsPosition(POS_FIGHTING))
-		ch->SetPosition(POS_STANDING);
-
-#if defined(__ATTR_6TH_7TH__)
-	ch->StopHitBuffEvent();
-#endif
-}
-
-void battle_end(LPCHARACTER ch)
-{
-	battle_end_ex(ch);
-}
-
-// AG = Attack Grade
-// AL = Attack Limit
-int CalcBattleDamage(int iDam, int iAttackerLev, int iVictimLev)
-{
-	if (iDam < 3)
-		iDam = number(1, 5);
-
-	//return CALCULATE_DAMAGE_LVDELTA(iAttackerLev, iVictimLev, iDam);
-	return iDam;
-}
-
-int CalcMagicDamageWithValue(int iDam, LPCHARACTER pkAttacker, LPCHARACTER pkVictim)
-{
-	return CalcBattleDamage(iDam, pkAttacker->GetLevel(), pkVictim->GetLevel());
-}
-
-int CalcMagicDamage(LPCHARACTER pkAttacker, LPCHARACTER pkVictim)
-{
-	int iDam = 0;
-
-	if (pkAttacker->IsNPC())
-	{
-		iDam = CalcMeleeDamage(pkAttacker, pkVictim, false, false);
-	}
-
-	iDam += pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS);
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	iDam += pkAttacker->GetAcceWeaponMagicAttack();
-#endif
-
-	return CalcMagicDamageWithValue(iDam, pkAttacker, pkVictim);
-}
-
-float CalcAttackRating(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, bool bIgnoreTargetRating)
-{
-	int iARSrc;
-	int iERSrc;
-
-	if (LC_IsYMIR()) // 천마
-	{
-		iARSrc = MIN(gPlayerMaxLevelStats, pkAttacker->GetPolymorphPoint(POINT_DX));
-		iERSrc = MIN(gPlayerMaxLevelStats, pkVictim->GetPolymorphPoint(POINT_DX));
-	}
-	else
-	{
-		int attacker_dx = pkAttacker->GetPolymorphPoint(POINT_DX);
-		int attacker_lv = pkAttacker->GetLevel();
-
-		int victim_dx = pkVictim->GetPolymorphPoint(POINT_DX);
-		int victim_lv = pkAttacker->GetLevel();
-
-		iARSrc = MIN(gPlayerMaxLevelStats, (attacker_dx * 4 + attacker_lv * 2) / 6);
-		iERSrc = MIN(gPlayerMaxLevelStats, (victim_dx * 4 + victim_lv * 2) / 6);
-	}
-
-	float fAR = ((float)iARSrc + 210.0f) / 300.0f; // fAR = 0.7 ~ 1.0
-
-	if (bIgnoreTargetRating)
-		return fAR;
-
-	// ((Edx * 2 + 20) / (Edx + 110)) * 0.3
-	float fER = ((float)(iERSrc * 2 + 5) / (iERSrc + 95)) * 3.0f / 10.0f;
-
-	return fAR - fER;
-}
-
-static int CalcAttBonusWithPct(const LPCHARACTER& c_pAttacker,
-	const POINT_TYPE c_wAttPoint, const POINT_TYPE c_wAttPctPoint)
-{
-	if ((c_wAttPoint == POINT_NONE) || (c_wAttPoint > POINT_MAX_NUM || c_wAttPctPoint > POINT_MAX_NUM))
-		return 0;
-
-	if (c_wAttPctPoint == POINT_NONE)
-		return c_pAttacker->GetPoint(c_wAttPoint);
-
-	int iAttValue = c_pAttacker->GetPoint(c_wAttPoint);
-	if (iAttValue == 0)
-		return 0;
-
-	int iAttPctValue = c_pAttacker->GetPoint(c_wAttPctPoint);
-	if (iAttPctValue)
-	{
-		float fPctValue = (iAttValue * iAttPctValue) / 100.0f;
-		iAttValue += MAX(static_cast<int>(fPctValue), 1);
-	}
-
-	return iAttValue;
-}
-
-int CalcAttBonus(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, int iAtk)
-{
-	// PvP에는 적용하지않음
-	if (!pkVictim->IsPC())
-		iAtk += pkAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_ATTACK_BONUS);
-
-	// PvP에는 적용하지않음
-	if (!pkAttacker->IsPC())
-	{
-		int iReduceDamagePct = pkVictim->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_TRANSFER_DAMAGE);
-		iAtk = iAtk * (100 + iReduceDamagePct) / 100;
-	}
-
-	if (pkAttacker->IsNPC() /*&& pkVictim->IsPC()*/)
-	{
-		iAtk = (iAtk * CHARACTER_MANAGER::instance().GetMobDamageRate(pkAttacker)) / 100;
-	}
-
-	if (pkVictim->IsPC() && (pkVictim->GetHP() >= (pkVictim->GetMaxHP() * 0.9)))
-		iAtk -= (iAtk * pkVictim->GetPoint(POINT_MORE_THEN_HP90_DAMAGE_REDUCE)) / 100;
-
-	if (pkVictim->IsNPC())
-	{
-		if (pkVictim->IsRaceFlag(RACE_FLAG_ANIMAL))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_ANIMAL, POINT_ATTBONUS_PER_ANIMAL)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_UNDEAD))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_UNDEAD, POINT_ATTBONUS_PER_UNDEAD)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_DEVIL))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_DEVIL, POINT_ATTBONUS_PER_DEVIL)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_HUMAN))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_HUMAN, POINT_ATTBONUS_PER_HUMAN)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_ORC))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_ORC, POINT_ATTBONUS_PER_ORC)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_MILGYO))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_MILGYO, POINT_ATTBONUS_PER_MILGYO)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_INSECT))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_INSECT, POINT_ATTBONUS_PER_INSECT)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_DESERT))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_DESERT, POINT_ATTBONUS_PER_DESERT)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_TREE))
-			iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_TREE)) / 100;
-
-		if (pkVictim->IsRaceFlag(RACE_FLAG_ATT_CZ))
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_CZ, POINT_ATTBONUS_PER_CZ)) / 100;
-
-#if defined(__ELEMENT_SYSTEM__)
-		if (pkVictim->GetMobElement(MOB_ELEMENT_ELECT))
-			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_ELECT, POINT_ENCHANT_PER_ELECT) - pkVictim->GetMobElement(MOB_ELEMENT_ELECT)) / 2)) / 100);
-		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_ELECT, POINT_ENCHANT_PER_ELECT) - pkVictim->GetMobElement(MOB_ELEMENT_ELECT))) / 100;
-
-		if (pkVictim->GetMobElement(MOB_ELEMENT_FIRE))
-			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_FIRE, POINT_ENCHANT_PER_FIRE) - pkVictim->GetMobElement(MOB_ELEMENT_FIRE)) / 2)) / 100);
-		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_FIRE, POINT_ENCHANT_PER_FIRE) - pkVictim->GetMobElement(MOB_ELEMENT_FIRE))) / 100;
-
-		if (pkVictim->GetMobElement(MOB_ELEMENT_ICE))
-			iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_ICE, POINT_ENCHANT_PER_ICE) - pkVictim->GetMobElement(MOB_ELEMENT_ICE))) / 100;
-
-		if (pkVictim->GetMobElement(MOB_ELEMENT_WIND))
-			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_WIND, POINT_ENCHANT_PER_WIND) - pkVictim->GetMobElement(MOB_ELEMENT_WIND)) / 2)) / 100);
-		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_WIND, POINT_ENCHANT_PER_WIND) - pkVictim->GetMobElement(MOB_ELEMENT_WIND))) / 100;
-
-		if (pkVictim->GetMobElement(MOB_ELEMENT_EARTH))
-			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_EARTH, POINT_ENCHANT_PER_EARTH) - pkVictim->GetMobElement(MOB_ELEMENT_EARTH)) / 2)) / 100);
-		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_EARTH, POINT_ENCHANT_PER_EARTH) - pkVictim->GetMobElement(MOB_ELEMENT_EARTH))) / 100;
-
-		if (pkVictim->GetMobElement(MOB_ELEMENT_DARK))
-			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_DARK, POINT_ENCHANT_PER_DARK) - pkVictim->GetMobElement(MOB_ELEMENT_DARK)) / 2)) / 100);
-		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_DARK, POINT_ENCHANT_PER_DARK) - pkVictim->GetMobElement(MOB_ELEMENT_DARK))) / 100;
-#endif
-
-		if (pkVictim->IsNPC())
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_MONSTER, POINT_ATTBONUS_PER_MONSTER)) / 100;
-
-		if (pkVictim->IsStone())
-			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_STONE, POINT_ATTBONUS_PER_STONE)) / 100;
-
-		if (pkVictim->IsMonster() && pkVictim->GetMobRank() >= MOB_RANK_BOSS)
-			iAtk += (iAtk * pkAttacker->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE)) / 100;
-	}
-	else if (pkVictim->IsPC())
-	{
-#if defined(__ELEMENT_SYSTEM__)
-		iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_HUMAN, POINT_ATTBONUS_PER_HUMAN) - CalcAttBonusWithPct(pkVictim, POINT_RESIST_HUMAN, POINT_RESIST_PER_HUMAN))) / 100;
-#else
-		iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_HUMAN)) / 100;
-#endif
-
-		switch (pkVictim->GetJob())
-		{
-			case JOB_WARRIOR:
-				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_WARRIOR)) / 100;
-				break;
-
-			case JOB_ASSASSIN:
-				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_ASSASSIN)) / 100;
-				break;
-
-			case JOB_SURA:
-				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_SURA)) / 100;
-				break;
-
-			case JOB_SHAMAN:
-				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_SHAMAN)) / 100;
-				break;
-
-			case JOB_WOLFMAN:
-				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_WOLFMAN)) / 100;
-				break;
-		}
-	}
-
-	if (pkAttacker->IsPC())
-	{
-		switch (pkAttacker->GetJob())
-		{
-			case JOB_WARRIOR:
-				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_WARRIOR)) / 100;
-				break;
-
-			case JOB_ASSASSIN:
-				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_ASSASSIN)) / 100;
-				break;
-
-			case JOB_SURA:
-				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_SURA)) / 100;
-				break;
-
-			case JOB_SHAMAN:
-				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_SHAMAN)) / 100;
-				break;
-
-			case JOB_WOLFMAN:
-				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_WOLFMAN)) / 100;
-				break;
-		}
-
-		if (pkAttacker->GetPoint(POINT_ALIGNMENT_DAMAGE_BONUS))
-		{
-			if (pkAttacker->GetAlignmentGrade() >= ALIGN_GRADE_NORMAL)
-			{
-				int iAlignmentDamage = 0;
-				switch (pkAttacker->GetAlignmentGrade())
-				{
-					case ALIGN_GRADE_EVIL_1: iAlignmentDamage = 1; break;
-					case ALIGN_GRADE_EVIL_2: iAlignmentDamage = 2; break;
-					case ALIGN_GRADE_EVIL_3: iAlignmentDamage = 3; break;
-					case ALIGN_GRADE_EVIL_4: iAlignmentDamage = 5; break;
-				}
-				iAtk += (iAtk * iAlignmentDamage) / 100;
-			}
-		}
-	}
-
-	// [mob -> PC] Apply elemental defense
-	// 20130117.
-	// Resistance is applied to the value corresponding to x%
-	// of the damage caused by a monster's elemental attack.
-
-	const int c_iMobElementDef = 75;
-
-	if (pkAttacker->IsMonster() && pkVictim->IsPC())
-	{
-#if defined(__ATTR_6TH_7TH__)
-		iAtk -= (iAtk * pkVictim->GetPoint(POINT_MONSTER_DEFEND_BONUS)) / 100;
-
-		if (pkAttacker->GetMobRank() >= MOB_RANK_BOSS)
-			iAtk -= (iAtk * pkVictim->GetPoint(POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE)) / 100;
-#endif
-
-#if defined(__ELEMENT_SYSTEM__)
-		if (pkAttacker->GetMobElement(MOB_ELEMENT_ELECT))
-			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_ELEC, POINT_RESIST_PER_ELEC)) / 10000;
-
-		else if (pkAttacker->GetMobElement(MOB_ELEMENT_FIRE))
-			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_FIRE, POINT_RESIST_PER_FIRE)) / 10000;
-
-		else if (pkAttacker->GetMobElement(MOB_ELEMENT_ICE))
-			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_ICE, POINT_RESIST_PER_ICE)) / 10000;
-
-		else if (pkAttacker->GetMobElement(MOB_ELEMENT_WIND))
-			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_WIND, POINT_RESIST_PER_WIND)) / 10000;
-
-		else if (pkAttacker->GetMobElement(MOB_ELEMENT_EARTH))
-			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_EARTH, POINT_RESIST_PER_EARTH)) / 10000;
-
-		else if (pkAttacker->GetMobElement(MOB_ELEMENT_DARK))
-			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_DARK, POINT_RESIST_PER_DARK)) / 10000;
-#else
-		/*
-		if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_ELEC))
-			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_ELEC)) / 10000;
-		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_FIRE))
-			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_FIRE)) / 10000;
-		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_ICE))
-			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_ICE)) / 10000;
-		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_WIND))
-			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_WIND)) / 10000;
-		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_EARTH))
-			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_EARTH)) / 10000;
-		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_DARK))
-			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_DARK)) / 10000;
-		*/
-#endif
-	}
-
-	return iAtk;
-}
-
-void Item_GetDamage(LPITEM pkItem, int* pdamMin, int* pdamMax)
-{
-	*pdamMin = 0;
-	*pdamMax = 1;
-
-	if (!pkItem)
-		return;
-
-	switch (pkItem->GetType())
-	{
-		case ITEM_ROD:
-		case ITEM_PICK:
-			return;
-	}
-
-	if (pkItem->GetType() != ITEM_WEAPON)
-		sys_err("Item_GetDamage - !ITEM_WEAPON vnum=%d, type=%d", pkItem->GetOriginalVnum(), pkItem->GetType());
-
-#if defined(__ITEM_APPLY_RANDOM__) && defined(__ITEM_VALUE10__)
-	DWORD dwMinDam = 0, dwMaxDam = 0;
-	const DWORD dwMinMax = pkItem->GetSocket(ITEM_SOCKET_ATK_MINMAX_RANDOM);
-
-	if (dwMinMax != 0)
-	{
-		dwMinDam += dwMinMax / ITEM_VALUE_MINMAX_RANDOM_DIVISION_VALUE;
-		dwMaxDam += dwMinMax % (ITEM_VALUE_MINMAX_RANDOM_DIVISION_VALUE / 100);
-	}
-	else
-	{
-		dwMinDam = pkItem->GetValue(3);
-		dwMaxDam = pkItem->GetValue(4);
-	}
-
-	*pdamMin = dwMinDam;
-	*pdamMax = dwMaxDam;
-#else
-	* pdamMin = pkItem->GetValue(3);
-	*pdamMax = pkItem->GetValue(4);
-#endif
-}
-
-int CalcMeleeDamage(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, bool bIgnoreDefense, bool bIgnoreTargetRating)
-{
-	LPITEM pWeapon = pkAttacker->GetWear(WEAR_WEAPON);
-	bool bPolymorphed = pkAttacker->IsPolymorphed();
-
-	if (pWeapon && !(bPolymorphed && !pkAttacker->IsPolyMaintainStat()))
-	{
-		if (pWeapon->GetType() != ITEM_WEAPON)
-			return 0;
-
-		switch (pWeapon->GetSubType())
-		{
-			case WEAPON_SWORD:
-			case WEAPON_DAGGER:
-			case WEAPON_TWO_HANDED:
-			case WEAPON_BELL:
-			case WEAPON_FAN:
-			case WEAPON_MOUNT_SPEAR:
-			case WEAPON_CLAW:
-				break;
-
-			case WEAPON_BOW:
-				sys_err("CalcMeleeDamage should not handle bows (name: %s)", pkAttacker->GetName());
-				return 0;
-
-			default:
-				return 0;
-		}
-	}
-
-	int iDam = 0;
-	float fAR = CalcAttackRating(pkAttacker, pkVictim, bIgnoreTargetRating);
-	int iDamMin = 0, iDamMax = 0;
-
-	// TESTSERVER_SHOW_ATTACKINFO
-	int DEBUG_iDamCur = 0;
-	int DEBUG_iDamBonus = 0;
-	// END_OF_TESTSERVER_SHOW_ATTACKINFO
-
-	if (bPolymorphed && !pkAttacker->IsPolyMaintainStat())
-	{
-		// MONKEY_ROD_ATTACK_BUG_FIX
-		Item_GetDamage(pWeapon, &iDamMin, &iDamMax);
-		// END_OF_MONKEY_ROD_ATTACK_BUG_FIX
-
-		DWORD dwMobVnum = pkAttacker->GetPolymorphVnum();
-		const CMob* pMob = CMobManager::instance().Get(dwMobVnum);
-
-		if (pMob)
-		{
-			int iPower = pkAttacker->GetPolymorphPower();
-			iDamMin += pMob->m_table.dwDamageRange[0] * iPower / 100;
-			iDamMax += pMob->m_table.dwDamageRange[1] * iPower / 100;
-		}
-	}
-	else if (pWeapon)
-	{
-		// MONKEY_ROD_ATTACK_BUG_FIX
-		Item_GetDamage(pWeapon, &iDamMin, &iDamMax);
-		// END_OF_MONKEY_ROD_ATTACK_BUG_FIX
-	}
-	else if (pkAttacker->IsNPC())
-	{
-		iDamMin = pkAttacker->GetMobDamageMin();
-		iDamMax = pkAttacker->GetMobDamageMax();
-	}
-
-	iDam = number(iDamMin, iDamMax) * 2;
-
-	// TESTSERVER_SHOW_ATTACKINFO
-	DEBUG_iDamCur = iDam;
-	// END_OF_TESTSERVER_SHOW_ATTACKINFO
-	//
-	int iAtk = 0;
-
-	// level must be ignored when multiply by fAR, so subtract it before calculation.
-	iAtk = pkAttacker->GetPoint(POINT_ATT_GRADE) + iDam - (pkAttacker->GetLevel() * 2);
-	iAtk = (int)(iAtk * fAR);
-	iAtk += pkAttacker->GetLevel() * 2; // and add again
-
-	if (pWeapon)
-	{
-		iAtk += pWeapon->GetValue(5) * 2;
-
-		// 20041112.myevan.TESTSERVER_SHOW_ATTACKINFO
-		DEBUG_iDamBonus = pWeapon->GetValue(5) * 2;
-		///////////////////////////////////////////////
-	}
-
-	iAtk += pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS); // party attacker role bonus
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	iAtk += pkAttacker->GetAcceWeaponAttack();
-#endif
-	iAtk = (int)(iAtk * (100 + (pkAttacker->GetPoint(POINT_ATT_BONUS) + pkAttacker->GetPoint(POINT_MELEE_MAGIC_ATT_BONUS_PER))) / 100);
-
-	iAtk = CalcAttBonus(pkAttacker, pkVictim, iAtk);
-
-	int iDef = 0;
-
-	if (!bIgnoreDefense)
-	{
-		iDef = (pkVictim->GetPoint(POINT_DEF_GRADE) * (100 + pkVictim->GetPoint(POINT_DEF_BONUS)) / 100);
-
-		if (!pkAttacker->IsPC())
-			iDef += pkVictim->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_DEFENSE_BONUS);
-	}
-
-	if (pkAttacker->IsNPC())
-		iAtk = (int)(iAtk * pkAttacker->GetMobDamageMultiply());
-
-	iDam = MAX(0, iAtk - iDef);
-
-	if (test_server && g_bTestMobLog)
-	{
-		int DEBUG_iLV = pkAttacker->GetLevel() * 2;
-		int DEBUG_iST = int((pkAttacker->GetPoint(POINT_ATT_GRADE) - DEBUG_iLV) * fAR);
-		int DEBUG_iPT = pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS);
-		int DEBUG_iWP = 0;
-		int DEBUG_iPureAtk = 0;
-		int DEBUG_iPureDam = 0;
-		char szRB[32] = "";
-		char szGradeAtkBonus[32] = "";
-
-		DEBUG_iWP = int(DEBUG_iDamCur * fAR);
-		DEBUG_iPureAtk = DEBUG_iLV + DEBUG_iST + DEBUG_iWP + DEBUG_iDamBonus;
-		DEBUG_iPureDam = iAtk - iDef;
-
-		if (pkAttacker->IsNPC())
-		{
-			snprintf(szGradeAtkBonus, sizeof(szGradeAtkBonus), "=%d*%.1f", DEBUG_iPureAtk, pkAttacker->GetMobDamageMultiply());
-			DEBUG_iPureAtk = int(DEBUG_iPureAtk * pkAttacker->GetMobDamageMultiply());
-		}
-
-		if (DEBUG_iDamBonus != 0)
-			snprintf(szRB, sizeof(szRB), "+RB(%d)", DEBUG_iDamBonus);
-
-		char szPT[32] = "";
-
-		if (DEBUG_iPT != 0)
-			snprintf(szPT, sizeof(szPT), ", PT=%d", DEBUG_iPT);
-
-		char szUnknownAtk[32] = "";
-
-		if (iAtk != DEBUG_iPureAtk)
-			snprintf(szUnknownAtk, sizeof(szUnknownAtk), "+?(%d)", iAtk - DEBUG_iPureAtk);
-
-		char szUnknownDam[32] = "";
-
-		if (iDam != DEBUG_iPureDam)
-			snprintf(szUnknownDam, sizeof(szUnknownDam), "+?(%d)", iDam - DEBUG_iPureDam);
-
-		char szMeleeAttack[128];
-
-		snprintf(szMeleeAttack, sizeof(szMeleeAttack),
-			"%s(%d)-%s(%d)=%d%s, ATK=LV(%d)+ST(%d)+WP(%d)%s%s%s, AR=%.3g%s",
-			pkAttacker->GetName(),
-			iAtk,
-			pkVictim->GetName(),
-			iDef,
-			iDam,
-			szUnknownDam,
-			DEBUG_iLV,
-			DEBUG_iST,
-			DEBUG_iWP,
-			szRB,
-			szUnknownAtk,
-			szGradeAtkBonus,
-			fAR,
-			szPT);
-
-		pkAttacker->ChatPacket(CHAT_TYPE_TALKING, "%s", szMeleeAttack);
-		pkVictim->ChatPacket(CHAT_TYPE_TALKING, "%s", szMeleeAttack);
-	}
-
-	return CalcBattleDamage(iDam, pkAttacker->GetLevel(), pkVictim->GetLevel());
-}
-
-int CalcArrowDamage(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, LPITEM pkBow, LPITEM pkArrow, bool bIgnoreDefense)
-{
-	if (!pkBow || pkBow->GetType() != ITEM_WEAPON || pkBow->GetSubType() != WEAPON_BOW)
-		return 0;
-
-	if (!pkArrow)
-		return 0;
-
-	// 타격치 계산부
-	int iDist = (int)(DISTANCE_SQRT(pkAttacker->GetX() - pkVictim->GetX(), pkAttacker->GetY() - pkVictim->GetY()));
-	//int iGap = (iDist / 100) - 5 - pkBow->GetValue(5) - pkAttacker->GetPoint(POINT_BOW_DISTANCE);
-	int iGap = (iDist / 100) - 5 - pkAttacker->GetPoint(POINT_BOW_DISTANCE);
-	int iPercent = 100 - (iGap * 5);
-
-#if defined(__QUIVER_SYSTEM__)
-	if (pkArrow->GetSubType() == WEAPON_QUIVER)
-		iPercent = 100;
-#endif
-
-	if (iPercent <= 0)
-		return 0;
-	else if (iPercent > 100)
-		iPercent = 100;
-
-	int iDam = 0;
-
-	float fAR = CalcAttackRating(pkAttacker, pkVictim, false);
-	iDam = number(pkBow->GetValue(3), pkBow->GetValue(4)) * 2 + pkArrow->GetValue(3);
-	int iAtk;
-
-	// level must be ignored when multiply by fAR, so subtract it before calculation.
-	iAtk = pkAttacker->GetPoint(POINT_ATT_GRADE) + iDam - (pkAttacker->GetLevel() * 2);
-	iAtk = (int)(iAtk * fAR);
-	iAtk += pkAttacker->GetLevel() * 2; // and add again
-
-	// Refine Grade
-	iAtk += pkBow->GetValue(5) * 2;
-
-	iAtk += pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS);
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	iAtk += pkAttacker->GetAcceWeaponAttack();
-#endif
-	iAtk = (int)(iAtk * (100 + (pkAttacker->GetPoint(POINT_ATT_BONUS) + pkAttacker->GetPoint(POINT_MELEE_MAGIC_ATT_BONUS_PER))) / 100);
-
-	iAtk = CalcAttBonus(pkAttacker, pkVictim, iAtk);
-
-	int iDef = 0;
-
-	if (!bIgnoreDefense)
-		iDef = (pkVictim->GetPoint(POINT_DEF_GRADE) * (100 + pkAttacker->GetPoint(POINT_DEF_BONUS)) / 100);
-
-	if (pkAttacker->IsNPC())
-		iAtk = (int)(iAtk * pkAttacker->GetMobDamageMultiply());
-
-	iDam = MAX(0, iAtk - iDef);
-
-	int iPureDam = iDam;
-
-	iPureDam = (iPureDam * iPercent) / 100;
-
-	if (test_server)
-	{
-		pkAttacker->ChatPacket(CHAT_TYPE_INFO, "ARROW %s -> %s, DAM %d DIST %d GAP %d %% %d",
-			pkAttacker->GetName(),
-			pkVictim->GetName(),
-			iPureDam,
-			iDist, iGap, iPercent);
-	}
-
-	return iPureDam;
-	//return iDam;
-}
-
-void NormalAttackAffect(LPCHARACTER pkAttacker, LPCHARACTER pkVictim)
-{
-	// 독 공격은 특이하므로 특수 처리
-	if (pkAttacker->GetPoint(POINT_POISON_PCT) && !pkVictim->IsAffectFlag(AFF_POISON))
-	{
-#if defined(__CONQUEROR_LEVEL__)
-		int iPoisonPct = pkAttacker->GetPoint(POINT_POISON_PCT);
-		if (pkAttacker->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
-			iPoisonPct /= 2;
-
-		if (number(1, 100) <= iPoisonPct)
-			pkVictim->AttackedByPoison(pkAttacker);
-#else
-		if (number(1, 100) <= pkAttacker->GetPoint(POINT_POISON_PCT))
-			pkVictim->AttackedByPoison(pkAttacker);
-#endif
-	}
-
-	if (pkAttacker->GetPoint(POINT_BLEEDING_PCT) && !pkVictim->IsAffectFlag(AFF_BLEEDING))
-	{
-#if defined(__CONQUEROR_LEVEL__)
-		int iBleedingPct = pkAttacker->GetPoint(POINT_BLEEDING_PCT);
-		if (pkAttacker->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
-			iBleedingPct /= 2;
-
-		if (number(1, 100) <= iBleedingPct)
-			pkVictim->AttackedByPoison(pkAttacker);
-#else
-		if (number(1, 100) <= pkAttacker->GetPoint(POINT_BLEEDING_PCT))
-			pkVictim->AttackedByBleeding(pkAttacker);
-#endif
-	}
-
-	int iStunDuration = 2;
-	if (pkAttacker->IsPC() && !pkVictim->IsPC())
-		iStunDuration = 4;
-
-	AttackAffect(pkAttacker, pkVictim, POINT_STUN_PCT, IMMUNE_STUN, AFFECT_STUN, POINT_NONE, 0, AFF_STUN, iStunDuration, "STUN");
-	AttackAffect(pkAttacker, pkVictim, POINT_SLOW_PCT, IMMUNE_SLOW, AFFECT_SLOW, POINT_MOV_SPEED, -30, AFF_SLOW, 20, "SLOW");
-}
-
-int battle_hit(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, int& iRetDam)
-{
-	int iDam = CalcMeleeDamage(pkAttacker, pkVictim);
-	if (iDam <= 0)
-		return (BATTLE_DAMAGE);
-
-	NormalAttackAffect(pkAttacker, pkVictim);
-
-	// 데미지 계산
-	//iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST)) / 100;
-	LPITEM pkWeapon = pkAttacker->GetWear(WEAR_WEAPON);
-
-	if (pkWeapon)
-	{
-		switch (pkWeapon->GetSubType())
-		{
-			case WEAPON_SWORD:
-			{
-#if defined(__ELEMENT_SYSTEM__)
-				if (pkVictim->IsPC())
-					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_SWORD) - pkAttacker->GetPoint(POINT_ATTBONUS_SWORD))) / 100;
-				else
-					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_SWORD)) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_SWORD)) / 100;
-#endif
-			}
-			break;
-
-			case WEAPON_TWO_HANDED:
-			{
-#if defined(__ELEMENT_SYSTEM__)
-				if (pkVictim->IsPC())
-					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_TWOHAND) - pkAttacker->GetPoint(POINT_ATTBONUS_TWOHAND))) / 100;
-				else
-					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_TWOHAND)) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_TWOHAND)) / 100;
-#endif
-			}
-			break;
-
-			case WEAPON_DAGGER:
-			{
-#if defined(__ELEMENT_SYSTEM__)
-				if (pkVictim->IsPC())
-					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_DAGGER) - pkVictim->GetPoint(POINT_ATTBONUS_DAGGER))) / 100;
-				else
-					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_DAGGER)) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_DAGGER)) / 100;
-#endif
-			}
-			break;
-
-			case WEAPON_BELL:
-			{
-#if defined(__ELEMENT_SYSTEM__)
-				if (pkVictim->IsPC())
-					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_BELL) - pkAttacker->GetPoint(POINT_ATTBONUS_BELL))) / 100;
-				else
-					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BELL)) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BELL)) / 100;
-#endif
-			}
-			break;
-
-			case WEAPON_FAN:
-			{
-#if defined(__ELEMENT_SYSTEM__)
-				if (pkVictim->IsPC())
-					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_FAN) - pkAttacker->GetPoint(POINT_ATTBONUS_FAN))) / 100;
-				else
-					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_FAN)) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_FAN)) / 100;
-#endif
-			}
-			break;
-
-			case WEAPON_BOW:
-			{
-#if defined(__ELEMENT_SYSTEM__)
-				if (pkVictim->IsPC())
-					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_BOW) - pkAttacker->GetPoint(POINT_ATTBONUS_BOW))) / 100;
-				else
-					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BOW)) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BOW)) / 100;
-#endif
-			}
-			break;
-
-			case WEAPON_CLAW:
-			{
-#if defined(__ELEMENT_SYSTEM__)
-				if (pkVictim->IsPC())
-					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_CLAW) - pkAttacker->GetPoint(POINT_ATTBONUS_CLAW))) / 100;
-				else
-					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_CLAW)) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_CLAW)) / 100;
-#endif
-			}
-			break;
-
-			default:
-				break;
-		}
-	}
-	else
-	{
-		if (pkAttacker->IsPC())
-			iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_FIST)) / 100;
-	}
-
-	// 최종적인 데미지 보정. (2011년 2월 현재 대왕거미에게만 적용.)
-	float attMul = pkAttacker->GetAttMul();
-	float tempIDam = static_cast<float>(iDam);
-	iDam = static_cast<int>(attMul * tempIDam + 0.5f);
-
-	iRetDam = iDam;
-
-	//PROF_UNIT puHit("Hit");
-	if (test_server)
-		sys_log(0, "battle_hit : [%s] attack to [%s] : dam :%d", pkAttacker->GetName(), pkVictim->GetName(), iRetDam);
-
-	//PROF_UNIT puDam("Dam");
-	if (pkVictim->Damage(pkAttacker, iDam, DAMAGE_TYPE_NORMAL))
-		return BATTLE_DEAD;
-
-	return BATTLE_DAMAGE;
-}
-
-DWORD GET_ATTACK_SPEED(LPCHARACTER ch)
-{
-	if (NULL == ch)
-		return 1000;
-
-	LPITEM item = ch->GetWear(WEAR_WEAPON);
-	DWORD default_bonus = SPEEDHACK_LIMIT_BONUS * 3; // 유두리 공속(기본 80)
-	DWORD riding_bonus = 0;
-
-	if (ch->IsRiding())
-	{
-		// 뭔가를 탔으면 추가공속 50
-		riding_bonus = 50;
-	}
-
-	DWORD ani_speed = ani_attack_speed(ch);
-	DWORD real_speed = (ani_speed * 100) / (default_bonus + ch->GetPoint(POINT_ATT_SPEED) + riding_bonus);
-
-	// 단검의 경우 공속 2배
-	if (item && item->GetSubType() == WEAPON_DAGGER)
-		real_speed /= 2;
-	else if (item && item->GetSubType() == WEAPON_CLAW)
-		real_speed /= 2;
-
-	return real_speed;
-}
-
-void SET_ATTACK_TIME(LPCHARACTER ch, LPCHARACTER victim, DWORD current_time)
-{
-	if (NULL == ch || NULL == victim)
-		return;
-
-	if (!ch->IsPC())
-		return;
-
-	ch->m_kAttackLog.dwVID = victim->GetVID();
-	ch->m_kAttackLog.dwTime = current_time;
-}
-
-void SET_ATTACKED_TIME(LPCHARACTER ch, LPCHARACTER victim, DWORD current_time)
-{
-	if (NULL == ch || NULL == victim)
-		return;
-
-	if (!ch->IsPC())
-		return;
-
-	victim->m_AttackedLog.dwPID = ch->GetPlayerID();
-	victim->m_AttackedLog.dwAttackedTime = current_time;
-}
-
-bool IS_SPEED_HACK(LPCHARACTER ch, LPCHARACTER victim, DWORD current_time)
-{
-	if (!gHackCheckEnable)
-		return false;
-
-	if (ch->m_kAttackLog.dwVID == victim->GetVID())
-	{
-		if (current_time - ch->m_kAttackLog.dwTime < GET_ATTACK_SPEED(ch))
-		{
-			INCREASE_SPEED_HACK_COUNT(ch);
-
-			if (test_server)
-			{
-				sys_log(0, "%s attack hack! time (delta, limit)=(%u, %u) hack_count %d",
-					ch->GetName(),
-					current_time - ch->m_kAttackLog.dwTime,
-					GET_ATTACK_SPEED(ch),
-					ch->m_speed_hack_count);
-
-				ch->ChatPacket(CHAT_TYPE_INFO, "%s attack hack! time (delta, limit)=(%u, %u) hack_count %d",
-					ch->GetName(),
-					current_time - ch->m_kAttackLog.dwTime,
-					GET_ATTACK_SPEED(ch),
-					ch->m_speed_hack_count);
-			}
-
-			SET_ATTACK_TIME(ch, victim, current_time);
-			SET_ATTACKED_TIME(ch, victim, current_time);
-			return true;
-		}
-	}
-
-	SET_ATTACK_TIME(ch, victim, current_time);
-
-	if (victim->m_AttackedLog.dwPID == ch->GetPlayerID())
-	{
-		if (current_time - victim->m_AttackedLog.dwAttackedTime < GET_ATTACK_SPEED(ch))
-		{
-			INCREASE_SPEED_HACK_COUNT(ch);
-
-			if (test_server)
-			{
-				sys_log(0, "%s Attack Speed HACK! time (delta, limit)=(%u, %u), hack_count = %d",
-					ch->GetName(),
-					current_time - victim->m_AttackedLog.dwAttackedTime,
-					GET_ATTACK_SPEED(ch),
-					ch->m_speed_hack_count);
-
-				ch->ChatPacket(CHAT_TYPE_INFO, "Attack Speed Hack(%s), (delta, limit)=(%u, %u)",
-					ch->GetName(),
-					current_time - victim->m_AttackedLog.dwAttackedTime,
-					GET_ATTACK_SPEED(ch));
-			}
-
-			SET_ATTACKED_TIME(ch, victim, current_time);
-			return true;
-		}
-	}
-
-	SET_ATTACKED_TIME(ch, victim, current_time);
-	return false;
-}
+#include "stdafx.h"
+#include "utils.h"
+#include "config.h"
+#include "desc.h"
+#include "char.h"
+#include "char_manager.h"
+#include "battle.h"
+#include "item.h"
+#include "item_manager.h"
+#include "mob_manager.h"
+#include "vector.h"
+#include "packet.h"
+#include "pvp.h"
+#include "profiler.h"
+#include "guild.h"
+#include "affect.h"
+#include "unique_item.h"
+#include "lua_incl.h"
+#include "arena.h"
+#include "castle.h"
+#include "sectree.h"
+#include "ani.h"
+#include "locale_service.h"
+
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+int battle_hit(LPCHARACTER ch, LPCHARACTER victim, int& iRetDam);
+
+//bool battle_distance_valid_by_xy(long x, long y, long tx, long ty)
+//{
+//	long distance = DISTANCE_APPROX(x - tx, y - ty);
+//
+//	if (distance > 170)
+//		return false;
+//
+//	return true;
+//}
+
+bool battle_distance_valid(LPCHARACTER ch, LPCHARACTER victim)
+{
+	//return battle_distance_valid_by_xy(ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY());
+
+	const int iDistance = DISTANCE_APPROX(ch->GetX() - victim->GetX(), ch->GetY() - victim->GetY());
+	float fHitRange = 300 + static_cast<int>(victim->GetMonsterHitRange());
+
+	// [Security] Prevent click-through attacks across floors/ceilings (DT/Cata).
+	const long lZDist = ch->GetZ() - victim->GetZ();
+	if (lZDist > 1000 || lZDist < -1000)
+		return false;
+
+	if (iDistance > fHitRange)
+		return false;
+
+	return true;
+}
+
+int battle_get_max_distance(LPCHARACTER ch, LPCHARACTER victim)
+{
+	int max = 300;
+
+	if (!ch || !victim)
+		return max;
+
+	if (victim->IsMonster() || victim->IsStone())
+		max = (max / 100) * static_cast<int>(victim->GetMonsterHitRange());
+
+	if (ch->IsRiding())
+		max += 100;
+
+	return max;
+}
+
+bool timed_event_cancel(LPCHARACTER ch)
+{
+	if (ch->m_pkTimedEvent)
+	{
+		event_cancel(&ch->m_pkTimedEvent);
+		return true;
+	}
+
+	// RECALL_DELAY
+	//    환 隔  퓸   玲 
+	/*
+	if (ch->m_pk_RecallEvent)
+	{
+		event_cancel(&ch->m_pkRecallEvent);
+		return true;
+	}
+	*/
+	// END_OF_RECALL_DELAY
+
+	return false;
+}
+
+bool battle_is_attackable(LPCHARACTER ch, LPCHARACTER victim)
+{
+	// [Security Fix] Ghost attack: observer/spectator cannot attack or be attacked.
+	if (!ch || ch->IsDead() || ch->IsObserverMode())
+		return false;
+
+	//  類 杉磯.
+	if (victim->IsDead() || victim->IsObserverMode())
+		return false;
+
+	//  杉
+	{
+		SECTREE* sectree = NULL;
+
+		sectree = ch->GetSectree();
+		if (sectree && sectree->IsAttr(ch->GetX(), ch->GetY(), ATTR_BANPK))
+			return false;
+
+		sectree = victim->GetSectree();
+		if (sectree && sectree->IsAttr(victim->GetX(), victim->GetY(), ATTR_BANPK))
+			return false;
+	}
+
+	//  類 杉磯.
+	if (ch->IsStun() || ch->IsDead() || ch->IsObserverMode())
+		return false;
+
+	if (ch->IsPC() && victim->IsPC())
+	{
+		CGuild* g1 = ch->GetGuild();
+		CGuild* g2 = victim->GetGuild();
+
+		if (g1 && g2)
+		{
+			if (g1->UnderWar(g2->GetID()))
+				return true;
+		}
+	}
+
+	if (IS_CASTLE_MAP(ch->GetMapIndex()) && false == castle_can_attack(ch, victim))
+		return false;
+
+	if (CArenaManager::instance().CanAttack(ch, victim) == true)
+		return true;
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (CGuildDragonLairManager::Instance().IsKing(ch->GetRaceNum()) && ch->GetGuildDragonLair())
+		return false;
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+	if (ch->GetDefenseWave())
+	{
+		if (CDefenseWaveManager::Instance().CanAttack(ch, victim) == false)
+			return false;
+
+		if (ch->IsMonster() && CDefenseWaveManager::Instance().IsShipMast(victim->GetRaceNum()))
+			return true;
+	}
+#endif
+
+#if defined(__CONQUEROR_LEVEL__)
+	if (ch->IsPC() && ch->IsNewWorldMapIndex() && !(victim->IsPC()))
+		if (ch->GetConquerorLevel() == 0)
+			return false;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (victim->IsInvincible())
+		return false;
+#endif
+
+	return CPVPManager::instance().CanAttack(ch, victim);
+}
+
+int battle_melee_attack(LPCHARACTER ch, LPCHARACTER victim)
+{
+	if (test_server && ch->IsPC())
+		sys_log(0, "battle_melee_attack : [%s] attack to [%s]", ch->GetName(), victim->GetName());
+
+	if (!victim || ch == victim)
+		return BATTLE_NONE;
+
+	if (test_server && ch->IsPC())
+		sys_log(0, "battle_melee_attack : [%s] attack to [%s]", ch->GetName(), victim->GetName());
+
+	if (!battle_is_attackable(ch, victim))
+		return BATTLE_NONE;
+
+	if (test_server && ch->IsPC())
+		sys_log(0, "battle_melee_attack : [%s] attack to [%s]", ch->GetName(), victim->GetName());
+
+	// 타 체크
+	int distance = DISTANCE_APPROX(ch->GetX() - victim->GetX(), ch->GetY() - victim->GetY());
+
+	if (!victim->IsBuilding())
+	{
+		int max = battle_get_max_distance(ch, victim);
+
+		if (false == ch->IsPC())
+		{
+			//     타 
+			max = (int)(ch->GetMobAttackRange() * 1.15f);
+		}
+		else
+		{
+			// PC  諛 melee     타 獵  타
+			if (false == victim->IsPC() && BATTLE_TYPE_MELEE == victim->GetMobBattleType())
+				max = MAX(max, (int)(victim->GetMobAttackRange() * 1.15f));
+		}
+
+		if (distance > max)
+		{
+			if (test_server)
+				sys_log(0, "VICTIM_FAR: %s distance: %d max: %d", ch->GetName(), distance, max);
+
+			return BATTLE_NONE;
+		}
+	}
+
+	if (timed_event_cancel(ch))
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  퓸  퓸求."));
+
+	if (timed_event_cancel(victim))
+		victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  퓸  퓸求."));
+
+	ch->SetPosition(POS_FIGHTING);
+	ch->SetVictim(victim);
+
+	const PIXEL_POSITION& vpos = victim->GetXYZ();
+	ch->SetRotationToXY(vpos.x, vpos.y);
+
+	int dam;
+	int ret = battle_hit(ch, victim, dam);
+	return (ret);
+}
+
+//  GET_BATTLE_VICTIM NULL  遣트 캔 킨.
+void battle_end_ex(LPCHARACTER ch)
+{
+	if (ch->IsPosition(POS_FIGHTING))
+		ch->SetPosition(POS_STANDING);
+
+#if defined(__ATTR_6TH_7TH__)
+	ch->StopHitBuffEvent();
+#endif
+}
+
+void battle_end(LPCHARACTER ch)
+{
+	battle_end_ex(ch);
+}
+
+// AG = Attack Grade
+// AL = Attack Limit
+int CalcBattleDamage(int iDam, int iAttackerLev, int iVictimLev)
+{
+	if (iDam < 3)
+		iDam = number(1, 5);
+
+	//return CALCULATE_DAMAGE_LVDELTA(iAttackerLev, iVictimLev, iDam);
+	return iDam;
+}
+
+int CalcMagicDamageWithValue(int iDam, LPCHARACTER pkAttacker, LPCHARACTER pkVictim)
+{
+	if (!pkAttacker || !pkVictim)
+		return 0;
+
+	return CalcBattleDamage(iDam, pkAttacker->GetLevel(), pkVictim->GetLevel());
+}
+
+int CalcMagicDamage(LPCHARACTER pkAttacker, LPCHARACTER pkVictim)
+{
+	int iDam = 0;
+
+	if (!pkAttacker || !pkVictim)
+		return 0;
+
+	if (pkAttacker->IsNPC())
+	{
+		iDam = CalcMeleeDamage(pkAttacker, pkVictim, false, false);
+	}
+
+	iDam += pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS);
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	iDam += pkAttacker->GetAcceWeaponMagicAttack();
+#endif
+
+	return CalcMagicDamageWithValue(iDam, pkAttacker, pkVictim);
+}
+
+float CalcAttackRating(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, bool bIgnoreTargetRating)
+{
+	if (!pkAttacker || !pkVictim)
+		return 0.0f;
+
+	int iARSrc;
+	int iERSrc;
+
+	if (LC_IsYMIR()) // 천
+	{
+		iARSrc = MIN(gPlayerMaxLevelStats, pkAttacker->GetPolymorphPoint(POINT_DX));
+		iERSrc = MIN(gPlayerMaxLevelStats, pkVictim->GetPolymorphPoint(POINT_DX));
+	}
+	else
+	{
+		int attacker_dx = pkAttacker->GetPolymorphPoint(POINT_DX);
+		int attacker_lv = pkAttacker->GetLevel();
+
+		int victim_dx = pkVictim->GetPolymorphPoint(POINT_DX);
+		int victim_lv = pkVictim->GetLevel();
+
+		iARSrc = MIN(gPlayerMaxLevelStats, (attacker_dx * 4 + attacker_lv * 2) / 6);
+		iERSrc = MIN(gPlayerMaxLevelStats, (victim_dx * 4 + victim_lv * 2) / 6);
+	}
+
+	float fAR = ((float)iARSrc + 210.0f) / 300.0f; // fAR = 0.7 ~ 1.0
+
+	if (bIgnoreTargetRating)
+		return fAR;
+
+	// ((Edx * 2 + 20) / (Edx + 110)) * 0.3
+	float fER = ((float)(iERSrc * 2 + 5) / (iERSrc + 95)) * 3.0f / 10.0f;
+
+	return fAR - fER;
+}
+
+static int CalcAttBonusWithPct(const LPCHARACTER& c_pAttacker,
+	const POINT_TYPE c_wAttPoint, const POINT_TYPE c_wAttPctPoint)
+{
+	if ((c_wAttPoint == POINT_NONE) || (c_wAttPoint > POINT_MAX_NUM || c_wAttPctPoint > POINT_MAX_NUM))
+		return 0;
+
+	if (c_wAttPctPoint == POINT_NONE)
+		return c_pAttacker->GetPoint(c_wAttPoint);
+
+	int iAttValue = c_pAttacker->GetPoint(c_wAttPoint);
+	if (iAttValue == 0)
+		return 0;
+
+	int iAttPctValue = c_pAttacker->GetPoint(c_wAttPctPoint);
+	if (iAttPctValue)
+	{
+		float fPctValue = (iAttValue * iAttPctValue) / 100.0f;
+		iAttValue += MAX(static_cast<int>(fPctValue), 1);
+	}
+
+	return iAttValue;
+}
+
+int CalcAttBonus(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, int iAtk)
+{
+	if (!pkAttacker || !pkVictim)
+		return iAtk;
+
+	// PvP\xbf\xa1\xb4\xc2 \xc0\xfb\xbf\xeb\xc7\xcf\xc1\xf6\xbe\xca\xc0\xbd
+	if (!pkVictim->IsPC())
+		iAtk += pkAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_ATTACK_BONUS);
+
+	// PvP 
+	if (!pkAttacker->IsPC())
+	{
+		int iReduceDamagePct = pkVictim->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_TRANSFER_DAMAGE);
+		iAtk = iAtk * (100 + iReduceDamagePct) / 100;
+	}
+
+	if (pkAttacker->IsNPC() /*&& pkVictim->IsPC()*/)
+	{
+		iAtk = (iAtk * CHARACTER_MANAGER::instance().GetMobDamageRate(pkAttacker)) / 100;
+	}
+
+	if (pkVictim->IsPC() && (pkVictim->GetHP() >= (pkVictim->GetMaxHP() * 0.9)))
+		iAtk -= (iAtk * pkVictim->GetPoint(POINT_MORE_THEN_HP90_DAMAGE_REDUCE)) / 100;
+
+	if (pkVictim->IsNPC())
+	{
+		if (pkVictim->IsRaceFlag(RACE_FLAG_ANIMAL))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_ANIMAL, POINT_ATTBONUS_PER_ANIMAL)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_UNDEAD))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_UNDEAD, POINT_ATTBONUS_PER_UNDEAD)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_DEVIL))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_DEVIL, POINT_ATTBONUS_PER_DEVIL)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_HUMAN))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_HUMAN, POINT_ATTBONUS_PER_HUMAN)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_ORC))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_ORC, POINT_ATTBONUS_PER_ORC)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_MILGYO))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_MILGYO, POINT_ATTBONUS_PER_MILGYO)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_INSECT))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_INSECT, POINT_ATTBONUS_PER_INSECT)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_DESERT))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_DESERT, POINT_ATTBONUS_PER_DESERT)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_TREE))
+			iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_TREE)) / 100;
+
+		if (pkVictim->IsRaceFlag(RACE_FLAG_ATT_CZ))
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_CZ, POINT_ATTBONUS_PER_CZ)) / 100;
+
+#if defined(__ELEMENT_SYSTEM__)
+		if (pkVictim->GetMobElement(MOB_ELEMENT_ELECT))
+			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_ELECT, POINT_ENCHANT_PER_ELECT) - pkVictim->GetMobElement(MOB_ELEMENT_ELECT)) / 2)) / 100);
+		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_ELECT, POINT_ENCHANT_PER_ELECT) - pkVictim->GetMobElement(MOB_ELEMENT_ELECT))) / 100;
+
+		if (pkVictim->GetMobElement(MOB_ELEMENT_FIRE))
+			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_FIRE, POINT_ENCHANT_PER_FIRE) - pkVictim->GetMobElement(MOB_ELEMENT_FIRE)) / 2)) / 100);
+		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_FIRE, POINT_ENCHANT_PER_FIRE) - pkVictim->GetMobElement(MOB_ELEMENT_FIRE))) / 100;
+
+		if (pkVictim->GetMobElement(MOB_ELEMENT_ICE))
+			iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_ICE, POINT_ENCHANT_PER_ICE) - pkVictim->GetMobElement(MOB_ELEMENT_ICE))) / 100;
+
+		if (pkVictim->GetMobElement(MOB_ELEMENT_WIND))
+			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_WIND, POINT_ENCHANT_PER_WIND) - pkVictim->GetMobElement(MOB_ELEMENT_WIND)) / 2)) / 100);
+		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_WIND, POINT_ENCHANT_PER_WIND) - pkVictim->GetMobElement(MOB_ELEMENT_WIND))) / 100;
+
+		if (pkVictim->GetMobElement(MOB_ELEMENT_EARTH))
+			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_EARTH, POINT_ENCHANT_PER_EARTH) - pkVictim->GetMobElement(MOB_ELEMENT_EARTH)) / 2)) / 100);
+		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_EARTH, POINT_ENCHANT_PER_EARTH) - pkVictim->GetMobElement(MOB_ELEMENT_EARTH))) / 100;
+
+		if (pkVictim->GetMobElement(MOB_ELEMENT_DARK))
+			iAtk += (iAtk * (100 + ((CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_DARK, POINT_ENCHANT_PER_DARK) - pkVictim->GetMobElement(MOB_ELEMENT_DARK)) / 2)) / 100);
+		//iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ENCHANT_DARK, POINT_ENCHANT_PER_DARK) - pkVictim->GetMobElement(MOB_ELEMENT_DARK))) / 100;
+#endif
+
+		if (pkVictim->IsNPC())
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_MONSTER, POINT_ATTBONUS_PER_MONSTER)) / 100;
+
+		if (pkVictim->IsStone())
+			iAtk += (iAtk * CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_STONE, POINT_ATTBONUS_PER_STONE)) / 100;
+
+		if (pkVictim->IsMonster() && pkVictim->GetMobRank() >= MOB_RANK_BOSS)
+			iAtk += (iAtk * pkAttacker->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE)) / 100;
+	}
+	else if (pkVictim->IsPC())
+	{
+#if defined(__ELEMENT_SYSTEM__)
+		iAtk += (iAtk * (CalcAttBonusWithPct(pkAttacker, POINT_ATTBONUS_HUMAN, POINT_ATTBONUS_PER_HUMAN) - CalcAttBonusWithPct(pkVictim, POINT_RESIST_HUMAN, POINT_RESIST_PER_HUMAN))) / 100;
+#else
+		iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_HUMAN)) / 100;
+#endif
+
+		switch (pkVictim->GetJob())
+		{
+			case JOB_WARRIOR:
+				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_WARRIOR)) / 100;
+				break;
+
+			case JOB_ASSASSIN:
+				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_ASSASSIN)) / 100;
+				break;
+
+			case JOB_SURA:
+				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_SURA)) / 100;
+				break;
+
+			case JOB_SHAMAN:
+				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_SHAMAN)) / 100;
+				break;
+
+			case JOB_WOLFMAN:
+				iAtk += (iAtk * pkAttacker->GetPoint(POINT_ATTBONUS_WOLFMAN)) / 100;
+				break;
+		}
+	}
+
+	if (pkAttacker->IsPC())
+	{
+		switch (pkAttacker->GetJob())
+		{
+			case JOB_WARRIOR:
+				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_WARRIOR)) / 100;
+				break;
+
+			case JOB_ASSASSIN:
+				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_ASSASSIN)) / 100;
+				break;
+
+			case JOB_SURA:
+				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_SURA)) / 100;
+				break;
+
+			case JOB_SHAMAN:
+				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_SHAMAN)) / 100;
+				break;
+
+			case JOB_WOLFMAN:
+				iAtk -= (iAtk * pkVictim->GetPoint(POINT_RESIST_WOLFMAN)) / 100;
+				break;
+		}
+
+		if (pkAttacker->GetPoint(POINT_ALIGNMENT_DAMAGE_BONUS))
+		{
+			if (pkAttacker->GetAlignmentGrade() >= ALIGN_GRADE_NORMAL)
+			{
+				int iAlignmentDamage = 0;
+				switch (pkAttacker->GetAlignmentGrade())
+				{
+					case ALIGN_GRADE_EVIL_1: iAlignmentDamage = 1; break;
+					case ALIGN_GRADE_EVIL_2: iAlignmentDamage = 2; break;
+					case ALIGN_GRADE_EVIL_3: iAlignmentDamage = 3; break;
+					case ALIGN_GRADE_EVIL_4: iAlignmentDamage = 5; break;
+				}
+				iAtk += (iAtk * iAlignmentDamage) / 100;
+			}
+		}
+	}
+
+	// [mob -> PC] Apply elemental defense
+	// 20130117.
+	// Resistance is applied to the value corresponding to x%
+	// of the damage caused by a monster's elemental attack.
+
+	const int c_iMobElementDef = 75;
+
+	if (pkAttacker->IsMonster() && pkVictim->IsPC())
+	{
+#if defined(__ATTR_6TH_7TH__)
+		iAtk -= (iAtk * pkVictim->GetPoint(POINT_MONSTER_DEFEND_BONUS)) / 100;
+
+		if (pkAttacker->GetMobRank() >= MOB_RANK_BOSS)
+			iAtk -= (iAtk * pkVictim->GetPoint(POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE)) / 100;
+#endif
+
+#if defined(__ELEMENT_SYSTEM__)
+		if (pkAttacker->GetMobElement(MOB_ELEMENT_ELECT))
+			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_ELEC, POINT_RESIST_PER_ELEC)) / 10000;
+
+		else if (pkAttacker->GetMobElement(MOB_ELEMENT_FIRE))
+			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_FIRE, POINT_RESIST_PER_FIRE)) / 10000;
+
+		else if (pkAttacker->GetMobElement(MOB_ELEMENT_ICE))
+			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_ICE, POINT_RESIST_PER_ICE)) / 10000;
+
+		else if (pkAttacker->GetMobElement(MOB_ELEMENT_WIND))
+			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_WIND, POINT_RESIST_PER_WIND)) / 10000;
+
+		else if (pkAttacker->GetMobElement(MOB_ELEMENT_EARTH))
+			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_EARTH, POINT_RESIST_PER_EARTH)) / 10000;
+
+		else if (pkAttacker->GetMobElement(MOB_ELEMENT_DARK))
+			iAtk -= (iAtk * c_iMobElementDef * CalcAttBonusWithPct(pkVictim, POINT_RESIST_DARK, POINT_RESIST_PER_DARK)) / 10000;
+#else
+		/*
+		if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_ELEC))
+			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_ELEC)) / 10000;
+		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_FIRE))
+			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_FIRE)) / 10000;
+		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_ICE))
+			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_ICE)) / 10000;
+		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_WIND))
+			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_WIND)) / 10000;
+		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_EARTH))
+			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_EARTH)) / 10000;
+		else if (pkAttacker->IsRaceFlag(RACE_FLAG_ATT_DARK))
+			iAtk -= (iAtk * 30 * pkVictim->GetPoint(POINT_RESIST_DARK)) / 10000;
+		*/
+#endif
+	}
+
+	return iAtk;
+}
+
+void Item_GetDamage(LPITEM pkItem, int* pdamMin, int* pdamMax)
+{
+	*pdamMin = 0;
+	*pdamMax = 1;
+
+	if (!pkItem)
+		return;
+
+	switch (pkItem->GetType())
+	{
+		case ITEM_ROD:
+		case ITEM_PICK:
+			return;
+	}
+
+	if (pkItem->GetType() != ITEM_WEAPON)
+		sys_err("Item_GetDamage - !ITEM_WEAPON vnum=%d, type=%d", pkItem->GetOriginalVnum(), pkItem->GetType());
+
+#if defined(__ITEM_APPLY_RANDOM__) && defined(__ITEM_VALUE10__)
+	DWORD dwMinDam = 0, dwMaxDam = 0;
+	const DWORD dwMinMax = pkItem->GetSocket(ITEM_SOCKET_ATK_MINMAX_RANDOM);
+
+	if (dwMinMax != 0)
+	{
+		dwMinDam += dwMinMax / ITEM_VALUE_MINMAX_RANDOM_DIVISION_VALUE;
+		dwMaxDam += dwMinMax % (ITEM_VALUE_MINMAX_RANDOM_DIVISION_VALUE / 100);
+	}
+	else
+	{
+		dwMinDam = pkItem->GetValue(3);
+		dwMaxDam = pkItem->GetValue(4);
+	}
+
+	*pdamMin = dwMinDam;
+	*pdamMax = dwMaxDam;
+#else
+	* pdamMin = pkItem->GetValue(3);
+	*pdamMax = pkItem->GetValue(4);
+#endif
+}
+
+int CalcMeleeDamage(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, bool bIgnoreDefense, bool bIgnoreTargetRating)
+{
+	if (!pkAttacker || !pkVictim)
+		return 0;
+
+	LPITEM pWeapon = pkAttacker->GetWear(WEAR_WEAPON);
+	bool bPolymorphed = pkAttacker->IsPolymorphed();
+
+	if (pWeapon && !(bPolymorphed && !pkAttacker->IsPolyMaintainStat()))
+	{
+		if (pWeapon->GetType() != ITEM_WEAPON)
+			return 0;
+
+		switch (pWeapon->GetSubType())
+		{
+			case WEAPON_SWORD:
+			case WEAPON_DAGGER:
+			case WEAPON_TWO_HANDED:
+			case WEAPON_BELL:
+			case WEAPON_FAN:
+			case WEAPON_MOUNT_SPEAR:
+			case WEAPON_CLAW:
+				break;
+
+			case WEAPON_BOW:
+				sys_err("CalcMeleeDamage should not handle bows (name: %s)", pkAttacker->GetName());
+				return 0;
+
+			default:
+				return 0;
+		}
+	}
+
+	int iDam = 0;
+	float fAR = CalcAttackRating(pkAttacker, pkVictim, bIgnoreTargetRating);
+	int iDamMin = 0, iDamMax = 0;
+
+	// TESTSERVER_SHOW_ATTACKINFO
+	int DEBUG_iDamCur = 0;
+	int DEBUG_iDamBonus = 0;
+	// END_OF_TESTSERVER_SHOW_ATTACKINFO
+
+	if (bPolymorphed && !pkAttacker->IsPolyMaintainStat())
+	{
+		// MONKEY_ROD_ATTACK_BUG_FIX
+		Item_GetDamage(pWeapon, &iDamMin, &iDamMax);
+		// END_OF_MONKEY_ROD_ATTACK_BUG_FIX
+
+		DWORD dwMobVnum = pkAttacker->GetPolymorphVnum();
+		const CMob* pMob = CMobManager::instance().Get(dwMobVnum);
+
+		if (pMob)
+		{
+			int iPower = pkAttacker->GetPolymorphPower();
+			iDamMin += pMob->m_table.dwDamageRange[0] * iPower / 100;
+			iDamMax += pMob->m_table.dwDamageRange[1] * iPower / 100;
+		}
+	}
+	else if (pWeapon)
+	{
+		// MONKEY_ROD_ATTACK_BUG_FIX
+		Item_GetDamage(pWeapon, &iDamMin, &iDamMax);
+		// END_OF_MONKEY_ROD_ATTACK_BUG_FIX
+	}
+	else if (pkAttacker->IsNPC())
+	{
+		iDamMin = pkAttacker->GetMobDamageMin();
+		iDamMax = pkAttacker->GetMobDamageMax();
+	}
+
+	iDam = number(iDamMin, iDamMax) * 2;
+
+	// TESTSERVER_SHOW_ATTACKINFO
+	DEBUG_iDamCur = iDam;
+	// END_OF_TESTSERVER_SHOW_ATTACKINFO
+	//
+	int iAtk = 0;
+
+	// level must be ignored when multiply by fAR, so subtract it before calculation.
+	iAtk = pkAttacker->GetPoint(POINT_ATT_GRADE) + iDam - (pkAttacker->GetLevel() * 2);
+	iAtk = (int)(iAtk * fAR);
+	iAtk += pkAttacker->GetLevel() * 2; // and add again
+
+	if (pWeapon)
+	{
+		iAtk += pWeapon->GetValue(5) * 2;
+
+		// 20041112.myevan.TESTSERVER_SHOW_ATTACKINFO
+		DEBUG_iDamBonus = pWeapon->GetValue(5) * 2;
+		///////////////////////////////////////////////
+	}
+
+	iAtk += pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS); // party attacker role bonus
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	iAtk += pkAttacker->GetAcceWeaponAttack();
+#endif
+	iAtk = (int)(iAtk * (100 + (pkAttacker->GetPoint(POINT_ATT_BONUS) + pkAttacker->GetPoint(POINT_MELEE_MAGIC_ATT_BONUS_PER))) / 100);
+
+	iAtk = CalcAttBonus(pkAttacker, pkVictim, iAtk);
+
+	int iDef = 0;
+
+	if (!bIgnoreDefense)
+	{
+		iDef = (pkVictim->GetPoint(POINT_DEF_GRADE) * (100 + pkVictim->GetPoint(POINT_DEF_BONUS)) / 100);
+
+		if (!pkAttacker->IsPC())
+			iDef += pkVictim->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_DEFENSE_BONUS);
+	}
+
+	if (pkAttacker->IsNPC())
+		iAtk = (int)(iAtk * pkAttacker->GetMobDamageMultiply());
+
+	iDam = MAX(0, iAtk - iDef);
+
+	if (test_server && g_bTestMobLog)
+	{
+		int DEBUG_iLV = pkAttacker->GetLevel() * 2;
+		int DEBUG_iST = int((pkAttacker->GetPoint(POINT_ATT_GRADE) - DEBUG_iLV) * fAR);
+		int DEBUG_iPT = pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS);
+		int DEBUG_iWP = 0;
+		int DEBUG_iPureAtk = 0;
+		int DEBUG_iPureDam = 0;
+		char szRB[32] = "";
+		char szGradeAtkBonus[32] = "";
+
+		DEBUG_iWP = int(DEBUG_iDamCur * fAR);
+		DEBUG_iPureAtk = DEBUG_iLV + DEBUG_iST + DEBUG_iWP + DEBUG_iDamBonus;
+		DEBUG_iPureDam = iAtk - iDef;
+
+		if (pkAttacker->IsNPC())
+		{
+			snprintf(szGradeAtkBonus, sizeof(szGradeAtkBonus), "=%d*%.1f", DEBUG_iPureAtk, pkAttacker->GetMobDamageMultiply());
+			DEBUG_iPureAtk = int(DEBUG_iPureAtk * pkAttacker->GetMobDamageMultiply());
+		}
+
+		if (DEBUG_iDamBonus != 0)
+			snprintf(szRB, sizeof(szRB), "+RB(%d)", DEBUG_iDamBonus);
+
+		char szPT[32] = "";
+
+		if (DEBUG_iPT != 0)
+			snprintf(szPT, sizeof(szPT), ", PT=%d", DEBUG_iPT);
+
+		char szUnknownAtk[32] = "";
+
+		if (iAtk != DEBUG_iPureAtk)
+			snprintf(szUnknownAtk, sizeof(szUnknownAtk), "+?(%d)", iAtk - DEBUG_iPureAtk);
+
+		char szUnknownDam[32] = "";
+
+		if (iDam != DEBUG_iPureDam)
+			snprintf(szUnknownDam, sizeof(szUnknownDam), "+?(%d)", iDam - DEBUG_iPureDam);
+
+		char szMeleeAttack[128];
+
+		snprintf(szMeleeAttack, sizeof(szMeleeAttack),
+			"%s(%d)-%s(%d)=%d%s, ATK=LV(%d)+ST(%d)+WP(%d)%s%s%s, AR=%.3g%s",
+			pkAttacker->GetName(),
+			iAtk,
+			pkVictim->GetName(),
+			iDef,
+			iDam,
+			szUnknownDam,
+			DEBUG_iLV,
+			DEBUG_iST,
+			DEBUG_iWP,
+			szRB,
+			szUnknownAtk,
+			szGradeAtkBonus,
+			fAR,
+			szPT);
+
+		pkAttacker->ChatPacket(CHAT_TYPE_TALKING, "%s", szMeleeAttack);
+		pkVictim->ChatPacket(CHAT_TYPE_TALKING, "%s", szMeleeAttack);
+	}
+
+	return CalcBattleDamage(iDam, pkAttacker->GetLevel(), pkVictim->GetLevel());
+}
+
+int CalcArrowDamage(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, LPITEM pkBow, LPITEM pkArrow, bool bIgnoreDefense)
+{
+	if (!pkBow || pkBow->GetType() != ITEM_WEAPON || pkBow->GetSubType() != WEAPON_BOW)
+		return 0;
+
+	if (!pkArrow)
+		return 0;
+
+	// 타치 
+	int iDist = (int)(DISTANCE_SQRT(pkAttacker->GetX() - pkVictim->GetX(), pkAttacker->GetY() - pkVictim->GetY()));
+
+	// [Security Fix] Bow-Morph ghost range: when polymorphed, do not allow weapon range to override mob range.
+	if (pkAttacker->IsPolymorphed())
+	{
+		const int iMaxPolyRange = (int)(pkAttacker->GetMobAttackRange() * 1.15f);
+		if (iDist > iMaxPolyRange)
+			return 0;
+	}
+	//int iGap = (iDist / 100) - 5 - pkBow->GetValue(5) - pkAttacker->GetPoint(POINT_BOW_DISTANCE);
+	int iGap = (iDist / 100) - 5 - pkAttacker->GetPoint(POINT_BOW_DISTANCE);
+	int iPercent = 100 - (iGap * 5);
+
+#if defined(__QUIVER_SYSTEM__)
+	if (pkArrow->GetSubType() == WEAPON_QUIVER)
+		iPercent = 100;
+#endif
+
+	if (iPercent <= 0)
+		return 0;
+	else if (iPercent > 100)
+		iPercent = 100;
+
+	int iDam = 0;
+
+	float fAR = CalcAttackRating(pkAttacker, pkVictim, false);
+	iDam = number(pkBow->GetValue(3), pkBow->GetValue(4)) * 2 + pkArrow->GetValue(3);
+	int iAtk;
+
+	// level must be ignored when multiply by fAR, so subtract it before calculation.
+	iAtk = pkAttacker->GetPoint(POINT_ATT_GRADE) + iDam - (pkAttacker->GetLevel() * 2);
+	iAtk = (int)(iAtk * fAR);
+	iAtk += pkAttacker->GetLevel() * 2; // and add again
+
+	// Refine Grade
+	iAtk += pkBow->GetValue(5) * 2;
+
+	iAtk += pkAttacker->GetPoint(POINT_PARTY_ATTACKER_BONUS);
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	iAtk += pkAttacker->GetAcceWeaponAttack();
+#endif
+	iAtk = (int)(iAtk * (100 + (pkAttacker->GetPoint(POINT_ATT_BONUS) + pkAttacker->GetPoint(POINT_MELEE_MAGIC_ATT_BONUS_PER))) / 100);
+
+	iAtk = CalcAttBonus(pkAttacker, pkVictim, iAtk);
+
+	int iDef = 0;
+
+	if (!bIgnoreDefense)
+		iDef = (pkVictim->GetPoint(POINT_DEF_GRADE) * (100 + pkAttacker->GetPoint(POINT_DEF_BONUS)) / 100);
+
+	if (pkAttacker->IsNPC())
+		iAtk = (int)(iAtk * pkAttacker->GetMobDamageMultiply());
+
+	iDam = MAX(0, iAtk - iDef);
+
+	int iPureDam = iDam;
+
+	iPureDam = (iPureDam * iPercent) / 100;
+
+	if (test_server)
+	{
+		pkAttacker->ChatPacket(CHAT_TYPE_INFO, "ARROW %s -> %s, DAM %d DIST %d GAP %d %% %d",
+			pkAttacker->GetName(),
+			pkVictim->GetName(),
+			iPureDam,
+			iDist, iGap, iPercent);
+	}
+
+	return iPureDam;
+	//return iDam;
+}
+
+void NormalAttackAffect(LPCHARACTER pkAttacker, LPCHARACTER pkVictim)
+{
+	//   특球퓐 특 처
+	if (pkAttacker->GetPoint(POINT_POISON_PCT) && !pkVictim->IsAffectFlag(AFF_POISON))
+	{
+#if defined(__CONQUEROR_LEVEL__)
+		int iPoisonPct = pkAttacker->GetPoint(POINT_POISON_PCT);
+		if (pkAttacker->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
+			iPoisonPct /= 2;
+
+		if (number(1, 100) <= iPoisonPct)
+			pkVictim->AttackedByPoison(pkAttacker);
+#else
+		if (number(1, 100) <= pkAttacker->GetPoint(POINT_POISON_PCT))
+			pkVictim->AttackedByPoison(pkAttacker);
+#endif
+	}
+
+	if (pkAttacker->GetPoint(POINT_BLEEDING_PCT) && !pkVictim->IsAffectFlag(AFF_BLEEDING))
+	{
+#if defined(__CONQUEROR_LEVEL__)
+		int iBleedingPct = pkAttacker->GetPoint(POINT_BLEEDING_PCT);
+		if (pkAttacker->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
+			iBleedingPct /= 2;
+
+		if (number(1, 100) <= iBleedingPct)
+			pkVictim->AttackedByPoison(pkAttacker);
+#else
+		if (number(1, 100) <= pkAttacker->GetPoint(POINT_BLEEDING_PCT))
+			pkVictim->AttackedByBleeding(pkAttacker);
+#endif
+	}
+
+	int iStunDuration = 2;
+	if (pkAttacker->IsPC() && !pkVictim->IsPC())
+		iStunDuration = 4;
+
+	AttackAffect(pkAttacker, pkVictim, POINT_STUN_PCT, IMMUNE_STUN, AFFECT_STUN, POINT_NONE, 0, AFF_STUN, iStunDuration, "STUN");
+	AttackAffect(pkAttacker, pkVictim, POINT_SLOW_PCT, IMMUNE_SLOW, AFFECT_SLOW, POINT_MOV_SPEED, -30, AFF_SLOW, 20, "SLOW");
+}
+
+int battle_hit(LPCHARACTER pkAttacker, LPCHARACTER pkVictim, int& iRetDam)
+{
+	iRetDam = 0;
+	if (!pkAttacker || !pkVictim)
+		return (BATTLE_DAMAGE);
+
+	int iDam = CalcMeleeDamage(pkAttacker, pkVictim);
+	if (iDam <= 0)
+		return (BATTLE_DAMAGE);
+
+	NormalAttackAffect(pkAttacker, pkVictim);
+
+	//  
+	//iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST)) / 100;
+	LPITEM pkWeapon = pkAttacker->GetWear(WEAR_WEAPON);
+
+	if (pkWeapon)
+	{
+		switch (pkWeapon->GetSubType())
+		{
+			case WEAPON_SWORD:
+			{
+#if defined(__ELEMENT_SYSTEM__)
+				if (pkVictim->IsPC())
+					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_SWORD) - pkAttacker->GetPoint(POINT_ATTBONUS_SWORD))) / 100;
+				else
+					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_SWORD)) / 100;
+#else
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_SWORD)) / 100;
+#endif
+			}
+			break;
+
+			case WEAPON_TWO_HANDED:
+			{
+#if defined(__ELEMENT_SYSTEM__)
+				if (pkVictim->IsPC())
+					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_TWOHAND) - pkAttacker->GetPoint(POINT_ATTBONUS_TWOHAND))) / 100;
+				else
+					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_TWOHAND)) / 100;
+#else
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_TWOHAND)) / 100;
+#endif
+			}
+			break;
+
+			case WEAPON_DAGGER:
+			{
+#if defined(__ELEMENT_SYSTEM__)
+				if (pkVictim->IsPC())
+					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_DAGGER) - pkAttacker->GetPoint(POINT_ATTBONUS_DAGGER))) / 100;
+				else
+					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_DAGGER)) / 100;
+#else
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_DAGGER)) / 100;
+#endif
+			}
+			break;
+
+			case WEAPON_BELL:
+			{
+#if defined(__ELEMENT_SYSTEM__)
+				if (pkVictim->IsPC())
+					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_BELL) - pkAttacker->GetPoint(POINT_ATTBONUS_BELL))) / 100;
+				else
+					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BELL)) / 100;
+#else
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BELL)) / 100;
+#endif
+			}
+			break;
+
+			case WEAPON_FAN:
+			{
+#if defined(__ELEMENT_SYSTEM__)
+				if (pkVictim->IsPC())
+					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_FAN) - pkAttacker->GetPoint(POINT_ATTBONUS_FAN))) / 100;
+				else
+					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_FAN)) / 100;
+#else
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_FAN)) / 100;
+#endif
+			}
+			break;
+
+			case WEAPON_BOW:
+			{
+#if defined(__ELEMENT_SYSTEM__)
+				if (pkVictim->IsPC())
+					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_BOW) - pkAttacker->GetPoint(POINT_ATTBONUS_BOW))) / 100;
+				else
+					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BOW)) / 100;
+#else
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BOW)) / 100;
+#endif
+			}
+			break;
+
+			case WEAPON_CLAW:
+			{
+#if defined(__ELEMENT_SYSTEM__)
+				if (pkVictim->IsPC())
+					iDam = iDam * (100 - (pkVictim->GetPoint(POINT_RESIST_CLAW) - pkAttacker->GetPoint(POINT_ATTBONUS_CLAW))) / 100;
+				else
+					iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_CLAW)) / 100;
+#else
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_CLAW)) / 100;
+#endif
+			}
+			break;
+
+			default:
+				break;
+		}
+	}
+	else
+	{
+		if (pkAttacker->IsPC())
+			iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_FIST)) / 100;
+	}
+
+	//   . (2011 2  卵탁結毒 .)
+	float attMul = pkAttacker->GetAttMul();
+	float tempIDam = static_cast<float>(iDam);
+	iDam = static_cast<int>(attMul * tempIDam + 0.5f);
+
+	iRetDam = iDam;
+
+	//PROF_UNIT puHit("Hit");
+	if (test_server)
+		sys_log(0, "battle_hit : [%s] attack to [%s] : dam :%d", pkAttacker->GetName(), pkVictim->GetName(), iRetDam);
+
+	//PROF_UNIT puDam("Dam");
+	if (pkVictim->Damage(pkAttacker, iDam, DAMAGE_TYPE_NORMAL))
+		return BATTLE_DEAD;
+
+	return BATTLE_DAMAGE;
+}
+
+DWORD GET_ATTACK_SPEED(LPCHARACTER ch)
+{
+	if (NULL == ch)
+		return 1000;
+
+	LPITEM item = ch->GetWear(WEAR_WEAPON);
+	DWORD default_bonus = SPEEDHACK_LIMIT_BONUS * 3; // 罐 (羞 80)
+	DWORD riding_bonus = 0;
+
+	if (ch->IsRiding())
+	{
+		//   煞 50
+		riding_bonus = 50;
+	}
+
+	DWORD ani_speed = ani_attack_speed(ch);
+	DWORD real_speed = (ani_speed * 100) / (default_bonus + ch->GetPoint(POINT_ATT_SPEED) + riding_bonus);
+
+	// 丙   2
+	if (item && item->GetSubType() == WEAPON_DAGGER)
+		real_speed /= 2;
+	else if (item && item->GetSubType() == WEAPON_CLAW)
+		real_speed /= 2;
+
+	return real_speed;
+}
+
+void SET_ATTACK_TIME(LPCHARACTER ch, LPCHARACTER victim, DWORD current_time)
+{
+	if (NULL == ch || NULL == victim)
+		return;
+
+	if (!ch->IsPC())
+		return;
+
+	ch->m_kAttackLog.dwVID = victim->GetVID();
+	ch->m_kAttackLog.dwTime = current_time;
+}
+
+void SET_ATTACKED_TIME(LPCHARACTER ch, LPCHARACTER victim, DWORD current_time)
+{
+	if (NULL == ch || NULL == victim)
+		return;
+
+	if (!ch->IsPC())
+		return;
+
+	victim->m_AttackedLog.dwPID = ch->GetPlayerID();
+	victim->m_AttackedLog.dwAttackedTime = current_time;
+}
+
+bool IS_SPEED_HACK(LPCHARACTER ch, LPCHARACTER victim, DWORD current_time)
+{
+	if (!gHackCheckEnable)
+		return false;
+
+	if (ch->m_kAttackLog.dwVID == victim->GetVID())
+	{
+		if (current_time - ch->m_kAttackLog.dwTime < GET_ATTACK_SPEED(ch))
+		{
+			INCREASE_SPEED_HACK_COUNT(ch);
+
+			if (test_server)
+			{
+				sys_log(0, "%s attack hack! time (delta, limit)=(%u, %u) hack_count %d",
+					ch->GetName(),
+					current_time - ch->m_kAttackLog.dwTime,
+					GET_ATTACK_SPEED(ch),
+					ch->m_speed_hack_count);
+
+				ch->ChatPacket(CHAT_TYPE_INFO, "%s attack hack! time (delta, limit)=(%u, %u) hack_count %d",
+					ch->GetName(),
+					current_time - ch->m_kAttackLog.dwTime,
+					GET_ATTACK_SPEED(ch),
+					ch->m_speed_hack_count);
+			}
+
+			SET_ATTACK_TIME(ch, victim, current_time);
+			SET_ATTACKED_TIME(ch, victim, current_time);
+			return true;
+		}
+	}
+
+	SET_ATTACK_TIME(ch, victim, current_time);
+
+	if (victim->m_AttackedLog.dwPID == ch->GetPlayerID())
+	{
+		if (current_time - victim->m_AttackedLog.dwAttackedTime < GET_ATTACK_SPEED(ch))
+		{
+			INCREASE_SPEED_HACK_COUNT(ch);
+
+			if (test_server)
+			{
+				sys_log(0, "%s Attack Speed HACK! time (delta, limit)=(%u, %u), hack_count = %d",
+					ch->GetName(),
+					current_time - victim->m_AttackedLog.dwAttackedTime,
+					GET_ATTACK_SPEED(ch),
+					ch->m_speed_hack_count);
+
+				ch->ChatPacket(CHAT_TYPE_INFO, "Attack Speed Hack(%s), (delta, limit)=(%u, %u)",
+					ch->GetName(),
+					current_time - victim->m_AttackedLog.dwAttackedTime,
+					GET_ATTACK_SPEED(ch));
+			}
+
+			SET_ATTACKED_TIME(ch, victim, current_time);
+			return true;
+		}
+	}
+
+	SET_ATTACKED_TIME(ch, victim, current_time);
+	return false;
+}
diff --git a/server/metin2/Source/Server/game/src/char_battle.cpp b/server/metin2/Source/Server/game/src/char_battle.cpp
index a368986..80e70b5 100644
--- a/server/metin2/Source/Server/game/src/char_battle.cpp
+++ b/server/metin2/Source/Server/game/src/char_battle.cpp
@@ -1,4299 +1,4314 @@
-#include "stdafx.h"
-#include "utils.h"
-#include "config.h"
-#include "desc.h"
-#include "desc_manager.h"
-#include "char_manager.h"
-#include "item.h"
-#include "item_manager.h"
-#include "mob_manager.h"
-#include "battle.h"
-#include "pvp.h"
-#include "skill.h"
-#include "start_position.h"
-#include "profiler.h"
-#include "cmd.h"
-#include "dungeon.h"
-#include "log.h"
-#include "unique_item.h"
-#include "priv_manager.h"
-#include "db.h"
-#include "vector.h"
-#include "marriage.h"
-#include "arena.h"
-#include "regen.h"
-#include "monarch.h"
-#include "exchange.h"
-#include "shop_manager.h"
-#include "castle.h"
-#include "dev_log.h"
-#include "ani.h"
-#include "BattleArena.h"
-#include "packet.h"
-#include "party.h"
-#include "affect.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "questmanager.h"
-#include "questlua.h"
-#include "threeway_war.h"
-#ifdef ENABLE_QUEEN_NETHIS
-#include "SnakeLair.h"
-#endif
-#include "BlueDragon.h"
-#include "DragonLair.h"
-#if defined(__MT_THUNDER_DUNGEON__)
-#	include "mt_thunder_dungeon.h"
-#endif
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-#	include "guild_dragonlair.h"
-#endif
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-#if defined(__PET_LOOT__)
-#	include "PetSystem.h"
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-
-DWORD AdjustExpByLevel(const LPCHARACTER ch, const DWORD exp)
-{
-	if (PLAYER_EXP_TABLE_MAX < ch->GetLevel())
-	{
-		double ret = 0.95;
-		double factor = 0.1;
-
-		for (ssize_t i = 0; i < ch->GetLevel() - 100; ++i)
-		{
-			if ((i % 10) == 0)
-				factor /= 2.0;
-
-			ret *= 1.0 - factor;
-		}
-
-		ret = ret * static_cast<double>(exp);
-
-		if (ret < 1.0)
-			return 1;
-
-		return static_cast<DWORD>(ret);
-	}
-
-	return exp;
-}
-
-bool CHARACTER::CanBeginFight() const
-{
-	if (!CanMove())
-		return false;
-
-	return m_pointsInstant.position == POS_STANDING && !IsDead() && !IsStun();
-}
-
-void CHARACTER::BeginFight(LPCHARACTER pkVictim)
-{
-	SetVictim(pkVictim);
-	SetNowWalking(false);
-	SetPosition(POS_FIGHTING);
-	SetNextStatePulse(1);
-}
-
-bool CHARACTER::CanFight() const
-{
-	return m_pointsInstant.position >= POS_FIGHTING ? true : false;
-}
-
-void CHARACTER::CreateFly(BYTE bType, LPCHARACTER pkVictim)
-{
-	TPacketGCCreateFly packFly;
-
-	packFly.bHeader = HEADER_GC_CREATE_FLY;
-	packFly.bType = bType;
-	packFly.dwStartVID = GetVID();
-	packFly.dwEndVID = pkVictim->GetVID();
-
-	PacketAround(&packFly, sizeof(TPacketGCCreateFly));
-}
-
-void CHARACTER::DistributeSP(LPCHARACTER pkKiller, int iMethod)
-{
-	if (pkKiller->GetSP() >= pkKiller->GetMaxSP())
-		return;
-
-	bool bAttacking = (get_dword_time() - GetLastAttackTime()) < 3000;
-	bool bMoving = (get_dword_time() - GetLastMoveTime()) < 3000;
-
-	if (iMethod == 1)
-	{
-		int num = number(0, 3);
-
-		if (!num)
-		{
-			int iLvDelta = GetLevel() - pkKiller->GetLevel();
-			int iAmount = 0;
-
-			if (iLvDelta >= 5)
-				iAmount = 10;
-			else if (iLvDelta >= 0)
-				iAmount = 6;
-			else if (iLvDelta >= -3)
-				iAmount = 2;
-
-			if (iAmount != 0)
-			{
-				iAmount += (iAmount * pkKiller->GetPoint(POINT_SP_REGEN)) / 100;
-
-				if (iAmount >= 11)
-					CreateFly(FLY_SP_BIG, pkKiller);
-				else if (iAmount >= 7)
-					CreateFly(FLY_SP_MEDIUM, pkKiller);
-				else
-					CreateFly(FLY_SP_SMALL, pkKiller);
-
-				pkKiller->PointChange(POINT_SP, iAmount);
-			}
-		}
-	}
-	else
-	{
-		if (pkKiller->GetJob() == JOB_SHAMAN || (pkKiller->GetJob() == JOB_SURA && pkKiller->GetSkillGroup() == 2))
-		{
-			int iAmount;
-
-			if (bAttacking)
-				iAmount = 2 + GetMaxSP() / 100;
-			else if (bMoving)
-				iAmount = 3 + GetMaxSP() * 2 / 100;
-			else
-				iAmount = 10 + GetMaxSP() * 3 / 100; // 평상시
-
-			iAmount += (iAmount * pkKiller->GetPoint(POINT_SP_REGEN)) / 100;
-			pkKiller->PointChange(POINT_SP, iAmount);
-		}
-		else
-		{
-			int iAmount;
-
-			if (bAttacking)
-				iAmount = 2 + pkKiller->GetMaxSP() / 200;
-			else if (bMoving)
-				iAmount = 2 + pkKiller->GetMaxSP() / 100;
-			else
-			{
-				// 평상시
-				if (pkKiller->GetHP() < pkKiller->GetMaxHP())
-					iAmount = 2 + (pkKiller->GetMaxSP() / 100); // 피 다 안찼을때
-				else
-					iAmount = 9 + (pkKiller->GetMaxSP() / 100); // 기본
-			}
-
-			iAmount += (iAmount * pkKiller->GetPoint(POINT_SP_REGEN)) / 100;
-			pkKiller->PointChange(POINT_SP, iAmount);
-		}
-	}
-}
-
-bool CHARACTER::Attack(LPCHARACTER pkVictim, BYTE bType)
-{
-	if (test_server)
-		sys_log(0, "[TEST_SERVER] Attack : %s type %d, MobBattleType %d", GetName(), bType, !GetMobBattleType() ? 0 : GetMobAttackRange());
-
-	//PROF_UNIT puAttack("Attack");
-	if (!CanMove() || IsObserverMode())
-		return false;
-
-	// CASTLE
-	if (IS_CASTLE_MAP(GetMapIndex()) && false == castle_can_attack(this, pkVictim))
-		return false;
-	// CASTLE
-
-#if defined(__DEFENSE_WAVE__)
-	if (GetDefenseWave() && CDefenseWaveManager::Instance().CanAttack(this, pkVictim) == false)
-		return false;
-#endif
-
-	if (!battle_is_attackable(this, pkVictim))
-		return false;
-
-	DWORD dwCurrentTime = get_dword_time();
-
-	if (IsPC())
-	{
-		if (IS_SPEED_HACK(this, pkVictim, dwCurrentTime))
-			return false;
-
-		if (bType == 0 && dwCurrentTime < GetSkipComboAttackByTime())
-			return false;
-	}
-	else
-	{
-		MonsterChat(MONSTER_CHAT_ATTACK);
-	}
-
-	pkVictim->SetSyncOwner(this);
-
-	if (pkVictim->CanBeginFight())
-		pkVictim->BeginFight(this);
-
-	int iRet;
-
-	if (bType == 0)
-	{
-		//
-		// 일반 공격
-		//
-		switch (GetMobBattleType())
-		{
-			case BATTLE_TYPE_MELEE:
-			case BATTLE_TYPE_POWER:
-			case BATTLE_TYPE_TANKER:
-			case BATTLE_TYPE_SUPER_POWER:
-			case BATTLE_TYPE_SUPER_TANKER:
-				iRet = battle_melee_attack(this, pkVictim);
-				break;
-
-			case BATTLE_TYPE_RANGE:
-				FlyTarget(pkVictim->GetVID(), pkVictim->GetX(), pkVictim->GetY(), HEADER_CG_FLY_TARGETING);
-				iRet = Shoot(0) ? BATTLE_DAMAGE : BATTLE_NONE;
-				break;
-
-			case BATTLE_TYPE_MAGIC:
-				FlyTarget(pkVictim->GetVID(), pkVictim->GetX(), pkVictim->GetY(), HEADER_CG_FLY_TARGETING);
-				iRet = Shoot(1) ? BATTLE_DAMAGE : BATTLE_NONE;
-				break;
-
-			default:
-				sys_err("Unhandled battle type %d", GetMobBattleType());
-				iRet = BATTLE_NONE;
-				break;
-		}
-
-#if defined(__SOUL_SYSTEM__)
-		if (IsPC() && iRet != BATTLE_NONE)
-			SoulItemProcess(RED_SOUL);
-#endif
-	}
-	else
-	{
-		if (IsPC() == true)
-		{
-			if (dwCurrentTime - m_dwLastSkillTime > 1500)
-			{
-				sys_log(1, "HACK: Too long skill using term. Name(%s) PID(%u) delta(%u)",
-					GetName(), GetPlayerID(), (dwCurrentTime - m_dwLastSkillTime));
-				return false;
-			}
-		}
-
-		sys_log(1, "Attack call ComputeSkill %d %s", bType, pkVictim ? pkVictim->GetName() : "");
-		iRet = ComputeSkill(bType, pkVictim);
-
-#if defined(__SOUL_SYSTEM__)
-		if (IsPC() && iRet != BATTLE_NONE)
-			SoulItemProcess(BLUE_SOUL);
-#endif
-	}
-
-#if defined(__ATTR_6TH_7TH__)
-	if (IsPC() && iRet != BATTLE_NONE)
-		this->StartHitBuffEvent();
-#endif
-
-	//if (test_server && IsPC())
-		//sys_log(0, "%s Attack %s type %u ret %d", GetName(), pkVictim->GetName(), bType, iRet);
-
-	if (iRet == BATTLE_DAMAGE || iRet == BATTLE_DEAD)
-	{
-		OnMove(true);
-		pkVictim->OnMove();
-
-		// Only pc sets victim null. For npc, state machine will reset this.
-		if (BATTLE_DEAD == iRet && IsPC())
-			SetVictim(NULL);
-
-		return true;
-	}
-
-	return false;
-}
-
-void CHARACTER::DeathPenalty(BYTE bTown)
-{
-	sys_log(1, "DEATH_PERNALY_CHECK(%s) town(%d)", GetName(), bTown);
-
-#if defined(__CUBE_RENEWAL__)
-	CCubeManager::Instance().CloseCube(this);
-#else
-	Cube_close(this);
-#endif
-
-	if (CBattleArena::instance().IsBattleArenaMap(GetMapIndex()) == true)
-	{
-		return;
-	}
-
-	if (GetLevel() < 10)
-	{
-		sys_log(0, "NO_DEATH_PENALTY_LESS_LV10(%s)", GetName());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("용신의 가호로 경험치가 떨어지지 않았습니다."));
-		return;
-	}
-
-	if (number(0, 2))
-	{
-		sys_log(0, "NO_DEATH_PENALTY_LUCK(%s)", GetName());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("용신의 가호로 경험치가 떨어지지 않았습니다."));
-		return;
-	}
-
-	if (IS_SET(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY))
-	{
-		REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
-
-		// NO_DEATH_PENALTY_BUG_FIX 
-		if (LC_IsYMIR()) // 천마 버전에서는 언제나 용신의 가호 아이템을 체크한다.
-		{
-			if (FindAffect(AFFECT_NO_DEATH_PENALTY))
-			{
-				sys_log(0, "NO_DEATH_PENALTY_AFFECT(%s)", GetName());
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("용신의 가호로 경험치가 떨어지지 않았습니다."));
-				RemoveAffect(AFFECT_NO_DEATH_PENALTY);
-				return;
-			}
-		}
-		else if (!bTown) // 국제 버전에서는 제자리 부활시만 용신의 가호를 사용한다. (마을 복귀시는 경험치 패널티 없음)
-		{
-			if (FindAffect(AFFECT_NO_DEATH_PENALTY))
-			{
-				sys_log(0, "NO_DEATH_PENALTY_AFFECT(%s)", GetName());
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("용신의 가호로 경험치가 떨어지지 않았습니다."));
-				RemoveAffect(AFFECT_NO_DEATH_PENALTY);
-				return;
-			}
-		}
-		// END_OF_NO_DEATH_PENALTY_BUG_FIX
-
-		int iLoss = ((GetNextExp() * aiExpLossPercents[MINMAX(1, GetLevel(), PLAYER_EXP_TABLE_MAX)]) / 100);
-
-		if (true == LC_IsYMIR())
-		{
-			if (PLAYER_EXP_TABLE_MAX < GetLevel())
-			{
-				iLoss = MIN(500000, iLoss);
-			}
-			else
-			{
-				iLoss = MIN(200000, iLoss);
-			}
-		}
-		else if (true == LC_IsEurope())
-		{
-			iLoss = MIN(800000, iLoss);
-		}
-
-		if (bTown)
-		{
-			if (g_iUseLocale)
-			{
-				iLoss = 0;
-			}
-			else
-			{
-				iLoss -= iLoss / 3;
-			}
-		}
-
-		if (IsEquipUniqueItem(UNIQUE_ITEM_TEARDROP_OF_GODNESS))
-			iLoss /= 2;
-
-		sys_log(0, "DEATH_PENALTY(%s) EXP_LOSS: %d percent %d%%", GetName(), iLoss, aiExpLossPercents[MIN(gPlayerMaxLevel, GetLevel())]);
-
-		PointChange(POINT_EXP, -iLoss, true);
-	}
-}
-
-bool CHARACTER::IsStun() const
-{
-	if (IS_SET(m_pointsInstant.instant_flag, INSTANT_FLAG_STUN))
-		return true;
-
-	return false;
-}
-
-EVENTFUNC(StunEvent)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("StunEvent> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = info->ch;
-
-	if (ch == NULL) // <Factor>
-		return 0;
-
-	ch->m_pkStunEvent = NULL;
-	ch->Dead();
-	return 0;
-}
-
-void CHARACTER::Stun(bool bImmediate)
-{
-	if (IsStun())
-		return;
-
-	if (IsDead())
-		return;
-
-	if (!IsPC() && m_pkParty)
-	{
-		m_pkParty->SendMessage(this, PM_ATTACKED_BY, 0, 0);
-	}
-
-	sys_log(1, "%s: Stun %p", GetName(), this);
-
-	PointChange(POINT_HP_RECOVERY, -GetPoint(POINT_HP_RECOVERY));
-	PointChange(POINT_SP_RECOVERY, -GetPoint(POINT_SP_RECOVERY));
-
-	CloseMyShop();
-
-	event_cancel(&m_pkRecoveryEvent); // 회복 이벤트를 죽인다.
-
-	TPacketGCStun pack;
-	pack.header = HEADER_GC_STUN;
-	pack.vid = m_vid;
-	PacketAround(&pack, sizeof(pack));
-
-	SET_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_STUN);
-
-	if (m_pkStunEvent)
-		return;
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-
-	info->ch = this;
-
-	m_pkStunEvent = event_create(StunEvent, info, PASSES_PER_SEC(bImmediate ? 1 : 3));
-}
-
-EVENTINFO(SCharDeadEventInfo)
-{
-	bool isPC;
-	uint32_t dwID;
-
-	SCharDeadEventInfo()
-		: isPC(0)
-		, dwID(0)
-	{
-	}
-};
-
-EVENTFUNC(dead_event)
-{
-	const SCharDeadEventInfo* info = dynamic_cast<SCharDeadEventInfo*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("dead_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = NULL;
-
-	if (true == info->isPC)
-	{
-		ch = CHARACTER_MANAGER::instance().FindByPID(info->dwID);
-	}
-	else
-	{
-		ch = CHARACTER_MANAGER::instance().Find(info->dwID);
-	}
-
-	if (NULL == ch)
-	{
-		sys_err("DEAD_EVENT: cannot find char pointer with %s id(%d)", info->isPC ? "PC" : "MOB", info->dwID);
-		return 0;
-	}
-
-	ch->m_pkDeadEvent = NULL;
-
-	if (ch->GetDesc())
-	{
-		ch->GetDesc()->SetPhase(PHASE_GAME);
-		ch->SetPosition(POS_STANDING);
-
-		long lMapIndex = ch->GetMapIndex();
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-		if (CGuildDragonLairManager::Instance().IsRedDragonLair(lMapIndex))
-		{
-			CGuildDragonLairManager::Instance().Exit(ch);
-			return 0;
-		}
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-		if (IS_ELEMENTAL_DUNGEON(ch->GetMapIndex()))
-		{
-			PIXEL_POSITION WarpPos;
-			if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(MAP_DEFENSEWAVE_PORT, ch->GetEmpire(), WarpPos))
-				ch->WarpSet(WarpPos.x, WarpPos.y);
-			else
-			{
-				sys_err("cannot find spawn position (name %s)", ch->GetName());
-				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-			}
-
-			ch->PointChange(POINT_HP, (ch->GetMaxHP() / 2) - ch->GetHP(), true);
-			ch->DeathPenalty(0);
-			ch->StartRecoveryEvent();
-			ch->ChatPacket(CHAT_TYPE_COMMAND, "CloseRestartWindow");
-
-			return 0;
-		}
-#endif
-
-		PIXEL_POSITION pos;
-		if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(lMapIndex, ch->GetEmpire(), pos))
-			ch->WarpSet(pos.x, pos.y);
-		else
-		{
-			sys_err("cannot find spawn position (name %s)", ch->GetName());
-			ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-
-		ch->PointChange(POINT_HP, (ch->GetMaxHP() / 2) - ch->GetHP(), true);
-		ch->DeathPenalty(0);
-		ch->StartRecoveryEvent();
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "CloseRestartWindow");
-	}
-	else
-	{
-		if (ch->IsMonster())
-		{
-			if (!ch->IsRevive() && ch->HasReviverInParty())
-			{
-				ch->SetPosition(POS_STANDING);
-				ch->SetHP(ch->GetMaxHP());
-
-				ch->ViewReencode();
-
-				ch->SetAggressive();
-				ch->SetRevive(true);
-
-				return 0;
-			}
-		}
-
-		M2_DESTROY_CHARACTER(ch);
-	}
-
-	return 0;
-}
-
-bool CHARACTER::IsDead() const
-{
-	if (m_pointsInstant.position == POS_DEAD)
-		return true;
-
-	return false;
-}
-
-#define GetGoldMultipler() (distribution_test_server ? 3 : 1)
-
-void CHARACTER::RewardGold(LPCHARACTER pkAttacker)
-{
-	// ADD_PREMIUM
-	bool isAutoLoot =
-		(pkAttacker->GetPremiumRemainSeconds(PREMIUM_AUTOLOOT) > 0 ||
-			pkAttacker->IsEquipUniqueGroup(UNIQUE_GROUP_AUTO_LOOT))
-		? true : false; // 제3의 손
-	// END_OF_ADD_PREMIUM
-
-	PIXEL_POSITION pos;
-
-	if (!isAutoLoot)
-		if (!SECTREE_MANAGER::instance().GetMovablePosition(GetMapIndex(), GetX(), GetY(), pos))
-			return;
-
-	int iTotalGold = 0;
-	//
-	// --------- 돈 드롭 확률 계산 ----------
-	//
-	int iGoldPercent = MobRankStats[GetMobRank()].iGoldPercent;
-
-	if (pkAttacker->IsPC())
-		iGoldPercent = iGoldPercent * (100 + CPrivManager::instance().GetPriv(pkAttacker, PRIV_GOLD_DROP)) / 100;
-
-	if (pkAttacker->GetPoint(POINT_MALL_GOLDBONUS))
-		iGoldPercent += (iGoldPercent * pkAttacker->GetPoint(POINT_MALL_GOLDBONUS) / 100);
-
-	iGoldPercent = iGoldPercent * CHARACTER_MANAGER::instance().GetMobGoldDropRate(pkAttacker) / 100;
-
-	// ADD_PREMIUM
-	if (pkAttacker->GetPremiumRemainSeconds(PREMIUM_GOLD) > 0 ||
-		pkAttacker->IsEquipUniqueGroup(UNIQUE_GROUP_LUCKY_GOLD))
-		iGoldPercent += iGoldPercent;
-	// END_OF_ADD_PREMIUM
-
-	if (iGoldPercent > 100)
-		iGoldPercent = 100;
-
-	int iPercent;
-
-	if (GetMobRank() >= MOB_RANK_BOSS)
-		iPercent = ((iGoldPercent * PERCENT_LVDELTA_BOSS(pkAttacker->GetLevel(), GetLevel())) / 100);
-	else
-		iPercent = ((iGoldPercent * PERCENT_LVDELTA(pkAttacker->GetLevel(), GetLevel())) / 100);
-	//int iPercent = CALCULATE_VALUE_LVDELTA(pkAttacker->GetLevel(), GetLevel(), iGoldPercent);
-
-	if (number(1, 100) > iPercent)
-		return;
-
-	int iGoldMultipler = GetGoldMultipler();
-
-	if (1 == number(1, 50000)) // 1 / 50000 확률로 돈이 10배
-		iGoldMultipler *= 10;
-	else if (1 == number(1, 10000)) // 1 / 10000 확률로 돈이 5배
-		iGoldMultipler *= 5;
-
-	// 개인 적용
-	if (pkAttacker->GetPoint(POINT_GOLD_DOUBLE_BONUS))
-		if (number(1, 100) <= pkAttacker->GetPoint(POINT_GOLD_DOUBLE_BONUS))
-			iGoldMultipler *= 2;
-
-	//
-	// --------- 돈 드롭 배수 결정 ----------
-	//
-	if (test_server)
-		pkAttacker->ChatPacket(CHAT_TYPE_PARTY, "gold_mul %d rate %d", iGoldMultipler, CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker));
-
-	//
-	// --------- 실제 드롭 처리 -------------
-	//
-	LPITEM item;
-
-	int iGold10DropPct = 100;
-	iGold10DropPct = (iGold10DropPct * 100) / (100 + CPrivManager::instance().GetPriv(pkAttacker, PRIV_GOLD10_DROP));
-
-	// MOB_RANK가 BOSS보다 높으면 무조건 돈폭탄
-	if (GetMobRank() >= MOB_RANK_BOSS && !IsStone() && GetMobTable().dwGoldMax != 0)
-	{
-		if (1 == number(1, iGold10DropPct))
-			iGoldMultipler *= 10; // 1% 확률로 돈 10배
-
-		int iSplitCount = number(25, 35);
-
-		for (int i = 0; i < iSplitCount; ++i)
-		{
-			int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax) / iSplitCount;
-			if (test_server)
-				sys_log(0, "iGold %d", iGold);
-			iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker) / 100;
-			iGold *= iGoldMultipler;
-
-			if (iGold == 0)
-			{
-				continue;
-			}
-
-			if (test_server)
-			{
-				sys_log(0, "Drop Moeny MobGoldAmountRate %d %d", CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker), iGoldMultipler);
-				sys_log(0, "Drop Money gold %d GoldMin %d GoldMax %d", iGold, GetMobTable().dwGoldMax, GetMobTable().dwGoldMax);
-			}
-
-			// NOTE: 돈 폭탄은 제 3의 손 처리를 하지 않음
-			if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold)))
-			{
-				pos.x = GetX() + ((number(-14, 14) + number(-14, 14)) * 23);
-				pos.y = GetY() + ((number(-14, 14) + number(-14, 14)) * 23);
-
-				item->AddToGround(GetMapIndex(), pos);
-				item->StartDestroyEvent();
-
-				iTotalGold += iGold; // Total gold
-			}
-		}
-	}
-	// 1% 확률로 돈을 10개 떨어 뜨린다. (10배 드롭임)
-	else if (1 == number(1, iGold10DropPct))
-	{
-		//
-		// 돈 폭탄식 드롭
-		//
-		for (int i = 0; i < 10; ++i)
-		{
-			int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax);
-			iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker) / 100;
-			iGold *= iGoldMultipler;
-
-			if (iGold == 0)
-			{
-				continue;
-			}
-
-			// NOTE : 돈 폭탄은 제 3의 손 처리를 하지 않음
-			if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold)))
-			{
-				pos.x = GetX() + (number(-7, 7) * 20);
-				pos.y = GetY() + (number(-7, 7) * 20);
-
-				item->AddToGround(GetMapIndex(), pos);
-				item->StartDestroyEvent();
-
-				iTotalGold += iGold; // Total gold
-			}
-		}
-	}
-	else
-	{
-		//
-		// 일반적인 방식의 돈 드롭
-		//
-		int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax);
-		iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker) / 100;
-		iGold *= iGoldMultipler;
-
-		int iSplitCount;
-
-		if (iGold >= 3 && !LC_IsYMIR())
-			iSplitCount = number(1, 3);
-		else if (GetMobRank() >= MOB_RANK_BOSS)
-		{
-			iSplitCount = number(3, 10);
-
-			if ((iGold / iSplitCount) == 0)
-				iSplitCount = 1;
-		}
-		else
-			iSplitCount = 1;
-
-		if (iGold != 0)
-		{
-			iTotalGold += iGold; // Total gold
-
-			for (int i = 0; i < iSplitCount; ++i)
-			{
-				if (isAutoLoot)
-				{
-					pkAttacker->GiveGold(iGold / iSplitCount);
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-					pkAttacker->UpdateExtBattlePassMissionProgress(YANG_COLLECT, iGold / iSplitCount, pkAttacker->GetMapIndex());
-#endif
-				}
-				else if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold / iSplitCount)))
-				{
-					pos.x = GetX() + (number(-7, 7) * 20);
-					pos.y = GetY() + (number(-7, 7) * 20);
-
-					item->AddToGround(GetMapIndex(), pos);
-					item->StartDestroyEvent();
-				}
-			}
-		}
-	}
-
-	DBManager::instance().SendMoneyLog(MONEY_LOG_MONSTER, GetRaceNum(), iTotalGold);
-}
-
-void CHARACTER::Reward(bool bItemDrop)
-{
-	if (GetRaceNum() == 5001) // 왜구는 돈을 무조건 드롭
-	{
-		PIXEL_POSITION pos;
-
-		if (!SECTREE_MANAGER::instance().GetMovablePosition(GetMapIndex(), GetX(), GetY(), pos))
-			return;
-
-		LPITEM item;
-		int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax);
-		iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(NULL) / 100;
-		iGold *= GetGoldMultipler();
-		int iSplitCount = number(25, 35);
-
-		sys_log(0, "WAEGU Dead gold %d split %d", iGold, iSplitCount);
-
-		for (int i = 1; i <= iSplitCount; ++i)
-		{
-			if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold / iSplitCount)))
-			{
-				if (i != 0)
-				{
-					pos.x = number(-7, 7) * 20;
-					pos.y = number(-7, 7) * 20;
-
-					pos.x += GetX();
-					pos.y += GetY();
-				}
-
-				item->AddToGround(GetMapIndex(), pos);
-				item->StartDestroyEvent();
-			}
-		}
-		return;
-	}
-
-	//PROF_UNIT puReward("Reward");
-	LPCHARACTER pkAttacker = DistributeExp();
-
-	if (!pkAttacker)
-		return;
-
-	//PROF_UNIT pu1("r1");
-	if (pkAttacker->IsPC())
-	{
-		if (GetLevel() - pkAttacker->GetLevel() >= -10)
-		{
-			if (pkAttacker->GetRealAlignment() < 0)
-			{
-				if (pkAttacker->IsEquipUniqueItem(UNIQUE_ITEM_FASTER_ALIGNMENT_UP_BY_KILL))
-					pkAttacker->UpdateAlignment(14);
-				else
-					pkAttacker->UpdateAlignment(7);
-			}
-			else
-				pkAttacker->UpdateAlignment(2);
-		}
-
-		pkAttacker->SetQuestNPCID(GetVID());
-		quest::CQuestManager::instance().Kill(pkAttacker->GetPlayerID(), GetRaceNum());
-		CHARACTER_MANAGER::instance().KillLog(GetRaceNum());
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		pkAttacker->UpdateExtBattlePassMissionProgress(KILL_MONSTER, 1, GetRaceNum());
-#endif
-
-#if defined(__PARTY_KILL_RENEWAL__)
-		if (pkAttacker->GetParty())
-		{
-			quest::CQuestManager::instance().PartyKill(pkAttacker->GetPlayerID(), GetRaceNum());
-
-			FPartyKill f(this, pkAttacker);
-			pkAttacker->GetParty()->ForEachNearMember(f);
-		}
-#endif
-
-		if (!number(0, 9))
-		{
-			if (pkAttacker->GetPoint(POINT_KILL_HP_RECOVERY))
-			{
-				int iHP = pkAttacker->GetMaxHP() * pkAttacker->GetPoint(POINT_KILL_HP_RECOVERY) / 100;
-				pkAttacker->PointChange(POINT_HP, iHP);
-				CreateFly(FLY_HP_SMALL, pkAttacker);
-			}
-
-			if (pkAttacker->GetPoint(POINT_KILL_SP_RECOVER))
-			{
-				int iSP = pkAttacker->GetMaxSP() * pkAttacker->GetPoint(POINT_KILL_SP_RECOVER) / 100;
-				pkAttacker->PointChange(POINT_SP, iSP);
-				CreateFly(FLY_SP_SMALL, pkAttacker);
-			}
-		}
-	}
-	//pu1.Pop();
-
-	if (!bItemDrop)
-		return;
-
-	PIXEL_POSITION pos = GetXYZ();
-
-	if (!SECTREE_MANAGER::instance().GetMovablePosition(GetMapIndex(), pos.x, pos.y, pos))
-		return;
-
-	//
-	// 돈 드롭
-	//
-	//PROF_UNIT pu2("r2");
-	if (test_server)
-		sys_log(0, "Drop money : Attacker %s", pkAttacker->GetName());
-	RewardGold(pkAttacker);
-	//pu2.Pop();
-
-	//
-	// 아이템 드롭
-	//
-	//PROF_UNIT pu3("r3");
-	LPITEM item;
-
-	static std::vector<LPITEM> s_vec_item;
-	s_vec_item.clear();
-
-	if (ITEM_MANAGER::instance().CreateDropItem(this, pkAttacker, s_vec_item))
-	{
-		if (s_vec_item.size() == 0);
-		else if (s_vec_item.size() == 1)
-		{
-			item = s_vec_item[0];
-
-#if defined(__DICE_SYSTEM__)
-			FPartyDropDiceRoll f(item, pkAttacker);
-			f.Process(this);
-#endif
-
-#if defined (__PET_SYSTEM__) && defined(__PET_LOOT__)
-			if ((f.GetItemOwner() == pkAttacker) && (pkAttacker->GetPetSystem() && pkAttacker->GetPetSystem()->LootItem(item)))
-				pkAttacker->AutoGiveItem(item, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					, true
-#endif
-				);
-			else
-#endif
-			{
-				item->AddToGround(GetMapIndex(), pos);
-				if (CBattleArena::instance().IsBattleArenaMap(pkAttacker->GetMapIndex()) == false)
-#if defined(__DICE_SYSTEM__)
-					item->SetOwnership(f.GetItemOwner());
-#else
-					item->SetOwnership(pkAttacker);
-#endif
-				item->StartDestroyEvent();
-
-				pos.x = number(-7, 7) * 20;
-				pos.y = number(-7, 7) * 20;
-				pos.x += GetX();
-				pos.y += GetY();
-
-				sys_log(0, "DROP_ITEM: %s %d %d from %s", item->GetName(), pos.x, pos.y, GetName());
-			}
-		}
-		else
-		{
-			int iItemIdx = s_vec_item.size() - 1;
-
-			std::priority_queue<std::pair<int, LPCHARACTER>> pq;
-
-			int total_dam = 0;
-
-			for (TDamageMap::iterator it = m_map_kDamage.begin(); it != m_map_kDamage.end(); ++it)
-			{
-				int iDamage = it->second.iTotalDamage;
-				if (iDamage > 0)
-				{
-					LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(it->first);
-
-					if (ch)
-					{
-						pq.push(std::make_pair(iDamage, ch));
-						total_dam += iDamage;
-					}
-				}
-			}
-
-			std::vector<LPCHARACTER> v;
-
-			while (!pq.empty() && pq.top().first * 10 >= total_dam)
-			{
-				v.push_back(pq.top().second);
-				pq.pop();
-			}
-
-			if (v.empty())
-			{
-				// 데미지를 특별히 많이 준 사람이 없으니 소유권 없음
-				while (iItemIdx >= 0)
-				{
-					item = s_vec_item[iItemIdx--];
-
-					if (!item)
-					{
-						sys_err("item null in vector idx %d", iItemIdx + 1);
-						continue;
-					}
-
-					item->AddToGround(GetMapIndex(), pos);
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-					pkAttacker->UpdateExtBattlePassMissionProgress(BP_ITEM_COLLECT, item->GetCount(), item->GetVnum());
-#endif
-					// 10% 이하 데미지 준 사람끼리는 소유권없음
-					//item->SetOwnership(pkAttacker);
-					item->StartDestroyEvent();
-
-					pos.x = number(-7, 7) * 20;
-					pos.y = number(-7, 7) * 20;
-					pos.x += GetX();
-					pos.y += GetY();
-
-					sys_log(0, "DROP_ITEM: %s %d %d by %s", item->GetName(), pos.x, pos.y, GetName());
-				}
-			}
-			else
-			{
-				// 데미지 많이 준 사람들 끼리만 소유권 나눠가짐
-				std::vector<LPCHARACTER>::iterator it = v.begin();
-
-				while (iItemIdx >= 0)
-				{
-					item = s_vec_item[iItemIdx--];
-
-					if (!item)
-					{
-						sys_err("item null in vector idx %d", iItemIdx + 1);
-						continue;
-					}
-
-					LPCHARACTER ch = *it;
-
-					if (ch->GetParty())
-						ch = ch->GetParty()->GetNextOwnership(ch, GetX(), GetY());
-
-					++it;
-
-					if (it == v.end())
-						it = v.begin();
-
-#if defined(__DICE_SYSTEM__)
-					FPartyDropDiceRoll f(item, ch);
-					f.Process(this);
-#endif
-
-#if defined(__PET_SYSTEM__) && defined(__PET_LOOT__)
-					if ((f.GetItemOwner() == pkAttacker) && (pkAttacker->GetPetSystem() && pkAttacker->GetPetSystem()->LootItem(item)))
-						pkAttacker->AutoGiveItem(item, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-							, true
-#endif
-						);
-					else
-#endif
-					{
-						item->AddToGround(GetMapIndex(), pos);
-						if (CBattleArena::instance().IsBattleArenaMap(ch->GetMapIndex()) == false)
-						{
-#if defined(__DICE_SYSTEM__)
-							item->SetOwnership(f.GetItemOwner());
-#else
-							item->SetOwnership(ch);
-#endif
-						}
-						item->StartDestroyEvent();
-
-						pos.x = number(-7, 7) * 20;
-						pos.y = number(-7, 7) * 20;
-						pos.x += GetX();
-						pos.y += GetY();
-
-						sys_log(0, "DROP_ITEM: %s %d %d by %s", item->GetName(), pos.x, pos.y, GetName());
-					}
-				}
-			}
-		}
-	}
-
-	m_map_kDamage.clear();
-}
-
-struct TItemDropPenalty
-{
-	int iInventoryPct; // Range: 1 ~ 1000
-	int iInventoryQty; // Range: --
-	int iEquipmentPct; // Range: 1 ~ 100
-	int iEquipmentQty; // Range: --
-};
-
-TItemDropPenalty aItemDropPenalty_kor[9] =
-{
-	{ 0, 0, 0, 0 }, // 선왕
-	{ 0, 0, 0, 0 }, // 영웅
-	{ 0, 0, 0, 0 }, // 성자
-	{ 0, 0, 0, 0 }, // 지인
-	{ 0, 0, 0, 0 }, // 양민
-	{ 20, 5, 5, 1 }, // 낭인
-	{ 30, 10, 10, 2 }, // 악인
-	{ 40, 20, 35, 3 }, // 마두
-	{ 80, 40, 40, 4 }, // 패왕
-};
-
-void CHARACTER::ItemDropPenalty(LPCHARACTER pkKiller)
-{
-	// 개인상점을 연 상태에서는 아이템을 드롭하지 않는다.
-	if (GetMyShop())
-		return;
-
-	if (false == LC_IsYMIR())
-	{
-		if (GetLevel() < 50)
-			return;
-	}
-
-	if (CArenaManager::Instance().IsArenaMap(GetMapIndex()))
-		return;
-
-	if (CBattleArena::instance().IsBattleArenaMap(GetMapIndex()) == true)
-		return;
-
-	struct TItemDropPenalty* table = &aItemDropPenalty_kor[0];
-
-	if (GetLevel() < 10)
-		return;
-
-	int iAlignIndex;
-	if (GetRealAlignment() >= 120000)
-		iAlignIndex = 0;
-	else if (GetRealAlignment() >= 80000)
-		iAlignIndex = 1;
-	else if (GetRealAlignment() >= 40000)
-		iAlignIndex = 2;
-	else if (GetRealAlignment() >= 10000)
-		iAlignIndex = 3;
-	else if (GetRealAlignment() >= 0)
-		iAlignIndex = 4;
-	else if (GetRealAlignment() > -40000)
-		iAlignIndex = 5;
-	else if (GetRealAlignment() > -80000)
-		iAlignIndex = 6;
-	else if (GetRealAlignment() > -120000)
-		iAlignIndex = 7;
-	else
-		iAlignIndex = 8;
-
-	std::vector<std::pair<LPITEM, int>> vec_item;
-	LPITEM pkItem;
-	int i;
-	bool isDropAllEquipments = false;
-
-	TItemDropPenalty& r = table[iAlignIndex];
-	sys_log(0, "%s align %d inven_pct %d equip_pct %d", GetName(), iAlignIndex, r.iInventoryPct, r.iEquipmentPct);
-
-	bool bDropInventory = r.iInventoryPct >= number(1, 1000);
-	bool bDropEquipment = r.iEquipmentPct >= number(1, 100);
-	bool bDropAntiDropUniqueItem = false;
-
-	if ((bDropInventory || bDropEquipment) && IsEquipUniqueItem(UNIQUE_ITEM_SKIP_ITEM_DROP_PENALTY))
-	{
-		bDropInventory = false;
-		bDropEquipment = false;
-		bDropAntiDropUniqueItem = true;
-	}
-
-	if (bDropInventory) // Drop Inventory
-	{
-		const bool bIsRunningQuest = IsRunningQuest();
-		std::vector<BYTE> vec_bSlots;
-
-		for (i = 0; i < INVENTORY_MAX_NUM; ++i)
-		{
-			pkItem = GetInventoryItem(i);
-			if (pkItem && !(bIsRunningQuest && pkItem->GetType() == ITEM_QUEST))
-				vec_bSlots.push_back(i);
-		}
-
-		if (!vec_bSlots.empty())
-		{
-			std::random_device rd;
-			std::mt19937 g(rd());
-			std::shuffle(vec_bSlots.begin(), vec_bSlots.end(), g);
-
-			int iQty = MIN(vec_bSlots.size(), r.iInventoryQty);
-
-			if (iQty)
-				iQty = number(1, iQty);
-
-			for (i = 0; i < iQty; ++i)
-			{
-				pkItem = GetInventoryItem(vec_bSlots[i]);
-
-#if defined(__MAILBOX__)
-				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP | ITEM_ANTIFLAG_MAIL))
-#else
-				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP))
-#endif
-					continue;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-				if (pkItem->IsSealed())
-					continue;
-#endif
-
-				SyncQuickslot(SLOT_TYPE_INVENTORY, vec_bSlots[i], WORD_MAX);
-				vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), INVENTORY));
-			}
-		}
-		else if (iAlignIndex == 8)
-			isDropAllEquipments = true;
-	}
-
-	if (bDropEquipment) // Drop Equipment
-	{
-		std::vector<BYTE> vec_bSlots;
-
-		for (i = 0; i < EQUIPMENT_MAX_NUM; ++i)
-			if (GetEquipmentItem(i))
-				vec_bSlots.push_back(i);
-
-		if (!vec_bSlots.empty())
-		{
-			std::random_device rd;
-			std::mt19937 g(rd());
-			std::shuffle(vec_bSlots.begin(), vec_bSlots.end(), g);
-			int iQty;
-
-			if (isDropAllEquipments)
-				iQty = vec_bSlots.size();
-			else
-				iQty = MIN(vec_bSlots.size(), number(1, r.iEquipmentQty));
-
-			if (iQty)
-				iQty = number(1, iQty);
-
-			for (i = 0; i < iQty; ++i)
-			{
-				pkItem = GetEquipmentItem(vec_bSlots[i]);
-
-#if defined(__MAILBOX__)
-				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP | ITEM_ANTIFLAG_MAIL))
-#else
-				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP))
-#endif
-					continue;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				if (pkItem->IsDragonSoul())
-					continue;
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-				if (pkItem->IsSealed())
-					continue;
-#endif
-
-				SyncQuickslot(SLOT_TYPE_INVENTORY, vec_bSlots[i], WORD_MAX);
-				vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), EQUIPMENT));
-			}
-		}
-	}
-
-	if (bDropAntiDropUniqueItem)
-	{
-		LPITEM pkItem;
-
-		pkItem = GetWear(WEAR_UNIQUE1);
-
-		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_SKIP_ITEM_DROP_PENALTY)
-		{
-			SyncQuickslot(SLOT_TYPE_INVENTORY, WEAR_UNIQUE1, WORD_MAX);
-			vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), EQUIPMENT));
-		}
-
-		pkItem = GetWear(WEAR_UNIQUE2);
-
-		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_SKIP_ITEM_DROP_PENALTY)
-		{
-			SyncQuickslot(SLOT_TYPE_INVENTORY, WEAR_UNIQUE2, WORD_MAX);
-			vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), EQUIPMENT));
-		}
-	}
-
-	{
-		PIXEL_POSITION pos;
-		pos.x = GetX();
-		pos.y = GetY();
-
-		unsigned int i;
-
-		for (i = 0; i < vec_item.size(); ++i)
-		{
-			LPITEM item = vec_item[i].first;
-			int window = vec_item[i].second;
-
-			item->AddToGround(GetMapIndex(), pos);
-			item->StartDestroyEvent();
-
-			sys_log(0, "DROP_ITEM_PK: %s %d %d from %s", item->GetName(), pos.x, pos.y, GetName());
-			LogManager::instance().ItemLog(this, item, "DEAD_DROP", (window == INVENTORY) ? "INVENTORY" : ((window == EQUIPMENT) ? "EQUIPMENT" : ""));
-
-			pos.x = GetX() + number(-7, 7) * 20;
-			pos.y = GetY() + number(-7, 7) * 20;
-		}
-	}
-}
-
-class FPartyAlignmentCompute
-{
-public:
-	FPartyAlignmentCompute(int iAmount, int x, int y)
-	{
-		m_iAmount = iAmount;
-		m_iCount = 0;
-		m_iStep = 0;
-		m_iKillerX = x;
-		m_iKillerY = y;
-	}
-
-	void operator () (LPCHARACTER pkChr)
-	{
-		if (DISTANCE_APPROX(pkChr->GetX() - m_iKillerX, pkChr->GetY() - m_iKillerY) < PARTY_DEFAULT_RANGE)
-		{
-			if (m_iStep == 0)
-			{
-				++m_iCount;
-			}
-			else
-			{
-				pkChr->UpdateAlignment(m_iAmount / m_iCount);
-			}
-		}
-	}
-
-	int m_iAmount;
-	int m_iCount;
-	int m_iStep;
-
-	int m_iKillerX;
-	int m_iKillerY;
-};
-
-void CHARACTER::Dead(LPCHARACTER pkKiller, bool bImmediateDead)
-{
-	if (IsDead())
-		return;
-
-#if !defined(__MOUNT_COSTUME_SYSTEM__)
-	if (IsHorseRiding())
-	{
-		StopRiding();
-	}
-	else if (GetMountVnum())
-	{
-		RemoveAffect(AFFECT_MOUNT_BONUS);
-
-		m_dwMountVnum = 0;
-		UnEquipSpecialRideUniqueItem();
-
-		UpdatePacket();
-	}
-#endif
-
-	if (!pkKiller && m_dwKillerPID)
-		pkKiller = CHARACTER_MANAGER::instance().FindByPID(m_dwKillerPID);
-
-	m_dwKillerPID = 0; // 반드시 초기화 해야함 DO NOT DELETE THIS LINE UNLESS YOU ARE 1000000% SURE
-
-#if defined(__SKILL_COOLTIME_UPDATE__)
-	if (IsPC())
-		ResetSkillCoolTimes();
-#endif
-
-	// 20200716.Owsap : Remove bad affects on death.
-	if (IsPC())
-		RemoveBadAffect();
-
-	ForgetMyAttacker(false);
-
-	bool isAgreedPVP = false;
-	bool isUnderGuildWar = false;
-	bool isDuel = false;
-	bool isForked = false;
-
-	if (pkKiller && pkKiller->IsPC())
-	{
-		if (pkKiller->m_pkChrTarget == this)
-			pkKiller->SetTarget(NULL);
-
-		if (!IsPC() && pkKiller->GetDungeon())
-			pkKiller->GetDungeon()->IncKillCount(pkKiller, this);
-
-		isAgreedPVP = CPVPManager::instance().Dead(this, pkKiller->GetPlayerID());
-		isDuel = CArenaManager::instance().OnDead(pkKiller, this);
-
-		if (IsPC())
-		{
-			CGuild* g1 = GetGuild();
-			CGuild* g2 = pkKiller->GetGuild();
-
-			if (g1 && g2)
-				if (g1->UnderWar(g2->GetID()))
-					isUnderGuildWar = true;
-
-			pkKiller->SetQuestNPCID(GetVID());
-			quest::CQuestManager::instance().Kill(pkKiller->GetPlayerID(), quest::QUEST_NO_NPC);
-			CGuildManager::instance().Kill(pkKiller, this);
-		}
-	}
-
-	if (IsPC())
-	{
-#if defined(__QUEST_EVENT_DEAD__)
-		if (pkKiller)
-			SetQuestNPCID(pkKiller->GetVID());
-
-		quest::CQuestManager::Instance().Dead(GetPlayerID(), (pkKiller) ? pkKiller->GetRaceNum() : quest::QUEST_NO_NPC);
-#endif
-
-		// CHECK_FORKEDROAD_WAR
-		if (CThreeWayWar::instance().IsThreeWayWarMapIndex(GetMapIndex()))
-			isForked = true;
-		// END_CHECK_FORKEDROAD_WAR
-	}
-
-	if (pkKiller &&
-		!isAgreedPVP &&
-		!isUnderGuildWar &&
-		IsPC() &&
-		!isDuel &&
-		!isForked &&
-		!IS_CASTLE_MAP(GetMapIndex()))
-	{
-		if (GetGMLevel() == GM_PLAYER || test_server)
-		{
-			ItemDropPenalty(pkKiller);
-		}
-	}
-
-	// CASTLE_SIEGE
-	if (IS_CASTLE_MAP(GetMapIndex()))
-	{
-		if (CASTLE_FROG_VNUM == GetRaceNum())
-			castle_frog_die(this, pkKiller);
-		else if (castle_is_guard_vnum(GetRaceNum()))
-			castle_guard_die(this, pkKiller);
-		else if (castle_is_tower_vnum(GetRaceNum()))
-			castle_tower_die(this, pkKiller);
-	}
-	// CASTLE_SIEGE
-
-	if (true == isForked)
-	{
-		CThreeWayWar::instance().onDead(this, pkKiller);
-	}
-
-	SetPosition(POS_DEAD);
-	ClearAffect(true);
-
-	if (pkKiller && IsPC())
-	{
-		if (!pkKiller->IsPC())
-		{
-			if (!isForked)
-			{
-				sys_log(1, "DEAD: %s %p WITH PENALTY", GetName(), this);
-				SET_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
-				LogManager::instance().CharLog(this, pkKiller->GetRaceNum(), "DEAD_BY_NPC", pkKiller->GetName());
-			}
-		}
-		else
-		{
-			sys_log(1, "DEAD_BY_PC: %s %p KILLER %s %p", GetName(), this, pkKiller->GetName(), get_pointer(pkKiller));
-			REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			pkKiller->UpdateExtBattlePassMissionProgress(KILL_PLAYER, 1, GetLevel());
-#endif
-
-			if (GetEmpire() != pkKiller->GetEmpire())
-			{
-				int iEP = MIN(GetPoint(POINT_EMPIRE_POINT), pkKiller->GetPoint(POINT_EMPIRE_POINT));
-
-				PointChange(POINT_EMPIRE_POINT, -(iEP / 10));
-				pkKiller->PointChange(POINT_EMPIRE_POINT, iEP / 5);
-
-				if (GetPoint(POINT_EMPIRE_POINT) < 10)
-				{
-					// TODO : 입구로 날리는 코드를 넣어야 한다.
-				}
-
-				char buf[256];
-				snprintf(buf, sizeof(buf),
-					"%d %d %d %s %d %d %d %s",
-					GetEmpire(), GetAlignment(), GetPKMode(), GetName(),
-					pkKiller->GetEmpire(), pkKiller->GetAlignment(), pkKiller->GetPKMode(), pkKiller->GetName());
-
-				LogManager::instance().CharLog(this, pkKiller->GetPlayerID(), "DEAD_BY_PC", buf);
-			}
-			else
-			{
-				if (!isAgreedPVP && !isUnderGuildWar && !IsKillerMode() && GetAlignment() >= 0 && !isDuel && !isForked)
-				{
-					int iNoPenaltyProb = 0;
-
-					if (g_iUseLocale)
-					{
-						if (pkKiller->GetAlignment() >= 0) // 1 / 3 percent down
-							iNoPenaltyProb = 33;
-						else // 4 / 5 percent down
-							iNoPenaltyProb = 20;
-					}
-
-					if (number(1, 100) < iNoPenaltyProb)
-						pkKiller->ChatPacket(CHAT_TYPE_INFO, LC_STRING("용신의 보호로 아이템이 떨어지지 않았습니다."));
-					else
-					{
-						if (g_iUseLocale && pkKiller->GetParty())
-						{
-							FPartyAlignmentCompute f(-20000, pkKiller->GetX(), pkKiller->GetY());
-							pkKiller->GetParty()->ForEachOnMapMember(f, pkKiller->GetMapIndex());
-
-							if (f.m_iCount == 0)
-								pkKiller->UpdateAlignment(-20000);
-							else
-							{
-								sys_log(0, "ALIGNMENT PARTY count %d amount %d", f.m_iCount, f.m_iAmount);
-
-								f.m_iStep = 1;
-								pkKiller->GetParty()->ForEachOnMapMember(f, pkKiller->GetMapIndex());
-							}
-						}
-						else
-							pkKiller->UpdateAlignment(-20000);
-					}
-				}
-
-				char buf[256];
-				snprintf(buf, sizeof(buf),
-					"%d %d %d %s %d %d %d %s",
-					GetEmpire(), GetAlignment(), GetPKMode(), GetName(),
-					pkKiller->GetEmpire(), pkKiller->GetAlignment(), pkKiller->GetPKMode(), pkKiller->GetName());
-
-				LogManager::instance().CharLog(this, pkKiller->GetPlayerID(), "DEAD_BY_PC", buf);
-			}
-		}
-	}
-	else
-	{
-		sys_log(1, "DEAD: %s %p", GetName(), this);
-		REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
-	}
-
-	ClearSync();
-
-	//sys_log(1, "stun cancel %s[%d]", GetName(), (DWORD)GetVID());
-	event_cancel(&m_pkStunEvent); // 기절 이벤트는 죽인다.
-
-	if (IsPC())
-	{
-		m_dwLastDeadTime = get_dword_time();
-		SetKillerMode(false);
-		GetDesc()->SetPhase(PHASE_DEAD);
-	}
-	else
-	{
-		// 가드에게 공격받은 몬스터는 보상이 없어야 한다.
-		if (!IS_SET(m_pointsInstant.instant_flag, INSTANT_FLAG_NO_REWARD))
-		{
-			if (!(pkKiller && pkKiller->IsPC() && pkKiller->GetGuild() && pkKiller->GetGuild()->UnderAnyWar(GUILD_WAR_TYPE_FIELD)))
-			{
-				// 부활하는 몬스터는 보상을 주지 않는다.
-				if (GetMobTable().dwResurrectionVnum)
-				{
-					// DUNGEON_MONSTER_REBIRTH_BUG_FIX
-					LPCHARACTER chResurrect = CHARACTER_MANAGER::instance().SpawnMob(GetMobTable().dwResurrectionVnum, GetMapIndex(), GetX(), GetY(), GetZ(), true, (int)GetRotation());
-					if (GetDungeon() && chResurrect)
-					{
-						chResurrect->SetDungeon(GetDungeon());
-					}
-					// END_OF_DUNGEON_MONSTER_REBIRTH_BUG_FIX
-
-					Reward(false);
-				}
-				else if (IsRevive() == true)
-				{
-					Reward(false);
-				}
-				else
-				{
-					Reward(true); // Drops gold, item, etc..
-				}
-			}
-			else
-			{
-				if (pkKiller->m_dwUnderGuildWarInfoMessageTime < get_dword_time())
-				{
-					pkKiller->m_dwUnderGuildWarInfoMessageTime = get_dword_time() + 60000;
-					pkKiller->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드전중에는 사냥에 따른 이익이 없습니다."));
-				}
-			}
-		}
-	}
-
-	// BOSS_KILL_LOG
-	if (GetMobRank() >= MOB_RANK_BOSS && pkKiller && pkKiller->IsPC())
-	{
-		char buf[51];
-		snprintf(buf, sizeof(buf), "%d %ld", g_bChannel, pkKiller->GetMapIndex());
-		if (IsStone())
-			LogManager::instance().CharLog(pkKiller, GetRaceNum(), "STONE_KILL", buf);
-		else
-			LogManager::instance().CharLog(pkKiller, GetRaceNum(), "BOSS_KILL", buf);
-	}
-	// END_OF_BOSS_KILL_LOG
-
-	TPacketGCDead pack;
-	pack.header = HEADER_GC_DEAD;
-	pack.vid = m_vid;
-	pack.map_index = GetMapIndex();
-	pack.dialog_type = DEAD_DIALOG_NORMAL;
-
-#if defined(__ELEMENTAL_DUNGEON__)
-	if (IS_ELEMENTAL_DUNGEON(GetMapIndex()))
-		pack.dialog_type = DEAD_DIALOG_GIVE_UP;
-#endif
-
-	PacketAround(&pack, sizeof(pack));
-
-	REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_STUN);
-
-	// 플레이어 캐릭터이면
-	if (GetDesc() != NULL)
-	{
-		//
-		// 클라이언트에 에펙트 패킷을 다시 보낸다.
-		//
-		auto it = m_list_pkAffect.begin();
-		while (it != m_list_pkAffect.end())
-			SendAffectAddPacket(GetDesc(), *it++);
-	}
-
-	//
-	// Dead 이벤트 생성,
-	//
-	// Dead 이벤트에서는 몬스터의 경우 몇초 후에 Destroy 되도록 해주며,
-	// PC의 경우 3분 있다가 마을에서 나오도록 해 준다. 3분 내에는 유저로부터
-	// 마을에서 시작할 건지, 여기서 시작할 건지 결정을 받는다.
-	if (isDuel == false)
-	{
-		if (m_pkDeadEvent)
-		{
-			sys_log(1, "DEAD_EVENT_CANCEL: %s %p %p", GetName(), this, get_pointer(m_pkDeadEvent));
-			event_cancel(&m_pkDeadEvent);
-		}
-
-		if (IsStone())
-			ClearStone();
-
-		if (GetDungeon())
-			GetDungeon()->DeadCharacter(this);
-
-		SCharDeadEventInfo* pEventInfo = AllocEventInfo<SCharDeadEventInfo>();
-
-		if (IsPC())
-		{
-			pEventInfo->isPC = true;
-			pEventInfo->dwID = this->GetPlayerID();
-
-			m_pkDeadEvent = event_create(dead_event, pEventInfo, PASSES_PER_SEC(180));
-		}
-		else
-		{
-			pEventInfo->isPC = false;
-			pEventInfo->dwID = this->GetVID();
-
-			if (IsRevive() == false && HasReviverInParty() == true)
-			{
-				m_pkDeadEvent = event_create(dead_event, pEventInfo, bImmediateDead ? 1 : PASSES_PER_SEC(1));
-			}
-			else
-			{
-				BYTE sec = 3;
-				if (!IsMonster())
-					sec = 10;
-
-				m_pkDeadEvent = event_create(dead_event, pEventInfo, bImmediateDead ? 1 : PASSES_PER_SEC(sec));
-			}
-		}
-
-		sys_log(1, "DEAD_EVENT_CREATE: %s %p %p", GetName(), this, get_pointer(m_pkDeadEvent));
-	}
-
-	if (m_pkExchange != NULL)
-	{
-		m_pkExchange->Cancel();
-	}
-
-	if (IsCubeOpen() == true)
-	{
-#if defined(__CUBE_RENEWAL__)
-		CCubeManager::Instance().CloseCube(this);
-#else
-		Cube_close(this);
-#endif
-	}
-
-	CShopManager::instance().StopShopping(this);
-	CloseMyShop();
-	CloseSafebox();
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	if (IsAcceRefineWindowOpen())
-		AcceRefineWindowClose(true);
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-	if (IsAuraRefineWindowOpen())
-		AuraRefineWindowClose(true);
-#endif
-
-#if defined(__MT_THUNDER_DUNGEON__)
-	if (IsMonster() && GetMobTable().dwVnum == CMTThunderDungeon::GUARDIAN_VNUM)
-		if ((pkKiller) && (pkKiller->GetMapIndex() == CMTThunderDungeon::MAP_INDEX))
-			CMTThunderDungeon::Instance().SpawnPortal(this);
-#endif
-
-	if (IsMonster() && BlueDragon::BossVnum == GetMobTable().dwVnum)
-	{
-		if (NULL != pkKiller && NULL != pkKiller->GetGuild())
-		{
-			CDragonLairManager::instance().OnDragonDead(this, pkKiller->GetGuild()->GetID());
-		}
-		else
-		{
-			sys_err("DragonLair: Dragon killed by nobody");
-		}
-	}
-
-#ifdef ENABLE_QUEEN_NETHIS
-	if ((IsStone()) || (IsMonster()))
-	{
-		if (pkKiller && pkKiller->IsPC())
-		{
-			if (SnakeLair::CSnk::instance().IsSnakeMap(pkKiller->GetMapIndex()))
-				SnakeLair::CSnk::instance().OnKill(this, pkKiller);
-		}
-	}
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (pkKiller && CGuildDragonLairManager::Instance().IsRedDragonLair(pkKiller->GetMapIndex()))
-	{
-		if (IsMonster() || IsStone())
-		{
-			CGuildDragonLair* pGuildDragonLair = pkKiller->GetGuildDragonLair();
-			if (pGuildDragonLair)
-				pGuildDragonLair->Kill(this);
-		}
-	}
-#endif
-}
-
-struct FuncSetLastAttacked
-{
-	FuncSetLastAttacked(DWORD dwTime) : m_dwTime(dwTime)
-	{
-	}
-
-	void operator () (LPCHARACTER ch)
-	{
-		ch->SetLastAttacked(m_dwTime);
-	}
-
-	DWORD m_dwTime;
-};
-
-void CHARACTER::SetLastAttacked(DWORD dwTime)
-{
-	assert(m_pkMobInst != NULL);
-
-	m_pkMobInst->m_dwLastAttackedTime = dwTime;
-	m_pkMobInst->m_posLastAttacked = GetXYZ();
-}
-
-void CHARACTER::SendDamagePacket(LPCHARACTER pAttacker, int Damage, BYTE DamageFlag)
-{
-	{
-		TPacketGCDamageInfo damageInfo;
-		memset(&damageInfo, 0, sizeof(TPacketGCDamageInfo));
-
-		damageInfo.header = HEADER_GC_DAMAGE_INFO;
-		damageInfo.dwVID = (DWORD)GetVID();
-		damageInfo.flag = DamageFlag;
-		damageInfo.damage = Damage;
-
-		if (GetDesc() != NULL)
-		{
-			GetDesc()->Packet(&damageInfo, sizeof(TPacketGCDamageInfo));
-		}
-
-		if (pAttacker && pAttacker->GetDesc())
-		{
-			if (pAttacker->GetTarget() == this)
-				pAttacker->GetDesc()->Packet(&damageInfo, sizeof(TPacketGCDamageInfo));
-		}
-
-		/*
-		if (GetArenaObserverMode() == false && GetArena() != NULL)
-		{
-			GetArena()->SendPacketToObserver(&damageInfo, sizeof(TPacketGCDamageInfo));
-		}
-		*/
-	}
-}
-
-//
-// CHARACTER::Damage 메소드는 this가 데미지를 입게 한다.
-//
-// Arguments
-//	pAttacker : 공격자
-//	dam : 데미지
-//	EDamageType : 어떤 형식의 공격인가?
-//
-// Return value
-//	true : dead
-//	false : not dead yet
-//
-bool CHARACTER::Damage(LPCHARACTER pAttacker, int dam, EDamageType type /*= DAMAGE_TYPE_NORMAL*/) // returns true if dead
-{
-	if (IsPC() && IsDead())
-		return false;
-
-	if (!GetSectree() || GetSectree()->IsAttr(GetX(), GetY(), ATTR_BANPK))
-		return false;
-
-	// 20190823.Owsap : Check skill affect without weapon.
-	if (pAttacker && this)
-	{
-		if (pAttacker->IsAffectFlag(AFF_GWIGUM) && !pAttacker->GetWear(WEAR_WEAPON))
-		{
-			pAttacker->RemoveAffect(SKILL_GWIGEOM);
-			return false;
-		}
-
-		if (pAttacker->IsAffectFlag(AFF_GEOMGYEONG) && !pAttacker->GetWear(WEAR_WEAPON))
-		{
-			pAttacker->RemoveAffect(SKILL_GEOMKYUNG);
-			return false;
-		}
-	}
-
-#if defined(__9TH_SKILL__)
-	if (pAttacker && FindAffect(AFFECT_CHEONUN_INVINCIBILITY))
-	{
-		SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-		return false;
-	}
-#endif
-
-#if defined(__CONQUEROR_LEVEL__)
-	if (pAttacker && pAttacker->IsNewWorldMapIndex() && pAttacker->IsPC() && !IsStone())
-	{
-		if (pAttacker->IsSungMaCursed(POINT_SUNGMA_STR))
-			dam /= 2;
-
-		int iHitPct = pAttacker->GetNewWorldSungMa(POINT_HIT_PCT);
-		if (iHitPct > 0 && iHitPct > pAttacker->GetPoint(POINT_HIT_PCT))
-		{
-			int iMissHitPct = ((iHitPct - pAttacker->GetPoint(POINT_HIT_PCT)) * 100.0) / iHitPct;
-			if (number(1, 100) <= iMissHitPct)
-			{
-				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-				return false;
-			}
-		}
-	}
-#endif
-
-#if defined(__SNOW_DUNGEON__)
-	if (pAttacker && IS_SNOW_DUNGEON(pAttacker->GetMapIndex()))
-	{
-		LPDUNGEON pDungeon = pAttacker->GetDungeon();
-		if (pDungeon)
-		{
-			switch (GetRaceNum())
-			{
-				case 8058: // Metin of Cold
-#if defined(__LABYRINTH_DUNGEON__)
-				case 8125: // TR: Metin of Cold
-				case 8135: // RX: Metin of Cold
-#endif
-				{
-					if (pDungeon->GetFlag("level") == 6)
-					{
-						if (pAttacker->GetJob() != JOB_SHAMAN)
-						{
-							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-							return false;
-						}
-					}
-				}
-				break;
-
-				case 20399: // North Dragon Pillar
-#if defined(__LABYRINTH_DUNGEON__)
-				case 20518: // TR: North Dragon Pillar
-				case 20538: // RX: North Dragon Pillar
-#endif
-				{
-					if (pDungeon->GetFlag("level") == 9)
-					{
-						if (pAttacker->GetJob() != JOB_SHAMAN && pAttacker->GetJob() != JOB_ASSASSIN)
-						{
-							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-							return false;
-						}
-					}
-				}
-				break;
-
-				case 6151: // Szel
-#if defined(__LABYRINTH_DUNGEON__)
-				case 4249: // TR: Szel
-				case 4329: // RX: Szel
-#endif
-				{
-					if (pDungeon->GetFlag("level") == 4)
-					{
-						if (!pAttacker->IsAffectFlag(AFF_HOSIN))
-						{
-							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-							return false;
-						}
-					}
-					else if (pDungeon->GetFlag("level") == 7)
-					{
-						if (!pAttacker->IsAffectFlag(AFF_GICHEON))
-						{
-							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-							return false;
-						}
-					}
-				}
-				break;
-
-			}
-		}
-	}
-#endif
-
-#if defined(__BLUE_DRAGON_RENEWAL__)
-	if (BlueDragon_IsBoss(GetRaceNum()))
-	{
-		if (BlueDragon_Block(pAttacker->GetMapIndex()))
-		{
-			SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-			return false;
-		}
-	}
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-	if (pAttacker && GetDefenseWave())
-	{
-		if (GetDefenseWave()->Damage(this) == false)
-		{
-			SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-			return false;
-		}
-	}
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (pAttacker && CGuildDragonLairManager::Instance().IsRedDragonLair(pAttacker->GetMapIndex()))
-	{
-		if (CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
-		{
-			CGuildDragonLair* pGuildDragonLair = pAttacker->GetGuildDragonLair();
-			if (pGuildDragonLair && pGuildDragonLair->Damage(this) == false)
-			{
-				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-				return false;
-			}
-		}
-		else if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
-		{
-			SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-			return false;
-		}
-	}
-#endif
-
-	if (EDamageType::DAMAGE_TYPE_MAGIC == type)
-	{
-		dam = (int)((float)dam * (100 + (pAttacker->GetPoint(POINT_MAGIC_ATT_BONUS_PER) + pAttacker->GetPoint(POINT_MELEE_MAGIC_ATT_BONUS_PER))) / 100.f + 0.5f);
-		
-		int iMtkBonus = pAttacker->GetPoint(POINT_MAGIC_ATT_GRADE_BONUS);
-		if (iMtkBonus > 0)
-		{
-			int iRawMtkBonus = dam * iMtkBonus / 100;
-			float fAdjFactor = iMtkBonus / 10.0f - 2.5f;
-			int iFinalMtkBonus = int(iRawMtkBonus / 100.0f * fAdjFactor + 0.5f);
-			dam += iFinalMtkBonus;
-		}
-	}
-
-	if (GetRaceNum() == 5001)
-	{
-		bool bDropMoney = false;
-		int iPercent = 0;
-		if (GetMaxHP() >= 0)
-			iPercent = (GetHP() * 100) / GetMaxHP();
-
-		if (iPercent <= 10 && GetMaxSP() < 5)
-		{
-			SetMaxSP(5);
-			bDropMoney = true;
-		}
-		else if (iPercent <= 20 && GetMaxSP() < 4)
-		{
-			SetMaxSP(4);
-			bDropMoney = true;
-		}
-		else if (iPercent <= 40 && GetMaxSP() < 3)
-		{
-			SetMaxSP(3);
-			bDropMoney = true;
-		}
-		else if (iPercent <= 60 && GetMaxSP() < 2)
-		{
-			SetMaxSP(2);
-			bDropMoney = true;
-		}
-		else if (iPercent <= 80 && GetMaxSP() < 1)
-		{
-			SetMaxSP(1);
-			bDropMoney = true;
-		}
-
-		if (bDropMoney)
-		{
-			DWORD dwGold = 1000;
-			int iSplitCount = number(10, 13);
-
-			sys_log(0, "WAEGU DropGoldOnHit %d times", GetMaxSP());
-
-			for (int i = 1; i <= iSplitCount; ++i)
-			{
-				PIXEL_POSITION pos;
-				LPITEM item;
-
-				if ((item = ITEM_MANAGER::instance().CreateItem(1, dwGold / iSplitCount)))
-				{
-					if (i != 0)
-					{
-						pos.x = (number(-14, 14) + number(-14, 14)) * 20;
-						pos.y = (number(-14, 14) + number(-14, 14)) * 20;
-
-						pos.x += GetX();
-						pos.y += GetY();
-					}
-
-					item->AddToGround(GetMapIndex(), pos);
-					item->StartDestroyEvent();
-				}
-			}
-		}
-	}
-
-	// 평타가 아닐 때는 공포 처리
-	if (type != EDamageType::DAMAGE_TYPE_NORMAL && type != EDamageType::DAMAGE_TYPE_NORMAL_RANGE)
-	{
-		if (IsAffectFlag(AFF_TERROR))
-		{
-			int pct = GetSkillPower(SKILL_TERROR) / 400;
-
-			if (number(1, 100) <= pct)
-				return false;
-		}
-	}
-
-	int iCurHP = GetHP();
-	int iCurSP = GetSP();
-
-	bool IsCritical = false;
-	bool IsPenetrate = false;
-	bool IsDeathBlow = false;
-
-	//PROF_UNIT puAttr("Attr");
-
-	//
-	// 마법형 스킬과, 레인지형 스킬은(궁자객) 크리티컬과, 관통공격 계산을 한다.
-	// 원래는 하지 않아야 하는데 Nerf(다운밸런스)패치를 할 수 없어서 크리티컬과
-	// 관통공격의 원래 값을 쓰지 않고, /2 이상하여 적용한다.
-	//
-	// 무사 이야기가 많아서 밀리 스킬도 추가
-	//
-	// 20091109 : 무사가 결과적으로 엄청나게 강해진 것으로 결론남, 독일 기준 무사 비율 70% 육박
-	//
-	if (type == EDamageType::DAMAGE_TYPE_MELEE || type == EDamageType::DAMAGE_TYPE_RANGE || type == EDamageType::DAMAGE_TYPE_MAGIC)
-	{
-		if (pAttacker)
-		{
-			// 크리티컬
-			int iCriticalPct = pAttacker->GetPoint(POINT_CRITICAL_PCT);
-
-			if (!IsPC())
-				iCriticalPct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_CRITICAL_BONUS);
-
-			if (iCriticalPct)
-			{
-				if (iCriticalPct >= 10) // 10보다 크면 5% + (4마다 1%씩 증가), 따라서 수치가 50이면 20%
-					iCriticalPct = 5 + (iCriticalPct - 10) / 4;
-				else // 10보다 작으면 단순히 반으로 깎음, 10 = 5%
-					iCriticalPct /= 2;
-
-				// 크리티컬 저항 값 적용.
-				iCriticalPct -= GetPoint(POINT_RESIST_CRITICAL);
-
-				if (number(1, 100) <= iCriticalPct)
-				{
-					IsCritical = true;
-
-					// NOTE : According to the planner, in 2018 the critical damage multiplier in PvP
-					// was adjusted from 2 to 1.5 in order to balance the damage.
-					dam *= 1.5; // 2.0
-
-					EffectPacket(SE_CRITICAL);
-
-					if (IsAffectFlag(AFF_MANASHIELD))
-					{
-						RemoveAffect(AFF_MANASHIELD);
-					}
-				}
-			}
-
-			// 관통공격
-			int iPenetratePct = pAttacker->GetPoint(POINT_PENETRATE_PCT);
-
-			if (!IsPC())
-				iPenetratePct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_PENETRATE_BONUS);
-
-			if (iPenetratePct)
-			{
-				{
-					CSkillProto* pkSk = CSkillManager::instance().Get(SKILL_RESIST_PENETRATE);
-
-					if (NULL != pkSk)
-					{
-						pkSk->SetPointVar("k", 1.0f * GetSkillPower(SKILL_RESIST_PENETRATE) / 100.0f);
-
-						iPenetratePct -= static_cast<int>(pkSk->kPointPoly.Eval());
-					}
-				}
-
-				if (iPenetratePct >= 10)
-				{
-					// 10보다 크면 5% + (4마다 1%씩 증가), 따라서 수치가 50이면 20%
-					iPenetratePct = 5 + (iPenetratePct - 10) / 4;
-				}
-				else
-				{
-					// 10보다 작으면 단순히 반으로 깎음, 10 = 5%
-					iPenetratePct /= 2;
-				}
-
-				// 관통타격 저항 값 적용.
-				iPenetratePct -= GetPoint(POINT_RESIST_PENETRATE);
-
-				if (number(1, 100) <= iPenetratePct)
-				{
-					IsPenetrate = true;
-
-					if (test_server)
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("관통 추가 데미지 %d", GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100));
-
-					dam += GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100;
-					if (iPenetratePct > 100)
-						dam += dam * (iPenetratePct - 100) / 200;
-
-					EffectPacket(SE_PENETRATE);
-
-					if (IsAffectFlag(AFF_MANASHIELD))
-					{
-						RemoveAffect(AFF_MANASHIELD);
-					}
-				}
-			}
-		}
-	}
-	//
-	// 콤보 공격, 활 공격, 즉 평타 일 때만 속성값들을 계산을 한다.
-	//
-	else if (type == EDamageType::DAMAGE_TYPE_NORMAL || type == EDamageType::DAMAGE_TYPE_NORMAL_RANGE)
-	{
-		if (type == EDamageType::DAMAGE_TYPE_NORMAL)
-		{
-			// 근접 평타일 경우 막을 수 있음
-			if (GetPoint(POINT_BLOCK) && number(1, 100) <= GetPoint(POINT_BLOCK))
-			{
-				if (test_server)
-				{
-					pAttacker->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 블럭! (%d%%)", GetName(), GetPoint(POINT_BLOCK)));
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 블럭! (%d%%)", GetName(), GetPoint(POINT_BLOCK)));
-				}
-
-				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-				return false;
-			}
-
-			if (GetPoint(POINT_NORMAL_DAMAGE_GUARD) && number(1, 100) <= GetPoint(POINT_NORMAL_DAMAGE_GUARD))
-			{
-				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
-				return false;
-			}
-		}
-		else if (type == EDamageType::DAMAGE_TYPE_NORMAL_RANGE)
-		{
-			// 원거리 평타의 경우 피할 수 있음
-			if (GetPoint(POINT_DODGE) && number(1, 100) <= GetPoint(POINT_DODGE))
-			{
-				if (test_server)
-				{
-					pAttacker->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 회피! (%d%%)", GetName(), GetPoint(POINT_DODGE)));
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 회피! (%d%%)", GetName(), GetPoint(POINT_DODGE)));
-				}
-
-				SendDamagePacket(pAttacker, 0, DAMAGE_DODGE);
-				return false;
-			}
-		}
-
-		if (IsAffectFlag(AFF_JEONGWIHON))
-			dam = (int)(dam * (100 + GetSkillPower(SKILL_JEONGWI) * 25 / 100) / 100);
-
-		if (IsAffectFlag(AFF_TERROR))
-			dam = (int)(dam * (95 - GetSkillPower(SKILL_TERROR) / 5) / 100);
-
-		if (IsAffectFlag(AFF_HOSIN))
-			dam = dam * (100 - GetPoint(POINT_RESIST_NORMAL_DAMAGE)) / 100;
-
-		//
-		// 공격자 속성 적용
-		//
-		if (pAttacker)
-		{
-			if (type == EDamageType::DAMAGE_TYPE_NORMAL)
-			{
-				// 반사
-				if (GetPoint(POINT_REFLECT_MELEE))
-				{
-					int reflectDamage = dam * GetPoint(POINT_REFLECT_MELEE) / 100;
-
-					// NOTE: 공격자가 IMMUNE_REFLECT 속성을 갖고있다면 반사를 안 하는 게 
-					// 아니라 1/3 데미지로 고정해서 들어가도록 기획에서 요청.
-					if (pAttacker->IsImmune(IMMUNE_REFLECT))
-						reflectDamage = int(reflectDamage / 3.0f + 0.5f);
-
-					if (reflectDamage > 0)
-						pAttacker->Damage(this, reflectDamage, DAMAGE_TYPE_SPECIAL);
-				}
-			}
-
-			// 크리티컬
-			int iCriticalPct = pAttacker->GetPoint(POINT_CRITICAL_PCT);
-
-			if (!IsPC())
-				iCriticalPct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_CRITICAL_BONUS);
-
-			if (iCriticalPct)
-			{
-				//크리티컬 저항 값 적용.
-				iCriticalPct -= GetPoint(POINT_RESIST_CRITICAL);
-
-				if (number(1, 100) <= iCriticalPct)
-				{
-					IsCritical = true;
-					dam *= 2;
-					EffectPacket(SE_CRITICAL);
-				}
-			}
-
-			// 관통공격
-			int iPenetratePct = pAttacker->GetPoint(POINT_PENETRATE_PCT);
-
-			if (!IsPC())
-				iPenetratePct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_PENETRATE_BONUS);
-
-			{
-				CSkillProto* pkSk = CSkillManager::instance().Get(SKILL_RESIST_PENETRATE);
-
-				if (NULL != pkSk)
-				{
-					pkSk->SetPointVar("k", 1.0f * GetSkillPower(SKILL_RESIST_PENETRATE) / 100.0f);
-
-					iPenetratePct -= static_cast<int>(pkSk->kPointPoly.Eval());
-				}
-			}
-
-			if (iPenetratePct)
-			{
-				// 관통타격 저항 값 적용.
-				iPenetratePct -= GetPoint(POINT_RESIST_PENETRATE);
-
-				if (number(1, 100) <= iPenetratePct)
-				{
-					IsPenetrate = true;
-
-					if (test_server)
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("관통 추가 데미지 %d", GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100));
-
-					dam += GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100;
-					if (iPenetratePct > 100)
-						dam += dam * (iPenetratePct - 100) / 200;
-
-					EffectPacket(SE_PENETRATE);
-				}
-			}
-
-			// HP 스틸
-			if (pAttacker->GetPoint(POINT_STEAL_HP))
-			{
-				int pct = 1;
-
-				if (number(1, 10) <= pct)
-				{
-					int iHP = MIN(dam, MAX(0, iCurHP)) * pAttacker->GetPoint(POINT_STEAL_HP) / 100;
-
-					if (iHP > 0 && GetHP() >= iHP)
-					{
-						CreateFly(FLY_HP_SMALL, pAttacker);
-						pAttacker->PointChange(POINT_HP, iHP);
-						PointChange(POINT_HP, -iHP);
-					}
-				}
-			}
-
-			// SP 스틸
-			if (pAttacker->GetPoint(POINT_STEAL_SP))
-			{
-				int pct = 1;
-
-				if (number(1, 10) <= pct)
-				{
-					int iCur;
-
-					if (IsPC())
-						iCur = iCurSP;
-					else
-						iCur = iCurHP;
-
-					int iSP = MIN(dam, MAX(0, iCur)) * pAttacker->GetPoint(POINT_STEAL_SP) / 100;
-
-					if (iSP > 0 && iCur >= iSP)
-					{
-						CreateFly(FLY_SP_SMALL, pAttacker);
-						pAttacker->PointChange(POINT_SP, iSP);
-
-						if (IsPC())
-							PointChange(POINT_SP, -iSP);
-					}
-				}
-			}
-
-			// 돈 스틸
-			if (pAttacker->GetPoint(POINT_STEAL_GOLD))
-			{
-				if (number(1, 100) <= pAttacker->GetPoint(POINT_STEAL_GOLD))
-				{
-					long llAmount = number(1, GetLevel());
-					pAttacker->PointChange(POINT_GOLD, llAmount);
-					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 1, llAmount);
-				}
-			}
-
-			// 칠 때마다 HP회복
-			if (pAttacker->GetPoint(POINT_HIT_HP_RECOVERY) && number(0, 4) > 0) // 80% 확률
-			{
-				int i = ((iCurHP >= 0) ? MIN(dam, iCurHP) : dam) * pAttacker->GetPoint(POINT_HIT_HP_RECOVERY) / 100;
-
-				if (i)
-				{
-					CreateFly(FLY_HP_SMALL, pAttacker);
-					pAttacker->PointChange(POINT_HP, i);
-				}
-			}
-
-			// 칠 때마다 SP회복
-			if (pAttacker->GetPoint(POINT_HIT_SP_RECOVERY) && number(0, 4) > 0) // 80% 확률
-			{
-				int i = ((iCurHP >= 0) ? MIN(dam, iCurHP) : dam) * pAttacker->GetPoint(POINT_HIT_SP_RECOVERY) / 100;
-
-				if (i)
-				{
-					CreateFly(FLY_SP_SMALL, pAttacker);
-					pAttacker->PointChange(POINT_SP, i);
-				}
-			}
-
-			// 상대방의 마나를 없앤다.
-			if (pAttacker->GetPoint(POINT_MANA_BURN_PCT))
-			{
-				if (number(1, 100) <= pAttacker->GetPoint(POINT_MANA_BURN_PCT))
-					PointChange(POINT_SP, -50);
-			}
-		}
-	}
-
-	//
-	// 평타 또는 스킬로 인한 보너스 피해/방어 계산
-	//
-	switch (type)
-	{
-		case EDamageType::DAMAGE_TYPE_NORMAL:
-		case EDamageType::DAMAGE_TYPE_NORMAL_RANGE:
-		{
-			if (pAttacker)
-			{
-				if (pAttacker->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS))
-					dam = dam * (100 + pAttacker->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS)) / 100;
-
-#if defined(__SOUL_SYSTEM__) && !defined(__SOUL_SYSTEM_CALC_FINAL_DAMAGE__)
-				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_RED))
-					dam = dam * (100 + pAttacker->GetSoulDamage(RED_SOUL)) / 100;
-#endif
-			}
-
-			dam = dam * (100 - MIN(99, GetPoint(POINT_NORMAL_HIT_DEFEND_BONUS))) / 100;
-
-			{
-				DWORD dwDmgHPRecover = GetPoint(POINT_DAMAGE_HP_RECOVERY);
-				if (dwDmgHPRecover != 0)
-				{
-					int iHPRecover = (float(dwDmgHPRecover) / 100) * dam;
-					PointChange(POINT_HP, iHPRecover);
-					CreateFly(FLY_HP_SMALL, this);
-				}
-
-				DWORD dwDmgSPRecover = GetPoint(POINT_DAMAGE_SP_RECOVERY);
-				if (dwDmgSPRecover != 0)
-				{
-					int iSPRecover = (float(dwDmgSPRecover) / 100) * dam;
-					PointChange(POINT_SP, iSPRecover);
-					CreateFly(FLY_SP_SMALL, this);
-				}
-			}
-		}
-		break;
-
-		case EDamageType::DAMAGE_TYPE_MELEE:
-		case EDamageType::DAMAGE_TYPE_RANGE:
-		case EDamageType::DAMAGE_TYPE_FIRE:
-		case EDamageType::DAMAGE_TYPE_ICE:
-		case EDamageType::DAMAGE_TYPE_ELEC:
-		case EDamageType::DAMAGE_TYPE_MAGIC:
-		{
-			if (pAttacker)
-			{
-				if (pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS))
-					dam = dam * (100 + pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS)) / 100;
-
-#if defined(__SOUL_SYSTEM__) && !defined(__SOUL_SYSTEM_CALC_FINAL_DAMAGE__)
-				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_BLUE))
-					dam = dam * (100 + pAttacker->GetSoulDamage(BLUE_SOUL)) / 100;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-				if (pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE))
-					if (IsMonster() && GetMobRank() >= MOB_RANK_BOSS)
-						dam = dam * (100 + pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE)) / 100;
-
-				if (GetPoint(POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE))
-					if (pAttacker->IsMonster() && pAttacker->GetMobRank() >= MOB_RANK_BOSS)
-						dam = dam * (100 - MIN(99, GetPoint(POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE))) / 100;
-#endif
-			}
-
-			dam = dam * (100 - MIN(99, GetPoint(POINT_SKILL_DEFEND_BONUS))) / 100;
-		}
-		break;
-
-		default:
-			break;
-	}
-
-	//
-	// 마나쉴드(흑신수호)
-	//
-	if (IsAffectFlag(AFF_MANASHIELD))
-	{
-		// POINT_MANASHIELD 는 작아질수록 좋다
-		int iDamageSPPart = dam / 3;
-		int iDamageToSP = iDamageSPPart * GetPoint(POINT_MANASHIELD) / 100;
-		int iSP = GetSP();
-
-		// SP가 있으면 무조건 데미지 절반 감소
-		if (iDamageToSP <= iSP)
-		{
-			PointChange(POINT_SP, -iDamageToSP);
-			dam -= iDamageSPPart;
-		}
-		else
-		{
-			// 정신력이 모자라서 피가 더 깍여야할
-			PointChange(POINT_SP, -GetSP());
-			dam -= iSP * 100 / MAX(GetPoint(POINT_MANASHIELD), 1);
-		}
-	}
-
-	//
-	// 전체 방어력 상승 (몰 아이템)
-	//
-	if (GetPoint(POINT_MALL_DEFBONUS) > 0)
-	{
-		int dec_dam = MIN(200, dam * GetPoint(POINT_MALL_DEFBONUS) / 100);
-		dam -= dec_dam;
-	}
-
-	if (pAttacker)
-	{
-		//
-		// 전체 공격력 상승 (몰 아이템)
-		//
-		if (pAttacker->GetPoint(POINT_MALL_ATTBONUS) > 0)
-		{
-			int add_dam = MIN(300, dam * pAttacker->GetLimitPoint(POINT_MALL_ATTBONUS) / 100);
-			dam += add_dam;
-		}
-
-		//
-		// 제국으로 인한 보너스 (한국 올드 버전만 적용)
-		//
-		int iEmpire = GetEmpire();
-		long lMapIndex = GetMapIndex();
-		int iMapEmpire = SECTREE_MANAGER::instance().GetEmpireFromMapIndex(lMapIndex);
-
-		// Damage increased by 10% for pc empire
-		if (iEmpire && iMapEmpire && iEmpire != iMapEmpire)
-			dam += (dam * 10) / 100;
-
-		if (pAttacker->IsPC())
-		{
-			iEmpire = pAttacker->GetEmpire();
-			lMapIndex = pAttacker->GetMapIndex();
-			iMapEmpire = SECTREE_MANAGER::instance().GetEmpireFromMapIndex(lMapIndex);
-
-			// Damage reduced by 10% for other empires
-			/*
-			if (iEmpire && iMapEmpire && iEmpire != iMapEmpire)
-			{
-				int percent = 10;
-
-				if (184 <= lMapIndex && lMapIndex <= 189)
-					percent = 9;
-				else
-					percent = 9;
-
-				dam = dam * percent / 10;
-			}
-			*/
-
-			if (!IsPC() && GetMonsterDrainSPPoint())
-			{
-				int iDrain = GetMonsterDrainSPPoint();
-
-				if (iDrain <= pAttacker->GetSP())
-					pAttacker->PointChange(POINT_SP, -iDrain);
-				else
-				{
-					int iSP = pAttacker->GetSP();
-					pAttacker->PointChange(POINT_SP, -iSP);
-				}
-			}
-		}
-		else if (pAttacker->IsGuardNPC())
-		{
-			SET_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_NO_REWARD);
-			Stun();
-			return true;
-		}
-
-		//
-		// 군주의 금강권 & 사자후 
-		//
-		if (pAttacker->IsPC() && CMonarch::instance().IsPowerUp(pAttacker->GetEmpire()))
-		{
-			// 10% 피해 증가
-			dam += dam / 10;
-		}
-
-		if (IsPC() && CMonarch::instance().IsDefenceUp(GetEmpire()))
-		{
-			// 10% 피해 감소
-			dam -= dam / 10;
-		}
-
-#if defined(__SOUL_SYSTEM__) && defined(__SOUL_SYSTEM_CALC_FINAL_DAMAGE__)
-		switch (type)
-		{
-			case EDamageType::DAMAGE_TYPE_NORMAL:
-			case EDamageType::DAMAGE_TYPE_NORMAL_RANGE:
-			{
-				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_RED))
-				{
-					if (!pAttacker->IsPolymorphed() && !IsPC())
-					{
-						float fDamMultiplier = static_cast<float>(100 * pAttacker->GetSoulDamage(RED_SOUL)) / 1000;
-						if (fDamMultiplier != 0)
-							dam = (int)(dam * fDamMultiplier);
-					}
-				}
-			}
-			break;
-
-			case EDamageType::DAMAGE_TYPE_MELEE:
-			case EDamageType::DAMAGE_TYPE_RANGE:
-			case EDamageType::DAMAGE_TYPE_FIRE:
-			case EDamageType::DAMAGE_TYPE_ICE:
-			case EDamageType::DAMAGE_TYPE_ELEC:
-			case EDamageType::DAMAGE_TYPE_MAGIC:
-			{
-				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_BLUE))
-				{
-					if (!pAttacker->IsPolymorphed() && !IsPC())
-					{
-						float fDamMultiplier = static_cast<float>(100 * pAttacker->GetSoulDamage(BLUE_SOUL)) / 1000;
-						if (fDamMultiplier != 0)
-							dam = (int)(dam * fDamMultiplier);
-					}
-				}
-			}
-			break;
-		}
-#endif
-	}
-	//puAttr.Pop();
-
-	if (!GetSectree() || GetSectree()->IsAttr(GetX(), GetY(), ATTR_BANPK))
-		return false;
-
-	if (!IsPC())
-	{
-		if (m_pkParty && m_pkParty->GetLeader())
-			m_pkParty->GetLeader()->SetLastAttacked(get_dword_time());
-		else
-			SetLastAttacked(get_dword_time());
-
-		// 몬스터 대사 : 맞을 때
-		MonsterChat(MONSTER_CHAT_ATTACKED);
-	}
-
-	if (IsStun())
-	{
-		Dead(pAttacker);
-		return true;
-	}
-
-	if (IsDead())
-		return true;
-
-	// 독 공격으로 죽지 않도록 함.
-	if (type == DAMAGE_TYPE_POISON)
-	{
-		if (GetHP() - dam <= 0)
-		{
-			dam = GetHP() - 1;
-		}
-	}
-
-	else if (type == DAMAGE_TYPE_BLEEDING)
-	{
-		if (GetHP() - dam <= 0)
-		{
-			dam = GetHP();
-		}
-	}
-
-	// ------------------------
-	// 독일 프리미엄 모드 
-	// -----------------------
-	if (pAttacker && pAttacker->IsPC())
-	{
-		int iDmgPct = CHARACTER_MANAGER::instance().GetUserDamageRate(pAttacker);
-		dam = dam * iDmgPct / 100;
-	}
-
-	// STONE SKIN : 피해 반으로 감소
-	if (IsMonster() && IsStoneSkinner())
-	{
-		if (GetHPPct() < GetMobTable().bStoneSkinPoint)
-			dam /= 2;
-	}
-
-	//PROF_UNIT puRest1("Rest1");
-	if (pAttacker)
-	{
-		// DEATH BLOW : 확률 적으로 4배 피해 (!? 현재 이벤트나 공성전용 몬스터만 사용함)
-		if (pAttacker->IsMonster() && pAttacker->IsDeathBlower())
-		{
-			if (pAttacker->IsDeathBlow())
-			{
-				int rate = 2 * MINMAX(1, 51 - pAttacker->GetHPPct(), 50);
-				if (GetPoint(POINT_BLOCK) > 0 && number(1, 100) <= GetPoint(POINT_BLOCK))
-				{
-					rate -= MINMAX(1, GetPoint(POINT_BLOCK), 75);
-				}
-
-				IsDeathBlow = true;
-				dam *= (int)(1.5 + 1.5 * rate / 100.0);
-			}
-		}
-
-		// MOUNT_FALL
-		if (pAttacker->IsMonster() && pAttacker->IsFaller())
-		{
-			unsigned int iUnMountChance = 30 - GetPoint(POINT_RESIST_MOUNT_FALL);
-			if (number(1, 100) <= iUnMountChance)
-			{
-				if (!FindAffect(AFFECT_MOUNT_FALL))
-					AddAffect(AFFECT_MOUNT_FALL, POINT_NONE, 0, AFF_NONE, 5, 0, true);
-			}
-		}
-		// END_OF_MOUNT_FALL
-
-		dam = BlueDragon_Damage(this, pAttacker, dam);
-	}
-
-	BYTE damageFlag = 0;
-
-	if (type == DAMAGE_TYPE_POISON)
-		damageFlag = DAMAGE_POISON;
-	else if (type == DAMAGE_TYPE_BLEEDING)
-		damageFlag = DAMAGE_BLEEDING;
-	else
-		damageFlag = DAMAGE_NORMAL;
-
-	if (IsCritical == true)
-		damageFlag |= DAMAGE_CRITICAL;
-
-	if (IsPenetrate == true)
-		damageFlag |= DAMAGE_PENETRATE;
-
-	// 최종 데미지 보정
-	float damMul = this->GetDamMul();
-	float tempDam = dam;
-	dam = tempDam * damMul + 0.5f;
-
-	//if (pAttacker)
-	SendDamagePacket(pAttacker, dam, damageFlag);
-
-	if (test_server && g_bTestMobLog)
-	{
-		int iPercent = 0;
-		if (GetMaxHP() >= 0)
-			iPercent = (GetHP() * 100) / GetMaxHP();
-
-		if (pAttacker)
-		{
-			pAttacker->ChatPacket(CHAT_TYPE_INFO, "-> %s, DAM %d HP %d(%d%%) %s%s",
-				GetName(),
-				dam,
-				GetHP(),
-				iPercent,
-				IsCritical ? "crit " : "",
-				IsPenetrate ? "pene " : "",
-				IsDeathBlow ? "deathblow " : "");
-		}
-
-		ChatPacket(CHAT_TYPE_PARTY, "<- %s, DAM %d HP %d(%d%%) %s%s",
-			pAttacker ? pAttacker->GetName() : 0,
-			dam,
-			GetHP(),
-			iPercent,
-			IsCritical ? "crit " : "",
-			IsPenetrate ? "pene " : "",
-			IsDeathBlow ? "deathblow " : "");
-	}
-
-	if (pAttacker)
-	{
-		if (m_bDetailLog)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s[%d]가 공격 위치: %d %d", pAttacker->GetName(), (DWORD)pAttacker->GetVID(), pAttacker->GetX(), pAttacker->GetY()));
-		}
-	}
-
-	//
-	// !!!!!!!!! 실제 HP를 줄이는 부분 !!!!!!!!!
-	//
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	if (type != DAMAGE_TYPE_POISON)
-	{
-		if (IsPC())
-			pAttacker->UpdateExtBattlePassMissionProgress(DAMAGE_PLAYER, dam, GetLevel());
-		else
-			pAttacker->UpdateExtBattlePassMissionProgress(DAMAGE_MONSTER, dam, GetRaceNum());
-	}
-#endif
-
-	if (!cannot_dead)
-	{
-		dam = (GetHP() - dam <= 0) ? GetHP() : dam;
-
-#if defined(__QUEST_EVENT_DAMAGE__)
-		if (pAttacker && pAttacker->IsPC())
-		{
-			pAttacker->SetQuestNPCID(GetVID());
-			quest::CQuestManager::instance().Damage(pAttacker->GetPlayerID(), GetRaceNum());
-		}
-#endif
-
-		PointChange(POINT_HP, -dam, false);
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-		if (pAttacker && CGuildDragonLairManager::Instance().IsRedDragonLair(pAttacker->GetMapIndex()))
-		{
-			if (GetHP() == 0 && CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
-			{
-				PointChange(POINT_HP, 1, false);
-			}
-		}
-#endif
-	}
-
-	//puRest1.Pop();
-
-	//PROF_UNIT puRest2("Rest2");
-	if (pAttacker && dam > 0 && IsNPC())
-	{
-		//PROF_UNIT puRest20("Rest20");
-		TDamageMap::iterator it = m_map_kDamage.find(pAttacker->GetVID());
-
-		if (it == m_map_kDamage.end())
-		{
-			m_map_kDamage.insert(TDamageMap::value_type(pAttacker->GetVID(), TBattleInfo(dam, 0)));
-			it = m_map_kDamage.find(pAttacker->GetVID());
-		}
-		else
-		{
-			it->second.iTotalDamage += dam;
-		}
-		//puRest20.Pop();
-
-		//PROF_UNIT puRest21("Rest21");
-		StartRecoveryEvent(); // 몬스터는 데미지를 입으면 회복을 시작한다.
-		//puRest21.Pop();
-
-		//PROF_UNIT puRest22("Rest22");
-		UpdateAggrPointEx(pAttacker, type, dam, it->second);
-		//puRest22.Pop();
-
-		pAttacker->SetAccumulatedDamage(dam);
-	}
-	//puRest2.Pop();
-
-	//PROF_UNIT puRest3("Rest3");
-	if (GetHP() <= 0)
-	{
-		if (IsMonster())
-			Dead(pAttacker);
-		else
-			Stun(true);
-
-		if (pAttacker && !pAttacker->IsNPC())
-			m_dwKillerPID = pAttacker->GetPlayerID();
-		else
-			m_dwKillerPID = 0;
-	}
-
-	return false;
-}
-
-void CHARACTER::DistributeHP(LPCHARACTER pkKiller)
-{
-	if (pkKiller->GetDungeon()) // 던젼내에선 만두가나오지않는다
-		return;
-}
-
-#if defined(__CONQUEROR_LEVEL__)
-static void GiveExp(LPCHARACTER from, LPCHARACTER to, int iExp, int iConquerorExp)
-#else
-static void GiveExp(LPCHARACTER from, LPCHARACTER to, int iExp)
-#endif
-{
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	to->UpdateExtBattlePassMissionProgress(EXP_COLLECT, iExp, from->GetRaceNum());
-#endif
-	{
-		LPITEM pkItem;
-
-		pkItem = to->GetWear(WEAR_UNIQUE1);
-
-		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_ANTI_EXP)
-		{
-			if (test_server)
-				to->ChatPacket(CHAT_TYPE_INFO, "exp blocked by ring %d", UNIQUE_ITEM_ANTI_EXP);
-			return;
-		}
-
-		pkItem = to->GetWear(WEAR_UNIQUE2);
-		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_ANTI_EXP)
-		{
-			if (test_server)
-				to->ChatPacket(CHAT_TYPE_INFO, "exp blocked by ring %d", UNIQUE_ITEM_ANTI_EXP);
-			return;
-		}
-	}
-
-	// 레벨차 경험치 가감비율
-	iExp = CALCULATE_VALUE_LVDELTA(to->GetLevel(), from->GetLevel(), iExp);
-	const int iBaseExp = iExp;
-
-#if defined(__CONQUEROR_LEVEL__)
-	iConquerorExp = CALCULATE_VALUE_LVDELTA(to->GetLevel(), from->GetLevel(), iConquerorExp);
-	const int iBaseConquerorExp = iConquerorExp;
-#endif
-
-	int iRate = 100;
-
-	// 점술, 회사 경험치 이벤트 적용
-	iRate += CPrivManager::instance().GetPriv(to, PRIV_EXP_PCT);
-
-	// 게임내 기본 제공되는 경험치 보너스
-	{
-		// 노동절 메달
-		if (to->IsEquipUniqueItem(UNIQUE_ITEM_LARBOR_MEDAL))
-			iRate += 20;
-
-		// Devil tower experience bonus
-		if (to->GetMapIndex() >= 660000 && to->GetMapIndex() < 670000)
-			iRate += 20; // 1.2배 (20%)
-
-		// 아이템 경험치 두배 속성
-		if (to->GetPoint(POINT_EXP_DOUBLE_BONUS))
-			if (number(1, 100) <= to->GetPoint(POINT_EXP_DOUBLE_BONUS))
-				iRate += 30; // 1.3배 (30%)
-
-		// 경험의 반지 (2시간짜리)
-		// NOTE: Experience rings now work like special rings.
-		/*
-		if (to->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_EXP))
-		{
-			iRate += 50; // (50%)
-			if (test_server)
-				to->ChatPacket(CHAT_TYPE_INFO, "exp bonus + 50% (using ring)");
-		}
-		*/
-
-		// 아이템 몰 판매 경험치 보너스
-		if (to->GetPremiumRemainSeconds(PREMIUM_EXP) > 0) // 아이템 몰: 경험치 결제
-			iRate += 50;
-
-		iRate += to->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_EXP_BONUS); // 결혼 보너스
-		iRate += to->GetPoint(POINT_RAMADAN_CANDY_BONUS_EXP);
-		iRate += to->GetPoint(POINT_MALL_EXPBONUS);
-	}
-
-	if (test_server)
-	{
-		sys_log(0, "Bonus Exp : Ramadan Candy: %d MallExp: %d PointExp: %d",
-			to->GetPoint(POINT_RAMADAN_CANDY_BONUS_EXP),
-			to->GetPoint(POINT_MALL_EXPBONUS),
-			to->GetPoint(POINT_EXP)
-		);
-	}
-
-	// 기획측 조정값 2005.04.21 현재 85%
-	iRate *= CHARACTER_MANAGER::instance().GetMobExpRate(to) / 100;
-
-	iExp *= (iRate / 100.0);
-#if defined(__CONQUEROR_LEVEL__)
-	iConquerorExp *= (iRate / 100.0);
-#endif
-
-	// 경험치 한번 획득량 제한
-	//iExp = MIN(to->GetNextExp() / 10, iExp);
-
-	//iExp = AdjustExpByLevel(to, iExp);
-
-	if (iBaseExp)
-	{
-		to->PointChange(POINT_EXP, iExp, true);
-		from->CreateFly(FLY_EXP, to);
-	}
-
-#if defined(__CONQUEROR_LEVEL__)
-	if (iBaseConquerorExp && to->GetConquerorLevel() > 0)
-	{
-		to->PointChange(POINT_CONQUEROR_EXP, iConquerorExp, true);
-		from->CreateFly(FLY_CONQUEROR_EXP, to);
-	}
-#endif
-
-	{
-		LPCHARACTER you = to->GetMarryPartner();
-		// 부부가 서로 파티중이면 금슬이 오른다
-		if (you)
-		{
-			// 1억이 100%
-			DWORD dwUpdatePoint = 2000 * iExp / to->GetLevel() / to->GetLevel() / 3;
-
-			if (to->GetPremiumRemainSeconds(PREMIUM_MARRIAGE_FAST) > 0 ||
-				you->GetPremiumRemainSeconds(PREMIUM_MARRIAGE_FAST) > 0)
-				dwUpdatePoint *= 3;
-
-			marriage::TMarriage* pMarriage = marriage::CManager::Instance().Get(to->GetPlayerID());
-
-			// DIVORCE_NULL_BUG_FIX
-			if (pMarriage && pMarriage->IsNear())
-				pMarriage->Update(dwUpdatePoint);
-			// END_OF_DIVORCE_NULL_BUG_FIX
-		}
-	}
-#ifdef __GROWTH_PET_SYSTEM__
-	if (to->GetActiveGrowthPet())
-	{
-		to->GetActiveGrowthPet()->RewardEXP(EXP_TYPE_MOB, iBaseExp);
-		from->CreateFly(FLY_EXP, to->GetActiveGrowthPet()->GetGrowthPet());
-	}
-#endif
-}
-
-namespace NPartyExpDistribute
-{
-	struct FPartyTotaler
-	{
-		int total;
-		int member_count;
-		int x, y;
-
-		FPartyTotaler(LPCHARACTER center)
-			: total(0), member_count(0), x(center->GetX()), y(center->GetY())
-		{};
-
-		void operator () (LPCHARACTER ch)
-		{
-			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-			{
-				total += party_exp_distribute_table[ch->GetLevel()];
-				++member_count;
-			}
-		}
-	};
-
-	struct FPartyDistributor
-	{
-		int total;
-		LPCHARACTER c;
-		int x, y;
-		DWORD _iExp;
-#if defined(__CONQUEROR_LEVEL__)
-		DWORD _iConquerorExp;
-#endif
-		int m_iMode;
-		int m_iMemberCount;
-
-#if defined(__CONQUEROR_LEVEL__)
-		FPartyDistributor(LPCHARACTER center, int member_count, int total, DWORD iExp, DWORD iConquerorExp, int iMode)
-			: total(total), c(center), x(center->GetX()), y(center->GetY()), _iExp(iExp), _iConquerorExp(iConquerorExp), m_iMode(iMode), m_iMemberCount(member_count)
-#else
-		FPartyDistributor(LPCHARACTER center, int member_count, int total, DWORD iExp, int iMode)
-			: total(total), c(center), x(center->GetX()), y(center->GetY()), _iExp(iExp), m_iMode(iMode), m_iMemberCount(member_count)
-#endif
-		{
-			if (m_iMemberCount == 0)
-				m_iMemberCount = 1;
-		};
-
-		void operator () (LPCHARACTER ch)
-		{
-			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-			{
-				DWORD iExp = 0;
-#if defined(__CONQUEROR_LEVEL__)
-				DWORD iConquerorExp = 0;
-#endif
-
-				switch (m_iMode)
-				{
-					case PARTY_EXP_DISTRIBUTION_NON_PARITY:
-						iExp = (DWORD)(_iExp * (float)party_exp_distribute_table[ch->GetLevel()] / total);
-#if defined(__CONQUEROR_LEVEL__)
-						iConquerorExp = (DWORD)(_iConquerorExp * (float)party_exp_distribute_table[ch->GetLevel()] / total);
-#endif
-						break;
-
-					case PARTY_EXP_DISTRIBUTION_PARITY:
-						iExp = _iExp / m_iMemberCount;
-#if defined(__CONQUEROR_LEVEL__)
-						iConquerorExp = _iConquerorExp / m_iMemberCount;
-#endif
-						break;
-
-					default:
-						sys_err("Unknown party exp distribution mode %d", m_iMode);
-						return;
-				}
-
-#if defined(__CONQUEROR_LEVEL__)
-				GiveExp(c, ch, iExp, iConquerorExp);
-#else
-				GiveExp(c, ch, iExp);
-#endif
-			}
-		}
-	};
-}
-
-typedef struct SDamageInfo
-{
-	int iDam;
-	LPCHARACTER pAttacker;
-	LPPARTY pParty;
-
-	void Clear()
-	{
-		pAttacker = NULL;
-		pParty = NULL;
-	}
-
-#if defined(__CONQUEROR_LEVEL__)
-	inline void Distribute(LPCHARACTER ch, int iExp, int iConquerorExp)
-#else
-	inline void Distribute(LPCHARACTER ch, int iExp)
-#endif
-	{
-		if (pAttacker)
-		{
-#if defined(__CONQUEROR_LEVEL__)
-			GiveExp(ch, pAttacker, iExp, iConquerorExp);
-#else
-			GiveExp(ch, pAttacker, iExp);
-#endif
-		}
-		else if (pParty)
-		{
-			NPartyExpDistribute::FPartyTotaler f(ch);
-			pParty->ForEachOnMapMember(f, ch->GetMapIndex());
-
-			if (pParty->IsPositionNearLeader(ch))
-				iExp = iExp * (100 + pParty->GetExpBonusPercent()) / 100;
-
-			if (test_server)
-			{
-				if (quest::CQuestManager::instance().GetEventFlag("exp_bonus_log") && pParty->GetExpBonusPercent())
-					pParty->ChatPacketToAllMember(CHAT_TYPE_INFO, "exp party bonus %d%%", pParty->GetExpBonusPercent());
-			}
-
-			// 경험치 몰아주기 (파티가 획득한 경험치를 5% 빼서 먼저 줌)
-			if (pParty->GetExpCentralizeCharacter())
-			{
-				LPCHARACTER tch = pParty->GetExpCentralizeCharacter();
-
-				if (DISTANCE_APPROX(ch->GetX() - tch->GetX(), ch->GetY() - tch->GetY()) <= PARTY_DEFAULT_RANGE)
-				{
-					int iExpCenteralize = (int)(iExp * 0.05f);
-					iExp -= iExpCenteralize;
-
-#if defined(__CONQUEROR_LEVEL__)
-					int iConquerorExpCenteralize = (int)(iExp * 0.05f);
-					iConquerorExp -= iConquerorExpCenteralize;
-
-					GiveExp(ch, pParty->GetExpCentralizeCharacter(), iExpCenteralize, iConquerorExpCenteralize);
-#else
-					GiveExp(ch, pParty->GetExpCentralizeCharacter(), iExpCenteralize);
-#endif
-				}
-			}
-
-#if defined(__CONQUEROR_LEVEL__)
-			NPartyExpDistribute::FPartyDistributor fDist(ch, f.member_count, f.total, iExp, iConquerorExp, pParty->GetExpDistributionMode());
-#else
-			NPartyExpDistribute::FPartyDistributor fDist(ch, f.member_count, f.total, iExp, pParty->GetExpDistributionMode());
-#endif
-			pParty->ForEachOnMapMember(fDist, ch->GetMapIndex());
-		}
-	}
-} TDamageInfo;
-
-LPCHARACTER CHARACTER::DistributeExp()
-{
-#if defined(__CONQUEROR_LEVEL__)
-	int iExpToDistribute = GetExp();
-	if (iExpToDistribute <= 0)
-		iExpToDistribute = 0;
-
-	int iConquerorExpToDistribute = GetConquerorExp();
-	if (iConquerorExpToDistribute <= 0)
-		iConquerorExpToDistribute = 0;
-#else
-	int iExpToDistribute = GetExp();
-	if (iExpToDistribute <= 0)
-		return NULL;
-#endif
-
-	int iTotalDam = 0;
-	LPCHARACTER pkChrMostAttacked = NULL;
-	int iMostDam = 0;
-
-	typedef std::vector<TDamageInfo> TDamageInfoTable;
-	TDamageInfoTable damage_info_table;
-	std::map<LPPARTY, TDamageInfo> map_party_damage;
-
-	damage_info_table.reserve(m_map_kDamage.size());
-
-	TDamageMap::iterator it = m_map_kDamage.begin();
-
-	// 일단 주위에 없는 사람을 걸러 낸다. (50m)
-	while (it != m_map_kDamage.end())
-	{
-		const VID& c_VID = it->first;
-		int iDam = it->second.iTotalDamage;
-
-		++it;
-
-		LPCHARACTER pAttacker = CHARACTER_MANAGER::instance().Find(c_VID);
-
-		// NPC가 때리기도 하나? -.-;
-		if (!pAttacker || pAttacker->IsNPC() || DISTANCE_APPROX(GetX() - pAttacker->GetX(), GetY() - pAttacker->GetY()) > 5000)
-			continue;
-
-		iTotalDam += iDam;
-		if (!pkChrMostAttacked || iDam > iMostDam)
-		{
-			pkChrMostAttacked = pAttacker;
-			iMostDam = iDam;
-		}
-
-		if (pAttacker->GetParty())
-		{
-			std::map<LPPARTY, TDamageInfo>::iterator it = map_party_damage.find(pAttacker->GetParty());
-			if (it == map_party_damage.end())
-			{
-				TDamageInfo di;
-				di.iDam = iDam;
-				di.pAttacker = NULL;
-				di.pParty = pAttacker->GetParty();
-				map_party_damage.insert(std::make_pair(di.pParty, di));
-			}
-			else
-			{
-				it->second.iDam += iDam;
-			}
-		}
-		else
-		{
-			TDamageInfo di;
-
-			di.iDam = iDam;
-			di.pAttacker = pAttacker;
-			di.pParty = NULL;
-
-			//sys_log(0, "__ pq_damage %s %d", pAttacker->GetName(), iDam);
-			//pq_damage.push(di);
-			damage_info_table.push_back(di);
-		}
-	}
-
-	for (std::map<LPPARTY, TDamageInfo>::iterator it = map_party_damage.begin(); it != map_party_damage.end(); ++it)
-	{
-		damage_info_table.push_back(it->second);
-		//sys_log(0, "__ pq_damage_party [%u] %d", it->second.pParty->GetLeaderPID(), it->second.iDam);
-	}
-
-	SetExp(0);
-#if defined(__CONQUEROR_LEVEL__)
-	SetConquerorExp(0);
-#endif
-	//m_map_kDamage.clear();
-
-	if (iTotalDam == 0) // 데미지 준게 0이면 리턴
-		return NULL;
-
-	if (m_pkChrStone)	// 돌이 있을 경우 경험치의 반을 돌에게 넘긴다.
-	{
-		//sys_log(0, "__ Give half to Stone : %d", iExpToDistribute>>1);
-		int iExp = iExpToDistribute >> 1;
-		m_pkChrStone->SetExp(m_pkChrStone->GetExp() + iExp);
-		iExpToDistribute -= iExp;
-	}
-
-	sys_log(1, "%s total exp: %d, damage_info_table.size() == %d, TotalDam %d",
-		GetName(), iExpToDistribute, damage_info_table.size(), iTotalDam);
-	//sys_log(1, "%s total exp: %d, pq_damage.size() == %d, TotalDam %d",
-	//GetName(), iExpToDistribute, pq_damage.size(), iTotalDam);
-
-	if (damage_info_table.empty())
-		return NULL;
-
-	// 제일 데미지를 많이 준 사람이 HP 회복을 한다.
-	DistributeHP(pkChrMostAttacked); // 만두 시스템
-
-	{
-		// 제일 데미지를 많이 준 사람이나 파티가 총 경험치의 20% + 자기가 때린만큼의 경험치를 먹는다.
-		TDamageInfoTable::iterator di = damage_info_table.begin();
-		{
-			TDamageInfoTable::iterator it;
-
-			for (it = damage_info_table.begin(); it != damage_info_table.end(); ++it)
-			{
-				if (it->iDam > di->iDam)
-					di = it;
-			}
-		}
-
-		int iExp = iExpToDistribute / 5;
-		iExpToDistribute -= iExp;
-
-#if defined(__CONQUEROR_LEVEL__)
-		int	iConquerorExp = iConquerorExpToDistribute / 5;
-		iConquerorExpToDistribute -= iConquerorExp;
-#endif
-
-		float fPercent = (float)di->iDam / iTotalDam;
-
-		if (fPercent > 1.0f)
-		{
-			sys_err("DistributeExp percent over 1.0 (fPercent %f name %s)", fPercent, di->pAttacker->GetName());
-			fPercent = 1.0f;
-		}
-
-		iExp += (int)(iExpToDistribute * fPercent);
-#if defined(__CONQUEROR_LEVEL__)
-		iConquerorExp += (int)(iConquerorExpToDistribute * fPercent);
-#endif
-
-		//sys_log(0, "%s given exp percent %.1f + 20 dam %d", GetName(), fPercent * 100.0f, di.iDam);
-
-#if defined(__CONQUEROR_LEVEL__)
-		di->Distribute(this, iExp, iConquerorExp);
-#else
-		di->Distribute(this, iExp);
-#endif
-
-		// 100% 다 먹었으면 리턴한다.
-		if (fPercent == 1.0f)
-			return pkChrMostAttacked;
-
-		di->Clear();
-	}
-
-	{
-		// 남은 80%의 경험치를 분배한다.
-		TDamageInfoTable::iterator it;
-
-		for (it = damage_info_table.begin(); it != damage_info_table.end(); ++it)
-		{
-			TDamageInfo& di = *it;
-
-			float fPercent = (float)di.iDam / iTotalDam;
-
-			if (fPercent > 1.0f)
-			{
-				sys_err("DistributeExp percent over 1.0 (fPercent %f name %s)", fPercent, di.pAttacker->GetName());
-				fPercent = 1.0f;
-			}
-
-			//sys_log(0, "%s given exp percent %.1f dam %d", GetName(), fPercent * 100.0f, di.iDam);
-#if defined(__CONQUEROR_LEVEL__)
-			di.Distribute(this, (int)(iExpToDistribute * fPercent), (int)(iConquerorExpToDistribute * fPercent));
-#else
-			di.Distribute(this, (int)(iExpToDistribute * fPercent));
-#endif
-		}
-	}
-
-	return pkChrMostAttacked;
-}
-
-// 화살 개수를 리턴해 줌
-int CHARACTER::GetArrowAndBow(LPITEM* ppkBow, LPITEM* ppkArrow, int iArrowCount/* = 1 */)
-{
-	LPITEM pkBow;
-	if (!(pkBow = GetWear(WEAR_WEAPON)) || pkBow->GetSubType() != WEAPON_BOW)
-		return 0;
-
-	LPITEM pkArrow;
-#if defined(__QUIVER_SYSTEM__)
-	if (!(pkArrow = GetWear(WEAR_ARROW)) || pkArrow->GetType() != ITEM_WEAPON || (pkArrow->GetSubType() != WEAPON_ARROW && pkArrow->GetSubType() != WEAPON_QUIVER))
-#else
-	if (!(pkArrow = GetWear(WEAR_ARROW)) || pkArrow->GetType() != ITEM_WEAPON || pkArrow->GetSubType() != WEAPON_ARROW)
-#endif
-	{
-		return 0;
-	}
-
-#if defined(__QUIVER_SYSTEM__)
-	if (pkArrow->GetSubType() == WEAPON_QUIVER)
-		iArrowCount = MIN(iArrowCount, pkArrow->GetSocket(0) - time(0));
-	else
-		iArrowCount = MIN(iArrowCount, pkArrow->GetCount());
-#else
-	iArrowCount = MIN(iArrowCount, pkArrow->GetCount());
-#endif
-
-	* ppkBow = pkBow;
-	*ppkArrow = pkArrow;
-
-	return iArrowCount;
-}
-
-void CHARACTER::UseArrow(LPITEM pkArrow, DWORD dwArrowCount)
-{
-#if defined(__QUIVER_SYSTEM__)
-	if (pkArrow->GetSubType() == WEAPON_QUIVER)
-		return;
-#endif
-
-	int iCount = pkArrow->GetCount();
-	DWORD dwVnum = pkArrow->GetVnum();
-	iCount = iCount - MIN(iCount, dwArrowCount);
-	pkArrow->SetCount(iCount);
-
-	if (iCount == 0)
-	{
-		LPITEM pkNewArrow = FindSpecifyItem(dwVnum);
-
-		sys_log(0, "UseArrow : FindSpecifyItem %u %p", dwVnum, get_pointer(pkNewArrow));
-
-		if (pkNewArrow)
-			EquipItem(pkNewArrow);
-	}
-}
-
-class CFuncShoot
-{
-public:
-	LPCHARACTER m_me;
-	BYTE m_bType;
-	bool m_bSucceed;
-
-	CFuncShoot(LPCHARACTER ch, BYTE bType) : m_me(ch), m_bType(bType), m_bSucceed(FALSE)
-	{
-	}
-
-	void operator () (DWORD dwTargetVID)
-	{
-		if (m_bType > 1)
-		{
-			if (g_bSkillDisable)
-				return;
-
-			m_me->m_SkillUseInfo[m_bType].SetMainTargetVID(dwTargetVID);
-			/*
-			if (m_bType == SKILL_BIPABU || m_bType == SKILL_KWANKYEOK)
-				m_me->m_SkillUseInfo[m_bType].ResetHitCount();
-			*/
-		}
-
-		LPCHARACTER pkVictim = CHARACTER_MANAGER::instance().Find(dwTargetVID);
-
-		if (!pkVictim)
-			return;
-
-		// 공격 불가
-		if (!battle_is_attackable(m_me, pkVictim))
-			return;
-
-		if (m_me->IsNPC())
-		{
-			if (DISTANCE_APPROX(m_me->GetX() - pkVictim->GetX(), m_me->GetY() - pkVictim->GetY()) > 5000)
-				return;
-		}
-
-		LPITEM pkBow, pkArrow;
-
-		switch (m_bType)
-		{
-			case 0: // 일반활
-			{
-				int iDam = 0;
-
-				if (m_me->IsPC())
-				{
-					if (m_me->GetJob() != JOB_ASSASSIN)
-						return;
-
-					if (0 == m_me->GetArrowAndBow(&pkBow, &pkArrow))
-						return;
-
-					if (m_me->GetSkillGroup() != 0)
-						if (!m_me->IsNPC() && m_me->GetSkillGroup() != 2)
-						{
-							if (m_me->GetSP() < 5)
-								return;
-
-							m_me->PointChange(POINT_SP, -5);
-						}
-
-					iDam = CalcArrowDamage(m_me, pkVictim, pkBow, pkArrow);
-					m_me->UseArrow(pkArrow, 1);
-
-					// Check speed hack
-					DWORD dwCurrentTime = get_dword_time();
-					if (IS_SPEED_HACK(m_me, pkVictim, dwCurrentTime))
-					{
-						iDam = 0;
-						return;
-					}
-				}
-				else
-					iDam = CalcMeleeDamage(m_me, pkVictim);
-
-				NormalAttackAffect(m_me, pkVictim);
-
-				// 데미지 계산
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BOW)) / 100;
-
-				//sys_log(0, "%s arrow %s dam %d", m_me->GetName(), pkVictim->GetName(), iDam);
-
-				m_me->OnMove(true);
-				pkVictim->OnMove();
-
-				if (pkVictim->CanBeginFight())
-					pkVictim->BeginFight(m_me);
-
-				pkVictim->Damage(m_me, iDam, EDamageType::DAMAGE_TYPE_NORMAL_RANGE);
-				// 타격치 계산부 끝
-			}
-			break;
-
-			case 1: // 일반 마법
-			{
-				int iDam;
-
-				if (m_me->IsPC())
-					return;
-
-				iDam = CalcMagicDamage(m_me, pkVictim);
-
-				NormalAttackAffect(m_me, pkVictim);
-
-				// 데미지 계산
-#if defined(__MAGIC_REDUCTION__)
-				const int c_iResMagic = MINMAX(0, pkVictim->GetPoint(POINT_RESIST_MAGIC), 100);
-				const int c_iResMagicReduction = MINMAX(0, (m_me->GetJob() == JOB_SURA) ? m_me->GetPoint(POINT_RESIST_MAGIC_REDUCTION) / 2 : m_me->GetPoint(POINT_RESIST_MAGIC_REDUCTION), 50);
-				const int c_iTotalMagicRes = MINMAX(0, c_iResMagic - c_iResMagicReduction, 100);
-				iDam = iDam * (100 - c_iTotalMagicRes) / 100;
-#else
-				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_MAGIC)) / 100;
-#endif
-
-				//sys_log(0, "%s arrow %s dam %d", m_me->GetName(), pkVictim->GetName(), iDam);
-
-				m_me->OnMove(true);
-				pkVictim->OnMove();
-
-				if (pkVictim->CanBeginFight())
-					pkVictim->BeginFight(m_me);
-
-				pkVictim->Damage(m_me, iDam, DAMAGE_TYPE_MAGIC);
-				// 타격치 계산부 끝
-			}
-			break;
-
-			case SKILL_YEONSA: // 연사
-			{
-				//int iUseArrow = 2 + (m_me->GetSkillPower(SKILL_YEONSA) *6/100);
-				int iUseArrow = 1;
-
-				// 토탈만 계산하는경우
-				{
-					if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
-					{
-						m_me->OnMove(true);
-						pkVictim->OnMove();
-
-						if (pkVictim->CanBeginFight())
-							pkVictim->BeginFight(m_me);
-
-						m_me->ComputeSkill(m_bType, pkVictim);
-						m_me->UseArrow(pkArrow, iUseArrow);
-
-						if (pkVictim->IsDead())
-							break;
-					}
-					else
-						break;
-				}
-			}
-			break;
-
-			case SKILL_KWANKYEOK:
-			{
-				int iUseArrow = 1;
-
-				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
-				{
-					m_me->OnMove(true);
-					pkVictim->OnMove();
-
-					if (pkVictim->CanBeginFight())
-						pkVictim->BeginFight(m_me);
-
-					sys_log(0, "%s kwankeyok %s", m_me->GetName(), pkVictim->GetName());
-					m_me->ComputeSkill(m_bType, pkVictim);
-					m_me->UseArrow(pkArrow, iUseArrow);
-				}
-			}
-			break;
-
-			case SKILL_GIGUNG:
-#if defined(__9TH_SKILL__)
-			case SKILL_PUNGLOEPO:
-#endif
-			{
-				int iUseArrow = 1;
-				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
-				{
-					m_me->OnMove(true);
-					pkVictim->OnMove();
-
-					if (pkVictim->CanBeginFight())
-						pkVictim->BeginFight(m_me);
-
-#if defined(__9TH_SKILL__)
-					if (m_bType == SKILL_PUNGLOEPO)
-						sys_log(0, "%s pungloepo %s", m_me->GetName(), pkVictim->GetName());
-					else
-						sys_log(0, "%s gigung %s", m_me->GetName(), pkVictim->GetName());
-#else
-					sys_log(0, "%s gigung %s", m_me->GetName(), pkVictim->GetName());
-#endif
-
-					m_me->ComputeSkill(m_bType, pkVictim);
-					m_me->UseArrow(pkArrow, iUseArrow);
-				}
-			}
-			break;
-
-			case SKILL_HWAJO:
-			{
-				int iUseArrow = 1;
-				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
-				{
-					m_me->OnMove(true);
-					pkVictim->OnMove();
-
-					if (pkVictim->CanBeginFight())
-						pkVictim->BeginFight(m_me);
-
-					sys_log(0, "%s hwajo %s", m_me->GetName(), pkVictim->GetName());
-					m_me->ComputeSkill(m_bType, pkVictim);
-					m_me->UseArrow(pkArrow, iUseArrow);
-				}
-			}
-			break;
-
-			case SKILL_HORSE_WILDATTACK_RANGE:
-			{
-				int iUseArrow = 1;
-				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
-				{
-					m_me->OnMove(true);
-					pkVictim->OnMove();
-
-					if (pkVictim->CanBeginFight())
-						pkVictim->BeginFight(m_me);
-
-					sys_log(0, "%s horse_wildattack %s", m_me->GetName(), pkVictim->GetName());
-					m_me->ComputeSkill(m_bType, pkVictim);
-					m_me->UseArrow(pkArrow, iUseArrow);
-				}
-			}
-			break;
-
-			case SKILL_MARYUNG:
-			case SKILL_TUSOK:
-			case SKILL_BIPABU:
-#if defined(__9TH_SKILL__)
-			case SKILL_ILGWANGPYO:
-			case SKILL_MABEOBAGGWI:
-#endif
-			case SKILL_NOEJEON:
-			case SKILL_GEOMPUNG:
-			case SKILL_SANGONG:
-			case SKILL_MAHWAN:
-			case SKILL_PABEOB:
-			{
-				m_me->OnMove(true);
-				pkVictim->OnMove();
-
-				if (pkVictim->CanBeginFight())
-					pkVictim->BeginFight(m_me);
-
-				sys_log(0, "%s - Skill %d -> %s", m_me->GetName(), m_bType, pkVictim->GetName());
-				m_me->ComputeSkill(m_bType, pkVictim);
-			}
-			break;
-
-			case SKILL_CHAIN:
-			{
-				m_me->OnMove(true);
-				pkVictim->OnMove();
-
-				if (pkVictim->CanBeginFight())
-					pkVictim->BeginFight(m_me);
-
-				sys_log(0, "%s - Skill %d -> %s", m_me->GetName(), m_bType, pkVictim->GetName());
-				m_me->ComputeSkill(m_bType, pkVictim);
-
-				// TODO 여러명에게 슉 슉 슉 하기
-			}
-			break;
-
-			/*
-			case SKILL_BUDONG:
-			{
-				m_me->OnMove(true);
-				pkVictim->OnMove();
-
-				DWORD * pdw;
-				DWORD dwEI = AllocEventInfo(sizeof(DWORD) * 2, &pdw);
-				pdw[0] = m_me->GetVID();
-				pdw[1] = pkVictim->GetVID();
-
-				event_create(budong_event_func, dwEI, PASSES_PER_SEC(1));
-			}
-			break;
-			*/
-
-			default:
-				sys_err("CFuncShoot: I don't know this type [%d] of range attack.", (int)m_bType);
-				break;
-		}
-
-		m_bSucceed = TRUE;
-	}
-};
-
-bool CHARACTER::Shoot(BYTE bType)
-{
-	sys_log(1, "Shoot %s type %u flyTargets.size %zu", GetName(), bType, m_vec_dwFlyTargets.size());
-
-	if (!CanMove())
-		return false;
-
-	if (IsPC() && IsPolymorphed())
-		return false;
-
-	CFuncShoot f(this, bType);
-
-	if (m_dwFlyTargetID != 0)
-	{
-		f(m_dwFlyTargetID);
-		m_dwFlyTargetID = 0;
-	}
-
-	f = std::for_each(m_vec_dwFlyTargets.begin(), m_vec_dwFlyTargets.end(), f);
-	m_vec_dwFlyTargets.clear();
-
-	return f.m_bSucceed;
-}
-
-void CHARACTER::FlyTarget(DWORD dwTargetVID, long x, long y, BYTE bHeader)
-{
-	LPCHARACTER pkVictim = CHARACTER_MANAGER::instance().Find(dwTargetVID);
-	TPacketGCFlyTargeting pack;
-
-	//pack.bHeader = HEADER_GC_FLY_TARGETING;
-	pack.bHeader = (bHeader == HEADER_CG_FLY_TARGETING) ? HEADER_GC_FLY_TARGETING : HEADER_GC_ADD_FLY_TARGETING;
-	pack.dwShooterVID = GetVID();
-
-	if (pkVictim)
-	{
-		pack.dwTargetVID = pkVictim->GetVID();
-		pack.x = pkVictim->GetX();
-		pack.y = pkVictim->GetY();
-
-		if (bHeader == HEADER_CG_FLY_TARGETING)
-			m_dwFlyTargetID = dwTargetVID;
-		else
-			m_vec_dwFlyTargets.push_back(dwTargetVID);
-	}
-	else
-	{
-		pack.dwTargetVID = 0;
-		pack.x = x;
-		pack.y = y;
-	}
-
-	sys_log(1, "FlyTarget %s vid %d x %d y %d", GetName(), pack.dwTargetVID, pack.x, pack.y);
-	PacketAround(&pack, sizeof(pack), this);
-}
-
-LPCHARACTER CHARACTER::GetNearestVictim(LPCHARACTER pkChr)
-{
-	if (NULL == pkChr)
-		pkChr = this;
-
-	float fMinDist = 99999.0f;
-	LPCHARACTER pkVictim = NULL;
-
-	TDamageMap::iterator it = m_map_kDamage.begin();
-
-	// 일단 주위에 없는 사람을 걸러 낸다.
-	while (it != m_map_kDamage.end())
-	{
-		const VID& c_VID = it->first;
-		++it;
-
-		LPCHARACTER pAttacker = CHARACTER_MANAGER::instance().Find(c_VID);
-
-		if (!pAttacker)
-			continue;
-
-		if (pAttacker->IsAffectFlag(AFF_EUNHYUNG) ||
-			pAttacker->IsAffectFlag(AFF_INVISIBILITY) ||
-			pAttacker->IsAffectFlag(AFF_REVIVE_INVISIBLE))
-			continue;
-
-		float fDist = DISTANCE_APPROX(pAttacker->GetX() - pkChr->GetX(), pAttacker->GetY() - pkChr->GetY());
-
-		if (fDist < fMinDist)
-		{
-			pkVictim = pAttacker;
-			fMinDist = fDist;
-		}
-	}
-
-	return pkVictim;
-}
-
-void CHARACTER::SetVictim(LPCHARACTER pkVictim)
-{
-	if (!pkVictim)
-	{
-		if (0 != (DWORD)m_kVIDVictim)
-			MonsterLog("Can't find victim");
-
-		m_kVIDVictim.Reset();
-		battle_end(this);
-	}
-	else
-	{
-		if (m_kVIDVictim != pkVictim->GetVID())
-			MonsterLog("Set victim: %s", pkVictim->GetName());
-
-		m_kVIDVictim = pkVictim->GetVID();
-		m_dwLastVictimSetTime = get_dword_time();
-	}
-}
-
-LPCHARACTER CHARACTER::GetVictim() const
-{
-	return CHARACTER_MANAGER::instance().Find(m_kVIDVictim);
-}
-
-LPCHARACTER CHARACTER::GetProtege() const // 보호해야 할 대상을 리턴
-{
-	if (m_pkChrStone)
-		return m_pkChrStone;
-
-	if (m_pkParty)
-		return m_pkParty->GetLeader();
-
-	return NULL;
-}
-
-int CHARACTER::GetAlignment() const
-{
-	return m_iAlignment;
-}
-
-int CHARACTER::GetRealAlignment() const
-{
-	return m_iRealAlignment;
-}
-
-void CHARACTER::ShowAlignment(bool bShow)
-{
-	if (bShow)
-	{
-		if (m_iAlignment != m_iRealAlignment)
-		{
-			m_iAlignment = m_iRealAlignment;
-			UpdatePacket();
-		}
-	}
-	else
-	{
-		if (m_iAlignment != 0)
-		{
-			m_iAlignment = 0;
-			UpdatePacket();
-		}
-	}
-}
-
-void CHARACTER::UpdateAlignment(int iAmount)
-{
-	bool bShow = false;
-
-#ifdef ENABLE_QUEEN_NETHIS
-	if (IsSnakeMap() && iAmount < 0)
-		return;
-#endif
-
-	if (m_iAlignment == m_iRealAlignment)
-		bShow = true;
-
-	int i = m_iAlignment / 10;
-
-	m_iRealAlignment = MINMAX(-200000, m_iRealAlignment + iAmount, 200000);
-
-	if (bShow)
-	{
-		m_iAlignment = m_iRealAlignment;
-
-		if (i != m_iAlignment / 10)
-			UpdatePacket();
-	}
-}
-
-UINT CHARACTER::GetAlignmentGrade() const
-{
-	const int iAlignment = GetRealAlignment();
-
-	if (iAlignment >= 12000)
-		return ALIGN_GRADE_GOOD_4;
-	else if (iAlignment >= 8000)
-		return ALIGN_GRADE_GOOD_3;
-	else if (iAlignment >= 4000)
-		return ALIGN_GRADE_GOOD_2;
-	else if (iAlignment >= 1000)
-		return ALIGN_GRADE_GOOD_1;
-	else if (iAlignment >= 0)
-		return ALIGN_GRADE_NORMAL;
-	else if (iAlignment > -4000)
-		return ALIGN_GRADE_EVIL_1;
-	else if (iAlignment > -8000)
-		return ALIGN_GRADE_EVIL_2;
-	else if (iAlignment > -12000)
-		return ALIGN_GRADE_EVIL_3;
-	else
-		return ALIGN_GRADE_EVIL_4;
-
-	return 0;
-}
-
-void CHARACTER::SetKillerMode(bool isOn)
-{
-	if ((isOn ? ADD_CHARACTER_STATE_KILLER : 0) == IS_SET(m_bAddChrState, ADD_CHARACTER_STATE_KILLER))
-		return;
-
-	if (isOn)
-		SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_KILLER);
-	else
-		REMOVE_BIT(m_bAddChrState, ADD_CHARACTER_STATE_KILLER);
-
-	m_iKillerModePulse = thecore_pulse();
-	UpdatePacket();
-	sys_log(0, "SetKillerMode Update %s[%d]", GetName(), GetPlayerID());
-}
-
-bool CHARACTER::IsKillerMode() const
-{
-	return IS_SET(m_bAddChrState, ADD_CHARACTER_STATE_KILLER);
-}
-
-void CHARACTER::UpdateKillerMode()
-{
-	if (!IsKillerMode())
-		return;
-
-	int iKillerSeconds = 60;
-
-	if (thecore_pulse() - m_iKillerModePulse >= PASSES_PER_SEC(iKillerSeconds))
-		SetKillerMode(false);
-}
-
-void CHARACTER::SetPKMode(BYTE bPKMode)
-{
-	if (bPKMode >= PK_MODE_MAX_NUM)
-		return;
-
-	if (m_bPKMode == bPKMode)
-		return;
-
-	if (bPKMode == PK_MODE_GUILD && !GetGuild())
-		bPKMode = PK_MODE_FREE;
-
-	m_bPKMode = bPKMode;
-	UpdatePacket();
-
-	sys_log(0, "PK_MODE: %s %d", GetName(), m_bPKMode);
-}
-
-BYTE CHARACTER::GetPKMode() const
-{
-	return m_bPKMode;
-}
-
-struct FuncForgetMyAttacker
-{
-	LPCHARACTER m_ch;
-	FuncForgetMyAttacker(LPCHARACTER ch)
-	{
-		m_ch = ch;
-	}
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-			if (ch->IsPC())
-				return;
-			if (ch->m_kVIDVictim == m_ch->GetVID())
-				ch->SetVictim(NULL);
-		}
-	}
-};
-
-struct FuncAggregateMonster
-{
-	LPCHARACTER m_ch;
-	FuncAggregateMonster(LPCHARACTER ch)
-	{
-		m_ch = ch;
-	}
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-			if (ch->IsPC())
-				return;
-			if (!ch->IsMonster())
-				return;
-			if (ch->GetVictim())
-				return;
-
-			if (number(1, 100) <= 50) // 임시로 50% 확률로 적을 끌어온다
-				if (DISTANCE_APPROX(ch->GetX() - m_ch->GetX(), ch->GetY() - m_ch->GetY()) < 5000)
-					if (ch->CanBeginFight())
-						ch->BeginFight(m_ch);
-		}
-	}
-};
-
-struct FuncAttractRanger
-{
-	LPCHARACTER m_ch;
-	FuncAttractRanger(LPCHARACTER ch)
-	{
-		m_ch = ch;
-	}
-
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-			if (ch->IsPC())
-				return;
-			if (!ch->IsMonster())
-				return;
-			if (ch->GetVictim() && ch->GetVictim() != m_ch)
-				return;
-			if (ch->GetMobAttackRange() > 150)
-			{
-				int iNewRange = 150; //(int)(ch->GetMobAttackRange() * 0.2);
-				if (iNewRange < 150)
-					iNewRange = 150;
-
-				ch->AddAffect(AFFECT_BOW_DISTANCE, POINT_BOW_DISTANCE, iNewRange - ch->GetMobAttackRange(), AFF_NONE, 3 * 60, 0, false);
-			}
-		}
-	}
-};
-
-struct FuncPullMonster
-{
-	LPCHARACTER m_ch;
-	int m_iLength;
-	FuncPullMonster(LPCHARACTER ch, int iLength = 300)
-	{
-		m_ch = ch;
-		m_iLength = iLength;
-	}
-
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-			if (ch->IsPC())
-				return;
-			if (!ch->IsMonster())
-				return;
-			/*
-			if (ch->GetVictim() && ch->GetVictim() != m_ch)
-				return;
-			*/
-			float fDist = DISTANCE_APPROX(m_ch->GetX() - ch->GetX(), m_ch->GetY() - ch->GetY());
-			if (fDist > 3000 || fDist < 100)
-				return;
-
-			float fNewDist = fDist - m_iLength;
-			if (fNewDist < 100)
-				fNewDist = 100;
-
-			float degree = GetDegreeFromPositionXY(ch->GetX(), ch->GetY(), m_ch->GetX(), m_ch->GetY());
-			float fx;
-			float fy;
-
-			GetDeltaByDegree(degree, fDist - fNewDist, &fx, &fy);
-			long tx = (long)(ch->GetX() + fx);
-			long ty = (long)(ch->GetY() + fy);
-
-			ch->Sync(tx, ty);
-			ch->Goto(tx, ty);
-			ch->CalculateMoveDuration();
-
-			ch->SyncPacket();
-		}
-	}
-};
-
-void CHARACTER::ForgetMyAttacker(bool bRevive)
-{
-	LPSECTREE pSec = GetSectree();
-	if (pSec)
-	{
-		FuncForgetMyAttacker f(this);
-		pSec->ForEachAround(f);
-	}
-
-	if (bRevive)
-		ReviveInvisible(5);
-}
-
-void CHARACTER::AggregateMonster()
-{
-	LPSECTREE pSec = GetSectree();
-	if (pSec)
-	{
-		FuncAggregateMonster f(this);
-		pSec->ForEachAround(f);
-		EffectPacket(SE_CAPE_OF_COURAGE);
-	}
-}
-
-void CHARACTER::AttractRanger()
-{
-	LPSECTREE pSec = GetSectree();
-	if (pSec)
-	{
-		FuncAttractRanger f(this);
-		pSec->ForEachAround(f);
-	}
-}
-
-void CHARACTER::PullMonster()
-{
-	LPSECTREE pSec = GetSectree();
-	if (pSec)
-	{
-		FuncPullMonster f(this);
-		pSec->ForEachAround(f);
-	}
-}
-
-void CHARACTER::UpdateAggrPointEx(LPCHARACTER pAttacker, EDamageType type, int dam, CHARACTER::TBattleInfo& info)
-{
-#if defined(__DEFENSE_WAVE__)
-	if (GetDefenseWave())
-	{
-		if (CDefenseWaveManager::Instance().IsHydraSpawn(GetRaceNum()))
-			return;
-
-		if (CDefenseWaveManager::Instance().IsHydra(GetRaceNum()))
-			return;
-	}
-#endif
-
-	// 특정 공격타입에 따라 더 올라간다
-	switch (type)
-	{
-		case EDamageType::DAMAGE_TYPE_NORMAL_RANGE:
-			dam = (int)(dam * 1.2f);
-			break;
-
-		case EDamageType::DAMAGE_TYPE_RANGE:
-			dam = (int)(dam * 1.5f);
-			break;
-
-		case EDamageType::DAMAGE_TYPE_MAGIC:
-			dam = (int)(dam * 1.2f);
-			break;
-
-		default:
-			break;
-	}
-
-	// 공격자가 현재 대상인 경우 보너스를 준다.
-	if (pAttacker == GetVictim())
-		dam = (int)(dam * 1.2f);
-
-	info.iAggro += dam;
-
-	if (info.iAggro < 0)
-		info.iAggro = 0;
-
-	//sys_log(0, "UpdateAggrPointEx for %s by %s dam %d total %d", GetName(), pAttacker->GetName(), dam, total);
-	if (GetParty() && dam > 0 && type != DAMAGE_TYPE_SPECIAL)
-	{
-		LPPARTY pParty = GetParty();
-
-		// 리더인 경우 영향력이 좀더 강하다
-		int iPartyAggroDist = dam;
-
-		if (pParty->GetLeaderPID() == GetVID())
-			iPartyAggroDist /= 2;
-		else
-			iPartyAggroDist /= 3;
-
-		pParty->SendMessage(this, PM_AGGRO_INCREASE, iPartyAggroDist, pAttacker->GetVID());
-	}
-
-	ChangeVictimByAggro(info.iAggro, pAttacker);
-}
-
-void CHARACTER::UpdateAggrPoint(LPCHARACTER pAttacker, EDamageType type, int dam)
-{
-	if (IsDead() || IsStun())
-		return;
-
-	TDamageMap::iterator it = m_map_kDamage.find(pAttacker->GetVID());
-	if (it == m_map_kDamage.end())
-	{
-		m_map_kDamage.insert(TDamageMap::value_type(pAttacker->GetVID(), TBattleInfo(0, dam)));
-		it = m_map_kDamage.find(pAttacker->GetVID());
-	}
-
-	UpdateAggrPointEx(pAttacker, type, dam, it->second);
-}
-
-void CHARACTER::ChangeVictimByAggro(int iNewAggro, LPCHARACTER pNewVictim)
-{
-	if (get_dword_time() - m_dwLastVictimSetTime < 3000) // 3초는 기다려야한다
-		return;
-
-	if (pNewVictim == GetVictim())
-	{
-		if (m_iMaxAggro < iNewAggro)
-		{
-			m_iMaxAggro = iNewAggro;
-			return;
-		}
-
-		// Aggro가 감소한 경우
-		TDamageMap::iterator it;
-		TDamageMap::iterator itFind = m_map_kDamage.end();
-
-		for (it = m_map_kDamage.begin(); it != m_map_kDamage.end(); ++it)
-		{
-			if (it->second.iAggro > iNewAggro)
-			{
-				LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(it->first);
-
-				if (ch && !ch->IsDead() && DISTANCE_APPROX(ch->GetX() - GetX(), ch->GetY() - GetY()) < 5000)
-				{
-					itFind = it;
-					iNewAggro = it->second.iAggro;
-				}
-			}
-		}
-
-		if (itFind != m_map_kDamage.end())
-		{
-			m_iMaxAggro = iNewAggro;
-			SetVictim(CHARACTER_MANAGER::Instance().Find(itFind->first));
-			m_dwStateDuration = 1;
-		}
-	}
-	else
-	{
-		if (m_iMaxAggro < iNewAggro)
-		{
-			m_iMaxAggro = iNewAggro;
-			SetVictim(pNewVictim);
-			m_dwStateDuration = 1;
-		}
-	}
-}
+#include "stdafx.h"
+#include "utils.h"
+#include "config.h"
+#include "desc.h"
+#include "desc_manager.h"
+#include "char_manager.h"
+#include "item.h"
+#include "item_manager.h"
+#include "mob_manager.h"
+#include "battle.h"
+#include "pvp.h"
+#include "skill.h"
+#include "start_position.h"
+#include "profiler.h"
+#include "cmd.h"
+#include "dungeon.h"
+#include "log.h"
+#include "unique_item.h"
+#include "priv_manager.h"
+#include "db.h"
+#include "vector.h"
+#include "marriage.h"
+#include "arena.h"
+#include "regen.h"
+#include "monarch.h"
+#include "exchange.h"
+#include "shop_manager.h"
+#include "castle.h"
+#include "dev_log.h"
+#include "ani.h"
+#include "BattleArena.h"
+#include "packet.h"
+#include "party.h"
+#include "affect.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "questmanager.h"
+#include "questlua.h"
+#include "threeway_war.h"
+#ifdef ENABLE_QUEEN_NETHIS
+#include "SnakeLair.h"
+#endif
+#include "BlueDragon.h"
+#include "DragonLair.h"
+#if defined(__MT_THUNDER_DUNGEON__)
+#	include "mt_thunder_dungeon.h"
+#endif
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+#	include "guild_dragonlair.h"
+#endif
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+#if defined(__PET_LOOT__)
+#	include "PetSystem.h"
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+
+DWORD AdjustExpByLevel(const LPCHARACTER ch, const DWORD exp)
+{
+	if (PLAYER_EXP_TABLE_MAX < ch->GetLevel())
+	{
+		double ret = 0.95;
+		double factor = 0.1;
+
+		for (ssize_t i = 0; i < ch->GetLevel() - 100; ++i)
+		{
+			if ((i % 10) == 0)
+				factor /= 2.0;
+
+			ret *= 1.0 - factor;
+		}
+
+		ret = ret * static_cast<double>(exp);
+
+		if (ret < 1.0)
+			return 1;
+
+		return static_cast<DWORD>(ret);
+	}
+
+	return exp;
+}
+
+bool CHARACTER::CanBeginFight() const
+{
+	if (!CanMove())
+		return false;
+
+	return m_pointsInstant.position == POS_STANDING && !IsDead() && !IsStun();
+}
+
+void CHARACTER::BeginFight(LPCHARACTER pkVictim)
+{
+	SetVictim(pkVictim);
+	SetNowWalking(false);
+	SetPosition(POS_FIGHTING);
+	SetNextStatePulse(1);
+}
+
+bool CHARACTER::CanFight() const
+{
+	return m_pointsInstant.position >= POS_FIGHTING ? true : false;
+}
+
+void CHARACTER::CreateFly(BYTE bType, LPCHARACTER pkVictim)
+{
+	TPacketGCCreateFly packFly;
+
+	packFly.bHeader = HEADER_GC_CREATE_FLY;
+	packFly.bType = bType;
+	packFly.dwStartVID = GetVID();
+	packFly.dwEndVID = pkVictim->GetVID();
+
+	PacketAround(&packFly, sizeof(TPacketGCCreateFly));
+}
+
+void CHARACTER::DistributeSP(LPCHARACTER pkKiller, int iMethod)
+{
+	if (pkKiller->GetSP() >= pkKiller->GetMaxSP())
+		return;
+
+	bool bAttacking = (get_dword_time() - GetLastAttackTime()) < 3000;
+	bool bMoving = (get_dword_time() - GetLastMoveTime()) < 3000;
+
+	if (iMethod == 1)
+	{
+		int num = number(0, 3);
+
+		if (!num)
+		{
+			int iLvDelta = GetLevel() - pkKiller->GetLevel();
+			int iAmount = 0;
+
+			if (iLvDelta >= 5)
+				iAmount = 10;
+			else if (iLvDelta >= 0)
+				iAmount = 6;
+			else if (iLvDelta >= -3)
+				iAmount = 2;
+
+			if (iAmount != 0)
+			{
+				iAmount += (iAmount * pkKiller->GetPoint(POINT_SP_REGEN)) / 100;
+
+				if (iAmount >= 11)
+					CreateFly(FLY_SP_BIG, pkKiller);
+				else if (iAmount >= 7)
+					CreateFly(FLY_SP_MEDIUM, pkKiller);
+				else
+					CreateFly(FLY_SP_SMALL, pkKiller);
+
+				pkKiller->PointChange(POINT_SP, iAmount);
+			}
+		}
+	}
+	else
+	{
+		if (pkKiller->GetJob() == JOB_SHAMAN || (pkKiller->GetJob() == JOB_SURA && pkKiller->GetSkillGroup() == 2))
+		{
+			int iAmount;
+
+			if (bAttacking)
+				iAmount = 2 + GetMaxSP() / 100;
+			else if (bMoving)
+				iAmount = 3 + GetMaxSP() * 2 / 100;
+			else
+				iAmount = 10 + GetMaxSP() * 3 / 100; // 
+
+			iAmount += (iAmount * pkKiller->GetPoint(POINT_SP_REGEN)) / 100;
+			pkKiller->PointChange(POINT_SP, iAmount);
+		}
+		else
+		{
+			int iAmount;
+
+			if (bAttacking)
+				iAmount = 2 + pkKiller->GetMaxSP() / 200;
+			else if (bMoving)
+				iAmount = 2 + pkKiller->GetMaxSP() / 100;
+			else
+			{
+				// 
+				if (pkKiller->GetHP() < pkKiller->GetMaxHP())
+					iAmount = 2 + (pkKiller->GetMaxSP() / 100); //   찼
+				else
+					iAmount = 9 + (pkKiller->GetMaxSP() / 100); // 羞
+			}
+
+			iAmount += (iAmount * pkKiller->GetPoint(POINT_SP_REGEN)) / 100;
+			pkKiller->PointChange(POINT_SP, iAmount);
+		}
+	}
+}
+
+bool CHARACTER::Attack(LPCHARACTER pkVictim, BYTE bType)
+{
+	if (test_server)
+		sys_log(0, "[TEST_SERVER] Attack : %s type %d, MobBattleType %d", GetName(), bType, !GetMobBattleType() ? 0 : GetMobAttackRange());
+
+	//PROF_UNIT puAttack("Attack");
+	if (!CanMove() || IsObserverMode())
+		return false;
+
+	// CASTLE
+	if (IS_CASTLE_MAP(GetMapIndex()) && false == castle_can_attack(this, pkVictim))
+		return false;
+	// CASTLE
+
+#if defined(__DEFENSE_WAVE__)
+	if (GetDefenseWave() && CDefenseWaveManager::Instance().CanAttack(this, pkVictim) == false)
+		return false;
+#endif
+
+	if (!battle_is_attackable(this, pkVictim))
+		return false;
+
+	// [Anti-Exploit] Prevent remote aggro / "Mob Puller" via packet spam.
+	// Attack() sets SyncOwner/BeginFight before distance checks; a forged packet could
+	// start combat from very far away. This hard cap is far above any legitimate range.
+	if (IsPC() && pkVictim && (pkVictim->IsMonster() || pkVictim->IsStone()))
+	{
+		const int iDist = DISTANCE_APPROX(GetX() - pkVictim->GetX(), GetY() - pkVictim->GetY());
+		if (iDist > 5000)
+			return false;
+	}
+
+	DWORD dwCurrentTime = get_dword_time();
+
+	if (IsPC())
+	{
+		if (IS_SPEED_HACK(this, pkVictim, dwCurrentTime))
+			return false;
+
+		if (bType == 0 && dwCurrentTime < GetSkipComboAttackByTime())
+			return false;
+	}
+	else
+	{
+		MonsterChat(MONSTER_CHAT_ATTACK);
+	}
+
+	pkVictim->SetSyncOwner(this);
+
+	if (pkVictim->CanBeginFight())
+		pkVictim->BeginFight(this);
+
+	int iRet;
+
+	if (bType == 0)
+	{
+		//
+		// 球 
+		//
+		switch (GetMobBattleType())
+		{
+			case BATTLE_TYPE_MELEE:
+			case BATTLE_TYPE_POWER:
+			case BATTLE_TYPE_TANKER:
+			case BATTLE_TYPE_SUPER_POWER:
+			case BATTLE_TYPE_SUPER_TANKER:
+				iRet = battle_melee_attack(this, pkVictim);
+				break;
+
+			case BATTLE_TYPE_RANGE:
+				FlyTarget(pkVictim->GetVID(), pkVictim->GetX(), pkVictim->GetY(), HEADER_CG_FLY_TARGETING);
+				iRet = Shoot(0) ? BATTLE_DAMAGE : BATTLE_NONE;
+				break;
+
+			case BATTLE_TYPE_MAGIC:
+				FlyTarget(pkVictim->GetVID(), pkVictim->GetX(), pkVictim->GetY(), HEADER_CG_FLY_TARGETING);
+				iRet = Shoot(1) ? BATTLE_DAMAGE : BATTLE_NONE;
+				break;
+
+			default:
+				sys_err("Unhandled battle type %d", GetMobBattleType());
+				iRet = BATTLE_NONE;
+				break;
+		}
+
+#if defined(__SOUL_SYSTEM__)
+		if (IsPC() && iRet != BATTLE_NONE)
+			SoulItemProcess(RED_SOUL);
+#endif
+	}
+	else
+	{
+		if (IsPC() == true)
+		{
+			if (dwCurrentTime - m_dwLastSkillTime > 1500)
+			{
+				sys_log(1, "HACK: Too long skill using term. Name(%s) PID(%u) delta(%u)",
+					GetName(), GetPlayerID(), (dwCurrentTime - m_dwLastSkillTime));
+				return false;
+			}
+		}
+
+		sys_log(1, "Attack call ComputeSkill %d %s", bType, pkVictim ? pkVictim->GetName() : "");
+		iRet = ComputeSkill(bType, pkVictim);
+
+#if defined(__SOUL_SYSTEM__)
+		if (IsPC() && iRet != BATTLE_NONE)
+			SoulItemProcess(BLUE_SOUL);
+#endif
+	}
+
+#if defined(__ATTR_6TH_7TH__)
+	if (IsPC() && iRet != BATTLE_NONE)
+		this->StartHitBuffEvent();
+#endif
+
+	//if (test_server && IsPC())
+		//sys_log(0, "%s Attack %s type %u ret %d", GetName(), pkVictim->GetName(), bType, iRet);
+
+	if (iRet == BATTLE_DAMAGE || iRet == BATTLE_DEAD)
+	{
+		OnMove(true);
+		pkVictim->OnMove();
+
+		// Only pc sets victim null. For npc, state machine will reset this.
+		if (BATTLE_DEAD == iRet && IsPC())
+			SetVictim(NULL);
+
+		return true;
+	}
+
+	return false;
+}
+
+void CHARACTER::DeathPenalty(BYTE bTown)
+{
+	sys_log(1, "DEATH_PERNALY_CHECK(%s) town(%d)", GetName(), bTown);
+
+#if defined(__CUBE_RENEWAL__)
+	CCubeManager::Instance().CloseCube(this);
+#else
+	Cube_close(this);
+#endif
+
+	if (CBattleArena::instance().IsBattleArenaMap(GetMapIndex()) == true)
+	{
+		return;
+	}
+
+	if (GetLevel() < 10)
+	{
+		sys_log(0, "NO_DEATH_PENALTY_LESS_LV10(%s)", GetName());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 호 치  刻努求."));
+		return;
+	}
+
+	if (number(0, 2))
+	{
+		sys_log(0, "NO_DEATH_PENALTY_LUCK(%s)", GetName());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 호 치  刻努求."));
+		return;
+	}
+
+	if (IS_SET(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY))
+	{
+		REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
+
+		// NO_DEATH_PENALTY_BUG_FIX 
+		if (LC_IsYMIR()) // 천    호  체크磯.
+		{
+			if (FindAffect(AFFECT_NO_DEATH_PENALTY))
+			{
+				sys_log(0, "NO_DEATH_PENALTY_AFFECT(%s)", GetName());
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 호 치  刻努求."));
+				RemoveAffect(AFFECT_NO_DEATH_PENALTY);
+				return;
+			}
+		}
+		else if (!bTown) //   美 활첩  호 磯. ( 枯척 치 均티 )
+		{
+			if (FindAffect(AFFECT_NO_DEATH_PENALTY))
+			{
+				sys_log(0, "NO_DEATH_PENALTY_AFFECT(%s)", GetName());
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 호 치  刻努求."));
+				RemoveAffect(AFFECT_NO_DEATH_PENALTY);
+				return;
+			}
+		}
+		// END_OF_NO_DEATH_PENALTY_BUG_FIX
+
+		int iLoss = ((GetNextExp() * aiExpLossPercents[MINMAX(1, GetLevel(), PLAYER_EXP_TABLE_MAX)]) / 100);
+
+		if (true == LC_IsYMIR())
+		{
+			if (PLAYER_EXP_TABLE_MAX < GetLevel())
+			{
+				iLoss = MIN(500000, iLoss);
+			}
+			else
+			{
+				iLoss = MIN(200000, iLoss);
+			}
+		}
+		else if (true == LC_IsEurope())
+		{
+			iLoss = MIN(800000, iLoss);
+		}
+
+		if (bTown)
+		{
+			if (g_iUseLocale)
+			{
+				iLoss = 0;
+			}
+			else
+			{
+				iLoss -= iLoss / 3;
+			}
+		}
+
+		if (IsEquipUniqueItem(UNIQUE_ITEM_TEARDROP_OF_GODNESS))
+			iLoss /= 2;
+
+		sys_log(0, "DEATH_PENALTY(%s) EXP_LOSS: %d percent %d%%", GetName(), iLoss, aiExpLossPercents[MIN(gPlayerMaxLevel, GetLevel())]);
+
+		PointChange(POINT_EXP, -iLoss, true);
+	}
+}
+
+bool CHARACTER::IsStun() const
+{
+	if (IS_SET(m_pointsInstant.instant_flag, INSTANT_FLAG_STUN))
+		return true;
+
+	return false;
+}
+
+EVENTFUNC(StunEvent)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("StunEvent> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = info->ch;
+
+	if (ch == NULL) // <Factor>
+		return 0;
+
+	ch->m_pkStunEvent = NULL;
+	ch->Dead();
+	return 0;
+}
+
+void CHARACTER::Stun(bool bImmediate)
+{
+	if (IsStun())
+		return;
+
+	if (IsDead())
+		return;
+
+	if (!IsPC() && m_pkParty)
+	{
+		m_pkParty->SendMessage(this, PM_ATTACKED_BY, 0, 0);
+	}
+
+	sys_log(1, "%s: Stun %p", GetName(), this);
+
+	PointChange(POINT_HP_RECOVERY, -GetPoint(POINT_HP_RECOVERY));
+	PointChange(POINT_SP_RECOVERY, -GetPoint(POINT_SP_RECOVERY));
+
+	CloseMyShop();
+
+	event_cancel(&m_pkRecoveryEvent); // 회 遣트 灌.
+
+	TPacketGCStun pack;
+	pack.header = HEADER_GC_STUN;
+	pack.vid = m_vid;
+	PacketAround(&pack, sizeof(pack));
+
+	SET_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_STUN);
+
+	if (m_pkStunEvent)
+		return;
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+
+	info->ch = this;
+
+	m_pkStunEvent = event_create(StunEvent, info, PASSES_PER_SEC(bImmediate ? 1 : 3));
+}
+
+EVENTINFO(SCharDeadEventInfo)
+{
+	bool isPC;
+	uint32_t dwID;
+
+	SCharDeadEventInfo()
+		: isPC(0)
+		, dwID(0)
+	{
+	}
+};
+
+EVENTFUNC(dead_event)
+{
+	const SCharDeadEventInfo* info = dynamic_cast<SCharDeadEventInfo*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("dead_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = NULL;
+
+	if (true == info->isPC)
+	{
+		ch = CHARACTER_MANAGER::instance().FindByPID(info->dwID);
+	}
+	else
+	{
+		ch = CHARACTER_MANAGER::instance().Find(info->dwID);
+	}
+
+	if (NULL == ch)
+	{
+		sys_err("DEAD_EVENT: cannot find char pointer with %s id(%d)", info->isPC ? "PC" : "MOB", info->dwID);
+		return 0;
+	}
+
+	ch->m_pkDeadEvent = NULL;
+
+	if (ch->GetDesc())
+	{
+		ch->GetDesc()->SetPhase(PHASE_GAME);
+		ch->SetPosition(POS_STANDING);
+
+		long lMapIndex = ch->GetMapIndex();
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+		if (CGuildDragonLairManager::Instance().IsRedDragonLair(lMapIndex))
+		{
+			CGuildDragonLairManager::Instance().Exit(ch);
+			return 0;
+		}
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+		if (IS_ELEMENTAL_DUNGEON(ch->GetMapIndex()))
+		{
+			PIXEL_POSITION WarpPos;
+			if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(MAP_DEFENSEWAVE_PORT, ch->GetEmpire(), WarpPos))
+				ch->WarpSet(WarpPos.x, WarpPos.y);
+			else
+			{
+				sys_err("cannot find spawn position (name %s)", ch->GetName());
+				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+			}
+
+			ch->PointChange(POINT_HP, (ch->GetMaxHP() / 2) - ch->GetHP(), true);
+			ch->DeathPenalty(0);
+			ch->StartRecoveryEvent();
+			ch->ChatPacket(CHAT_TYPE_COMMAND, "CloseRestartWindow");
+
+			return 0;
+		}
+#endif
+
+		PIXEL_POSITION pos;
+		if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(lMapIndex, ch->GetEmpire(), pos))
+			ch->WarpSet(pos.x, pos.y);
+		else
+		{
+			sys_err("cannot find spawn position (name %s)", ch->GetName());
+			ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+
+		ch->PointChange(POINT_HP, (ch->GetMaxHP() / 2) - ch->GetHP(), true);
+		ch->DeathPenalty(0);
+		ch->StartRecoveryEvent();
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "CloseRestartWindow");
+	}
+	else
+	{
+		if (ch->IsMonster())
+		{
+			if (!ch->IsRevive() && ch->HasReviverInParty())
+			{
+				ch->SetPosition(POS_STANDING);
+				ch->SetHP(ch->GetMaxHP());
+
+				ch->ViewReencode();
+
+				ch->SetAggressive();
+				ch->SetRevive(true);
+
+				return 0;
+			}
+		}
+
+		M2_DESTROY_CHARACTER(ch);
+	}
+
+	return 0;
+}
+
+bool CHARACTER::IsDead() const
+{
+	if (m_pointsInstant.position == POS_DEAD)
+		return true;
+
+	return false;
+}
+
+#define GetGoldMultipler() (distribution_test_server ? 3 : 1)
+
+void CHARACTER::RewardGold(LPCHARACTER pkAttacker)
+{
+	// ADD_PREMIUM
+	bool isAutoLoot =
+		(pkAttacker->GetPremiumRemainSeconds(PREMIUM_AUTOLOOT) > 0 ||
+			pkAttacker->IsEquipUniqueGroup(UNIQUE_GROUP_AUTO_LOOT))
+		? true : false; // 3 
+	// END_OF_ADD_PREMIUM
+
+	PIXEL_POSITION pos;
+
+	if (!isAutoLoot)
+		if (!SECTREE_MANAGER::instance().GetMovablePosition(GetMapIndex(), GetX(), GetY(), pos))
+			return;
+
+	int iTotalGold = 0;
+	//
+	// ---------   확  ----------
+	//
+	int iGoldPercent = MobRankStats[GetMobRank()].iGoldPercent;
+
+	if (pkAttacker->IsPC())
+		iGoldPercent = iGoldPercent * (100 + CPrivManager::instance().GetPriv(pkAttacker, PRIV_GOLD_DROP)) / 100;
+
+	if (pkAttacker->GetPoint(POINT_MALL_GOLDBONUS))
+		iGoldPercent += (iGoldPercent * pkAttacker->GetPoint(POINT_MALL_GOLDBONUS) / 100);
+
+	iGoldPercent = iGoldPercent * CHARACTER_MANAGER::instance().GetMobGoldDropRate(pkAttacker) / 100;
+
+	// ADD_PREMIUM
+	if (pkAttacker->GetPremiumRemainSeconds(PREMIUM_GOLD) > 0 ||
+		pkAttacker->IsEquipUniqueGroup(UNIQUE_GROUP_LUCKY_GOLD))
+		iGoldPercent += iGoldPercent;
+	// END_OF_ADD_PREMIUM
+
+	if (iGoldPercent > 100)
+		iGoldPercent = 100;
+
+	int iPercent;
+
+	if (GetMobRank() >= MOB_RANK_BOSS)
+		iPercent = ((iGoldPercent * PERCENT_LVDELTA_BOSS(pkAttacker->GetLevel(), GetLevel())) / 100);
+	else
+		iPercent = ((iGoldPercent * PERCENT_LVDELTA(pkAttacker->GetLevel(), GetLevel())) / 100);
+	//int iPercent = CALCULATE_VALUE_LVDELTA(pkAttacker->GetLevel(), GetLevel(), iGoldPercent);
+
+	if (number(1, 100) > iPercent)
+		return;
+
+	int iGoldMultipler = GetGoldMultipler();
+
+	if (1 == number(1, 50000)) // 1 / 50000 확  10
+		iGoldMultipler *= 10;
+	else if (1 == number(1, 10000)) // 1 / 10000 확  5
+		iGoldMultipler *= 5;
+
+	//  
+	if (pkAttacker->GetPoint(POINT_GOLD_DOUBLE_BONUS))
+		if (number(1, 100) <= pkAttacker->GetPoint(POINT_GOLD_DOUBLE_BONUS))
+			iGoldMultipler *= 2;
+
+	//
+	// ---------     ----------
+	//
+	if (test_server)
+		pkAttacker->ChatPacket(CHAT_TYPE_PARTY, "gold_mul %d rate %d", iGoldMultipler, CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker));
+
+	//
+	// ---------   처 -------------
+	//
+	LPITEM item;
+
+	int iGold10DropPct = 100;
+	iGold10DropPct = (iGold10DropPct * 100) / (100 + CPrivManager::instance().GetPriv(pkAttacker, PRIV_GOLD10_DROP));
+
+	// MOB_RANK BOSS   탄
+	if (GetMobRank() >= MOB_RANK_BOSS && !IsStone() && GetMobTable().dwGoldMax != 0)
+	{
+		if (1 == number(1, iGold10DropPct))
+			iGoldMultipler *= 10; // 1% 확  10
+
+		int iSplitCount = number(25, 35);
+
+		for (int i = 0; i < iSplitCount; ++i)
+		{
+			int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax) / iSplitCount;
+			if (test_server)
+				sys_log(0, "iGold %d", iGold);
+			iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker) / 100;
+			iGold *= iGoldMultipler;
+
+			if (iGold == 0)
+			{
+				continue;
+			}
+
+			if (test_server)
+			{
+				sys_log(0, "Drop Moeny MobGoldAmountRate %d %d", CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker), iGoldMultipler);
+				sys_log(0, "Drop Money gold %d GoldMin %d GoldMax %d", iGold, GetMobTable().dwGoldMax, GetMobTable().dwGoldMax);
+			}
+
+			// NOTE:  탄  3  처  
+			if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold)))
+			{
+				pos.x = GetX() + ((number(-14, 14) + number(-14, 14)) * 23);
+				pos.y = GetY() + ((number(-14, 14) + number(-14, 14)) * 23);
+
+				item->AddToGround(GetMapIndex(), pos);
+				item->StartDestroyEvent();
+
+				iTotalGold += iGold; // Total gold
+			}
+		}
+	}
+	// 1% 확  10  蔘. (10 )
+	else if (1 == number(1, iGold10DropPct))
+	{
+		//
+		//  탄 
+		//
+		for (int i = 0; i < 10; ++i)
+		{
+			int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax);
+			iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker) / 100;
+			iGold *= iGoldMultipler;
+
+			if (iGold == 0)
+			{
+				continue;
+			}
+
+			// NOTE :  탄  3  처  
+			if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold)))
+			{
+				pos.x = GetX() + (number(-7, 7) * 20);
+				pos.y = GetY() + (number(-7, 7) * 20);
+
+				item->AddToGround(GetMapIndex(), pos);
+				item->StartDestroyEvent();
+
+				iTotalGold += iGold; // Total gold
+			}
+		}
+	}
+	else
+	{
+		//
+		// 球   
+		//
+		int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax);
+		iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(pkAttacker) / 100;
+		iGold *= iGoldMultipler;
+
+		int iSplitCount;
+
+		if (iGold >= 3 && !LC_IsYMIR())
+			iSplitCount = number(1, 3);
+		else if (GetMobRank() >= MOB_RANK_BOSS)
+		{
+			iSplitCount = number(3, 10);
+
+			if ((iGold / iSplitCount) == 0)
+				iSplitCount = 1;
+		}
+		else
+			iSplitCount = 1;
+
+		if (iGold != 0)
+		{
+			iTotalGold += iGold; // Total gold
+
+			for (int i = 0; i < iSplitCount; ++i)
+			{
+				if (isAutoLoot)
+				{
+					pkAttacker->GiveGold(iGold / iSplitCount);
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+					pkAttacker->UpdateExtBattlePassMissionProgress(YANG_COLLECT, iGold / iSplitCount, pkAttacker->GetMapIndex());
+#endif
+				}
+				else if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold / iSplitCount)))
+				{
+					pos.x = GetX() + (number(-7, 7) * 20);
+					pos.y = GetY() + (number(-7, 7) * 20);
+
+					item->AddToGround(GetMapIndex(), pos);
+					item->StartDestroyEvent();
+				}
+			}
+		}
+	}
+
+	DBManager::instance().SendMoneyLog(MONEY_LOG_MONSTER, GetRaceNum(), iTotalGold);
+}
+
+void CHARACTER::Reward(bool bItemDrop)
+{
+	if (GetRaceNum() == 5001) // 殮   
+	{
+		PIXEL_POSITION pos;
+
+		if (!SECTREE_MANAGER::instance().GetMovablePosition(GetMapIndex(), GetX(), GetY(), pos))
+			return;
+
+		LPITEM item;
+		int iGold = number(GetMobTable().dwGoldMin, GetMobTable().dwGoldMax);
+		iGold = iGold * CHARACTER_MANAGER::instance().GetMobGoldAmountRate(NULL) / 100;
+		iGold *= GetGoldMultipler();
+		int iSplitCount = number(25, 35);
+
+		sys_log(0, "WAEGU Dead gold %d split %d", iGold, iSplitCount);
+
+		for (int i = 1; i <= iSplitCount; ++i)
+		{
+			if ((item = ITEM_MANAGER::instance().CreateItem(1, iGold / iSplitCount)))
+			{
+				if (i != 0)
+				{
+					pos.x = number(-7, 7) * 20;
+					pos.y = number(-7, 7) * 20;
+
+					pos.x += GetX();
+					pos.y += GetY();
+				}
+
+				item->AddToGround(GetMapIndex(), pos);
+				item->StartDestroyEvent();
+			}
+		}
+		return;
+	}
+
+	//PROF_UNIT puReward("Reward");
+	LPCHARACTER pkAttacker = DistributeExp();
+
+	if (!pkAttacker)
+		return;
+
+	//PROF_UNIT pu1("r1");
+	if (pkAttacker->IsPC())
+	{
+		if (GetLevel() - pkAttacker->GetLevel() >= -10)
+		{
+			if (pkAttacker->GetRealAlignment() < 0)
+			{
+				if (pkAttacker->IsEquipUniqueItem(UNIQUE_ITEM_FASTER_ALIGNMENT_UP_BY_KILL))
+					pkAttacker->UpdateAlignment(14);
+				else
+					pkAttacker->UpdateAlignment(7);
+			}
+			else
+				pkAttacker->UpdateAlignment(2);
+		}
+
+		pkAttacker->SetQuestNPCID(GetVID());
+		quest::CQuestManager::instance().Kill(pkAttacker->GetPlayerID(), GetRaceNum());
+		CHARACTER_MANAGER::instance().KillLog(GetRaceNum());
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		pkAttacker->UpdateExtBattlePassMissionProgress(KILL_MONSTER, 1, GetRaceNum());
+#endif
+
+#if defined(__PARTY_KILL_RENEWAL__)
+		if (pkAttacker->GetParty())
+		{
+			quest::CQuestManager::instance().PartyKill(pkAttacker->GetPlayerID(), GetRaceNum());
+
+			FPartyKill f(this, pkAttacker);
+			pkAttacker->GetParty()->ForEachNearMember(f);
+		}
+#endif
+
+		if (!number(0, 9))
+		{
+			if (pkAttacker->GetPoint(POINT_KILL_HP_RECOVERY))
+			{
+				int iHP = pkAttacker->GetMaxHP() * pkAttacker->GetPoint(POINT_KILL_HP_RECOVERY) / 100;
+				pkAttacker->PointChange(POINT_HP, iHP);
+				CreateFly(FLY_HP_SMALL, pkAttacker);
+			}
+
+			if (pkAttacker->GetPoint(POINT_KILL_SP_RECOVER))
+			{
+				int iSP = pkAttacker->GetMaxSP() * pkAttacker->GetPoint(POINT_KILL_SP_RECOVER) / 100;
+				pkAttacker->PointChange(POINT_SP, iSP);
+				CreateFly(FLY_SP_SMALL, pkAttacker);
+			}
+		}
+	}
+	//pu1.Pop();
+
+	if (!bItemDrop)
+		return;
+
+	PIXEL_POSITION pos = GetXYZ();
+
+	if (!SECTREE_MANAGER::instance().GetMovablePosition(GetMapIndex(), pos.x, pos.y, pos))
+		return;
+
+	//
+	//  
+	//
+	//PROF_UNIT pu2("r2");
+	if (test_server)
+		sys_log(0, "Drop money : Attacker %s", pkAttacker->GetName());
+	RewardGold(pkAttacker);
+	//pu2.Pop();
+
+	//
+	//  
+	//
+	//PROF_UNIT pu3("r3");
+	LPITEM item;
+
+	static std::vector<LPITEM> s_vec_item;
+	s_vec_item.clear();
+
+	if (ITEM_MANAGER::instance().CreateDropItem(this, pkAttacker, s_vec_item))
+	{
+		if (s_vec_item.size() == 0);
+		else if (s_vec_item.size() == 1)
+		{
+			item = s_vec_item[0];
+
+#if defined(__DICE_SYSTEM__)
+			FPartyDropDiceRoll f(item, pkAttacker);
+			f.Process(this);
+#endif
+
+#if defined (__PET_SYSTEM__) && defined(__PET_LOOT__)
+			if ((f.GetItemOwner() == pkAttacker) && (pkAttacker->GetPetSystem() && pkAttacker->GetPetSystem()->LootItem(item)))
+				pkAttacker->AutoGiveItem(item, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					, true
+#endif
+				);
+			else
+#endif
+			{
+				item->AddToGround(GetMapIndex(), pos);
+				if (CBattleArena::instance().IsBattleArenaMap(pkAttacker->GetMapIndex()) == false)
+#if defined(__DICE_SYSTEM__)
+					item->SetOwnership(f.GetItemOwner());
+#else
+					item->SetOwnership(pkAttacker);
+#endif
+				item->StartDestroyEvent();
+
+				pos.x = number(-7, 7) * 20;
+				pos.y = number(-7, 7) * 20;
+				pos.x += GetX();
+				pos.y += GetY();
+
+				sys_log(0, "DROP_ITEM: %s %d %d from %s", item->GetName(), pos.x, pos.y, GetName());
+			}
+		}
+		else
+		{
+			int iItemIdx = s_vec_item.size() - 1;
+
+			std::priority_queue<std::pair<int, LPCHARACTER>> pq;
+
+			int total_dam = 0;
+
+			for (TDamageMap::iterator it = m_map_kDamage.begin(); it != m_map_kDamage.end(); ++it)
+			{
+				int iDamage = it->second.iTotalDamage;
+				if (iDamage > 0)
+				{
+					LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(it->first);
+
+					if (ch)
+					{
+						pq.push(std::make_pair(iDamage, ch));
+						total_dam += iDamage;
+					}
+				}
+			}
+
+			std::vector<LPCHARACTER> v;
+
+			while (!pq.empty() && pq.top().first * 10 >= total_dam)
+			{
+				v.push_back(pq.top().second);
+				pq.pop();
+			}
+
+			if (v.empty())
+			{
+				//  특      
+				while (iItemIdx >= 0)
+				{
+					item = s_vec_item[iItemIdx--];
+
+					if (!item)
+					{
+						sys_err("item null in vector idx %d", iItemIdx + 1);
+						continue;
+					}
+
+					item->AddToGround(GetMapIndex(), pos);
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+					pkAttacker->UpdateExtBattlePassMissionProgress(BP_ITEM_COLLECT, item->GetCount(), item->GetVnum());
+#endif
+					// 10%     퓸
+					//item->SetOwnership(pkAttacker);
+					item->StartDestroyEvent();
+
+					pos.x = number(-7, 7) * 20;
+					pos.y = number(-7, 7) * 20;
+					pos.x += GetX();
+					pos.y += GetY();
+
+					sys_log(0, "DROP_ITEM: %s %d %d by %s", item->GetName(), pos.x, pos.y, GetName());
+				}
+			}
+			else
+			{
+				//       
+				std::vector<LPCHARACTER>::iterator it = v.begin();
+
+				while (iItemIdx >= 0)
+				{
+					item = s_vec_item[iItemIdx--];
+
+					if (!item)
+					{
+						sys_err("item null in vector idx %d", iItemIdx + 1);
+						continue;
+					}
+
+					LPCHARACTER ch = *it;
+
+					if (ch->GetParty())
+						ch = ch->GetParty()->GetNextOwnership(ch, GetX(), GetY());
+
+					++it;
+
+					if (it == v.end())
+						it = v.begin();
+
+#if defined(__DICE_SYSTEM__)
+					FPartyDropDiceRoll f(item, ch);
+					f.Process(this);
+#endif
+
+#if defined(__PET_SYSTEM__) && defined(__PET_LOOT__)
+					if ((f.GetItemOwner() == pkAttacker) && (pkAttacker->GetPetSystem() && pkAttacker->GetPetSystem()->LootItem(item)))
+						pkAttacker->AutoGiveItem(item, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+							, true
+#endif
+						);
+					else
+#endif
+					{
+						item->AddToGround(GetMapIndex(), pos);
+						if (CBattleArena::instance().IsBattleArenaMap(ch->GetMapIndex()) == false)
+						{
+#if defined(__DICE_SYSTEM__)
+							item->SetOwnership(f.GetItemOwner());
+#else
+							item->SetOwnership(ch);
+#endif
+						}
+						item->StartDestroyEvent();
+
+						pos.x = number(-7, 7) * 20;
+						pos.y = number(-7, 7) * 20;
+						pos.x += GetX();
+						pos.y += GetY();
+
+						sys_log(0, "DROP_ITEM: %s %d %d by %s", item->GetName(), pos.x, pos.y, GetName());
+					}
+				}
+			}
+		}
+	}
+
+	m_map_kDamage.clear();
+}
+
+struct TItemDropPenalty
+{
+	int iInventoryPct; // Range: 1 ~ 1000
+	int iInventoryQty; // Range: --
+	int iEquipmentPct; // Range: 1 ~ 100
+	int iEquipmentQty; // Range: --
+};
+
+TItemDropPenalty aItemDropPenalty_kor[9] =
+{
+	{ 0, 0, 0, 0 }, // 
+	{ 0, 0, 0, 0 }, // 
+	{ 0, 0, 0, 0 }, // 
+	{ 0, 0, 0, 0 }, // 
+	{ 0, 0, 0, 0 }, // 
+	{ 20, 5, 5, 1 }, // 
+	{ 30, 10, 10, 2 }, // 
+	{ 40, 20, 35, 3 }, // 
+	{ 80, 40, 40, 4 }, // 極
+};
+
+void CHARACTER::ItemDropPenalty(LPCHARACTER pkKiller)
+{
+	// 貫  쩔   苛쨈.
+	if (GetMyShop())
+		return;
+
+	if (false == LC_IsYMIR())
+	{
+		if (GetLevel() < 50)
+			return;
+	}
+
+	if (CArenaManager::Instance().IsArenaMap(GetMapIndex()))
+		return;
+
+	if (CBattleArena::instance().IsBattleArenaMap(GetMapIndex()) == true)
+		return;
+
+	struct TItemDropPenalty* table = &aItemDropPenalty_kor[0];
+
+	if (GetLevel() < 10)
+		return;
+
+	int iAlignIndex;
+	if (GetRealAlignment() >= 120000)
+		iAlignIndex = 0;
+	else if (GetRealAlignment() >= 80000)
+		iAlignIndex = 1;
+	else if (GetRealAlignment() >= 40000)
+		iAlignIndex = 2;
+	else if (GetRealAlignment() >= 10000)
+		iAlignIndex = 3;
+	else if (GetRealAlignment() >= 0)
+		iAlignIndex = 4;
+	else if (GetRealAlignment() > -40000)
+		iAlignIndex = 5;
+	else if (GetRealAlignment() > -80000)
+		iAlignIndex = 6;
+	else if (GetRealAlignment() > -120000)
+		iAlignIndex = 7;
+	else
+		iAlignIndex = 8;
+
+	std::vector<std::pair<LPITEM, int>> vec_item;
+	LPITEM pkItem;
+	int i;
+	bool isDropAllEquipments = false;
+
+	TItemDropPenalty& r = table[iAlignIndex];
+	sys_log(0, "%s align %d inven_pct %d equip_pct %d", GetName(), iAlignIndex, r.iInventoryPct, r.iEquipmentPct);
+
+	bool bDropInventory = r.iInventoryPct >= number(1, 1000);
+	bool bDropEquipment = r.iEquipmentPct >= number(1, 100);
+	bool bDropAntiDropUniqueItem = false;
+
+	if ((bDropInventory || bDropEquipment) && IsEquipUniqueItem(UNIQUE_ITEM_SKIP_ITEM_DROP_PENALTY))
+	{
+		bDropInventory = false;
+		bDropEquipment = false;
+		bDropAntiDropUniqueItem = true;
+	}
+
+	if (bDropInventory) // Drop Inventory
+	{
+		const bool bIsRunningQuest = IsRunningQuest();
+		std::vector<BYTE> vec_bSlots;
+
+		for (i = 0; i < INVENTORY_MAX_NUM; ++i)
+		{
+			pkItem = GetInventoryItem(i);
+			if (pkItem && !(bIsRunningQuest && pkItem->GetType() == ITEM_QUEST))
+				vec_bSlots.push_back(i);
+		}
+
+		if (!vec_bSlots.empty())
+		{
+			std::random_device rd;
+			std::mt19937 g(rd());
+			std::shuffle(vec_bSlots.begin(), vec_bSlots.end(), g);
+
+			int iQty = MIN(vec_bSlots.size(), r.iInventoryQty);
+
+			if (iQty)
+				iQty = number(1, iQty);
+
+			for (i = 0; i < iQty; ++i)
+			{
+				pkItem = GetInventoryItem(vec_bSlots[i]);
+
+#if defined(__MAILBOX__)
+				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP | ITEM_ANTIFLAG_MAIL))
+#else
+				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP))
+#endif
+					continue;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+				if (pkItem->IsSealed())
+					continue;
+#endif
+
+				SyncQuickslot(SLOT_TYPE_INVENTORY, vec_bSlots[i], WORD_MAX);
+				vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), INVENTORY));
+			}
+		}
+		else if (iAlignIndex == 8)
+			isDropAllEquipments = true;
+	}
+
+	if (bDropEquipment) // Drop Equipment
+	{
+		std::vector<BYTE> vec_bSlots;
+
+		for (i = 0; i < EQUIPMENT_MAX_NUM; ++i)
+			if (GetEquipmentItem(i))
+				vec_bSlots.push_back(i);
+
+		if (!vec_bSlots.empty())
+		{
+			std::random_device rd;
+			std::mt19937 g(rd());
+			std::shuffle(vec_bSlots.begin(), vec_bSlots.end(), g);
+			int iQty;
+
+			if (isDropAllEquipments)
+				iQty = vec_bSlots.size();
+			else
+				iQty = MIN(vec_bSlots.size(), number(1, r.iEquipmentQty));
+
+			if (iQty)
+				iQty = number(1, iQty);
+
+			for (i = 0; i < iQty; ++i)
+			{
+				pkItem = GetEquipmentItem(vec_bSlots[i]);
+
+#if defined(__MAILBOX__)
+				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP | ITEM_ANTIFLAG_MAIL))
+#else
+				if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_PKDROP | ITEM_ANTIFLAG_MYSHOP))
+#endif
+					continue;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				if (pkItem->IsDragonSoul())
+					continue;
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+				if (pkItem->IsSealed())
+					continue;
+#endif
+
+				SyncQuickslot(SLOT_TYPE_INVENTORY, vec_bSlots[i], WORD_MAX);
+				vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), EQUIPMENT));
+			}
+		}
+	}
+
+	if (bDropAntiDropUniqueItem)
+	{
+		LPITEM pkItem;
+
+		pkItem = GetWear(WEAR_UNIQUE1);
+
+		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_SKIP_ITEM_DROP_PENALTY)
+		{
+			SyncQuickslot(SLOT_TYPE_INVENTORY, WEAR_UNIQUE1, WORD_MAX);
+			vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), EQUIPMENT));
+		}
+
+		pkItem = GetWear(WEAR_UNIQUE2);
+
+		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_SKIP_ITEM_DROP_PENALTY)
+		{
+			SyncQuickslot(SLOT_TYPE_INVENTORY, WEAR_UNIQUE2, WORD_MAX);
+			vec_item.push_back(std::make_pair(pkItem->RemoveFromCharacter(), EQUIPMENT));
+		}
+	}
+
+	{
+		PIXEL_POSITION pos;
+		pos.x = GetX();
+		pos.y = GetY();
+
+		unsigned int i;
+
+		for (i = 0; i < vec_item.size(); ++i)
+		{
+			LPITEM item = vec_item[i].first;
+			int window = vec_item[i].second;
+
+			item->AddToGround(GetMapIndex(), pos);
+			item->StartDestroyEvent();
+
+			sys_log(0, "DROP_ITEM_PK: %s %d %d from %s", item->GetName(), pos.x, pos.y, GetName());
+			LogManager::instance().ItemLog(this, item, "DEAD_DROP", (window == INVENTORY) ? "INVENTORY" : ((window == EQUIPMENT) ? "EQUIPMENT" : ""));
+
+			pos.x = GetX() + number(-7, 7) * 20;
+			pos.y = GetY() + number(-7, 7) * 20;
+		}
+	}
+}
+
+class FPartyAlignmentCompute
+{
+public:
+	FPartyAlignmentCompute(int iAmount, int x, int y)
+	{
+		m_iAmount = iAmount;
+		m_iCount = 0;
+		m_iStep = 0;
+		m_iKillerX = x;
+		m_iKillerY = y;
+	}
+
+	void operator () (LPCHARACTER pkChr)
+	{
+		if (DISTANCE_APPROX(pkChr->GetX() - m_iKillerX, pkChr->GetY() - m_iKillerY) < PARTY_DEFAULT_RANGE)
+		{
+			if (m_iStep == 0)
+			{
+				++m_iCount;
+			}
+			else
+			{
+				pkChr->UpdateAlignment(m_iAmount / m_iCount);
+			}
+		}
+	}
+
+	int m_iAmount;
+	int m_iCount;
+	int m_iStep;
+
+	int m_iKillerX;
+	int m_iKillerY;
+};
+
+void CHARACTER::Dead(LPCHARACTER pkKiller, bool bImmediateDead)
+{
+	if (IsDead())
+		return;
+
+#if !defined(__MOUNT_COSTUME_SYSTEM__)
+	if (IsHorseRiding())
+	{
+		StopRiding();
+	}
+	else if (GetMountVnum())
+	{
+		RemoveAffect(AFFECT_MOUNT_BONUS);
+
+		m_dwMountVnum = 0;
+		UnEquipSpecialRideUniqueItem();
+
+		UpdatePacket();
+	}
+#endif
+
+	if (!pkKiller && m_dwKillerPID)
+		pkKiller = CHARACTER_MANAGER::instance().FindByPID(m_dwKillerPID);
+
+	m_dwKillerPID = 0; // 訃 珂화 瞞 DO NOT DELETE THIS LINE UNLESS YOU ARE 1000000% SURE
+
+#if defined(__SKILL_COOLTIME_UPDATE__)
+	if (IsPC())
+		ResetSkillCoolTimes();
+#endif
+
+	// 20200716.Owsap : Remove bad affects on death.
+	if (IsPC())
+		RemoveBadAffect();
+
+	ForgetMyAttacker(false);
+
+	bool isAgreedPVP = false;
+	bool isUnderGuildWar = false;
+	bool isDuel = false;
+	bool isForked = false;
+
+	if (pkKiller && pkKiller->IsPC())
+	{
+		if (pkKiller->m_pkChrTarget == this)
+			pkKiller->SetTarget(NULL);
+
+		if (!IsPC() && pkKiller->GetDungeon())
+			pkKiller->GetDungeon()->IncKillCount(pkKiller, this);
+
+		isAgreedPVP = CPVPManager::instance().Dead(this, pkKiller->GetPlayerID());
+		isDuel = CArenaManager::instance().OnDead(pkKiller, this);
+
+		if (IsPC())
+		{
+			CGuild* g1 = GetGuild();
+			CGuild* g2 = pkKiller->GetGuild();
+
+			if (g1 && g2)
+				if (g1->UnderWar(g2->GetID()))
+					isUnderGuildWar = true;
+
+			pkKiller->SetQuestNPCID(GetVID());
+			quest::CQuestManager::instance().Kill(pkKiller->GetPlayerID(), quest::QUEST_NO_NPC);
+			CGuildManager::instance().Kill(pkKiller, this);
+		}
+	}
+
+	if (IsPC())
+	{
+#if defined(__QUEST_EVENT_DEAD__)
+		if (pkKiller)
+			SetQuestNPCID(pkKiller->GetVID());
+
+		quest::CQuestManager::Instance().Dead(GetPlayerID(), (pkKiller) ? pkKiller->GetRaceNum() : quest::QUEST_NO_NPC);
+#endif
+
+		// CHECK_FORKEDROAD_WAR
+		if (CThreeWayWar::instance().IsThreeWayWarMapIndex(GetMapIndex()))
+			isForked = true;
+		// END_CHECK_FORKEDROAD_WAR
+	}
+
+	if (pkKiller &&
+		!isAgreedPVP &&
+		!isUnderGuildWar &&
+		IsPC() &&
+		!isDuel &&
+		!isForked &&
+		!IS_CASTLE_MAP(GetMapIndex()))
+	{
+		if (GetGMLevel() == GM_PLAYER || test_server)
+		{
+			ItemDropPenalty(pkKiller);
+		}
+	}
+
+	// CASTLE_SIEGE
+	if (IS_CASTLE_MAP(GetMapIndex()))
+	{
+		if (CASTLE_FROG_VNUM == GetRaceNum())
+			castle_frog_die(this, pkKiller);
+		else if (castle_is_guard_vnum(GetRaceNum()))
+			castle_guard_die(this, pkKiller);
+		else if (castle_is_tower_vnum(GetRaceNum()))
+			castle_tower_die(this, pkKiller);
+	}
+	// CASTLE_SIEGE
+
+	if (true == isForked)
+	{
+		CThreeWayWar::instance().onDead(this, pkKiller);
+	}
+
+	SetPosition(POS_DEAD);
+	ClearAffect(true);
+
+	if (pkKiller && IsPC())
+	{
+		if (!pkKiller->IsPC())
+		{
+			if (!isForked)
+			{
+				sys_log(1, "DEAD: %s %p WITH PENALTY", GetName(), this);
+				SET_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
+				LogManager::instance().CharLog(this, pkKiller->GetRaceNum(), "DEAD_BY_NPC", pkKiller->GetName());
+			}
+		}
+		else
+		{
+			sys_log(1, "DEAD_BY_PC: %s %p KILLER %s %p", GetName(), this, pkKiller->GetName(), get_pointer(pkKiller));
+			REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			pkKiller->UpdateExtBattlePassMissionProgress(KILL_PLAYER, 1, GetLevel());
+#endif
+
+			if (GetEmpire() != pkKiller->GetEmpire())
+			{
+				int iEP = MIN(GetPoint(POINT_EMPIRE_POINT), pkKiller->GetPoint(POINT_EMPIRE_POINT));
+
+				PointChange(POINT_EMPIRE_POINT, -(iEP / 10));
+				pkKiller->PointChange(POINT_EMPIRE_POINT, iEP / 5);
+
+				if (GetPoint(POINT_EMPIRE_POINT) < 10)
+				{
+					// TODO : 逃  湄躍 羚 磯.
+				}
+
+				char buf[256];
+				snprintf(buf, sizeof(buf),
+					"%d %d %d %s %d %d %d %s",
+					GetEmpire(), GetAlignment(), GetPKMode(), GetName(),
+					pkKiller->GetEmpire(), pkKiller->GetAlignment(), pkKiller->GetPKMode(), pkKiller->GetName());
+
+				LogManager::instance().CharLog(this, pkKiller->GetPlayerID(), "DEAD_BY_PC", buf);
+			}
+			else
+			{
+				if (!isAgreedPVP && !isUnderGuildWar && !IsKillerMode() && GetAlignment() >= 0 && !isDuel && !isForked)
+				{
+					int iNoPenaltyProb = 0;
+
+					if (g_iUseLocale)
+					{
+						if (pkKiller->GetAlignment() >= 0) // 1 / 3 percent down
+							iNoPenaltyProb = 33;
+						else // 4 / 5 percent down
+							iNoPenaltyProb = 20;
+					}
+
+					if (number(1, 100) < iNoPenaltyProb)
+						pkKiller->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 호   刻努求."));
+					else
+					{
+						if (g_iUseLocale && pkKiller->GetParty())
+						{
+							FPartyAlignmentCompute f(-20000, pkKiller->GetX(), pkKiller->GetY());
+							pkKiller->GetParty()->ForEachOnMapMember(f, pkKiller->GetMapIndex());
+
+							if (f.m_iCount == 0)
+								pkKiller->UpdateAlignment(-20000);
+							else
+							{
+								sys_log(0, "ALIGNMENT PARTY count %d amount %d", f.m_iCount, f.m_iAmount);
+
+								f.m_iStep = 1;
+								pkKiller->GetParty()->ForEachOnMapMember(f, pkKiller->GetMapIndex());
+							}
+						}
+						else
+							pkKiller->UpdateAlignment(-20000);
+					}
+				}
+
+				char buf[256];
+				snprintf(buf, sizeof(buf),
+					"%d %d %d %s %d %d %d %s",
+					GetEmpire(), GetAlignment(), GetPKMode(), GetName(),
+					pkKiller->GetEmpire(), pkKiller->GetAlignment(), pkKiller->GetPKMode(), pkKiller->GetName());
+
+				LogManager::instance().CharLog(this, pkKiller->GetPlayerID(), "DEAD_BY_PC", buf);
+			}
+		}
+	}
+	else
+	{
+		sys_log(1, "DEAD: %s %p", GetName(), this);
+		REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_DEATH_PENALTY);
+	}
+
+	ClearSync();
+
+	//sys_log(1, "stun cancel %s[%d]", GetName(), (DWORD)GetVID());
+	event_cancel(&m_pkStunEvent); //  遣트 灌.
+
+	if (IsPC())
+	{
+		m_dwLastDeadTime = get_dword_time();
+		SetKillerMode(false);
+		GetDesc()->SetPhase(PHASE_DEAD);
+	}
+	else
+	{
+		// 恙 赴 姑   磯.
+		if (!IS_SET(m_pointsInstant.instant_flag, INSTANT_FLAG_NO_REWARD))
+		{
+			if (!(pkKiller && pkKiller->IsPC() && pkKiller->GetGuild() && pkKiller->GetGuild()->UnderAnyWar(GUILD_WAR_TYPE_FIELD)))
+			{
+				// 활求 姑   苛쨈.
+				if (GetMobTable().dwResurrectionVnum)
+				{
+					// DUNGEON_MONSTER_REBIRTH_BUG_FIX
+					LPCHARACTER chResurrect = CHARACTER_MANAGER::instance().SpawnMob(GetMobTable().dwResurrectionVnum, GetMapIndex(), GetX(), GetY(), GetZ(), true, (int)GetRotation());
+					if (GetDungeon() && chResurrect)
+					{
+						chResurrect->SetDungeon(GetDungeon());
+					}
+					// END_OF_DUNGEON_MONSTER_REBIRTH_BUG_FIX
+
+					Reward(false);
+				}
+				else if (IsRevive() == true)
+				{
+					Reward(false);
+				}
+				else
+				{
+					Reward(true); // Drops gold, item, etc..
+				}
+			}
+			else
+			{
+				if (pkKiller->m_dwUnderGuildWarInfoMessageTime < get_dword_time())
+				{
+					pkKiller->m_dwUnderGuildWarInfoMessageTime = get_dword_time() + 60000;
+					pkKiller->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 傷    求."));
+				}
+			}
+		}
+	}
+
+	// BOSS_KILL_LOG
+	if (GetMobRank() >= MOB_RANK_BOSS && pkKiller && pkKiller->IsPC())
+	{
+		char buf[51];
+		snprintf(buf, sizeof(buf), "%d %ld", g_bChannel, pkKiller->GetMapIndex());
+		if (IsStone())
+			LogManager::instance().CharLog(pkKiller, GetRaceNum(), "STONE_KILL", buf);
+		else
+			LogManager::instance().CharLog(pkKiller, GetRaceNum(), "BOSS_KILL", buf);
+	}
+	// END_OF_BOSS_KILL_LOG
+
+	TPacketGCDead pack;
+	pack.header = HEADER_GC_DEAD;
+	pack.vid = m_vid;
+	pack.map_index = GetMapIndex();
+	pack.dialog_type = DEAD_DIALOG_NORMAL;
+
+#if defined(__ELEMENTAL_DUNGEON__)
+	if (IS_ELEMENTAL_DUNGEON(GetMapIndex()))
+		pack.dialog_type = DEAD_DIALOG_GIVE_UP;
+#endif
+
+	PacketAround(&pack, sizeof(pack));
+
+	REMOVE_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_STUN);
+
+	// 첨潔 캐見
+	if (GetDesc() != NULL)
+	{
+		//
+		// 클潔트 트 킷 母 .
+		//
+		auto it = m_list_pkAffect.begin();
+		while (it != m_list_pkAffect.end())
+			SendAffectAddPacket(GetDesc(), *it++);
+	}
+
+	//
+	// Dead 遣트 ,
+	//
+	// Dead 遣트    커 Destroy 풩 寧,
+	// PC  3 獵鳴    娩. 3  觀
+	//   , 茱    濱쨈.
+	if (isDuel == false)
+	{
+		if (m_pkDeadEvent)
+		{
+			sys_log(1, "DEAD_EVENT_CANCEL: %s %p %p", GetName(), this, get_pointer(m_pkDeadEvent));
+			event_cancel(&m_pkDeadEvent);
+		}
+
+		if (IsStone())
+			ClearStone();
+
+		if (GetDungeon())
+			GetDungeon()->DeadCharacter(this);
+
+		SCharDeadEventInfo* pEventInfo = AllocEventInfo<SCharDeadEventInfo>();
+
+		if (IsPC())
+		{
+			pEventInfo->isPC = true;
+			pEventInfo->dwID = this->GetPlayerID();
+
+			m_pkDeadEvent = event_create(dead_event, pEventInfo, PASSES_PER_SEC(180));
+		}
+		else
+		{
+			pEventInfo->isPC = false;
+			pEventInfo->dwID = this->GetVID();
+
+			if (IsRevive() == false && HasReviverInParty() == true)
+			{
+				m_pkDeadEvent = event_create(dead_event, pEventInfo, bImmediateDead ? 1 : PASSES_PER_SEC(1));
+			}
+			else
+			{
+				BYTE sec = 3;
+				if (!IsMonster())
+					sec = 10;
+
+				m_pkDeadEvent = event_create(dead_event, pEventInfo, bImmediateDead ? 1 : PASSES_PER_SEC(sec));
+			}
+		}
+
+		sys_log(1, "DEAD_EVENT_CREATE: %s %p %p", GetName(), this, get_pointer(m_pkDeadEvent));
+	}
+
+	if (m_pkExchange != NULL)
+	{
+		m_pkExchange->Cancel();
+	}
+
+	if (IsCubeOpen() == true)
+	{
+#if defined(__CUBE_RENEWAL__)
+		CCubeManager::Instance().CloseCube(this);
+#else
+		Cube_close(this);
+#endif
+	}
+
+	CShopManager::instance().StopShopping(this);
+	CloseMyShop();
+	CloseSafebox();
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	if (IsAcceRefineWindowOpen())
+		AcceRefineWindowClose(true);
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+	if (IsAuraRefineWindowOpen())
+		AuraRefineWindowClose(true);
+#endif
+
+#if defined(__MT_THUNDER_DUNGEON__)
+	if (IsMonster() && GetMobTable().dwVnum == CMTThunderDungeon::GUARDIAN_VNUM)
+		if ((pkKiller) && (pkKiller->GetMapIndex() == CMTThunderDungeon::MAP_INDEX))
+			CMTThunderDungeon::Instance().SpawnPortal(this);
+#endif
+
+	if (IsMonster() && BlueDragon::BossVnum == GetMobTable().dwVnum)
+	{
+		if (NULL != pkKiller && NULL != pkKiller->GetGuild())
+		{
+			CDragonLairManager::instance().OnDragonDead(this, pkKiller->GetGuild()->GetID());
+		}
+		else
+		{
+			sys_err("DragonLair: Dragon killed by nobody");
+		}
+	}
+
+#ifdef ENABLE_QUEEN_NETHIS
+	if ((IsStone()) || (IsMonster()))
+	{
+		if (pkKiller && pkKiller->IsPC())
+		{
+			if (SnakeLair::CSnk::instance().IsSnakeMap(pkKiller->GetMapIndex()))
+				SnakeLair::CSnk::instance().OnKill(this, pkKiller);
+		}
+	}
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (pkKiller && CGuildDragonLairManager::Instance().IsRedDragonLair(pkKiller->GetMapIndex()))
+	{
+		if (IsMonster() || IsStone())
+		{
+			CGuildDragonLair* pGuildDragonLair = pkKiller->GetGuildDragonLair();
+			if (pGuildDragonLair)
+				pGuildDragonLair->Kill(this);
+		}
+	}
+#endif
+}
+
+struct FuncSetLastAttacked
+{
+	FuncSetLastAttacked(DWORD dwTime) : m_dwTime(dwTime)
+	{
+	}
+
+	void operator () (LPCHARACTER ch)
+	{
+		ch->SetLastAttacked(m_dwTime);
+	}
+
+	DWORD m_dwTime;
+};
+
+void CHARACTER::SetLastAttacked(DWORD dwTime)
+{
+	assert(m_pkMobInst != NULL);
+
+	m_pkMobInst->m_dwLastAttackedTime = dwTime;
+	m_pkMobInst->m_posLastAttacked = GetXYZ();
+}
+
+void CHARACTER::SendDamagePacket(LPCHARACTER pAttacker, int Damage, BYTE DamageFlag)
+{
+	{
+		TPacketGCDamageInfo damageInfo;
+		memset(&damageInfo, 0, sizeof(TPacketGCDamageInfo));
+
+		damageInfo.header = HEADER_GC_DAMAGE_INFO;
+		damageInfo.dwVID = (DWORD)GetVID();
+		damageInfo.flag = DamageFlag;
+		damageInfo.damage = Damage;
+
+		if (GetDesc() != NULL)
+		{
+			GetDesc()->Packet(&damageInfo, sizeof(TPacketGCDamageInfo));
+		}
+
+		if (pAttacker && pAttacker->GetDesc())
+		{
+			if (pAttacker->GetTarget() == this)
+				pAttacker->GetDesc()->Packet(&damageInfo, sizeof(TPacketGCDamageInfo));
+		}
+
+		/*
+		if (GetArenaObserverMode() == false && GetArena() != NULL)
+		{
+			GetArena()->SendPacketToObserver(&damageInfo, sizeof(TPacketGCDamageInfo));
+		}
+		*/
+	}
+}
+
+//
+// CHARACTER::Damage 氷撚 this  蹈 磯.
+//
+// Arguments
+//	pAttacker : 
+//	dam : 
+//	EDamageType : 錚  寬?
+//
+// Return value
+//	true : dead
+//	false : not dead yet
+//
+bool CHARACTER::Damage(LPCHARACTER pAttacker, int dam, EDamageType type /*= DAMAGE_TYPE_NORMAL*/) // returns true if dead
+{
+	if (IsPC() && IsDead())
+		return false;
+
+	if (!GetSectree() || GetSectree()->IsAttr(GetX(), GetY(), ATTR_BANPK))
+		return false;
+
+	// 20190823.Owsap : Check skill affect without weapon.
+	if (pAttacker && this)
+	{
+		if (pAttacker->IsAffectFlag(AFF_GWIGUM) && !pAttacker->GetWear(WEAR_WEAPON))
+		{
+			pAttacker->RemoveAffect(SKILL_GWIGEOM);
+			return false;
+		}
+
+		if (pAttacker->IsAffectFlag(AFF_GEOMGYEONG) && !pAttacker->GetWear(WEAR_WEAPON))
+		{
+			pAttacker->RemoveAffect(SKILL_GEOMKYUNG);
+			return false;
+		}
+	}
+
+#if defined(__9TH_SKILL__)
+	if (pAttacker && FindAffect(AFFECT_CHEONUN_INVINCIBILITY))
+	{
+		SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+		return false;
+	}
+#endif
+
+#if defined(__CONQUEROR_LEVEL__)
+	if (pAttacker && pAttacker->IsNewWorldMapIndex() && pAttacker->IsPC() && !IsStone())
+	{
+		if (pAttacker->IsSungMaCursed(POINT_SUNGMA_STR))
+			dam /= 2;
+
+		int iHitPct = pAttacker->GetNewWorldSungMa(POINT_HIT_PCT);
+		if (iHitPct > 0 && iHitPct > pAttacker->GetPoint(POINT_HIT_PCT))
+		{
+			int iMissHitPct = ((iHitPct - pAttacker->GetPoint(POINT_HIT_PCT)) * 100.0) / iHitPct;
+			if (number(1, 100) <= iMissHitPct)
+			{
+				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+				return false;
+			}
+		}
+	}
+#endif
+
+#if defined(__SNOW_DUNGEON__)
+	if (pAttacker && IS_SNOW_DUNGEON(pAttacker->GetMapIndex()))
+	{
+		LPDUNGEON pDungeon = pAttacker->GetDungeon();
+		if (pDungeon)
+		{
+			switch (GetRaceNum())
+			{
+				case 8058: // Metin of Cold
+#if defined(__LABYRINTH_DUNGEON__)
+				case 8125: // TR: Metin of Cold
+				case 8135: // RX: Metin of Cold
+#endif
+				{
+					if (pDungeon->GetFlag("level") == 6)
+					{
+						if (pAttacker->GetJob() != JOB_SHAMAN)
+						{
+							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+							return false;
+						}
+					}
+				}
+				break;
+
+				case 20399: // North Dragon Pillar
+#if defined(__LABYRINTH_DUNGEON__)
+				case 20518: // TR: North Dragon Pillar
+				case 20538: // RX: North Dragon Pillar
+#endif
+				{
+					if (pDungeon->GetFlag("level") == 9)
+					{
+						if (pAttacker->GetJob() != JOB_SHAMAN && pAttacker->GetJob() != JOB_ASSASSIN)
+						{
+							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+							return false;
+						}
+					}
+				}
+				break;
+
+				case 6151: // Szel
+#if defined(__LABYRINTH_DUNGEON__)
+				case 4249: // TR: Szel
+				case 4329: // RX: Szel
+#endif
+				{
+					if (pDungeon->GetFlag("level") == 4)
+					{
+						if (!pAttacker->IsAffectFlag(AFF_HOSIN))
+						{
+							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+							return false;
+						}
+					}
+					else if (pDungeon->GetFlag("level") == 7)
+					{
+						if (!pAttacker->IsAffectFlag(AFF_GICHEON))
+						{
+							SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+							return false;
+						}
+					}
+				}
+				break;
+
+			}
+		}
+	}
+#endif
+
+#if defined(__BLUE_DRAGON_RENEWAL__)
+	if (BlueDragon_IsBoss(GetRaceNum()))
+	{
+		if (BlueDragon_Block(pAttacker->GetMapIndex()))
+		{
+			SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+			return false;
+		}
+	}
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+	if (pAttacker && GetDefenseWave())
+	{
+		if (GetDefenseWave()->Damage(this) == false)
+		{
+			SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+			return false;
+		}
+	}
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (pAttacker && CGuildDragonLairManager::Instance().IsRedDragonLair(pAttacker->GetMapIndex()))
+	{
+		if (CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
+		{
+			CGuildDragonLair* pGuildDragonLair = pAttacker->GetGuildDragonLair();
+			if (pGuildDragonLair && pGuildDragonLair->Damage(this) == false)
+			{
+				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+				return false;
+			}
+		}
+		else if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
+		{
+			SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+			return false;
+		}
+	}
+#endif
+
+	if (EDamageType::DAMAGE_TYPE_MAGIC == type)
+	{
+		dam = (int)((float)dam * (100 + (pAttacker->GetPoint(POINT_MAGIC_ATT_BONUS_PER) + pAttacker->GetPoint(POINT_MELEE_MAGIC_ATT_BONUS_PER))) / 100.f + 0.5f);
+		
+		int iMtkBonus = pAttacker->GetPoint(POINT_MAGIC_ATT_GRADE_BONUS);
+		if (iMtkBonus > 0)
+		{
+			int iRawMtkBonus = dam * iMtkBonus / 100;
+			float fAdjFactor = iMtkBonus / 10.0f - 2.5f;
+			int iFinalMtkBonus = int(iRawMtkBonus / 100.0f * fAdjFactor + 0.5f);
+			dam += iFinalMtkBonus;
+		}
+	}
+
+	if (GetRaceNum() == 5001)
+	{
+		bool bDropMoney = false;
+		int iPercent = 0;
+		if (GetMaxHP() >= 0)
+			iPercent = (GetHP() * 100) / GetMaxHP();
+
+		if (iPercent <= 10 && GetMaxSP() < 5)
+		{
+			SetMaxSP(5);
+			bDropMoney = true;
+		}
+		else if (iPercent <= 20 && GetMaxSP() < 4)
+		{
+			SetMaxSP(4);
+			bDropMoney = true;
+		}
+		else if (iPercent <= 40 && GetMaxSP() < 3)
+		{
+			SetMaxSP(3);
+			bDropMoney = true;
+		}
+		else if (iPercent <= 60 && GetMaxSP() < 2)
+		{
+			SetMaxSP(2);
+			bDropMoney = true;
+		}
+		else if (iPercent <= 80 && GetMaxSP() < 1)
+		{
+			SetMaxSP(1);
+			bDropMoney = true;
+		}
+
+		if (bDropMoney)
+		{
+			DWORD dwGold = 1000;
+			int iSplitCount = number(10, 13);
+
+			sys_log(0, "WAEGU DropGoldOnHit %d times", GetMaxSP());
+
+			for (int i = 1; i <= iSplitCount; ++i)
+			{
+				PIXEL_POSITION pos;
+				LPITEM item;
+
+				if ((item = ITEM_MANAGER::instance().CreateItem(1, dwGold / iSplitCount)))
+				{
+					if (i != 0)
+					{
+						pos.x = (number(-14, 14) + number(-14, 14)) * 20;
+						pos.y = (number(-14, 14) + number(-14, 14)) * 20;
+
+						pos.x += GetX();
+						pos.y += GetY();
+					}
+
+					item->AddToGround(GetMapIndex(), pos);
+					item->StartDestroyEvent();
+				}
+			}
+		}
+	}
+
+	// 타 틈   처
+	if (type != EDamageType::DAMAGE_TYPE_NORMAL && type != EDamageType::DAMAGE_TYPE_NORMAL_RANGE)
+	{
+		if (IsAffectFlag(AFF_TERROR))
+		{
+			int pct = GetSkillPower(SKILL_TERROR) / 400;
+
+			if (number(1, 100) <= pct)
+				return false;
+		}
+	}
+
+	int iCurHP = GetHP();
+	int iCurSP = GetSP();
+
+	bool IsCritical = false;
+	bool IsPenetrate = false;
+	bool IsDeathBlow = false;
+
+	//PROF_UNIT puAttr("Attr");
+
+	//
+	//  킬,  킬(微) 크티챨,   磯.
+	//   刻틴 求쨉 Nerf(牟酉)치   底 크티챨
+	//     歌, /2 鵑臼 磯.
+	//
+	//  潔薩璲 티 龜 킬 煞
+	//
+	// 20091109 : 怜  청   均,     70% 
+	//
+	if (type == EDamageType::DAMAGE_TYPE_MELEE || type == EDamageType::DAMAGE_TYPE_RANGE || type == EDamageType::DAMAGE_TYPE_MAGIC)
+	{
+		if (pAttacker)
+		{
+			// 크티
+			int iCriticalPct = pAttacker->GetPoint(POINT_CRITICAL_PCT);
+
+			if (!IsPC())
+				iCriticalPct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_CRITICAL_BONUS);
+
+			if (iCriticalPct)
+			{
+				if (iCriticalPct >= 10) // 10 크 5% + (4 1% ),  치 50見 20%
+					iCriticalPct = 5 + (iCriticalPct - 10) / 4;
+				else // 10  秉  , 10 = 5%
+					iCriticalPct /= 2;
+
+				// 크티   .
+				iCriticalPct -= GetPoint(POINT_RESIST_CRITICAL);
+
+				if (number(1, 100) <= iCriticalPct)
+				{
+					IsCritical = true;
+
+					// NOTE : According to the planner, in 2018 the critical damage multiplier in PvP
+					// was adjusted from 2 to 1.5 in order to balance the damage.
+					dam *= 1.5; // 2.0
+
+					EffectPacket(SE_CRITICAL);
+
+					if (IsAffectFlag(AFF_MANASHIELD))
+					{
+						RemoveAffect(AFF_MANASHIELD);
+					}
+				}
+			}
+
+			// 
+			int iPenetratePct = pAttacker->GetPoint(POINT_PENETRATE_PCT);
+
+			if (!IsPC())
+				iPenetratePct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_PENETRATE_BONUS);
+
+			if (iPenetratePct)
+			{
+				{
+					CSkillProto* pkSk = CSkillManager::instance().Get(SKILL_RESIST_PENETRATE);
+
+					if (NULL != pkSk)
+					{
+						pkSk->SetPointVar("k", 1.0f * GetSkillPower(SKILL_RESIST_PENETRATE) / 100.0f);
+
+						iPenetratePct -= static_cast<int>(pkSk->kPointPoly.Eval());
+					}
+				}
+
+				if (iPenetratePct >= 10)
+				{
+					// 10 크 5% + (4 1% ),  치 50見 20%
+					iPenetratePct = 5 + (iPenetratePct - 10) / 4;
+				}
+				else
+				{
+					// 10  秉  , 10 = 5%
+					iPenetratePct /= 2;
+				}
+
+				// 타   .
+				iPenetratePct -= GetPoint(POINT_RESIST_PENETRATE);
+
+				if (number(1, 100) <= iPenetratePct)
+				{
+					IsPenetrate = true;
+
+					if (test_server)
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 煞  %d", GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100));
+
+					dam += GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100;
+					if (iPenetratePct > 100)
+						dam += dam * (iPenetratePct - 100) / 200;
+
+					EffectPacket(SE_PENETRATE);
+
+					if (IsAffectFlag(AFF_MANASHIELD))
+					{
+						RemoveAffect(AFF_MANASHIELD);
+					}
+				}
+			}
+		}
+	}
+	//
+	// 頻 , 활 ,  타   憺  磯.
+	//
+	else if (type == EDamageType::DAMAGE_TYPE_NORMAL || type == EDamageType::DAMAGE_TYPE_NORMAL_RANGE)
+	{
+		if (type == EDamageType::DAMAGE_TYPE_NORMAL)
+		{
+			//  타    
+			if (GetPoint(POINT_BLOCK) && number(1, 100) <= GetPoint(POINT_BLOCK))
+			{
+				if (test_server)
+				{
+					pAttacker->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ! (%d%%)", GetName(), GetPoint(POINT_BLOCK)));
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ! (%d%%)", GetName(), GetPoint(POINT_BLOCK)));
+				}
+
+				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+				return false;
+			}
+
+			if (GetPoint(POINT_NORMAL_DAMAGE_GUARD) && number(1, 100) <= GetPoint(POINT_NORMAL_DAMAGE_GUARD))
+			{
+				SendDamagePacket(pAttacker, 0, DAMAGE_BLOCK);
+				return false;
+			}
+		}
+		else if (type == EDamageType::DAMAGE_TYPE_NORMAL_RANGE)
+		{
+			// 타 타    
+			if (GetPoint(POINT_DODGE) && number(1, 100) <= GetPoint(POINT_DODGE))
+			{
+				if (test_server)
+				{
+					pAttacker->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 회! (%d%%)", GetName(), GetPoint(POINT_DODGE)));
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 회! (%d%%)", GetName(), GetPoint(POINT_DODGE)));
+				}
+
+				SendDamagePacket(pAttacker, 0, DAMAGE_DODGE);
+				return false;
+			}
+		}
+
+		if (IsAffectFlag(AFF_JEONGWIHON))
+			dam = (int)(dam * (100 + GetSkillPower(SKILL_JEONGWI) * 25 / 100) / 100);
+
+		if (IsAffectFlag(AFF_TERROR))
+			dam = (int)(dam * (95 - GetSkillPower(SKILL_TERROR) / 5) / 100);
+
+		if (IsAffectFlag(AFF_HOSIN))
+			dam = dam * (100 - GetPoint(POINT_RESIST_NORMAL_DAMAGE)) / 100;
+
+		//
+		//  憺 
+		//
+		if (pAttacker)
+		{
+			if (type == EDamageType::DAMAGE_TYPE_NORMAL)
+			{
+				// 部
+				if (GetPoint(POINT_REFLECT_MELEE))
+				{
+					int reflectDamage = dam * GetPoint(POINT_REFLECT_MELEE) / 100;
+
+					// NOTE: 微 IMMUNE_REFLECT 憺 獵摸 部潁  求  
+					// 틈灸 1/3  漫 載 획 청.
+					if (pAttacker->IsImmune(IMMUNE_REFLECT))
+						reflectDamage = int(reflectDamage / 3.0f + 0.5f);
+
+					if (reflectDamage > 0)
+						pAttacker->Damage(this, reflectDamage, DAMAGE_TYPE_SPECIAL);
+				}
+			}
+
+			// 크티
+			int iCriticalPct = pAttacker->GetPoint(POINT_CRITICAL_PCT);
+
+			if (!IsPC())
+				iCriticalPct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_CRITICAL_BONUS);
+
+			if (iCriticalPct)
+			{
+				//크티   .
+				iCriticalPct -= GetPoint(POINT_RESIST_CRITICAL);
+
+				if (number(1, 100) <= iCriticalPct)
+				{
+					IsCritical = true;
+					dam *= 2;
+					EffectPacket(SE_CRITICAL);
+				}
+			}
+
+			// 
+			int iPenetratePct = pAttacker->GetPoint(POINT_PENETRATE_PCT);
+
+			if (!IsPC())
+				iPenetratePct += pAttacker->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_PENETRATE_BONUS);
+
+			{
+				CSkillProto* pkSk = CSkillManager::instance().Get(SKILL_RESIST_PENETRATE);
+
+				if (NULL != pkSk)
+				{
+					pkSk->SetPointVar("k", 1.0f * GetSkillPower(SKILL_RESIST_PENETRATE) / 100.0f);
+
+					iPenetratePct -= static_cast<int>(pkSk->kPointPoly.Eval());
+				}
+			}
+
+			if (iPenetratePct)
+			{
+				// 타   .
+				iPenetratePct -= GetPoint(POINT_RESIST_PENETRATE);
+
+				if (number(1, 100) <= iPenetratePct)
+				{
+					IsPenetrate = true;
+
+					if (test_server)
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 煞  %d", GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100));
+
+					dam += GetPoint(POINT_DEF_GRADE) * (100 + GetPoint(POINT_DEF_BONUS)) / 100;
+					if (iPenetratePct > 100)
+						dam += dam * (iPenetratePct - 100) / 200;
+
+					EffectPacket(SE_PENETRATE);
+				}
+			}
+
+			// HP 틸
+			if (pAttacker->GetPoint(POINT_STEAL_HP))
+			{
+				int pct = 1;
+
+				if (number(1, 10) <= pct)
+				{
+					int iHP = MIN(dam, MAX(0, iCurHP)) * pAttacker->GetPoint(POINT_STEAL_HP) / 100;
+
+					if (iHP > 0 && GetHP() >= iHP)
+					{
+						CreateFly(FLY_HP_SMALL, pAttacker);
+						pAttacker->PointChange(POINT_HP, iHP);
+						PointChange(POINT_HP, -iHP);
+					}
+				}
+			}
+
+			// SP 틸
+			if (pAttacker->GetPoint(POINT_STEAL_SP))
+			{
+				int pct = 1;
+
+				if (number(1, 10) <= pct)
+				{
+					int iCur;
+
+					if (IsPC())
+						iCur = iCurSP;
+					else
+						iCur = iCurHP;
+
+					int iSP = MIN(dam, MAX(0, iCur)) * pAttacker->GetPoint(POINT_STEAL_SP) / 100;
+
+					if (iSP > 0 && iCur >= iSP)
+					{
+						CreateFly(FLY_SP_SMALL, pAttacker);
+						pAttacker->PointChange(POINT_SP, iSP);
+
+						if (IsPC())
+							PointChange(POINT_SP, -iSP);
+					}
+				}
+			}
+
+			//  틸
+			if (pAttacker->GetPoint(POINT_STEAL_GOLD))
+			{
+				if (number(1, 100) <= pAttacker->GetPoint(POINT_STEAL_GOLD))
+				{
+					long llAmount = number(1, GetLevel());
+					pAttacker->PointChange(POINT_GOLD, llAmount);
+					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 1, llAmount);
+				}
+			}
+
+			// 칠  HP회
+			if (pAttacker->GetPoint(POINT_HIT_HP_RECOVERY) && number(0, 4) > 0) // 80% 확
+			{
+				int i = ((iCurHP >= 0) ? MIN(dam, iCurHP) : dam) * pAttacker->GetPoint(POINT_HIT_HP_RECOVERY) / 100;
+
+				if (i)
+				{
+					CreateFly(FLY_HP_SMALL, pAttacker);
+					pAttacker->PointChange(POINT_HP, i);
+				}
+			}
+
+			// 칠  SP회
+			if (pAttacker->GetPoint(POINT_HIT_SP_RECOVERY) && number(0, 4) > 0) // 80% 확
+			{
+				int i = ((iCurHP >= 0) ? MIN(dam, iCurHP) : dam) * pAttacker->GetPoint(POINT_HIT_SP_RECOVERY) / 100;
+
+				if (i)
+				{
+					CreateFly(FLY_SP_SMALL, pAttacker);
+					pAttacker->PointChange(POINT_SP, i);
+				}
+			}
+
+			//   娩.
+			if (pAttacker->GetPoint(POINT_MANA_BURN_PCT))
+			{
+				if (number(1, 100) <= pAttacker->GetPoint(POINT_MANA_BURN_PCT))
+					PointChange(POINT_SP, -50);
+			}
+		}
+	}
+
+	//
+	// 타 풔 킬  駕 / 
+	//
+	switch (type)
+	{
+		case EDamageType::DAMAGE_TYPE_NORMAL:
+		case EDamageType::DAMAGE_TYPE_NORMAL_RANGE:
+		{
+			if (pAttacker)
+			{
+				if (pAttacker->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS))
+					dam = dam * (100 + pAttacker->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS)) / 100;
+
+#if defined(__SOUL_SYSTEM__) && !defined(__SOUL_SYSTEM_CALC_FINAL_DAMAGE__)
+				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_RED))
+					dam = dam * (100 + pAttacker->GetSoulDamage(RED_SOUL)) / 100;
+#endif
+			}
+
+			dam = dam * (100 - MIN(99, GetPoint(POINT_NORMAL_HIT_DEFEND_BONUS))) / 100;
+
+			{
+				DWORD dwDmgHPRecover = GetPoint(POINT_DAMAGE_HP_RECOVERY);
+				if (dwDmgHPRecover != 0)
+				{
+					int iHPRecover = (float(dwDmgHPRecover) / 100) * dam;
+					PointChange(POINT_HP, iHPRecover);
+					CreateFly(FLY_HP_SMALL, this);
+				}
+
+				DWORD dwDmgSPRecover = GetPoint(POINT_DAMAGE_SP_RECOVERY);
+				if (dwDmgSPRecover != 0)
+				{
+					int iSPRecover = (float(dwDmgSPRecover) / 100) * dam;
+					PointChange(POINT_SP, iSPRecover);
+					CreateFly(FLY_SP_SMALL, this);
+				}
+			}
+		}
+		break;
+
+		case EDamageType::DAMAGE_TYPE_MELEE:
+		case EDamageType::DAMAGE_TYPE_RANGE:
+		case EDamageType::DAMAGE_TYPE_FIRE:
+		case EDamageType::DAMAGE_TYPE_ICE:
+		case EDamageType::DAMAGE_TYPE_ELEC:
+		case EDamageType::DAMAGE_TYPE_MAGIC:
+		{
+			if (pAttacker)
+			{
+				if (pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS))
+					dam = dam * (100 + pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS)) / 100;
+
+#if defined(__SOUL_SYSTEM__) && !defined(__SOUL_SYSTEM_CALC_FINAL_DAMAGE__)
+				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_BLUE))
+					dam = dam * (100 + pAttacker->GetSoulDamage(BLUE_SOUL)) / 100;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+				if (pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE))
+					if (IsMonster() && GetMobRank() >= MOB_RANK_BOSS)
+						dam = dam * (100 + pAttacker->GetPoint(POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE)) / 100;
+
+				if (GetPoint(POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE))
+					if (pAttacker->IsMonster() && pAttacker->GetMobRank() >= MOB_RANK_BOSS)
+						dam = dam * (100 - MIN(99, GetPoint(POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE))) / 100;
+#endif
+			}
+
+			dam = dam * (100 - MIN(99, GetPoint(POINT_SKILL_DEFEND_BONUS))) / 100;
+		}
+		break;
+
+		default:
+			break;
+	}
+
+	//
+	// (탉호)
+	//
+	if (IsAffectFlag(AFF_MANASHIELD))
+	{
+		// POINT_MANASHIELD  訪 
+		int iDamageSPPart = dam / 3;
+		int iDamageToSP = iDamageSPPart * GetPoint(POINT_MANASHIELD) / 100;
+		int iSP = GetSP();
+
+		// SP     
+		if (iDamageToSP <= iSP)
+		{
+			PointChange(POINT_SP, -iDamageToSP);
+			dam -= iDamageSPPart;
+		}
+		else
+		{
+			// 킹 眉 품  占⒡
+			PointChange(POINT_SP, -GetSP());
+			dam -= iSP * 100 / MAX(GetPoint(POINT_MANASHIELD), 1);
+		}
+	}
+
+	//
+	// 체   ( )
+	//
+	if (GetPoint(POINT_MALL_DEFBONUS) > 0)
+	{
+		int dec_dam = MIN(200, dam * GetPoint(POINT_MALL_DEFBONUS) / 100);
+		dam -= dec_dam;
+	}
+
+	if (pAttacker)
+	{
+		//
+		// 체 賦  ( )
+		//
+		if (pAttacker->GetPoint(POINT_MALL_ATTBONUS) > 0)
+		{
+			int add_dam = MIN(300, dam * pAttacker->GetLimitPoint(POINT_MALL_ATTBONUS) / 100);
+			dam += add_dam;
+		}
+
+		//
+		//   駕 (畸 천  )
+		//
+		int iEmpire = GetEmpire();
+		long lMapIndex = GetMapIndex();
+		int iMapEmpire = SECTREE_MANAGER::instance().GetEmpireFromMapIndex(lMapIndex);
+
+		// Damage increased by 10% for pc empire
+		if (iEmpire && iMapEmpire && iEmpire != iMapEmpire)
+			dam += (dam * 10) / 100;
+
+		if (pAttacker->IsPC())
+		{
+			iEmpire = pAttacker->GetEmpire();
+			lMapIndex = pAttacker->GetMapIndex();
+			iMapEmpire = SECTREE_MANAGER::instance().GetEmpireFromMapIndex(lMapIndex);
+
+			// Damage reduced by 10% for other empires
+			/*
+			if (iEmpire && iMapEmpire && iEmpire != iMapEmpire)
+			{
+				int percent = 10;
+
+				if (184 <= lMapIndex && lMapIndex <= 189)
+					percent = 9;
+				else
+					percent = 9;
+
+				dam = dam * percent / 10;
+			}
+			*/
+
+			if (!IsPC() && GetMonsterDrainSPPoint())
+			{
+				int iDrain = GetMonsterDrainSPPoint();
+
+				if (iDrain <= pAttacker->GetSP())
+					pAttacker->PointChange(POINT_SP, -iDrain);
+				else
+				{
+					int iSP = pAttacker->GetSP();
+					pAttacker->PointChange(POINT_SP, -iSP);
+				}
+			}
+		}
+		else if (pAttacker->IsGuardNPC())
+		{
+			SET_BIT(m_pointsInstant.instant_flag, INSTANT_FLAG_NO_REWARD);
+			Stun();
+			return true;
+		}
+
+		//
+		//  腑 &  
+		//
+		if (pAttacker->IsPC() && CMonarch::instance().IsPowerUp(pAttacker->GetEmpire()))
+		{
+			// 10%  
+			dam += dam / 10;
+		}
+
+		if (IsPC() && CMonarch::instance().IsDefenceUp(GetEmpire()))
+		{
+			// 10%  
+			dam -= dam / 10;
+		}
+
+#if defined(__SOUL_SYSTEM__) && defined(__SOUL_SYSTEM_CALC_FINAL_DAMAGE__)
+		switch (type)
+		{
+			case EDamageType::DAMAGE_TYPE_NORMAL:
+			case EDamageType::DAMAGE_TYPE_NORMAL_RANGE:
+			{
+				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_RED))
+				{
+					if (!pAttacker->IsPolymorphed() && !IsPC())
+					{
+						float fDamMultiplier = static_cast<float>(100 * pAttacker->GetSoulDamage(RED_SOUL)) / 1000;
+						if (fDamMultiplier != 0)
+							dam = (int)(dam * fDamMultiplier);
+					}
+				}
+			}
+			break;
+
+			case EDamageType::DAMAGE_TYPE_MELEE:
+			case EDamageType::DAMAGE_TYPE_RANGE:
+			case EDamageType::DAMAGE_TYPE_FIRE:
+			case EDamageType::DAMAGE_TYPE_ICE:
+			case EDamageType::DAMAGE_TYPE_ELEC:
+			case EDamageType::DAMAGE_TYPE_MAGIC:
+			{
+				if (pAttacker->FindAffect(AFFECT_SOUL, AFF_SOUL_BLUE))
+				{
+					if (!pAttacker->IsPolymorphed() && !IsPC())
+					{
+						float fDamMultiplier = static_cast<float>(100 * pAttacker->GetSoulDamage(BLUE_SOUL)) / 1000;
+						if (fDamMultiplier != 0)
+							dam = (int)(dam * fDamMultiplier);
+					}
+				}
+			}
+			break;
+		}
+#endif
+	}
+	//puAttr.Pop();
+
+	if (!GetSectree() || GetSectree()->IsAttr(GetX(), GetY(), ATTR_BANPK))
+		return false;
+
+	if (!IsPC())
+	{
+		if (m_pkParty && m_pkParty->GetLeader())
+			m_pkParty->GetLeader()->SetLastAttacked(get_dword_time());
+		else
+			SetLastAttacked(get_dword_time());
+
+		//   :  
+		MonsterChat(MONSTER_CHAT_ATTACKED);
+	}
+
+	if (IsStun())
+	{
+		Dead(pAttacker);
+		return true;
+	}
+
+	if (IsDead())
+		return true;
+
+	//    茄 .
+	if (type == DAMAGE_TYPE_POISON)
+	{
+		if (GetHP() - dam <= 0)
+		{
+			dam = GetHP() - 1;
+		}
+	}
+
+	else if (type == DAMAGE_TYPE_BLEEDING)
+	{
+		if (GetHP() - dam <= 0)
+		{
+			dam = GetHP();
+		}
+	}
+
+	// ------------------------
+	//  潔  
+	// -----------------------
+	if (pAttacker && pAttacker->IsPC())
+	{
+		int iDmgPct = CHARACTER_MANAGER::instance().GetUserDamageRate(pAttacker);
+		dam = dam * iDmgPct / 100;
+	}
+
+	// STONE SKIN :   
+	if (IsMonster() && IsStoneSkinner())
+	{
+		if (GetHPPct() < GetMobTable().bStoneSkinPoint)
+			dam /= 2;
+	}
+
+	//PROF_UNIT puRest1("Rest1");
+	if (pAttacker)
+	{
+		// DEATH BLOW : 확  4  (!?  遣트  拷 )
+		if (pAttacker->IsMonster() && pAttacker->IsDeathBlower())
+		{
+			if (pAttacker->IsDeathBlow())
+			{
+				int rate = 2 * MINMAX(1, 51 - pAttacker->GetHPPct(), 50);
+				if (GetPoint(POINT_BLOCK) > 0 && number(1, 100) <= GetPoint(POINT_BLOCK))
+				{
+					rate -= MINMAX(1, GetPoint(POINT_BLOCK), 75);
+				}
+
+				IsDeathBlow = true;
+				dam *= (int)(1.5 + 1.5 * rate / 100.0);
+			}
+		}
+
+		// MOUNT_FALL
+		if (pAttacker->IsMonster() && pAttacker->IsFaller())
+		{
+			unsigned int iUnMountChance = 30 - GetPoint(POINT_RESIST_MOUNT_FALL);
+			if (number(1, 100) <= iUnMountChance)
+			{
+				if (!FindAffect(AFFECT_MOUNT_FALL))
+					AddAffect(AFFECT_MOUNT_FALL, POINT_NONE, 0, AFF_NONE, 5, 0, true);
+			}
+		}
+		// END_OF_MOUNT_FALL
+
+		dam = BlueDragon_Damage(this, pAttacker, dam);
+	}
+
+	BYTE damageFlag = 0;
+
+	if (type == DAMAGE_TYPE_POISON)
+		damageFlag = DAMAGE_POISON;
+	else if (type == DAMAGE_TYPE_BLEEDING)
+		damageFlag = DAMAGE_BLEEDING;
+	else
+		damageFlag = DAMAGE_NORMAL;
+
+	if (IsCritical == true)
+		damageFlag |= DAMAGE_CRITICAL;
+
+	if (IsPenetrate == true)
+		damageFlag |= DAMAGE_PENETRATE;
+
+	//   
+	float damMul = this->GetDamMul();
+	float tempDam = dam;
+	dam = tempDam * damMul + 0.5f;
+
+	//if (pAttacker)
+	SendDamagePacket(pAttacker, dam, damageFlag);
+
+	if (test_server && g_bTestMobLog)
+	{
+		int iPercent = 0;
+		if (GetMaxHP() >= 0)
+			iPercent = (GetHP() * 100) / GetMaxHP();
+
+		if (pAttacker)
+		{
+			pAttacker->ChatPacket(CHAT_TYPE_INFO, "-> %s, DAM %d HP %d(%d%%) %s%s",
+				GetName(),
+				dam,
+				GetHP(),
+				iPercent,
+				IsCritical ? "crit " : "",
+				IsPenetrate ? "pene " : "",
+				IsDeathBlow ? "deathblow " : "");
+		}
+
+		ChatPacket(CHAT_TYPE_PARTY, "<- %s, DAM %d HP %d(%d%%) %s%s",
+			pAttacker ? pAttacker->GetName() : 0,
+			dam,
+			GetHP(),
+			iPercent,
+			IsCritical ? "crit " : "",
+			IsPenetrate ? "pene " : "",
+			IsDeathBlow ? "deathblow " : "");
+	}
+
+	if (pAttacker)
+	{
+		if (m_bDetailLog)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s[%d]  치: %d %d", pAttacker->GetName(), (DWORD)pAttacker->GetVID(), pAttacker->GetX(), pAttacker->GetY()));
+		}
+	}
+
+	//
+	// !!!!!!!!!  HP 甄 觀 !!!!!!!!!
+	//
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	if (type != DAMAGE_TYPE_POISON)
+	{
+		if (IsPC())
+			pAttacker->UpdateExtBattlePassMissionProgress(DAMAGE_PLAYER, dam, GetLevel());
+		else
+			pAttacker->UpdateExtBattlePassMissionProgress(DAMAGE_MONSTER, dam, GetRaceNum());
+	}
+#endif
+
+	if (!cannot_dead)
+	{
+		dam = (GetHP() - dam <= 0) ? GetHP() : dam;
+
+#if defined(__QUEST_EVENT_DAMAGE__)
+		if (pAttacker && pAttacker->IsPC())
+		{
+			pAttacker->SetQuestNPCID(GetVID());
+			quest::CQuestManager::instance().Damage(pAttacker->GetPlayerID(), GetRaceNum());
+		}
+#endif
+
+		PointChange(POINT_HP, -dam, false);
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+		if (pAttacker && CGuildDragonLairManager::Instance().IsRedDragonLair(pAttacker->GetMapIndex()))
+		{
+			if (GetHP() == 0 && CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
+			{
+				PointChange(POINT_HP, 1, false);
+			}
+		}
+#endif
+	}
+
+	//puRest1.Pop();
+
+	//PROF_UNIT puRest2("Rest2");
+	if (pAttacker && dam > 0 && IsNPC())
+	{
+		//PROF_UNIT puRest20("Rest20");
+		TDamageMap::iterator it = m_map_kDamage.find(pAttacker->GetVID());
+
+		if (it == m_map_kDamage.end())
+		{
+			m_map_kDamage.insert(TDamageMap::value_type(pAttacker->GetVID(), TBattleInfo(dam, 0)));
+			it = m_map_kDamage.find(pAttacker->GetVID());
+		}
+		else
+		{
+			it->second.iTotalDamage += dam;
+		}
+		//puRest20.Pop();
+
+		//PROF_UNIT puRest21("Rest21");
+		StartRecoveryEvent(); // 姑   회 磯.
+		//puRest21.Pop();
+
+		//PROF_UNIT puRest22("Rest22");
+		UpdateAggrPointEx(pAttacker, type, dam, it->second);
+		//puRest22.Pop();
+
+		pAttacker->SetAccumulatedDamage(dam);
+	}
+	//puRest2.Pop();
+
+	//PROF_UNIT puRest3("Rest3");
+	if (GetHP() <= 0)
+	{
+		if (IsMonster())
+			Dead(pAttacker);
+		else
+			Stun(true);
+
+		if (pAttacker && !pAttacker->IsNPC())
+			m_dwKillerPID = pAttacker->GetPlayerID();
+		else
+			m_dwKillerPID = 0;
+	}
+
+	return false;
+}
+
+void CHARACTER::DistributeHP(LPCHARACTER pkKiller)
+{
+	if (pkKiller->GetDungeon()) //  寬苛쨈
+		return;
+}
+
+#if defined(__CONQUEROR_LEVEL__)
+static void GiveExp(LPCHARACTER from, LPCHARACTER to, int iExp, int iConquerorExp)
+#else
+static void GiveExp(LPCHARACTER from, LPCHARACTER to, int iExp)
+#endif
+{
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	to->UpdateExtBattlePassMissionProgress(EXP_COLLECT, iExp, from->GetRaceNum());
+#endif
+	{
+		LPITEM pkItem;
+
+		pkItem = to->GetWear(WEAR_UNIQUE1);
+
+		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_ANTI_EXP)
+		{
+			if (test_server)
+				to->ChatPacket(CHAT_TYPE_INFO, "exp blocked by ring %d", UNIQUE_ITEM_ANTI_EXP);
+			return;
+		}
+
+		pkItem = to->GetWear(WEAR_UNIQUE2);
+		if (pkItem && pkItem->GetVnum() == UNIQUE_ITEM_ANTI_EXP)
+		{
+			if (test_server)
+				to->ChatPacket(CHAT_TYPE_INFO, "exp blocked by ring %d", UNIQUE_ITEM_ANTI_EXP);
+			return;
+		}
+	}
+
+	//  치 
+	iExp = CALCULATE_VALUE_LVDELTA(to->GetLevel(), from->GetLevel(), iExp);
+	const int iBaseExp = iExp;
+
+#if defined(__CONQUEROR_LEVEL__)
+	iConquerorExp = CALCULATE_VALUE_LVDELTA(to->GetLevel(), from->GetLevel(), iConquerorExp);
+	const int iBaseConquerorExp = iConquerorExp;
+#endif
+
+	int iRate = 100;
+
+	// , 회 치 遣트 
+	iRate += CPrivManager::instance().GetPriv(to, PRIV_EXP_PCT);
+
+	// 鄲 羞 풔 치 駕
+	{
+		// 逾 濱
+		if (to->IsEquipUniqueItem(UNIQUE_ITEM_LARBOR_MEDAL))
+			iRate += 20;
+
+		// Devil tower experience bonus
+		if (to->GetMapIndex() >= 660000 && to->GetMapIndex() < 670000)
+			iRate += 20; // 1.2 (20%)
+
+		//  치 菅 憺
+		if (to->GetPoint(POINT_EXP_DOUBLE_BONUS))
+			if (number(1, 100) <= to->GetPoint(POINT_EXP_DOUBLE_BONUS))
+				iRate += 30; // 1.3 (30%)
+
+		//   (2챨짜)
+		// NOTE: Experience rings now work like special rings.
+		/*
+		if (to->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_EXP))
+		{
+			iRate += 50; // (50%)
+			if (test_server)
+				to->ChatPacket(CHAT_TYPE_INFO, "exp bonus + 50% (using ring)");
+		}
+		*/
+
+		//   퓔 치 駕
+		if (to->GetPremiumRemainSeconds(PREMIUM_EXP) > 0) //  : 치 
+			iRate += 50;
+
+		iRate += to->GetMarriageBonus(UNIQUE_ITEM_MARRIAGE_EXP_BONUS); // 혼 駕
+		iRate += to->GetPoint(POINT_RAMADAN_CANDY_BONUS_EXP);
+		iRate += to->GetPoint(POINT_MALL_EXPBONUS);
+	}
+
+	if (test_server)
+	{
+		sys_log(0, "Bonus Exp : Ramadan Candy: %d MallExp: %d PointExp: %d",
+			to->GetPoint(POINT_RAMADAN_CANDY_BONUS_EXP),
+			to->GetPoint(POINT_MALL_EXPBONUS),
+			to->GetPoint(POINT_EXP)
+		);
+	}
+
+	// 획  2005.04.21  85%
+	iRate *= CHARACTER_MANAGER::instance().GetMobExpRate(to) / 100;
+
+	iExp *= (iRate / 100.0);
+#if defined(__CONQUEROR_LEVEL__)
+	iConquerorExp *= (iRate / 100.0);
+#endif
+
+	// 치 箕 획曆 
+	//iExp = MIN(to->GetNextExp() / 10, iExp);
+
+	//iExp = AdjustExpByLevel(to, iExp);
+
+	if (iBaseExp)
+	{
+		to->PointChange(POINT_EXP, iExp, true);
+		from->CreateFly(FLY_EXP, to);
+	}
+
+#if defined(__CONQUEROR_LEVEL__)
+	if (iBaseConquerorExp && to->GetConquerorLevel() > 0)
+	{
+		to->PointChange(POINT_CONQUEROR_EXP, iConquerorExp, true);
+		from->CreateFly(FLY_CONQUEROR_EXP, to);
+	}
+#endif
+
+	{
+		LPCHARACTER you = to->GetMarryPartner();
+		// 觀寬  티見 阜 
+		if (you)
+		{
+			// 1 100%
+			DWORD dwUpdatePoint = 2000 * iExp / to->GetLevel() / to->GetLevel() / 3;
+
+			if (to->GetPremiumRemainSeconds(PREMIUM_MARRIAGE_FAST) > 0 ||
+				you->GetPremiumRemainSeconds(PREMIUM_MARRIAGE_FAST) > 0)
+				dwUpdatePoint *= 3;
+
+			marriage::TMarriage* pMarriage = marriage::CManager::Instance().Get(to->GetPlayerID());
+
+			// DIVORCE_NULL_BUG_FIX
+			if (pMarriage && pMarriage->IsNear())
+				pMarriage->Update(dwUpdatePoint);
+			// END_OF_DIVORCE_NULL_BUG_FIX
+		}
+	}
+#ifdef __GROWTH_PET_SYSTEM__
+	if (to->GetActiveGrowthPet())
+	{
+		to->GetActiveGrowthPet()->RewardEXP(EXP_TYPE_MOB, iBaseExp);
+		from->CreateFly(FLY_EXP, to->GetActiveGrowthPet()->GetGrowthPet());
+	}
+#endif
+}
+
+namespace NPartyExpDistribute
+{
+	struct FPartyTotaler
+	{
+		int total;
+		int member_count;
+		int x, y;
+
+		FPartyTotaler(LPCHARACTER center)
+			: total(0), member_count(0), x(center->GetX()), y(center->GetY())
+		{};
+
+		void operator () (LPCHARACTER ch)
+		{
+			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+			{
+				total += party_exp_distribute_table[ch->GetLevel()];
+				++member_count;
+			}
+		}
+	};
+
+	struct FPartyDistributor
+	{
+		int total;
+		LPCHARACTER c;
+		int x, y;
+		DWORD _iExp;
+#if defined(__CONQUEROR_LEVEL__)
+		DWORD _iConquerorExp;
+#endif
+		int m_iMode;
+		int m_iMemberCount;
+
+#if defined(__CONQUEROR_LEVEL__)
+		FPartyDistributor(LPCHARACTER center, int member_count, int total, DWORD iExp, DWORD iConquerorExp, int iMode)
+			: total(total), c(center), x(center->GetX()), y(center->GetY()), _iExp(iExp), _iConquerorExp(iConquerorExp), m_iMode(iMode), m_iMemberCount(member_count)
+#else
+		FPartyDistributor(LPCHARACTER center, int member_count, int total, DWORD iExp, int iMode)
+			: total(total), c(center), x(center->GetX()), y(center->GetY()), _iExp(iExp), m_iMode(iMode), m_iMemberCount(member_count)
+#endif
+		{
+			if (m_iMemberCount == 0)
+				m_iMemberCount = 1;
+		};
+
+		void operator () (LPCHARACTER ch)
+		{
+			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+			{
+				DWORD iExp = 0;
+#if defined(__CONQUEROR_LEVEL__)
+				DWORD iConquerorExp = 0;
+#endif
+
+				switch (m_iMode)
+				{
+					case PARTY_EXP_DISTRIBUTION_NON_PARITY:
+						iExp = (DWORD)(_iExp * (float)party_exp_distribute_table[ch->GetLevel()] / total);
+#if defined(__CONQUEROR_LEVEL__)
+						iConquerorExp = (DWORD)(_iConquerorExp * (float)party_exp_distribute_table[ch->GetLevel()] / total);
+#endif
+						break;
+
+					case PARTY_EXP_DISTRIBUTION_PARITY:
+						iExp = _iExp / m_iMemberCount;
+#if defined(__CONQUEROR_LEVEL__)
+						iConquerorExp = _iConquerorExp / m_iMemberCount;
+#endif
+						break;
+
+					default:
+						sys_err("Unknown party exp distribution mode %d", m_iMode);
+						return;
+				}
+
+#if defined(__CONQUEROR_LEVEL__)
+				GiveExp(c, ch, iExp, iConquerorExp);
+#else
+				GiveExp(c, ch, iExp);
+#endif
+			}
+		}
+	};
+}
+
+typedef struct SDamageInfo
+{
+	int iDam;
+	LPCHARACTER pAttacker;
+	LPPARTY pParty;
+
+	void Clear()
+	{
+		pAttacker = NULL;
+		pParty = NULL;
+	}
+
+#if defined(__CONQUEROR_LEVEL__)
+	inline void Distribute(LPCHARACTER ch, int iExp, int iConquerorExp)
+#else
+	inline void Distribute(LPCHARACTER ch, int iExp)
+#endif
+	{
+		if (pAttacker)
+		{
+#if defined(__CONQUEROR_LEVEL__)
+			GiveExp(ch, pAttacker, iExp, iConquerorExp);
+#else
+			GiveExp(ch, pAttacker, iExp);
+#endif
+		}
+		else if (pParty)
+		{
+			NPartyExpDistribute::FPartyTotaler f(ch);
+			pParty->ForEachOnMapMember(f, ch->GetMapIndex());
+
+			if (pParty->IsPositionNearLeader(ch))
+				iExp = iExp * (100 + pParty->GetExpBonusPercent()) / 100;
+
+			if (test_server)
+			{
+				if (quest::CQuestManager::instance().GetEventFlag("exp_bonus_log") && pParty->GetExpBonusPercent())
+					pParty->ChatPacketToAllMember(CHAT_TYPE_INFO, "exp party bonus %d%%", pParty->GetExpBonusPercent());
+			}
+
+			// 치 殮 (티 획 치 5%   )
+			if (pParty->GetExpCentralizeCharacter())
+			{
+				LPCHARACTER tch = pParty->GetExpCentralizeCharacter();
+
+				if (DISTANCE_APPROX(ch->GetX() - tch->GetX(), ch->GetY() - tch->GetY()) <= PARTY_DEFAULT_RANGE)
+				{
+					int iExpCenteralize = (int)(iExp * 0.05f);
+					iExp -= iExpCenteralize;
+
+#if defined(__CONQUEROR_LEVEL__)
+					int iConquerorExpCenteralize = (int)(iExp * 0.05f);
+					iConquerorExp -= iConquerorExpCenteralize;
+
+					GiveExp(ch, pParty->GetExpCentralizeCharacter(), iExpCenteralize, iConquerorExpCenteralize);
+#else
+					GiveExp(ch, pParty->GetExpCentralizeCharacter(), iExpCenteralize);
+#endif
+				}
+			}
+
+#if defined(__CONQUEROR_LEVEL__)
+			NPartyExpDistribute::FPartyDistributor fDist(ch, f.member_count, f.total, iExp, iConquerorExp, pParty->GetExpDistributionMode());
+#else
+			NPartyExpDistribute::FPartyDistributor fDist(ch, f.member_count, f.total, iExp, pParty->GetExpDistributionMode());
+#endif
+			pParty->ForEachOnMapMember(fDist, ch->GetMapIndex());
+		}
+	}
+} TDamageInfo;
+
+LPCHARACTER CHARACTER::DistributeExp()
+{
+#if defined(__CONQUEROR_LEVEL__)
+	int iExpToDistribute = GetExp();
+	if (iExpToDistribute <= 0)
+		iExpToDistribute = 0;
+
+	int iConquerorExpToDistribute = GetConquerorExp();
+	if (iConquerorExpToDistribute <= 0)
+		iConquerorExpToDistribute = 0;
+#else
+	int iExpToDistribute = GetExp();
+	if (iExpToDistribute <= 0)
+		return NULL;
+#endif
+
+	int iTotalDam = 0;
+	LPCHARACTER pkChrMostAttacked = NULL;
+	int iMostDam = 0;
+
+	typedef std::vector<TDamageInfo> TDamageInfoTable;
+	TDamageInfoTable damage_info_table;
+	std::map<LPPARTY, TDamageInfo> map_party_damage;
+
+	damage_info_table.reserve(m_map_kDamage.size());
+
+	TDamageMap::iterator it = m_map_kDamage.begin();
+
+	// 求     . (50m)
+	while (it != m_map_kDamage.end())
+	{
+		const VID& c_VID = it->first;
+		int iDam = it->second.iTotalDamage;
+
+		++it;
+
+		LPCHARACTER pAttacker = CHARACTER_MANAGER::instance().Find(c_VID);
+
+		// NPC 竪 毬? -.-;
+		if (!pAttacker || pAttacker->IsNPC() || DISTANCE_APPROX(GetX() - pAttacker->GetX(), GetY() - pAttacker->GetY()) > 5000)
+			continue;
+
+		iTotalDam += iDam;
+		if (!pkChrMostAttacked || iDam > iMostDam)
+		{
+			pkChrMostAttacked = pAttacker;
+			iMostDam = iDam;
+		}
+
+		if (pAttacker->GetParty())
+		{
+			std::map<LPPARTY, TDamageInfo>::iterator it = map_party_damage.find(pAttacker->GetParty());
+			if (it == map_party_damage.end())
+			{
+				TDamageInfo di;
+				di.iDam = iDam;
+				di.pAttacker = NULL;
+				di.pParty = pAttacker->GetParty();
+				map_party_damage.insert(std::make_pair(di.pParty, di));
+			}
+			else
+			{
+				it->second.iDam += iDam;
+			}
+		}
+		else
+		{
+			TDamageInfo di;
+
+			di.iDam = iDam;
+			di.pAttacker = pAttacker;
+			di.pParty = NULL;
+
+			//sys_log(0, "__ pq_damage %s %d", pAttacker->GetName(), iDam);
+			//pq_damage.push(di);
+			damage_info_table.push_back(di);
+		}
+	}
+
+	for (std::map<LPPARTY, TDamageInfo>::iterator it = map_party_damage.begin(); it != map_party_damage.end(); ++it)
+	{
+		damage_info_table.push_back(it->second);
+		//sys_log(0, "__ pq_damage_party [%u] %d", it->second.pParty->GetLeaderPID(), it->second.iDam);
+	}
+
+	SetExp(0);
+#if defined(__CONQUEROR_LEVEL__)
+	SetConquerorExp(0);
+#endif
+	//m_map_kDamage.clear();
+
+	if (iTotalDam == 0) //  莫 0見 
+		return NULL;
+
+	if (m_pkChrStone)	//    치   畸.
+	{
+		//sys_log(0, "__ Give half to Stone : %d", iExpToDistribute>>1);
+		int iExp = iExpToDistribute >> 1;
+		m_pkChrStone->SetExp(m_pkChrStone->GetExp() + iExp);
+		iExpToDistribute -= iExp;
+	}
+
+	sys_log(1, "%s total exp: %d, damage_info_table.size() == %d, TotalDam %d",
+		GetName(), iExpToDistribute, damage_info_table.size(), iTotalDam);
+	//sys_log(1, "%s total exp: %d, pq_damage.size() == %d, TotalDam %d",
+	//GetName(), iExpToDistribute, pq_damage.size(), iTotalDam);
+
+	if (damage_info_table.empty())
+		return NULL;
+
+	//      HP 회 磯.
+	DistributeHP(pkChrMostAttacked); //  첵
+
+	{
+		//     犬 티  치 20% + 未璲 큼 치 都쨈.
+		TDamageInfoTable::iterator di = damage_info_table.begin();
+		{
+			TDamageInfoTable::iterator it;
+
+			for (it = damage_info_table.begin(); it != damage_info_table.end(); ++it)
+			{
+				if (it->iDam > di->iDam)
+					di = it;
+			}
+		}
+
+		int iExp = iExpToDistribute / 5;
+		iExpToDistribute -= iExp;
+
+#if defined(__CONQUEROR_LEVEL__)
+		int	iConquerorExp = iConquerorExpToDistribute / 5;
+		iConquerorExpToDistribute -= iConquerorExp;
+#endif
+
+		float fPercent = (float)di->iDam / iTotalDam;
+
+		if (fPercent > 1.0f)
+		{
+			sys_err("DistributeExp percent over 1.0 (fPercent %f name %s)", fPercent, di->pAttacker->GetName());
+			fPercent = 1.0f;
+		}
+
+		iExp += (int)(iExpToDistribute * fPercent);
+#if defined(__CONQUEROR_LEVEL__)
+		iConquerorExp += (int)(iConquerorExpToDistribute * fPercent);
+#endif
+
+		//sys_log(0, "%s given exp percent %.1f + 20 dam %d", GetName(), fPercent * 100.0f, di.iDam);
+
+#if defined(__CONQUEROR_LEVEL__)
+		di->Distribute(this, iExp, iConquerorExp);
+#else
+		di->Distribute(this, iExp);
+#endif
+
+		// 100%  禿 磯.
+		if (fPercent == 1.0f)
+			return pkChrMostAttacked;
+
+		di->Clear();
+	}
+
+	{
+		//  80% 치 橘磯.
+		TDamageInfoTable::iterator it;
+
+		for (it = damage_info_table.begin(); it != damage_info_table.end(); ++it)
+		{
+			TDamageInfo& di = *it;
+
+			float fPercent = (float)di.iDam / iTotalDam;
+
+			if (fPercent > 1.0f)
+			{
+				sys_err("DistributeExp percent over 1.0 (fPercent %f name %s)", fPercent, di.pAttacker->GetName());
+				fPercent = 1.0f;
+			}
+
+			//sys_log(0, "%s given exp percent %.1f dam %d", GetName(), fPercent * 100.0f, di.iDam);
+#if defined(__CONQUEROR_LEVEL__)
+			di.Distribute(this, (int)(iExpToDistribute * fPercent), (int)(iConquerorExpToDistribute * fPercent));
+#else
+			di.Distribute(this, (int)(iExpToDistribute * fPercent));
+#endif
+		}
+	}
+
+	return pkChrMostAttacked;
+}
+
+// 화   
+int CHARACTER::GetArrowAndBow(LPITEM* ppkBow, LPITEM* ppkArrow, int iArrowCount/* = 1 */)
+{
+	LPITEM pkBow;
+	if (!(pkBow = GetWear(WEAR_WEAPON)) || pkBow->GetSubType() != WEAPON_BOW)
+		return 0;
+
+	LPITEM pkArrow;
+#if defined(__QUIVER_SYSTEM__)
+	if (!(pkArrow = GetWear(WEAR_ARROW)) || pkArrow->GetType() != ITEM_WEAPON || (pkArrow->GetSubType() != WEAPON_ARROW && pkArrow->GetSubType() != WEAPON_QUIVER))
+#else
+	if (!(pkArrow = GetWear(WEAR_ARROW)) || pkArrow->GetType() != ITEM_WEAPON || pkArrow->GetSubType() != WEAPON_ARROW)
+#endif
+	{
+		return 0;
+	}
+
+#if defined(__QUIVER_SYSTEM__)
+	if (pkArrow->GetSubType() == WEAPON_QUIVER)
+		iArrowCount = MIN(iArrowCount, pkArrow->GetSocket(0) - time(0));
+	else
+		iArrowCount = MIN(iArrowCount, pkArrow->GetCount());
+#else
+	iArrowCount = MIN(iArrowCount, pkArrow->GetCount());
+#endif
+
+	* ppkBow = pkBow;
+	*ppkArrow = pkArrow;
+
+	return iArrowCount;
+}
+
+void CHARACTER::UseArrow(LPITEM pkArrow, DWORD dwArrowCount)
+{
+#if defined(__QUIVER_SYSTEM__)
+	if (pkArrow->GetSubType() == WEAPON_QUIVER)
+		return;
+#endif
+
+	int iCount = pkArrow->GetCount();
+	DWORD dwVnum = pkArrow->GetVnum();
+	iCount = iCount - MIN(iCount, dwArrowCount);
+	pkArrow->SetCount(iCount);
+
+	if (iCount == 0)
+	{
+		LPITEM pkNewArrow = FindSpecifyItem(dwVnum);
+
+		sys_log(0, "UseArrow : FindSpecifyItem %u %p", dwVnum, get_pointer(pkNewArrow));
+
+		if (pkNewArrow)
+			EquipItem(pkNewArrow);
+	}
+}
+
+class CFuncShoot
+{
+public:
+	LPCHARACTER m_me;
+	BYTE m_bType;
+	bool m_bSucceed;
+
+	CFuncShoot(LPCHARACTER ch, BYTE bType) : m_me(ch), m_bType(bType), m_bSucceed(FALSE)
+	{
+	}
+
+	void operator () (DWORD dwTargetVID)
+	{
+		if (m_bType > 1)
+		{
+			if (g_bSkillDisable)
+				return;
+
+			m_me->m_SkillUseInfo[m_bType].SetMainTargetVID(dwTargetVID);
+			/*
+			if (m_bType == SKILL_BIPABU || m_bType == SKILL_KWANKYEOK)
+				m_me->m_SkillUseInfo[m_bType].ResetHitCount();
+			*/
+		}
+
+		LPCHARACTER pkVictim = CHARACTER_MANAGER::instance().Find(dwTargetVID);
+
+		if (!pkVictim)
+			return;
+
+		//  柰
+		if (!battle_is_attackable(m_me, pkVictim))
+			return;
+
+		if (m_me->IsNPC())
+		{
+			if (DISTANCE_APPROX(m_me->GetX() - pkVictim->GetX(), m_me->GetY() - pkVictim->GetY()) > 5000)
+				return;
+		}
+
+		LPITEM pkBow, pkArrow;
+
+		switch (m_bType)
+		{
+			case 0: // 球활
+			{
+				int iDam = 0;
+
+				if (m_me->IsPC())
+				{
+					if (m_me->GetJob() != JOB_ASSASSIN)
+						return;
+
+					if (0 == m_me->GetArrowAndBow(&pkBow, &pkArrow))
+						return;
+
+					if (m_me->GetSkillGroup() != 0)
+						if (!m_me->IsNPC() && m_me->GetSkillGroup() != 2)
+						{
+							if (m_me->GetSP() < 5)
+								return;
+
+							m_me->PointChange(POINT_SP, -5);
+						}
+
+					iDam = CalcArrowDamage(m_me, pkVictim, pkBow, pkArrow);
+					m_me->UseArrow(pkArrow, 1);
+
+					// Check speed hack
+					DWORD dwCurrentTime = get_dword_time();
+					if (IS_SPEED_HACK(m_me, pkVictim, dwCurrentTime))
+					{
+						iDam = 0;
+						return;
+					}
+				}
+				else
+					iDam = CalcMeleeDamage(m_me, pkVictim);
+
+				NormalAttackAffect(m_me, pkVictim);
+
+				//  
+				iDam = iDam * (100 - pkVictim->GetPoint(POINT_RESIST_BOW)) / 100;
+
+				//sys_log(0, "%s arrow %s dam %d", m_me->GetName(), pkVictim->GetName(), iDam);
+
+				m_me->OnMove(true);
+				pkVictim->OnMove();
+
+				if (pkVictim->CanBeginFight())
+					pkVictim->BeginFight(m_me);
+
+				pkVictim->Damage(m_me, iDam, EDamageType::DAMAGE_TYPE_NORMAL_RANGE);
+				// 타치  
+			}
+			break;
+
+			case 1: // 球 
+			{
+				int iDam;
+
+				if (m_me->IsPC())
+					return;
+
+				iDam = CalcMagicDamage(m_me, pkVictim);
+
+				NormalAttackAffect(m_me, pkVictim);
+
+				//  
+{
+				// [Fix] Safe magic resistance/penetration: clamp resist to [0..100] and apply penetration correctly
+				const int c_iResMagic = MINMAX(0, pkVictim->GetPoint(POINT_RESIST_MAGIC), 100);
+				const int c_iResMagicReduction = MINMAX(0, (m_me->GetJob() == JOB_SURA) ? m_me->GetPoint(POINT_RESIST_MAGIC_REDUCTION) / 2 : m_me->GetPoint(POINT_RESIST_MAGIC_REDUCTION), 50);
+				const int c_iTotalMagicRes = MINMAX(0, c_iResMagic - c_iResMagicReduction, 100);
+				iDam = iDam * (100 - c_iTotalMagicRes) / 100;
+			}
+
+				//sys_log(0, "%s arrow %s dam %d", m_me->GetName(), pkVictim->GetName(), iDam);
+
+				m_me->OnMove(true);
+				pkVictim->OnMove();
+
+				if (pkVictim->CanBeginFight())
+					pkVictim->BeginFight(m_me);
+
+				pkVictim->Damage(m_me, iDam, DAMAGE_TYPE_MAGIC);
+				// 타치  
+			}
+			break;
+
+			case SKILL_YEONSA: // 
+			{
+				//int iUseArrow = 2 + (m_me->GetSkillPower(SKILL_YEONSA) *6/100);
+				int iUseArrow = 1;
+
+				// 탈 求째
+				{
+					if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
+					{
+						m_me->OnMove(true);
+						pkVictim->OnMove();
+
+						if (pkVictim->CanBeginFight())
+							pkVictim->BeginFight(m_me);
+
+						m_me->ComputeSkill(m_bType, pkVictim);
+						m_me->UseArrow(pkArrow, iUseArrow);
+
+						if (pkVictim->IsDead())
+							break;
+					}
+					else
+						break;
+				}
+			}
+			break;
+
+			case SKILL_KWANKYEOK:
+			{
+				int iUseArrow = 1;
+
+				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
+				{
+					m_me->OnMove(true);
+					pkVictim->OnMove();
+
+					if (pkVictim->CanBeginFight())
+						pkVictim->BeginFight(m_me);
+
+					sys_log(0, "%s kwankeyok %s", m_me->GetName(), pkVictim->GetName());
+					m_me->ComputeSkill(m_bType, pkVictim);
+					m_me->UseArrow(pkArrow, iUseArrow);
+				}
+			}
+			break;
+
+			case SKILL_GIGUNG:
+#if defined(__9TH_SKILL__)
+			case SKILL_PUNGLOEPO:
+#endif
+			{
+				int iUseArrow = 1;
+				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
+				{
+					m_me->OnMove(true);
+					pkVictim->OnMove();
+
+					if (pkVictim->CanBeginFight())
+						pkVictim->BeginFight(m_me);
+
+#if defined(__9TH_SKILL__)
+					if (m_bType == SKILL_PUNGLOEPO)
+						sys_log(0, "%s pungloepo %s", m_me->GetName(), pkVictim->GetName());
+					else
+						sys_log(0, "%s gigung %s", m_me->GetName(), pkVictim->GetName());
+#else
+					sys_log(0, "%s gigung %s", m_me->GetName(), pkVictim->GetName());
+#endif
+
+					m_me->ComputeSkill(m_bType, pkVictim);
+					m_me->UseArrow(pkArrow, iUseArrow);
+				}
+			}
+			break;
+
+			case SKILL_HWAJO:
+			{
+				int iUseArrow = 1;
+				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
+				{
+					m_me->OnMove(true);
+					pkVictim->OnMove();
+
+					if (pkVictim->CanBeginFight())
+						pkVictim->BeginFight(m_me);
+
+					sys_log(0, "%s hwajo %s", m_me->GetName(), pkVictim->GetName());
+					m_me->ComputeSkill(m_bType, pkVictim);
+					m_me->UseArrow(pkArrow, iUseArrow);
+				}
+			}
+			break;
+
+			case SKILL_HORSE_WILDATTACK_RANGE:
+			{
+				int iUseArrow = 1;
+				if (iUseArrow == m_me->GetArrowAndBow(&pkBow, &pkArrow, iUseArrow))
+				{
+					m_me->OnMove(true);
+					pkVictim->OnMove();
+
+					if (pkVictim->CanBeginFight())
+						pkVictim->BeginFight(m_me);
+
+					sys_log(0, "%s horse_wildattack %s", m_me->GetName(), pkVictim->GetName());
+					m_me->ComputeSkill(m_bType, pkVictim);
+					m_me->UseArrow(pkArrow, iUseArrow);
+				}
+			}
+			break;
+
+			case SKILL_MARYUNG:
+			case SKILL_TUSOK:
+			case SKILL_BIPABU:
+#if defined(__9TH_SKILL__)
+			case SKILL_ILGWANGPYO:
+			case SKILL_MABEOBAGGWI:
+#endif
+			case SKILL_NOEJEON:
+			case SKILL_GEOMPUNG:
+			case SKILL_SANGONG:
+			case SKILL_MAHWAN:
+			case SKILL_PABEOB:
+			{
+				m_me->OnMove(true);
+				pkVictim->OnMove();
+
+				if (pkVictim->CanBeginFight())
+					pkVictim->BeginFight(m_me);
+
+				sys_log(0, "%s - Skill %d -> %s", m_me->GetName(), m_bType, pkVictim->GetName());
+				m_me->ComputeSkill(m_bType, pkVictim);
+			}
+			break;
+
+			case SKILL_CHAIN:
+			{
+				m_me->OnMove(true);
+				pkVictim->OnMove();
+
+				if (pkVictim->CanBeginFight())
+					pkVictim->BeginFight(m_me);
+
+				sys_log(0, "%s - Skill %d -> %s", m_me->GetName(), m_bType, pkVictim->GetName());
+				m_me->ComputeSkill(m_bType, pkVictim);
+
+				// TODO     歐
+			}
+			break;
+
+			/*
+			case SKILL_BUDONG:
+			{
+				m_me->OnMove(true);
+				pkVictim->OnMove();
+
+				DWORD * pdw;
+				DWORD dwEI = AllocEventInfo(sizeof(DWORD) * 2, &pdw);
+				pdw[0] = m_me->GetVID();
+				pdw[1] = pkVictim->GetVID();
+
+				event_create(budong_event_func, dwEI, PASSES_PER_SEC(1));
+			}
+			break;
+			*/
+
+			default:
+				sys_err("CFuncShoot: I don't know this type [%d] of range attack.", (int)m_bType);
+				break;
+		}
+
+		m_bSucceed = TRUE;
+	}
+};
+
+bool CHARACTER::Shoot(BYTE bType)
+{
+	sys_log(1, "Shoot %s type %u flyTargets.size %zu", GetName(), bType, m_vec_dwFlyTargets.size());
+
+	if (!CanMove())
+		return false;
+
+	if (IsPC() && IsPolymorphed())
+		return false;
+
+	CFuncShoot f(this, bType);
+
+	if (m_dwFlyTargetID != 0)
+	{
+		f(m_dwFlyTargetID);
+		m_dwFlyTargetID = 0;
+	}
+
+	f = std::for_each(m_vec_dwFlyTargets.begin(), m_vec_dwFlyTargets.end(), f);
+	m_vec_dwFlyTargets.clear();
+
+	return f.m_bSucceed;
+}
+
+void CHARACTER::FlyTarget(DWORD dwTargetVID, long x, long y, BYTE bHeader)
+{
+	LPCHARACTER pkVictim = CHARACTER_MANAGER::instance().Find(dwTargetVID);
+	TPacketGCFlyTargeting pack;
+
+	//pack.bHeader = HEADER_GC_FLY_TARGETING;
+	pack.bHeader = (bHeader == HEADER_CG_FLY_TARGETING) ? HEADER_GC_FLY_TARGETING : HEADER_GC_ADD_FLY_TARGETING;
+	pack.dwShooterVID = GetVID();
+
+	if (pkVictim)
+	{
+		pack.dwTargetVID = pkVictim->GetVID();
+		pack.x = pkVictim->GetX();
+		pack.y = pkVictim->GetY();
+
+		if (bHeader == HEADER_CG_FLY_TARGETING)
+			m_dwFlyTargetID = dwTargetVID;
+		else
+			m_vec_dwFlyTargets.push_back(dwTargetVID);
+	}
+	else
+	{
+		pack.dwTargetVID = 0;
+		pack.x = x;
+		pack.y = y;
+	}
+
+	sys_log(1, "FlyTarget %s vid %d x %d y %d", GetName(), pack.dwTargetVID, pack.x, pack.y);
+	PacketAround(&pack, sizeof(pack), this);
+}
+
+LPCHARACTER CHARACTER::GetNearestVictim(LPCHARACTER pkChr)
+{
+	if (NULL == pkChr)
+		pkChr = this;
+
+	float fMinDist = 99999.0f;
+	LPCHARACTER pkVictim = NULL;
+
+	TDamageMap::iterator it = m_map_kDamage.begin();
+
+	// 求     .
+	while (it != m_map_kDamage.end())
+	{
+		const VID& c_VID = it->first;
+		++it;
+
+		LPCHARACTER pAttacker = CHARACTER_MANAGER::instance().Find(c_VID);
+
+		if (!pAttacker)
+			continue;
+
+		if (pAttacker->IsAffectFlag(AFF_EUNHYUNG) ||
+			pAttacker->IsAffectFlag(AFF_INVISIBILITY) ||
+			pAttacker->IsAffectFlag(AFF_REVIVE_INVISIBLE))
+			continue;
+
+		float fDist = DISTANCE_APPROX(pAttacker->GetX() - pkChr->GetX(), pAttacker->GetY() - pkChr->GetY());
+
+		if (fDist < fMinDist)
+		{
+			pkVictim = pAttacker;
+			fMinDist = fDist;
+		}
+	}
+
+	return pkVictim;
+}
+
+void CHARACTER::SetVictim(LPCHARACTER pkVictim)
+{
+	if (!pkVictim)
+	{
+		if (0 != (DWORD)m_kVIDVictim)
+			MonsterLog("Can't find victim");
+
+		m_kVIDVictim.Reset();
+		battle_end(this);
+	}
+	else
+	{
+		if (m_kVIDVictim != pkVictim->GetVID())
+			MonsterLog("Set victim: %s", pkVictim->GetName());
+
+		m_kVIDVictim = pkVictim->GetVID();
+		m_dwLastVictimSetTime = get_dword_time();
+	}
+}
+
+LPCHARACTER CHARACTER::GetVictim() const
+{
+	return CHARACTER_MANAGER::instance().Find(m_kVIDVictim);
+}
+
+LPCHARACTER CHARACTER::GetProtege() const // 호瞞   
+{
+	if (m_pkChrStone)
+		return m_pkChrStone;
+
+	if (m_pkParty)
+		return m_pkParty->GetLeader();
+
+	return NULL;
+}
+
+int CHARACTER::GetAlignment() const
+{
+	return m_iAlignment;
+}
+
+int CHARACTER::GetRealAlignment() const
+{
+	return m_iRealAlignment;
+}
+
+void CHARACTER::ShowAlignment(bool bShow)
+{
+	if (bShow)
+	{
+		if (m_iAlignment != m_iRealAlignment)
+		{
+			m_iAlignment = m_iRealAlignment;
+			UpdatePacket();
+		}
+	}
+	else
+	{
+		if (m_iAlignment != 0)
+		{
+			m_iAlignment = 0;
+			UpdatePacket();
+		}
+	}
+}
+
+void CHARACTER::UpdateAlignment(int iAmount)
+{
+	bool bShow = false;
+
+#ifdef ENABLE_QUEEN_NETHIS
+	if (IsSnakeMap() && iAmount < 0)
+		return;
+#endif
+
+	if (m_iAlignment == m_iRealAlignment)
+		bShow = true;
+
+	int i = m_iAlignment / 10;
+
+	m_iRealAlignment = MINMAX(-200000, m_iRealAlignment + iAmount, 200000);
+
+	if (bShow)
+	{
+		m_iAlignment = m_iRealAlignment;
+
+		if (i != m_iAlignment / 10)
+			UpdatePacket();
+	}
+}
+
+UINT CHARACTER::GetAlignmentGrade() const
+{
+	const int iAlignment = GetRealAlignment();
+
+	if (iAlignment >= 12000)
+		return ALIGN_GRADE_GOOD_4;
+	else if (iAlignment >= 8000)
+		return ALIGN_GRADE_GOOD_3;
+	else if (iAlignment >= 4000)
+		return ALIGN_GRADE_GOOD_2;
+	else if (iAlignment >= 1000)
+		return ALIGN_GRADE_GOOD_1;
+	else if (iAlignment >= 0)
+		return ALIGN_GRADE_NORMAL;
+	else if (iAlignment > -4000)
+		return ALIGN_GRADE_EVIL_1;
+	else if (iAlignment > -8000)
+		return ALIGN_GRADE_EVIL_2;
+	else if (iAlignment > -12000)
+		return ALIGN_GRADE_EVIL_3;
+	else
+		return ALIGN_GRADE_EVIL_4;
+
+	return 0;
+}
+
+void CHARACTER::SetKillerMode(bool isOn)
+{
+	if ((isOn ? ADD_CHARACTER_STATE_KILLER : 0) == IS_SET(m_bAddChrState, ADD_CHARACTER_STATE_KILLER))
+		return;
+
+	if (isOn)
+		SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_KILLER);
+	else
+		REMOVE_BIT(m_bAddChrState, ADD_CHARACTER_STATE_KILLER);
+
+	m_iKillerModePulse = thecore_pulse();
+	UpdatePacket();
+	sys_log(0, "SetKillerMode Update %s[%d]", GetName(), GetPlayerID());
+}
+
+bool CHARACTER::IsKillerMode() const
+{
+	return IS_SET(m_bAddChrState, ADD_CHARACTER_STATE_KILLER);
+}
+
+void CHARACTER::UpdateKillerMode()
+{
+	if (!IsKillerMode())
+		return;
+
+	int iKillerSeconds = 60;
+
+	if (thecore_pulse() - m_iKillerModePulse >= PASSES_PER_SEC(iKillerSeconds))
+		SetKillerMode(false);
+}
+
+void CHARACTER::SetPKMode(BYTE bPKMode)
+{
+	if (bPKMode >= PK_MODE_MAX_NUM)
+		return;
+
+	if (m_bPKMode == bPKMode)
+		return;
+
+	if (bPKMode == PK_MODE_GUILD && !GetGuild())
+		bPKMode = PK_MODE_FREE;
+
+	m_bPKMode = bPKMode;
+	UpdatePacket();
+
+	sys_log(0, "PK_MODE: %s %d", GetName(), m_bPKMode);
+}
+
+BYTE CHARACTER::GetPKMode() const
+{
+	return m_bPKMode;
+}
+
+struct FuncForgetMyAttacker
+{
+	LPCHARACTER m_ch;
+	FuncForgetMyAttacker(LPCHARACTER ch)
+	{
+		m_ch = ch;
+	}
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+			if (ch->IsPC())
+				return;
+			if (ch->m_kVIDVictim == m_ch->GetVID())
+				ch->SetVictim(NULL);
+		}
+	}
+};
+
+struct FuncAggregateMonster
+{
+	LPCHARACTER m_ch;
+	FuncAggregateMonster(LPCHARACTER ch)
+	{
+		m_ch = ch;
+	}
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+			if (ch->IsPC())
+				return;
+			if (!ch->IsMonster())
+				return;
+			if (ch->GetVictim())
+				return;
+
+			if (number(1, 100) <= 50) // 擔첨 50% 확  쨈
+				if (DISTANCE_APPROX(ch->GetX() - m_ch->GetX(), ch->GetY() - m_ch->GetY()) < 5000)
+					if (ch->CanBeginFight())
+						ch->BeginFight(m_ch);
+		}
+	}
+};
+
+struct FuncAttractRanger
+{
+	LPCHARACTER m_ch;
+	FuncAttractRanger(LPCHARACTER ch)
+	{
+		m_ch = ch;
+	}
+
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+			if (ch->IsPC())
+				return;
+			if (!ch->IsMonster())
+				return;
+			if (ch->GetVictim() && ch->GetVictim() != m_ch)
+				return;
+			if (ch->GetMobAttackRange() > 150)
+			{
+				int iNewRange = 150; //(int)(ch->GetMobAttackRange() * 0.2);
+				if (iNewRange < 150)
+					iNewRange = 150;
+
+				ch->AddAffect(AFFECT_BOW_DISTANCE, POINT_BOW_DISTANCE, iNewRange - ch->GetMobAttackRange(), AFF_NONE, 3 * 60, 0, false);
+			}
+		}
+	}
+};
+
+struct FuncPullMonster
+{
+	LPCHARACTER m_ch;
+	int m_iLength;
+	FuncPullMonster(LPCHARACTER ch, int iLength = 300)
+	{
+		m_ch = ch;
+		m_iLength = iLength;
+	}
+
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+			if (ch->IsPC())
+				return;
+			if (!ch->IsMonster())
+				return;
+			/*
+			if (ch->GetVictim() && ch->GetVictim() != m_ch)
+				return;
+			*/
+			float fDist = DISTANCE_APPROX(m_ch->GetX() - ch->GetX(), m_ch->GetY() - ch->GetY());
+			if (fDist > 3000 || fDist < 100)
+				return;
+
+			float fNewDist = fDist - m_iLength;
+			if (fNewDist < 100)
+				fNewDist = 100;
+
+			float degree = GetDegreeFromPositionXY(ch->GetX(), ch->GetY(), m_ch->GetX(), m_ch->GetY());
+			float fx;
+			float fy;
+
+			GetDeltaByDegree(degree, fDist - fNewDist, &fx, &fy);
+			long tx = (long)(ch->GetX() + fx);
+			long ty = (long)(ch->GetY() + fy);
+
+			ch->Sync(tx, ty);
+			ch->Goto(tx, ty);
+			ch->CalculateMoveDuration();
+
+			ch->SyncPacket();
+		}
+	}
+};
+
+void CHARACTER::ForgetMyAttacker(bool bRevive)
+{
+	LPSECTREE pSec = GetSectree();
+	if (pSec)
+	{
+		FuncForgetMyAttacker f(this);
+		pSec->ForEachAround(f);
+	}
+
+	if (bRevive)
+		ReviveInvisible(5);
+}
+
+void CHARACTER::AggregateMonster()
+{
+	LPSECTREE pSec = GetSectree();
+	if (pSec)
+	{
+		FuncAggregateMonster f(this);
+		pSec->ForEachAround(f);
+		EffectPacket(SE_CAPE_OF_COURAGE);
+	}
+}
+
+void CHARACTER::AttractRanger()
+{
+	LPSECTREE pSec = GetSectree();
+	if (pSec)
+	{
+		FuncAttractRanger f(this);
+		pSec->ForEachAround(f);
+	}
+}
+
+void CHARACTER::PullMonster()
+{
+	LPSECTREE pSec = GetSectree();
+	if (pSec)
+	{
+		FuncPullMonster f(this);
+		pSec->ForEachAround(f);
+	}
+}
+
+void CHARACTER::UpdateAggrPointEx(LPCHARACTER pAttacker, EDamageType type, int dam, CHARACTER::TBattleInfo& info)
+{
+	if (!pAttacker)
+		return;
+
+#if defined(__DEFENSE_WAVE__)
+	if (GetDefenseWave())
+	{
+		if (CDefenseWaveManager::Instance().IsHydraSpawn(GetRaceNum()))
+			return;
+
+		if (CDefenseWaveManager::Instance().IsHydra(GetRaceNum()))
+			return;
+	}
+#endif
+
+	// 특 타篤   철箚４
+	switch (type)
+	{
+		case EDamageType::DAMAGE_TYPE_NORMAL_RANGE:
+			dam = (int)(dam * 1.2f);
+			break;
+
+		case EDamageType::DAMAGE_TYPE_RANGE:
+			dam = (int)(dam * 1.5f);
+			break;
+
+		case EDamageType::DAMAGE_TYPE_MAGIC:
+			dam = (int)(dam * 1.2f);
+			break;
+
+		default:
+			break;
+	}
+
+	// 微    駕 娩.
+	if (pAttacker == GetVictim())
+		dam = (int)(dam * 1.2f);
+
+	info.iAggro += dam;
+
+	if (info.iAggro < 0)
+		info.iAggro = 0;
+
+	//sys_log(0, "UpdateAggrPointEx for %s by %s dam %d total %d", GetName(), pAttacker->GetName(), dam, total);
+	if (GetParty() && dam > 0 && type != DAMAGE_TYPE_SPECIAL)
+	{
+		LPPARTY pParty = GetParty();
+
+		//     求
+		int iPartyAggroDist = dam;
+
+		if (pParty->GetLeaderPID() == GetVID())
+			iPartyAggroDist /= 2;
+		else
+			iPartyAggroDist /= 3;
+
+		pParty->SendMessage(this, PM_AGGRO_INCREASE, iPartyAggroDist, pAttacker->GetVID());
+	}
+
+	ChangeVictimByAggro(info.iAggro, pAttacker);
+}
+
+void CHARACTER::UpdateAggrPoint(LPCHARACTER pAttacker, EDamageType type, int dam)
+{
+	if (IsDead() || IsStun())
+		return;
+
+	if (!pAttacker)
+		return;
+
+	TDamageMap::iterator it = m_map_kDamage.find(pAttacker->GetVID());
+	if (it == m_map_kDamage.end())
+	{
+		m_map_kDamage.insert(TDamageMap::value_type(pAttacker->GetVID(), TBattleInfo(0, dam)));
+		it = m_map_kDamage.find(pAttacker->GetVID());
+	}
+
+	UpdateAggrPointEx(pAttacker, type, dam, it->second);
+}
+
+void CHARACTER::ChangeVictimByAggro(int iNewAggro, LPCHARACTER pNewVictim)
+{
+	if (get_dword_time() - m_dwLastVictimSetTime < 3000) // 3苛 慕磯
+		return;
+
+	if (pNewVictim == GetVictim())
+	{
+		if (m_iMaxAggro < iNewAggro)
+		{
+			m_iMaxAggro = iNewAggro;
+			return;
+		}
+
+		// Aggro  
+		TDamageMap::iterator it;
+		TDamageMap::iterator itFind = m_map_kDamage.end();
+
+		for (it = m_map_kDamage.begin(); it != m_map_kDamage.end(); ++it)
+		{
+			if (it->second.iAggro > iNewAggro)
+			{
+				LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(it->first);
+
+				if (ch && !ch->IsDead() && DISTANCE_APPROX(ch->GetX() - GetX(), ch->GetY() - GetY()) < 5000)
+				{
+					itFind = it;
+					iNewAggro = it->second.iAggro;
+				}
+			}
+		}
+
+		if (itFind != m_map_kDamage.end())
+		{
+			m_iMaxAggro = iNewAggro;
+			SetVictim(CHARACTER_MANAGER::Instance().Find(itFind->first));
+			m_dwStateDuration = 1;
+		}
+	}
+	else
+	{
+		if (m_iMaxAggro < iNewAggro)
+		{
+			m_iMaxAggro = iNewAggro;
+			SetVictim(pNewVictim);
+			m_dwStateDuration = 1;
+		}
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/char_change_empire.cpp b/server/metin2/Source/Server/game/src/char_change_empire.cpp
index 1baa8cd..7330c53 100644
--- a/server/metin2/Source/Server/game/src/char_change_empire.cpp
+++ b/server/metin2/Source/Server/game/src/char_change_empire.cpp
@@ -1,234 +1,252 @@
-#include "stdafx.h"
-#include "config.h"
-#include "char.h"
-#include "char_manager.h"
-#include "db.h"
-#include "guild_manager.h"
-#include "marriage.h"
-#include "../../common/service.h"
-
-/*
-Return Value
-	0 : 알 수 없는 에러 or 쿼리 에러
-	1 : 동일한 제국으로 바꾸려고함
-	2 : 길드 가입한 캐릭터가 있음
-	3 : 결혼한 캐릭터가 있음
-
-	999 : 제국 이동 성공
-*/
-
-int CHARACTER::ChangeEmpire(BYTE empire)
-{
-	if (GetEmpire() == empire)
-		return 1;
-
-	char szQuery[1024 + 1];
-	DWORD dwAID;
-	DWORD dwPID[PLAYER_PER_ACCOUNT];
-	memset(dwPID, 0, sizeof(dwPID));
-
-	{
-		// 1. 내 계정의 모든 pid를 얻어 온다
-		snprintf(szQuery, sizeof(szQuery), "SELECT "
-			"id, "
-			"pid1, "
-			"pid2, "
-			"pid3, "
-			"pid4"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			", pid5"
-#endif
-			" FROM player_index%s WHERE "
-			"pid1=%u OR "
-			"pid2=%u OR "
-			"pid3=%u OR "
-			"pid4=%u"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			" OR pid5=%u"
-#endif
-			" AND empire=%u", get_table_postfix(),
-			GetPlayerID(),
-			GetPlayerID(),
-			GetPlayerID(),
-			GetPlayerID(),
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			GetPlayerID(),
-#endif
-			GetEmpire()
-		);
-
-		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-		if (pMsg->Get()->uiNumRows == 0)
-			return 0;
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-
-		str_to_number(dwAID, row[0]);
-		str_to_number(dwPID[0], row[1]);
-		str_to_number(dwPID[1], row[2]);
-		str_to_number(dwPID[2], row[3]);
-		str_to_number(dwPID[3], row[4]);
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		str_to_number(dwPID[4], row[5]);
-#endif
-	}
-
-	const int loop = 4;
-
-	{
-		// 2. 각 캐릭터의 길드 정보를 얻어온다.
-		// 한 캐릭터라도 길드에 가입 되어 있다면, 제국 이동을 할 수 없다.
-		DWORD dwGuildID[4];
-		CGuild* pGuild[4];
-
-		for (int i = 0; i < loop; ++i)
-		{
-			snprintf(szQuery, sizeof(szQuery), "SELECT guild_id FROM guild_member%s WHERE pid=%u", get_table_postfix(), dwPID[i]);
-			std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-
-			if (pMsg->Get()->uiNumRows > 0)
-			{
-				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-
-				str_to_number(dwGuildID[i], row[0]);
-
-				pGuild[i] = CGuildManager::instance().FindGuild(dwGuildID[i]);
-
-				if (pGuild[i] != NULL)
-					return 2;
-			}
-			else
-			{
-				dwGuildID[i] = 0;
-				pGuild[i] = NULL;
-			}
-		}
-	}
-
-	{
-		// 3. 각 캐릭터의 결혼 정보를 얻어온다.
-		// 한 캐릭터라도 결혼 상태라면 제국 이동을 할 수 없다.
-		for (int i = 0; i < loop; ++i)
-		{
-			if (marriage::CManager::instance().IsEngagedOrMarried(dwPID[i]) == true)
-				return 3;
-		}
-	}
-
-	{
-		// 4. db의 제국 정보를 업데이트 한다.
-		snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET empire=%u WHERE "
-			"pid1=%u OR "
-			"pid2=%u OR "
-			"pid3=%u OR "
-			"pid4=%u"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			" OR pid5=%u"
-#endif
-			" AND empire=%u",
-			get_table_postfix(),
-			empire,
-			GetPlayerID(),
-			GetPlayerID(),
-			GetPlayerID(),
-			GetPlayerID(),
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			GetPlayerID(),
-#endif
-			GetEmpire());
-
-		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-
-		if (pMsg->Get()->uiAffectedRows > 0)
-		{
-			// 5. 제국 변경 이력을 추가한다.
-			SetChangeEmpireCount();
-
-			return 999;
-		}
-	}
-
-	return 0;
-}
-
-int CHARACTER::GetChangeEmpireCount() const
-{
-	char szQuery[1024 + 1];
-	DWORD dwAID = GetAID();
-
-	if (dwAID == 0)
-		return 0;
-
-	snprintf(szQuery, sizeof(szQuery), "SELECT change_count FROM change_empire WHERE account_id = %u", dwAID);
-
-	DWORD dwCount = 0;
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	if (pMsg->Get()->uiNumRows > 0)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		str_to_number(dwCount, row[0]);
-		return dwCount;
-	}
-
-	return dwCount;
-}
-
-void CHARACTER::SetChangeEmpireCount()
-{
-	char szQuery[1024 + 1];
-
-	DWORD dwAID = GetAID();
-
-	if (dwAID == 0) return;
-
-	int count = GetChangeEmpireCount();
-
-	if (count == 0)
-	{
-		count++;
-		snprintf(szQuery, sizeof(szQuery), "INSERT INTO change_empire VALUES(%u, %d, NOW())", dwAID, count);
-	}
-	else
-	{
-		count++;
-		snprintf(szQuery, sizeof(szQuery), "UPDATE change_empire SET change_count=%d WHERE account_id=%u", count, dwAID);
-	}
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-}
-
-DWORD CHARACTER::GetAID() const
-{
-	char szQuery[1024 + 1];
-	DWORD dwAID = 0;
-
-	snprintf(szQuery, sizeof(szQuery), "SELECT id FROM player_index%s WHERE "
-		"pid1=%u OR "
-		"pid2=%u OR "
-		"pid3=%u OR "
-		"pid4=%u"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		" OR pid5=%u"
-#endif
-		" AND empire=%u",
-		get_table_postfix(),
-		GetPlayerID(),
-		GetPlayerID(),
-		GetPlayerID(),
-		GetPlayerID(),
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		GetPlayerID(),
-#endif
-		GetEmpire());
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	if (pMsg->Get()->uiNumRows > 0)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		str_to_number(dwAID, row[0]);
-		return dwAID;
-	}
-
-	return 0;
-}
+#include "stdafx.h"
+#include "config.h"
+#include "char.h"
+#include "char_manager.h"
+#include "db.h"
+#include "guild_manager.h"
+#include "marriage.h"
+#include "../../common/service.h"
+
+namespace
+{
+	static bool IsEngagedOrMarriedInDB(DWORD pid)
+	{
+		char szQuery[256];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT 1 FROM marriage%s WHERE pid1=%u OR pid2=%u LIMIT 1",
+			get_table_postfix(), pid, pid);
+		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+		return (pMsg && pMsg->Get()->uiNumRows > 0);
+	}
+}
+
+
+/*
+Return Value
+	0 :     or  
+	1 :   侮慕
+	2 :   캐叩 
+	3 : 혼 캐叩 
+
+	999 :  絹 
+*/
+
+int CHARACTER::ChangeEmpire(BYTE empire)
+{
+	if (GetEmpire() == empire)
+		return 1;
+
+	// [Security] Block empire change while in a guild (prevents guild/war table corruption).
+	if (GetGuild())
+		return 2;
+
+	char szQuery[1024 + 1];
+	DWORD dwAID;
+	DWORD dwPID[PLAYER_PER_ACCOUNT];
+	memset(dwPID, 0, sizeof(dwPID));
+
+	{
+		// 1.    pid  쨈
+		snprintf(szQuery, sizeof(szQuery), "SELECT "
+			"id, "
+			"pid1, "
+			"pid2, "
+			"pid3, "
+			"pid4"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			", pid5"
+#endif
+			" FROM player_index%s WHERE "
+			"pid1=%u OR "
+			"pid2=%u OR "
+			"pid3=%u OR "
+			"pid4=%u"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			" OR pid5=%u"
+#endif
+			" AND empire=%u", get_table_postfix(),
+			GetPlayerID(),
+			GetPlayerID(),
+			GetPlayerID(),
+			GetPlayerID(),
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			GetPlayerID(),
+#endif
+			GetEmpire()
+		);
+
+		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+		if (pMsg->Get()->uiNumRows == 0)
+			return 0;
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+
+		str_to_number(dwAID, row[0]);
+		str_to_number(dwPID[0], row[1]);
+		str_to_number(dwPID[1], row[2]);
+		str_to_number(dwPID[2], row[3]);
+		str_to_number(dwPID[3], row[4]);
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		str_to_number(dwPID[4], row[5]);
+#endif
+	}
+
+	const int loop = 4;
+
+	{
+		// 2.  캐   쨈.
+		//  캐尻 恙  퓸 獵摸,  絹   .
+		DWORD dwGuildID[4];
+		CGuild* pGuild[4];
+
+		for (int i = 0; i < loop; ++i)
+		{
+			snprintf(szQuery, sizeof(szQuery), "SELECT guild_id FROM guild_member%s WHERE pid=%u", get_table_postfix(), dwPID[i]);
+			std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+
+			if (pMsg->Get()->uiNumRows > 0)
+			{
+				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+
+				str_to_number(dwGuildID[i], row[0]);
+
+				pGuild[i] = CGuildManager::instance().FindGuild(dwGuildID[i]);
+
+				if (pGuild[i] != NULL)
+					return 2;
+			}
+			else
+			{
+				dwGuildID[i] = 0;
+				pGuild[i] = NULL;
+			}
+		}
+	}
+
+	{
+		// 3.  캐 혼  쨈.
+		//  캐尻 혼 쨋  絹   .
+		for (int i = 0; i < loop; ++i)
+		{
+			if (IsEngagedOrMarriedInDB(dwPID[i]))
+				return 3;
+		}
+	}
+
+	{
+		// 4. db   트 磯.
+		snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET empire=%u WHERE "
+			"pid1=%u OR "
+			"pid2=%u OR "
+			"pid3=%u OR "
+			"pid4=%u"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			" OR pid5=%u"
+#endif
+			" AND empire=%u",
+			get_table_postfix(),
+			empire,
+			GetPlayerID(),
+			GetPlayerID(),
+			GetPlayerID(),
+			GetPlayerID(),
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			GetPlayerID(),
+#endif
+			GetEmpire());
+
+		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+
+		if (pMsg->Get()->uiAffectedRows > 0)
+		{
+			// 5.   肩 煞磯.
+			SetChangeEmpireCount();
+
+			return 999;
+		}
+	}
+
+	return 0;
+}
+
+int CHARACTER::GetChangeEmpireCount() const
+{
+	char szQuery[1024 + 1];
+	DWORD dwAID = GetAID();
+
+	if (dwAID == 0)
+		return 0;
+
+	snprintf(szQuery, sizeof(szQuery), "SELECT change_count FROM change_empire WHERE account_id = %u", dwAID);
+
+	DWORD dwCount = 0;
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	if (pMsg->Get()->uiNumRows > 0)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		str_to_number(dwCount, row[0]);
+		return dwCount;
+	}
+
+	return dwCount;
+}
+
+void CHARACTER::SetChangeEmpireCount()
+{
+	char szQuery[1024 + 1];
+
+	DWORD dwAID = GetAID();
+
+	if (dwAID == 0) return;
+
+	int count = GetChangeEmpireCount();
+
+	if (count == 0)
+	{
+		count++;
+		snprintf(szQuery, sizeof(szQuery), "INSERT INTO change_empire VALUES(%u, %d, NOW())", dwAID, count);
+	}
+	else
+	{
+		count++;
+		snprintf(szQuery, sizeof(szQuery), "UPDATE change_empire SET change_count=%d WHERE account_id=%u", count, dwAID);
+	}
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+}
+
+DWORD CHARACTER::GetAID() const
+{
+	char szQuery[1024 + 1];
+	DWORD dwAID = 0;
+
+	snprintf(szQuery, sizeof(szQuery), "SELECT id FROM player_index%s WHERE "
+		"pid1=%u OR "
+		"pid2=%u OR "
+		"pid3=%u OR "
+		"pid4=%u"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		" OR pid5=%u"
+#endif
+		" AND empire=%u",
+		get_table_postfix(),
+		GetPlayerID(),
+		GetPlayerID(),
+		GetPlayerID(),
+		GetPlayerID(),
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		GetPlayerID(),
+#endif
+		GetEmpire());
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	if (pMsg->Get()->uiNumRows > 0)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		str_to_number(dwAID, row[0]);
+		return dwAID;
+	}
+
+	return 0;
+}
diff --git a/server/metin2/Source/Server/game/src/char_horse.cpp b/server/metin2/Source/Server/game/src/char_horse.cpp
index a3a653a..a21c0ca 100644
--- a/server/metin2/Source/Server/game/src/char_horse.cpp
+++ b/server/metin2/Source/Server/game/src/char_horse.cpp
@@ -1,404 +1,403 @@
-#include "stdafx.h"
-#include "config.h"
-#include "char.h"
-#include "char_manager.h"
-#include "packet.h"
-#include "guild.h"
-#include "vector.h"
-#include "questmanager.h"
-#include "item.h"
-#include "horsename_manager.h"
-#include "locale_service.h"
-#include "arena.h"
-#include "sectree_manager.h"
-
-#include "../../common/VnumHelper.h"
-
-bool CHARACTER::StartRiding()
-{
-	if (IsDead() == true)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("쓰러진 상태에서는 말에 탈 수 없습니다."));
-		return false;
-	}
-
-	if (IsPolymorphed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신 상태에서는 말에 탈 수 없습니다."));
-		return false;
-	}
-
-	if (IsFishing())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
-		return false;
-	}
-
-	if (IsRiding())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 탈것을 이용중입니다."));
-		return false;
-	}
-
-	if (FindAffect(AFFECT_MOUNT_FALL))
-		return false;
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, GetMapIndex()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
-		return false;
-	}
-#endif
-
-	// 턱시도 입은 상태의 말 타기 금지
-	LPITEM armor = GetWear(WEAR_BODY);
-
-	if (armor && (armor->GetVnum() >= 11901 && armor->GetVnum() <= 11904))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("예복을 입은 상태에서 말을 탈 수 없습니다."));
-		return false;
-	}
-
-	if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-		return false;
-
-	DWORD dwMountVnum = m_chHorse ? m_chHorse->GetRaceNum() : GetMyHorseVnum();
-
-	if (false == CHorseRider::StartRiding())
-	{
-		if (GetHorseLevel() <= 0)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("말을 소유하고 있지 않습니다."));
-		else if (GetHorseHealth() <= 0)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("말이 죽어있는 상태 입니다."));
-		else if (GetHorseStamina() <= 0)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("말의 스테미너가 부족하여 말을 탈 수 없습니다."));
-
-		return false;
-	}
-
-	// 소환한 말 없애고
-	HorseSummon(false);
-
-	MountVnum(dwMountVnum);
-
-	if (test_server)
-		sys_log(0, "Ride Horse : %s ", GetName());
-
-	return true;
-}
-
-bool CHARACTER::StopRiding()
-{
-	if (CHorseRider::StopRiding())
-	{
-		quest::CQuestManager::instance().Unmount(GetPlayerID());
-
-		if (!IsDead() && !IsStun())
-		{
-			DWORD dwOldVnum = GetMountVnum();
-			MountVnum(0);
-
-			// [NOTE] 말에서 내릴 땐 자기가 탔던걸 소환하도록 수정
-			HorseSummon(true, false, dwOldVnum);
-		}
-		else
-		{
-			m_dwMountVnum = 0;
-
-			ComputePoints();
-			UpdatePacket();
-		}
-
-		PointChange(POINT_ST, 0);
-		PointChange(POINT_DX, 0);
-		PointChange(POINT_HT, 0);
-		PointChange(POINT_IQ, 0);
-
-		return true;
-	}
-
-	return false;
-}
-
-EVENTFUNC(horse_dead_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("horse_dead_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = info->ch;
-
-	if (ch == NULL) // <Factor>
-		return 0;
-
-	ch->HorseSummon(false);
-	return 0;
-}
-
-void CHARACTER::SetRider(LPCHARACTER ch)
-{
-	if (m_chRider)
-		m_chRider->ClearHorseInfo();
-
-	m_chRider = ch;
-
-	if (m_chRider)
-		m_chRider->SendHorseInfo();
-}
-
-LPCHARACTER CHARACTER::GetRider() const
-{
-	return m_chRider;
-}
-
-void CHARACTER::HorseSummon(bool bSummon, bool bFromFar, DWORD dwVnum, const char* pHorseName)
-{
-	if (bSummon)
-	{
-		// NOTE : summon했는데 이미 horse가 있으면 아무것도 안한다.
-		if (m_chHorse != NULL)
-			return;
-
-		if (GetHorseLevel() <= 0)
-			return;
-
-		// 무언가를 타고 있다면 실패
-		if (IsRiding())
-			return;
-
-		sys_log(0, "HorseSummon : %s lv:%d bSummon:%d fromFar:%d", GetName(), GetLevel(), bSummon, bFromFar);
-
-		long x = GetX();
-		long y = GetY();
-
-		if (GetHorseHealth() <= 0)
-			bFromFar = false;
-
-		if (bFromFar)
-		{
-			x += (number(0, 1) * 2 - 1) * number(2000, 2500);
-			y += (number(0, 1) * 2 - 1) * number(2000, 2500);
-		}
-		else
-		{
-			x += number(-100, 100);
-			y += number(-100, 100);
-		}
-
-		m_chHorse = CHARACTER_MANAGER::instance().SpawnMob(
-			(0 == dwVnum) ? GetMyHorseVnum() : dwVnum,
-			GetMapIndex(),
-			x, y,
-			GetZ(), false, (int)(GetRotation() + 180), false);
-
-		if (!m_chHorse)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("말 소환에 실패하였습니다."));
-			return;
-		}
-
-		if (GetHorseHealth() <= 0)
-		{
-			// 죽은거처럼 있게 하는 처리
-			m_chHorse->SetPosition(POS_DEAD);
-
-			// 일정시간있다 사라지게 하자.
-			char_event_info* info = AllocEventInfo<char_event_info>();
-			info->ch = this;
-			m_chHorse->m_pkDeadEvent = event_create(horse_dead_event, info, PASSES_PER_SEC(60));
-		}
-
-		m_chHorse->SetLevel(GetHorseLevel());
-
-		const char* pHorseName = CHorseNameManager::instance().GetHorseName(GetPlayerID());
-
-		if (pHorseName != NULL && strlen(pHorseName) != 0)
-		{
-			m_chHorse->m_stName = pHorseName;
-		}
-		else
-		{
-			m_chHorse->m_stName = GetName();
-			m_chHorse->m_stName += LC_STRING("님의 말");
-		}
-
-		if (!m_chHorse->Show(GetMapIndex(), x, y, GetZ()))
-		{
-			M2_DESTROY_CHARACTER(m_chHorse);
-			sys_err("cannot show monster");
-			m_chHorse = NULL;
-			return;
-		}
-
-		if ((GetHorseHealth() <= 0))
-		{
-			TPacketGCDead pack;
-			pack.header = HEADER_GC_DEAD;
-			pack.vid = m_chHorse->GetVID();
-			PacketAround(&pack, sizeof(pack));
-		}
-
-		m_chHorse->SetRider(this);
-	}
-	else
-	{
-		if (!m_chHorse)
-			return;
-
-		LPCHARACTER chHorse = m_chHorse;
-
-		chHorse->SetRider(NULL); // m_chHorse assign to NULL
-
-		if (!bFromFar)
-		{
-			M2_DESTROY_CHARACTER(chHorse);
-		}
-		else
-		{
-			// 멀어지면서 사라지는 처리 하기
-			chHorse->SetNowWalking(false);
-			float fx, fy;
-			chHorse->SetRotation(GetDegreeFromPositionXY(chHorse->GetX(), chHorse->GetY(), GetX(), GetY()) + 180);
-			GetDeltaByDegree(chHorse->GetRotation(), 3500, &fx, &fy);
-			chHorse->Goto((long)(chHorse->GetX() + fx), (long)(chHorse->GetY() + fy));
-			chHorse->SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-		}
-
-		m_chHorse = NULL;
-	}
-}
-
-DWORD CHARACTER::GetMyHorseVnum() const
-{
-	int delta = 0;
-
-	if (GetGuild())
-	{
-		++delta;
-
-		if (GetGuild()->GetMasterPID() == GetPlayerID())
-			++delta;
-	}
-
-	return c_aHorseStat[GetHorseLevel()].iNPCRace + delta;
-}
-
-void CHARACTER::HorseDie()
-{
-	CHorseRider::HorseDie();
-	HorseSummon(false);
-}
-
-bool CHARACTER::ReviveHorse()
-{
-	if (CHorseRider::ReviveHorse())
-	{
-		HorseSummon(false);
-		HorseSummon(true);
-		return true;
-	}
-	return false;
-}
-
-void CHARACTER::ClearHorseInfo()
-{
-	if (!IsHorseRiding())
-	{
-		ChatPacket(CHAT_TYPE_COMMAND, "hide_horse_state");
-
-		m_bSendHorseLevel = 0;
-		m_bSendHorseHealthGrade = 0;
-		m_bSendHorseStaminaGrade = 0;
-	}
-
-	m_chHorse = NULL;
-
-}
-
-void CHARACTER::SendHorseInfo()
-{
-	if (m_chHorse || IsHorseRiding())
-	{
-		int iHealthGrade;
-		int iStaminaGrade;
-		/*
-			HP
-			3 : 70% < ~ <= 100%
-			2 : 30% < ~ <= 70%
-			1 : 0% < ~ <= 30%
-			0 : 사망
-
-			STM
-			3 : 71% < ~ <= 100%
-			2 : 31% < ~ <= 70%
-			1 : 10% < ~ <= 30%
-			0 : ~ <= 10%
-		*/
-		if (GetHorseHealth() == 0)
-			iHealthGrade = 0;
-		else if (GetHorseHealth() * 10 <= GetHorseMaxHealth() * 3)
-			iHealthGrade = 1;
-		else if (GetHorseHealth() * 10 <= GetHorseMaxHealth() * 7)
-			iHealthGrade = 2;
-		else
-			iHealthGrade = 3;
-
-		if (GetHorseStamina() * 10 <= GetHorseMaxStamina())
-			iStaminaGrade = 0;
-		else if (GetHorseStamina() * 10 <= GetHorseMaxStamina() * 3)
-			iStaminaGrade = 1;
-		else if (GetHorseStamina() * 10 <= GetHorseMaxStamina() * 7)
-			iStaminaGrade = 2;
-		else
-			iStaminaGrade = 3;
-
-		if (m_bSendHorseLevel != GetHorseLevel() ||
-			m_bSendHorseHealthGrade != iHealthGrade ||
-			m_bSendHorseStaminaGrade != iStaminaGrade)
-		{
-			ChatPacket(CHAT_TYPE_COMMAND, "horse_state %d %d %d", GetHorseLevel(), iHealthGrade, iStaminaGrade);
-
-			// FIX : 클라이언트에 "말 상태 버프" 아이콘을 표시하지 않을 목적으로 함수 초입에 return함으로써 아래 코드를 무시한다면
-			// 말을 무한대로 소환하는 무시무시한 버그가 생김.. 정확한 원인은 파악 안해봐서 모름.
-			m_bSendHorseLevel = GetHorseLevel();
-			m_bSendHorseHealthGrade = iHealthGrade;
-			m_bSendHorseStaminaGrade = iStaminaGrade;
-		}
-	}
-}
-
-bool CHARACTER::CanUseHorseSkill()
-{
-	if (IsRiding())
-	{
-		if (GetHorseGrade() == 3)
-			return true;
-		else
-			return false;
-
-		if (GetMountVnum())
-		{
-			if (GetMountVnum() >= 20209 && GetMountVnum() <= 20212)
-				return true;
-
-			// 라마단 흑마
-			if (CMobVnumHelper::IsRamadanBlackHorse(GetMountVnum()))
-				return true;
-		}
-		else
-			return false;
-	}
-
-	return false;
-}
-
-void CHARACTER::SetHorseLevel(int iLevel)
-{
-	CHorseRider::SetHorseLevel(iLevel);
-	SetSkillLevel(SKILL_HORSE, GetHorseLevel());
-}
+#include "stdafx.h"
+#include "config.h"
+#include "char.h"
+#include "char_manager.h"
+#include "packet.h"
+#include "guild.h"
+#include "vector.h"
+#include "questmanager.h"
+#include "item.h"
+#include "horsename_manager.h"
+#include "locale_service.h"
+#include "arena.h"
+#include "sectree_manager.h"
+
+#include "../../common/VnumHelper.h"
+
+bool CHARACTER::StartRiding()
+{
+	if (IsDead() == true)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 쩔  탈  求."));
+		return false;
+	}
+
+	if (IsPolymorphed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 쩔  탈  求."));
+		return false;
+	}
+
+	if (IsFishing())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
+		return false;
+	}
+
+	if (IsRiding())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 탈 結都求."));
+		return false;
+	}
+
+	if (FindAffect(AFFECT_MOUNT_FALL))
+		return false;
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, GetMapIndex()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
+		return false;
+	}
+#endif
+
+	// 館천    타 
+	LPITEM armor = GetWear(WEAR_BODY);
+
+	if (armor && (armor->GetVnum() >= 11901 && armor->GetVnum() <= 11904))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("  쩔  탈  求."));
+		return false;
+	}
+
+	if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+		return false;
+
+	DWORD dwMountVnum = m_chHorse ? m_chHorse->GetRaceNum() : GetMyHorseVnum();
+
+	if (false == CHorseRider::StartRiding())
+	{
+		if (GetHorseLevel() <= 0)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 構  駕求."));
+		else if (GetHorseHealth() <= 0)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 類獵  都求."));
+		else if (GetHorseStamina() <= 0)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 瑠犬歌 臼  탈  求."));
+
+		return false;
+	}
+
+	// 환  斂
+	HorseSummon(false);
+
+	MountVnum(dwMountVnum);
+
+	if (test_server)
+		sys_log(0, "Ride Horse : %s ", GetName());
+
+	return true;
+}
+
+bool CHARACTER::StopRiding()
+{
+	if (CHorseRider::StopRiding())
+	{
+		quest::CQuestManager::instance().Unmount(GetPlayerID());
+
+		if (!IsDead() && !IsStun())
+		{
+			DWORD dwOldVnum = GetMountVnum();
+			MountVnum(0);
+
+			// [NOTE]    未璲  환溝 
+			HorseSummon(true, false, dwOldVnum);
+		}
+		else
+		{
+			m_dwMountVnum = 0;
+
+			ComputePoints();
+			UpdatePacket();
+		}
+
+		PointChange(POINT_ST, 0);
+		PointChange(POINT_DX, 0);
+		PointChange(POINT_HT, 0);
+		PointChange(POINT_IQ, 0);
+
+		return true;
+	}
+
+	return false;
+}
+
+EVENTFUNC(horse_dead_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("horse_dead_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = info->ch;
+
+	if (ch == NULL) // <Factor>
+		return 0;
+
+	ch->HorseSummon(false);
+	return 0;
+}
+
+void CHARACTER::SetRider(LPCHARACTER ch)
+{
+	if (m_chRider)
+		m_chRider->ClearHorseInfo();
+
+	m_chRider = ch;
+
+	if (m_chRider)
+		m_chRider->SendHorseInfo();
+}
+
+LPCHARACTER CHARACTER::GetRider() const
+{
+	return m_chRider;
+}
+
+void CHARACTER::HorseSummon(bool bSummon, bool bFromFar, DWORD dwVnum, const char* pHorseName)
+{
+	if (bSummon)
+	{
+		// NOTE : summon杉쨉 譴 horse  틜孤 磯.
+		if (m_chHorse != NULL)
+			return;
+
+		if (GetHorseLevel() <= 0)
+			return;
+
+		// 臍「 타 獵摸 
+		if (IsRiding())
+			return;
+
+		sys_log(0, "HorseSummon : %s lv:%d bSummon:%d fromFar:%d", GetName(), GetLevel(), bSummon, bFromFar);
+
+		long x = GetX();
+		long y = GetY();
+
+		if (GetHorseHealth() <= 0)
+			bFromFar = false;
+
+		if (bFromFar)
+		{
+			x += (number(0, 1) * 2 - 1) * number(2000, 2500);
+			y += (number(0, 1) * 2 - 1) * number(2000, 2500);
+		}
+		else
+		{
+			x += number(-100, 100);
+			y += number(-100, 100);
+		}
+
+		m_chHorse = CHARACTER_MANAGER::instance().SpawnMob(
+			(0 == dwVnum) ? GetMyHorseVnum() : dwVnum,
+			GetMapIndex(),
+			x, y,
+			GetZ(), false, (int)(GetRotation() + 180), false);
+
+		if (!m_chHorse)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 환 臼求."));
+			return;
+		}
+
+		if (GetHorseHealth() <= 0)
+		{
+			// 처 斂 求 처
+			m_chHorse->SetPosition(POS_DEAD);
+
+			// 챨獵  .
+			char_event_info* info = AllocEventInfo<char_event_info>();
+			info->ch = this;
+			m_chHorse->m_pkDeadEvent = event_create(horse_dead_event, info, PASSES_PER_SEC(60));
+		}
+
+		m_chHorse->SetLevel(GetHorseLevel());
+
+		const char* pHorseName = CHorseNameManager::instance().GetHorseName(GetPlayerID());
+
+		if (pHorseName != NULL && strlen(pHorseName) != 0)
+		{
+			m_chHorse->m_stName = pHorseName;
+		}
+		else
+		{
+			m_chHorse->m_stName = GetName();
+			m_chHorse->m_stName += LC_STRING(" ");
+		}
+
+		if (!m_chHorse->Show(GetMapIndex(), x, y, GetZ()))
+		{
+			M2_DESTROY_CHARACTER(m_chHorse);
+			sys_err("cannot show monster");
+			m_chHorse = NULL;
+			return;
+		}
+
+		if ((GetHorseHealth() <= 0))
+		{
+			TPacketGCDead pack;
+			pack.header = HEADER_GC_DEAD;
+			pack.vid = m_chHorse->GetVID();
+			PacketAround(&pack, sizeof(pack));
+		}
+
+		m_chHorse->SetRider(this);
+	}
+	else
+	{
+		if (!m_chHorse)
+			return;
+
+		LPCHARACTER chHorse = m_chHorse;
+
+		chHorse->SetRider(NULL); // m_chHorse assign to NULL
+
+		if (!bFromFar)
+		{
+			M2_DESTROY_CHARACTER(chHorse);
+		}
+		else
+		{
+			// 羚庸  처 歐
+			chHorse->SetNowWalking(false);
+			float fx, fy;
+			chHorse->SetRotation(GetDegreeFromPositionXY(chHorse->GetX(), chHorse->GetY(), GetX(), GetY()) + 180);
+			GetDeltaByDegree(chHorse->GetRotation(), 3500, &fx, &fy);
+			chHorse->Goto((long)(chHorse->GetX() + fx), (long)(chHorse->GetY() + fy));
+			chHorse->SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+		}
+
+		m_chHorse = NULL;
+	}
+}
+
+DWORD CHARACTER::GetMyHorseVnum() const
+{
+	int delta = 0;
+
+	if (GetGuild())
+	{
+		++delta;
+
+		if (GetGuild()->GetMasterPID() == GetPlayerID())
+			++delta;
+	}
+
+	return c_aHorseStat[GetHorseLevel()].iNPCRace + delta;
+}
+
+void CHARACTER::HorseDie()
+{
+	CHorseRider::HorseDie();
+	HorseSummon(false);
+}
+
+bool CHARACTER::ReviveHorse()
+{
+	if (CHorseRider::ReviveHorse())
+	{
+		HorseSummon(false);
+		HorseSummon(true);
+		return true;
+	}
+	return false;
+}
+
+void CHARACTER::ClearHorseInfo()
+{
+	if (!IsHorseRiding())
+	{
+		ChatPacket(CHAT_TYPE_COMMAND, "hide_horse_state");
+
+		m_bSendHorseLevel = 0;
+		m_bSendHorseHealthGrade = 0;
+		m_bSendHorseStaminaGrade = 0;
+	}
+
+	m_chHorse = NULL;
+
+}
+
+void CHARACTER::SendHorseInfo()
+{
+	if (m_chHorse || IsHorseRiding())
+	{
+		int iHealthGrade;
+		int iStaminaGrade;
+		/*
+			HP
+			3 : 70% < ~ <= 100%
+			2 : 30% < ~ <= 70%
+			1 : 0% < ~ <= 30%
+			0 : 
+
+			STM
+			3 : 71% < ~ <= 100%
+			2 : 31% < ~ <= 70%
+			1 : 10% < ~ <= 30%
+			0 : ~ <= 10%
+		*/
+		if (GetHorseHealth() == 0)
+			iHealthGrade = 0;
+		else if (GetHorseHealth() * 10 <= GetHorseMaxHealth() * 3)
+			iHealthGrade = 1;
+		else if (GetHorseHealth() * 10 <= GetHorseMaxHealth() * 7)
+			iHealthGrade = 2;
+		else
+			iHealthGrade = 3;
+
+		if (GetHorseStamina() * 10 <= GetHorseMaxStamina())
+			iStaminaGrade = 0;
+		else if (GetHorseStamina() * 10 <= GetHorseMaxStamina() * 3)
+			iStaminaGrade = 1;
+		else if (GetHorseStamina() * 10 <= GetHorseMaxStamina() * 7)
+			iStaminaGrade = 2;
+		else
+			iStaminaGrade = 3;
+
+		if (m_bSendHorseLevel != GetHorseLevel() ||
+			m_bSendHorseHealthGrade != iHealthGrade ||
+			m_bSendHorseStaminaGrade != iStaminaGrade)
+		{
+			ChatPacket(CHAT_TYPE_COMMAND, "horse_state %d %d %d", GetHorseLevel(), iHealthGrade, iStaminaGrade);
+
+			// FIX : 클潔트 "  "  표   獨 篤 return館 틔 湄躍 磯摸
+			//  磯 환求 첫 陋 .. 확  컁 曼 .
+			m_bSendHorseLevel = GetHorseLevel();
+			m_bSendHorseHealthGrade = iHealthGrade;
+			m_bSendHorseStaminaGrade = iStaminaGrade;
+		}
+	}
+}
+
+bool CHARACTER::CanUseHorseSkill()
+{
+	if (!IsRiding())
+		return false;
+
+	// Default: only allow horse skills on advanced horses
+	if (GetHorseGrade() == 3)
+		return true;
+
+	// Allow specific mounts that are designed to use horse skills
+	if (GetMountVnum())
+	{
+		if (GetMountVnum() >= 20209 && GetMountVnum() <= 20212)
+			return true;
+
+		// Ramadan mount
+		if (CMobVnumHelper::IsRamadanBlackHorse(GetMountVnum()))
+			return true;
+	}
+
+	return false;
+}
+
+
+void CHARACTER::SetHorseLevel(int iLevel)
+{
+	CHorseRider::SetHorseLevel(iLevel);
+	SetSkillLevel(SKILL_HORSE, GetHorseLevel());
+}
diff --git a/server/metin2/Source/Server/game/src/char_skill.cpp b/server/metin2/Source/Server/game/src/char_skill.cpp
index 8a6dc6c..4d72751 100644
--- a/server/metin2/Source/Server/game/src/char_skill.cpp
+++ b/server/metin2/Source/Server/game/src/char_skill.cpp
@@ -1,4621 +1,4628 @@
-#include "stdafx.h"
-#include <sstream>
-
-#include "utils.h"
-#include "config.h"
-#include "vector.h"
-#include "char.h"
-#include "char_manager.h"
-#include "battle.h"
-#include "desc.h"
-#include "desc_manager.h"
-#include "packet.h"
-#include "affect.h"
-#include "item.h"
-#include "sectree_manager.h"
-#include "mob_manager.h"
-#include "start_position.h"
-#include "party.h"
-#include "buffer_manager.h"
-#include "guild.h"
-#include "log.h"
-#include "unique_item.h"
-#include "questmanager.h"
-#if defined(__DAWNMIST_DUNGEON__)
-#	include "dawnmist_dungeon.h"
-#endif
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-extern int test_server;
-
-static const DWORD s_adwSubSkillVnums[] =
-{
-	SKILL_LEADERSHIP,
-	SKILL_COMBO,
-	SKILL_MINING,
-	SKILL_LANGUAGE1,
-	SKILL_LANGUAGE2,
-	SKILL_LANGUAGE3,
-	SKILL_POLYMORPH,
-	SKILL_HORSE,
-	SKILL_HORSE_SUMMON,
-	SKILL_HORSE_WILDATTACK,
-	SKILL_HORSE_CHARGE,
-	SKILL_HORSE_ESCAPE,
-	SKILL_HORSE_WILDATTACK_RANGE,
-	SKILL_ADD_HP,
-	SKILL_RESIST_PENETRATE,
-#if defined(__PARTY_PROFICY__)
-	SKILL_ROLE_PROFICIENCY,
-#endif
-#if defined(__PARTY_INSIGHT__)
-	SKILL_INSIGHT,
-#endif
-	SKILL_HIT,
-};
-
-struct FPartyPIDCollector
-{
-	std::vector<DWORD> vecPIDs;
-	FPartyPIDCollector() = default;
-	void operator () (LPCHARACTER ch)
-	{
-		vecPIDs.push_back(ch->GetPlayerID());
-	}
-};
-
-struct FPartyMOBCollector
-{
-	std::vector<DWORD> vecPIDs;
-	FPartyMOBCollector() = default;
-	void operator () (LPCHARACTER ch)
-	{
-		vecPIDs.push_back(ch->GetVID());
-	}
-};
-
-time_t CHARACTER::GetSkillNextReadTime(DWORD dwVnum) const
-{
-	if (dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("vnum overflow (vnum: %u)", dwVnum);
-		return 0;
-	}
-
-	return m_pSkillLevels ? m_pSkillLevels[dwVnum].tNextRead : 0;
-}
-
-void CHARACTER::SetSkillNextReadTime(DWORD dwVnum, time_t time)
-{
-	if (m_pSkillLevels && dwVnum < SKILL_MAX_NUM)
-		m_pSkillLevels[dwVnum].tNextRead = time;
-}
-
-bool TSkillUseInfo::HitOnce(DWORD dwVnum)
-{
-	// 쓰지도않았으면 때리지도 못한다.
-	if (!bUsed)
-		return false;
-
-	sys_log(1, "__HitOnce NextUse %u current %u count %d scount %d", dwNextSkillUsableTime, get_dword_time(), iHitCount, iSplashCount);
-
-	if (dwNextSkillUsableTime && dwNextSkillUsableTime < get_dword_time()
-		&& dwVnum != SKILL_MUYEONG
-		&& dwVnum != SKILL_HORSE_WILDATTACK 
-#if defined(__PVP_BALANCE_IMPROVING__)
-		&& dwVnum != SKILL_GYEONGGONG
-#endif
-		)
-	{
-		sys_log(1, "__HitOnce can't hit");
-
-		return false;
-	}
-
-	if (iHitCount == -1)
-	{
-		sys_log(1, "__HitOnce OK %d %d %d", dwNextSkillUsableTime, get_dword_time(), iHitCount);
-		return true;
-	}
-
-	if (iHitCount)
-	{
-		sys_log(1, "__HitOnce OK %d %d %d", dwNextSkillUsableTime, get_dword_time(), iHitCount);
-		iHitCount--;
-		return true;
-	}
-	return false;
-}
-
-bool TSkillUseInfo::UseSkill(bool isGrandMaster, DWORD vid, DWORD dwCooltime, int splashcount, int hitcount, int range)
-{
-	this->isGrandMaster = isGrandMaster;
-	DWORD dwCur = get_dword_time();
-
-	// 아직 쿨타임이 끝나지 않았다.
-	if (bUsed && dwNextSkillUsableTime > dwCur)
-	{
-		sys_log(0, "cooltime is not over delta %u", dwNextSkillUsableTime - dwCur);
-		iHitCount = 0;
-		return false;
-	}
-
-	bUsed = true;
-
-	if (dwCooltime)
-		dwNextSkillUsableTime = dwCur + dwCooltime;
-	else
-		dwNextSkillUsableTime = 0;
-
-	iRange = range;
-	iMaxHitCount = iHitCount = hitcount;
-
-	if (test_server)
-		sys_log(0, "UseSkill NextUse %u current %u cooltime %d hitcount %d/%d", dwNextSkillUsableTime, dwCur, dwCooltime, iHitCount, iMaxHitCount);
-
-	dwVID = vid;
-	iSplashCount = splashcount;
-	return true;
-}
-
-int CHARACTER::GetChainLightningMaxCount() const
-{
-	return aiChainLightningCountBySkillLevel[MIN(SKILL_MAX_LEVEL, GetSkillLevel(SKILL_CHAIN))];
-}
-
-void CHARACTER::SetAffectedEunhyung()
-{
-	m_dwAffectedEunhyungLevel = GetSkillPower(SKILL_EUNHYUNG);
-}
-
-void CHARACTER::SetSkillGroup(BYTE bSkillGroup)
-{
-	if (bSkillGroup > 2)
-		return;
-
-	if (GetLevel() < 5)
-		return;
-
-	m_points.bSkillGroup = bSkillGroup;
-
-	TPacketGCChangeSkillGroup p;
-	p.header = HEADER_GC_SKILL_GROUP;
-	p.skill_group = m_points.bSkillGroup;
-
-	GetDesc()->Packet(&p, sizeof(TPacketGCChangeSkillGroup));
-}
-
-int CHARACTER::ComputeCooltime(int time)
-{
-	return CalculateDuration(GetPoint(POINT_CASTING_SPEED), time);
-}
-
-void CHARACTER::SkillLevelPacket()
-{
-	if (!GetDesc())
-		return;
-
-	TPacketGCSkillLevel pack;
-
-	pack.bHeader = HEADER_GC_SKILL_LEVEL;
-	thecore_memcpy(&pack.skills, m_pSkillLevels, sizeof(TPlayerSkill) * SKILL_MAX_NUM);
-	GetDesc()->Packet(&pack, sizeof(TPacketGCSkillLevel));
-}
-
-void CHARACTER::SetSkillLevel(DWORD dwVnum, BYTE bLev)
-{
-	if (NULL == m_pSkillLevels)
-		return;
-
-	if (dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("vnum overflow (vnum %u)", dwVnum);
-		return;
-	}
-
-	m_pSkillLevels[dwVnum].bLevel = MIN(SKILL_MAX_LEVEL, bLev);
-
-	if (bLev >= 40)
-		m_pSkillLevels[dwVnum].bMasterType = SKILL_PERFECT_MASTER;
-	else if (bLev >= 30)
-		m_pSkillLevels[dwVnum].bMasterType = SKILL_GRAND_MASTER;
-	else if (bLev >= 20)
-		m_pSkillLevels[dwVnum].bMasterType = SKILL_MASTER;
-	else
-		m_pSkillLevels[dwVnum].bMasterType = SKILL_NORMAL;
-}
-
-bool CHARACTER::IsLearnableSkill(DWORD dwSkillVnum) const
-{
-	const CSkillProto* pkSkill = CSkillManager::instance().Get(dwSkillVnum);
-
-	if (!pkSkill)
-		return false;
-
-	if (GetSkillLevel(dwSkillVnum) >= SKILL_MAX_LEVEL)
-		return false;
-
-	if (pkSkill->dwType == SKILL_BOOK_TYPE_SUPPORT)
-	{
-		if (GetSkillLevel(dwSkillVnum) >= pkSkill->bMaxLevel)
-			return false;
-
-		return true;
-	}
-
-	if (pkSkill->dwType == SKILL_BOOK_TYPE_HORSE)
-	{
-		if (dwSkillVnum == SKILL_HORSE_WILDATTACK_RANGE && GetJob() != JOB_ASSASSIN)
-			return false;
-
-		return true;
-	}
-
-	if (GetSkillGroup() == 0)
-		return false;
-
-	if (pkSkill->dwType - 1 == GetJob())
-		return true;
-
-	if (SKILL_BOOK_TYPE_WOLFMAN == pkSkill->dwType && JOB_WOLFMAN == GetJob())
-		return true;
-
-	if (SKILL_BOOK_TYPE_PASSIVE == pkSkill->dwType)
-	{
-		if (SKILL_7_A_ANTI_TANHWAN <= dwSkillVnum && dwSkillVnum <= SKILL_7_D_ANTI_YONGBI)
-		{
-			for (int i = 0; i < 4; i++)
-			{
-				if (unsigned(SKILL_7_A_ANTI_TANHWAN + i) != dwSkillVnum)
-				{
-					if (0 != GetSkillLevel(SKILL_7_A_ANTI_TANHWAN + i))
-					{
-						return false;
-					}
-				}
-			}
-
-			return true;
-		}
-
-		if (SKILL_8_A_ANTI_GIGONGCHAM <= dwSkillVnum && dwSkillVnum <= SKILL_8_D_ANTI_BYEURAK)
-		{
-			for (int i = 0; i < 4; i++)
-			{
-				if (unsigned(SKILL_8_A_ANTI_GIGONGCHAM + i) != dwSkillVnum)
-				{
-					if (0 != GetSkillLevel(SKILL_8_A_ANTI_GIGONGCHAM + i))
-						return false;
-				}
-			}
-
-			return true;
-		}
-
-#if defined(__7AND8TH_SKILLS__)
-		if (dwSkillVnum >= SKILL_ANTI_PALBANG && dwSkillVnum <= SKILL_HELP_SALPOONG)
-		{
-			if (GetSkillLevel(dwSkillVnum) != 0)
-				return true;
-		}
-#endif
-	}
-
-	return false;
-}
-
-// ADD_GRANDMASTER_SKILL
-bool CHARACTER::LearnGrandMasterSkill(DWORD dwSkillVnum)
-{
-	const CSkillProto* pkSk = CSkillManager::instance().Get(dwSkillVnum);
-
-	if (!pkSk)
-		return false;
-
-	if (!IsLearnableSkill(dwSkillVnum))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("수련할 수 없는 스킬입니다."));
-		return false;
-	}
-
-	sys_log(0, "learn grand master skill[%d] cur %d, next %d", dwSkillVnum, get_global_time(), GetSkillNextReadTime(dwSkillVnum));
-
-	/*
-	if (get_global_time() < GetSkillNextReadTime(dwSkillVnum))
-	{
-		if (!(test_server && quest::CQuestManager::instance().GetEventFlag("no_read_delay")))
-		{
-			if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
-			{
-				// 주안술서 사용중에는 시간 제한 무시
-				RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("주안술서를 통해 주화입마에서 빠져나왔습니다."));
-			}
-			else
-			{
-				SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
-				return false;
-			}
-		}
-	}
-	*/
-
-	// bType 이 0이면 처음부터 책으로 수련 가능
-	if (pkSk->dwType == SKILL_BOOK_TYPE_SUPPORT)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("그랜드 마스터 수련을 할 수 없는 스킬입니다."));
-		return false;
-	}
-
-	if (GetSkillMasterType(dwSkillVnum) != SKILL_GRAND_MASTER)
-	{
-		if (GetSkillMasterType(dwSkillVnum) > SKILL_GRAND_MASTER)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("퍼펙트 마스터된 스킬입니다. 더 이상 수련 할 수 없습니다."));
-		else
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 스킬은 아직 그랜드 마스터 수련을 할 경지에 이르지 않았습니다."));
-		return false;
-	}
-
-	std::string strTrainSkill;
-	{
-		std::ostringstream os;
-		os << "training_grandmaster_skill.skill" << dwSkillVnum;
-		strTrainSkill = os.str();
-	}
-
-	// 여기서 확률을 계산합니다.
-	BYTE bLastLevel = GetSkillLevel(dwSkillVnum);
-
-	int idx = MIN(9, GetSkillLevel(dwSkillVnum) - 30);
-
-	sys_log(0, "LearnGrandMasterSkill %s table idx %d value %d", GetName(), idx, aiGrandMasterSkillBookCountForLevelUp[idx]);
-
-	int iTotalReadCount = GetQuestFlag(strTrainSkill) + 1;
-	SetQuestFlag(strTrainSkill, iTotalReadCount);
-
-	int iMinReadCount = aiGrandMasterSkillBookMinCount[idx];
-	int iMaxReadCount = aiGrandMasterSkillBookMaxCount[idx];
-
-	int iBookCount = aiGrandMasterSkillBookCountForLevelUp[idx];
-
-	if (LC_IsYMIR() == true || LC_IsKorea() == true)
-	{
-		const int aiGrandMasterSkillBookCountForLevelUp_euckr[10] =
-		{
-			3, 3, 4, 5, 6, 7, 8, 9, 10, 15,
-		};
-
-		const int aiGrandMasterSkillBookMinCount_euckr[10] =
-		{
-			1, 1, 1, 2, 2, 2, 3, 3, 4, 5
-		};
-
-		const int aiGrandMasterSkillBookMaxCount_euckr[10] =
-		{
-			5, 7, 9, 11, 13, 15, 18, 23, 25, 30
-		};
-
-		iMinReadCount = aiGrandMasterSkillBookMinCount_euckr[idx];
-		iMaxReadCount = aiGrandMasterSkillBookMaxCount_euckr[idx];
-		iBookCount = aiGrandMasterSkillBookCountForLevelUp_euckr[idx];
-	}
-
-	if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
-	{
-		if (iBookCount & 1)
-			iBookCount = iBookCount / 2 + 1;
-		else
-			iBookCount = iBookCount / 2;
-
-		RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
-	}
-
-	int n = number(1, iBookCount);
-	sys_log(0, "Number(%d)", n);
-
-	DWORD nextTime = get_global_time() + number(28800, 43200);
-
-	sys_log(0, "GrandMaster SkillBookCount min %d cur %d max %d (next_time=%d)", iMinReadCount, iTotalReadCount, iMaxReadCount, nextTime);
-
-	bool bSuccess = n == 2;
-
-	if (iTotalReadCount < iMinReadCount)
-		bSuccess = false;
-	if (iTotalReadCount > iMaxReadCount)
-		bSuccess = true;
-
-	if (bSuccess)
-	{
-		SkillLevelUp(dwSkillVnum, SKILL_UP_BY_QUEST);
-	}
-
-	SetSkillNextReadTime(dwSkillVnum, nextTime);
-
-	if (bLastLevel == GetSkillLevel(dwSkillVnum))
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("크윽, 기가 역류하고 있어! 이거 설마 주화입마인가!? 젠장!"));
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("수련이 실패로 끝났습니다. 다시 도전해주시기 바랍니다."));
-		LogManager::instance().CharLog(this, dwSkillVnum, "GM_READ_FAIL", "");
-		return false;
-	}
-
-	ChatPacket(CHAT_TYPE_TALKING, LC_STRING("몸에서 뭔가 힘이 터져 나오는 기분이야!"));
-	ChatPacket(CHAT_TYPE_TALKING, LC_STRING("뜨거운 무엇이 계속 용솟음치고 있어! 이건, 이것은!"));
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 높은 경지의 수련을 성공적으로 끝내셨습니다."));
-	LogManager::instance().CharLog(this, dwSkillVnum, "GM_READ_SUCCESS", "");
-	return true;
-}
-// END_OF_ADD_GRANDMASTER_SKILL
-
-static bool FN_should_check_exp(LPCHARACTER ch)
-{
-	if (LC_IsCanada())
-		return ch->GetLevel() < gPlayerMaxLevel;
-
-	if (!LC_IsYMIR())
-		return true;
-
-	return false;
-}
-
-bool CHARACTER::LearnSkillByBook(DWORD dwSkillVnum, BYTE bProb)
-{
-	const CSkillProto* pkSk = CSkillManager::instance().Get(dwSkillVnum);
-	if (pkSk == nullptr)
-		return false;
-
-	if (!IsLearnableSkill(dwSkillVnum))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("수련할 수 없는 스킬입니다."));
-		return false;
-	}
-
-#if defined(__CONQUEROR_LEVEL__)
-	const bool bConquerorSkill = IsConquerorSkill(dwSkillVnum);
-	if (bConquerorSkill && GetConquerorLevel() <= 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can learn this after reaching the Champion Level."));
-		return false;
-	}
-#endif
-
-	POINT_VALUE need_exp = 0;
-
-	if (FN_should_check_exp(this))
-	{
-		need_exp = 20000;
-
-#if defined(__CONQUEROR_LEVEL__)
-		if (bConquerorSkill && GetConquerorExp() < need_exp)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("경험치가 부족하여 책을 읽을 수 없습니다."));
-			return false;
-		}
-		else
-		{
-			if (GetExp() < need_exp)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("경험치가 부족하여 책을 읽을 수 없습니다."));
-				return false;
-			}
-		}
-#else
-		if (GetExp() < need_exp)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("경험치가 부족하여 책을 읽을 수 없습니다."));
-			return false;
-		}
-#endif
-	}
-
-	if (pkSk->dwType != SKILL_BOOK_TYPE_SUPPORT)
-	{
-		if (GetSkillMasterType(dwSkillVnum) != SKILL_MASTER)
-		{
-			if (GetSkillMasterType(dwSkillVnum) > SKILL_MASTER)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 스킬은 책으로 더이상 수련할 수 없습니다."));
-				return false;
-			}
-			else
-			{
-				if (pkSk->dwType != SKILL_BOOK_TYPE_PASSIVE
-#if defined(__CONQUEROR_LEVEL__)
-					&& !bConquerorSkill
-#endif
-					)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 스킬은 아직 책으로 수련할 경지에 이르지 않았습니다."));
-					return false;
-				}
-			}
-		}
-	}
-
-	if (get_global_time() < GetSkillNextReadTime(dwSkillVnum))
-	{
-		if (!(test_server && quest::CQuestManager::instance().GetEventFlag("no_read_delay")))
-		{
-			if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
-			{
-				// 주안술서 사용중에는 시간 제한 무시
-				RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("주안술서를 통해 주화입마에서 빠져나왔습니다."));
-			}
-			else
-			{
-				SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
-				return false;
-			}
-		}
-	}
-
-	// 여기서 확률을 계산합니다.
-	BYTE bLastLevel = GetSkillLevel(dwSkillVnum);
-
-	if (bProb != 0)
-	{
-		// SKILL_BOOK_BONUS
-		if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
-		{
-			bProb += bProb / 2;
-			RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
-		}
-		// END_OF_SKILL_BOOK_BONUS
-
-		sys_log(0, "LearnSkillByBook Pct %u prob %d", dwSkillVnum, bProb);
-
-		if (number(1, 100) <= bProb)
-		{
-			if (test_server)
-				sys_log(0, "LearnSkillByBook %u SUCC", dwSkillVnum);
-
-			SkillLevelUp(dwSkillVnum, SKILL_UP_BY_BOOK);
-		}
-		else
-		{
-			if (test_server)
-				sys_log(0, "LearnSkillByBook %u FAIL", dwSkillVnum);
-		}
-	}
-	else
-	{
-		int idx = MIN(9, GetSkillLevel(dwSkillVnum) - 20);
-
-		sys_log(0, "LearnSkillByBook %s table idx %d value %d", GetName(), idx, aiSkillBookCountForLevelUp[idx]);
-
-		if (!LC_IsYMIR())
-		{
-			int need_bookcount = GetSkillLevel(dwSkillVnum) - 20;
-
-#if defined(__CONQUEROR_LEVEL__)
-			PointChange(bConquerorSkill ? POINT_CONQUEROR_EXP : POINT_EXP, -need_exp);
-#else
-			PointChange(POINT_EXP, -need_exp);
-#endif
-
-			quest::CQuestManager& q = quest::CQuestManager::instance();
-			quest::PC* pPC = q.GetPC(GetPlayerID());
-
-			if (pPC)
-			{
-				char flag[128 + 1];
-				memset(flag, 0, sizeof(flag));
-				snprintf(flag, sizeof(flag), "traning_master_skill.%u.read_count", dwSkillVnum);
-
-				int read_count = pPC->GetFlag(flag);
-				int percent = 65;
-
-				if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
-				{
-					percent = 0;
-					RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
-				}
-
-				if (number(1, 100) > percent)
-				{
-					// 책읽기에 성공
-					if (read_count >= need_bookcount)
-					{
-						SkillLevelUp(dwSkillVnum, SKILL_UP_BY_BOOK);
-						pPC->SetFlag(flag, 0);
-
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("책으로 더 높은 경지의 수련을 성공적으로 끝내셨습니다."));
-						LogManager::instance().CharLog(this, dwSkillVnum, "READ_SUCCESS", "");
-						return true;
-					}
-					else
-					{
-						pPC->SetFlag(flag, read_count + 1);
-
-						switch (number(1, 3))
-						{
-							case 1:
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("어느정도 이 기술에 대해 이해가 되었지만 조금 부족한듯 한데.."));
-								break;
-
-							case 2:
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("드디어 끝이 보이는 건가...  이 기술은 이해하기가 너무 힘들어.."));
-								break;
-
-							case 3:
-							default:
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("열심히 하는 배움을 가지는 것만이 기술을 배울수 있는 유일한 길이다.."));
-								break;
-						}
-
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 권을 더 읽어야 수련을 완료 할 수 있습니다.", need_bookcount - read_count));
-						return true;
-					}
-				}
-			}
-			else
-			{
-				// 사용자의 퀘스트 정보 로드 실패
-			}
-		}
-		// INTERNATIONAL_VERSION
-		else
-		{
-			int iBookCount = 99;
-
-			if (LC_IsYMIR() == true)
-			{
-				const int aiSkillBookCountForLevelUp_euckr[10] =
-				{
-					2, 2, 3, 3, 3, 3, 3, 3, 4, 5
-				};
-
-				iBookCount = aiSkillBookCountForLevelUp_euckr[idx];
-			}
-			else
-				iBookCount = aiSkillBookCountForLevelUp[idx];
-
-			if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
-			{
-				if (iBookCount & 1) // iBookCount % 2
-					iBookCount = iBookCount / 2 + 1;
-				else
-					iBookCount = iBookCount / 2;
-
-				RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
-			}
-
-			if (number(1, iBookCount) == 2)
-				SkillLevelUp(dwSkillVnum, SKILL_UP_BY_BOOK);
-		}
-		// END_OF_INTERNATIONAL_VERSION
-	}
-
-	if (bLastLevel != GetSkillLevel(dwSkillVnum))
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("몸에서 뭔가 힘이 터져 나오는 기분이야!"));
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("뜨거운 무엇이 계속 용솟음치고 있어! 이건, 이것은!"));
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("책으로 더 높은 경지의 수련을 성공적으로 끝내셨습니다."));
-		LogManager::instance().CharLog(this, dwSkillVnum, "READ_SUCCESS", "");
-	}
-	else
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("크윽, 기가 역류하고 있어! 이거 설마 주화입마인가!? 젠장!"));
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("수련이 실패로 끝났습니다. 다시 도전해주시기 바랍니다."));
-		LogManager::instance().CharLog(this, dwSkillVnum, "READ_FAIL", "");
-	}
-
-	return true;
-}
-
-bool CHARACTER::SkillLevelDown(DWORD dwVnum)
-{
-	if (NULL == m_pSkillLevels)
-		return false;
-
-	if (g_bSkillDisable)
-		return false;
-
-	if (IsPolymorphed())
-		return false;
-
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-
-	if (!pkSk)
-	{
-		sys_err("There is no such skill by number %u", dwVnum);
-		return false;
-	}
-
-	if (!IsLearnableSkill(dwVnum))
-		return false;
-
-	if (GetSkillMasterType(pkSk->dwVnum) != SKILL_NORMAL)
-		return false;
-
-	if (!GetSkillGroup())
-		return false;
-
-	if (pkSk->dwVnum >= SKILL_MAX_NUM)
-		return false;
-
-	if (m_pSkillLevels[pkSk->dwVnum].bLevel == 0)
-		return false;
-
-	int idx = POINT_SKILL;
-	switch (pkSk->dwType)
-	{
-		case 0:
-			idx = POINT_SUB_SKILL;
-			break;
-		case 1:
-		case 2:
-		case 3:
-		case 4:
-		case 6:
-		case 7:
-			idx = POINT_SKILL;
-			break;
-		case 5:
-			idx = POINT_HORSE_SKILL;
-			break;
-		default:
-			sys_err("Wrong skill type %d skill vnum %d", pkSk->dwType, pkSk->dwVnum);
-			return false;
-	}
-
-	PointChange(idx, +1);
-	SetSkillLevel(pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bLevel - 1);
-
-	sys_log(0, "SkillDown: %s %u %u %u type %u", GetName(), pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bMasterType, m_pSkillLevels[pkSk->dwVnum].bLevel, pkSk->dwType);
-	Save();
-
-	ComputePoints();
-	SkillLevelPacket();
-	return true;
-}
-
-void CHARACTER::SkillLevelUp(DWORD dwVnum, BYTE bMethod)
-{
-	if (NULL == m_pSkillLevels)
-		return;
-
-	if (g_bSkillDisable)
-		return;
-
-	if (IsPolymorphed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑 중에는 능력을 올릴 수 없습니다."));
-		return;
-	}
-
-	if (SKILL_7_A_ANTI_TANHWAN <= dwVnum && dwVnum <= SKILL_8_D_ANTI_BYEURAK)
-	{
-		if (0 == GetSkillLevel(dwVnum))
-			return;
-	}
-
-	const CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-
-	if (!pkSk)
-	{
-		sys_err("There is no such skill by number (vnum %u)", dwVnum);
-		return;
-	}
-
-	if (pkSk->dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("Skill Vnum overflow (vnum %u)", dwVnum);
-		return;
-	}
-
-	if (!IsLearnableSkill(dwVnum))
-		return;
-
-	// 그랜드 마스터는 퀘스트로만 수행가능
-	if (pkSk->dwType != SKILL_BOOK_TYPE_SUPPORT && pkSk->dwType != SKILL_BOOK_TYPE_PASSIVE)
-	{
-		switch (GetSkillMasterType(pkSk->dwVnum))
-		{
-			case SKILL_GRAND_MASTER:
-				if (bMethod != SKILL_UP_BY_QUEST)
-					return;
-				break;
-
-			case SKILL_PERFECT_MASTER:
-				return;
-		}
-	}
-
-	if (bMethod == SKILL_UP_BY_POINT)
-	{
-		// 마스터가 아닌 상태에서만 수련가능
-		if (GetSkillMasterType(pkSk->dwVnum) != SKILL_NORMAL)
-			return;
-
-		if (IS_SET(pkSk->dwFlag, SKILL_FLAG_DISABLE_BY_POINT_UP))
-			return;
-	}
-	else if (bMethod == SKILL_UP_BY_BOOK)
-	{
-		// 직업에 속하지 않았거나 포인트로 올릴수 없는 스킬은 처음부터 책으로 배울 수 있다.
-		if (pkSk->dwType != SKILL_BOOK_TYPE_SUPPORT && pkSk->dwType != SKILL_BOOK_TYPE_PASSIVE)
-			if (GetSkillMasterType(pkSk->dwVnum) != SKILL_MASTER
-#if defined(__CONQUEROR_LEVEL__)
-				&& !IsConquerorSkill(pkSk->dwVnum)
-#endif
-				)
-				return;
-	}
-
-	if (GetLevel() < pkSk->bLevelLimit)
-		return;
-
-	if (pkSk->preSkillVnum)
-	{
-		if (GetSkillMasterType(pkSk->preSkillVnum) == SKILL_NORMAL &&
-			GetSkillLevel(pkSk->preSkillVnum) < pkSk->preSkillLevel)
-			return;
-	}
-
-	if (bMethod == SKILL_UP_BY_POINT)
-	{
-		int idx;
-
-		switch (pkSk->dwType)
-		{
-			case 0:
-				idx = POINT_SUB_SKILL;
-				break;
-
-			case 1:
-			case 2:
-			case 3:
-			case 4:
-			case 6:
-			case 7:
-				idx = POINT_SKILL;
-				break;
-
-			case 5:
-				idx = POINT_HORSE_SKILL;
-				break;
-
-			default:
-				sys_err("Wrong skill type %d skill vnum %d", pkSk->dwType, pkSk->dwVnum);
-				return;
-		}
-
-		if (GetPoint(idx) < 1)
-			return;
-
-		PointChange(idx, -1);
-	}
-
-	int SkillPointBefore = GetSkillLevel(pkSk->dwVnum);
-	SetSkillLevel(pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bLevel + 1);
-
-	if (pkSk->dwType != 0)
-	{
-		// 갑자기 그레이드 업하는 코딩
-		switch (GetSkillMasterType(pkSk->dwVnum))
-		{
-			case SKILL_NORMAL:
-				// 번섭은 스킬 업그레이드 17~20 사이 랜덤 마스터 수련
-				if (GetSkillLevel(pkSk->dwVnum) >= 17)
-				{
-					if (GetQuestFlag("reset_scroll.force_to_master_skill") > 0)
-					{
-						SetSkillLevel(pkSk->dwVnum, 20);
-						SetQuestFlag("reset_scroll.force_to_master_skill", 0);
-					}
-					else
-					{
-						if (number(1, 21 - MIN(20, GetSkillLevel(pkSk->dwVnum))) == 1)
-							SetSkillLevel(pkSk->dwVnum, 20);
-					}
-				}
-				break;
-
-			case SKILL_MASTER:
-				if (GetSkillLevel(pkSk->dwVnum) >= 30)
-				{
-					if (number(1, 31 - MIN(30, GetSkillLevel(pkSk->dwVnum))) == 1)
-						SetSkillLevel(pkSk->dwVnum, 30);
-				}
-				break;
-
-			case SKILL_GRAND_MASTER:
-				if (GetSkillLevel(pkSk->dwVnum) >= 40)
-				{
-					SetSkillLevel(pkSk->dwVnum, 40);
-				}
-				break;
-		}
-	}
-
-	char szSkillUp[1024];
-
-	snprintf(szSkillUp, sizeof(szSkillUp), "SkillUp: %s %u %d %d[Before:%d] type %u",
-		GetName(), pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bMasterType, m_pSkillLevels[pkSk->dwVnum].bLevel, SkillPointBefore, pkSk->dwType);
-
-	sys_log(0, "%s", szSkillUp);
-
-	LogManager::instance().CharLog(this, pkSk->dwVnum, "SKILLUP", szSkillUp);
-	Save();
-
-	ComputePoints();
-	SkillLevelPacket();
-}
-
-void CHARACTER::ComputeSkillPoints()
-{
-	if (g_bSkillDisable)
-		return;
-
-	PointChange(POINT_HIT_PCT, aiPrecisionPowerByLevel[MINMAX(0, GetSkillLevel(SKILL_HIT), SKILL_MAX_LEVEL)]);
-}
-
-void CHARACTER::ResetSkill()
-{
-	if (NULL == m_pSkillLevels)
-		return;
-
-	// 보조 스킬은 리셋시키지 않는다
-	std::vector<std::pair<DWORD, TPlayerSkill>> vec;
-	size_t count = sizeof(s_adwSubSkillVnums) / sizeof(s_adwSubSkillVnums[0]);
-
-	for (size_t i = 0; i < count; ++i)
-	{
-		if (s_adwSubSkillVnums[i] >= SKILL_MAX_NUM)
-			continue;
-
-		vec.push_back(std::make_pair(s_adwSubSkillVnums[i], m_pSkillLevels[s_adwSubSkillVnums[i]]));
-	}
-
-	memset(m_pSkillLevels, 0, sizeof(TPlayerSkill) * SKILL_MAX_NUM);
-
-	std::vector<std::pair<DWORD, TPlayerSkill>>::const_iterator iter = vec.begin();
-
-	while (iter != vec.end())
-	{
-		const std::pair<DWORD, TPlayerSkill>& pair = *(iter++);
-		m_pSkillLevels[pair.first] = pair.second;
-	}
-
-	ComputePoints();
-	SkillLevelPacket();
-}
-
-void CHARACTER::ComputePassiveSkill(DWORD dwVnum)
-{
-	if (g_bSkillDisable)
-		return;
-
-	if (GetSkillLevel(dwVnum) == 0)
-		return;
-
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-	pkSk->SetPointVar("k", GetSkillLevel(dwVnum));
-	int iAmount = (int)pkSk->kPointPoly.Eval();
-
-	sys_log(2, "%s passive #%d on %d amount %d", GetName(), dwVnum, pkSk->wPointOn, iAmount);
-	PointChange(pkSk->wPointOn, iAmount);
-}
-
-struct FFindNearVictim
-{
-	FFindNearVictim(LPCHARACTER center, LPCHARACTER attacker, const CHARACTER_SET& excepts_set = empty_set_)
-		: m_pkChrCenter(center),
-		m_pkChrNextTarget(NULL),
-		m_pkChrAttacker(attacker),
-		m_count(0),
-		m_excepts_set(excepts_set)
-	{
-	}
-
-	void operator ()(LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_CHARACTER))
-			return;
-
-		LPCHARACTER pkChr = (LPCHARACTER)ent;
-
-		if (!m_excepts_set.empty())
-		{
-			if (m_excepts_set.find(pkChr) != m_excepts_set.end())
-				return;
-		}
-
-		if (m_pkChrCenter == pkChr)
-			return;
-
-		if (!battle_is_attackable(m_pkChrAttacker, pkChr))
-		{
-			return;
-		}
-
-		if (abs(m_pkChrCenter->GetX() - pkChr->GetX()) > 1000 || abs(m_pkChrCenter->GetY() - pkChr->GetY()) > 1000)
-			return;
-
-		float fDist = DISTANCE_APPROX(m_pkChrCenter->GetX() - pkChr->GetX(), m_pkChrCenter->GetY() - pkChr->GetY());
-
-		if (fDist < 1000)
-		{
-			++m_count;
-
-			if ((m_count == 1) || number(1, m_count) == 1)
-				m_pkChrNextTarget = pkChr;
-		}
-	}
-
-	LPCHARACTER GetVictim()
-	{
-		return m_pkChrNextTarget;
-	}
-
-	LPCHARACTER m_pkChrCenter;
-	LPCHARACTER m_pkChrNextTarget;
-	LPCHARACTER m_pkChrAttacker;
-	int m_count;
-	const CHARACTER_SET& m_excepts_set;
-
-private:
-	static CHARACTER_SET empty_set_;
-};
-
-CHARACTER_SET FFindNearVictim::empty_set_;
-
-EVENTINFO(chain_lightning_event_info)
-{
-	DWORD dwVictim;
-	DWORD dwChr;
-
-	chain_lightning_event_info()
-		: dwVictim(0)
-		, dwChr(0)
-	{
-	}
-};
-
-EVENTFUNC(ChainLightningEvent)
-{
-	chain_lightning_event_info* info = dynamic_cast<chain_lightning_event_info*>(event->info);
-
-	LPCHARACTER pkChrVictim = CHARACTER_MANAGER::instance().Find(info->dwVictim);
-	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().Find(info->dwChr);
-	LPCHARACTER pkTarget = NULL;
-
-	if (!pkChr || !pkChrVictim)
-	{
-		sys_log(1, "use chainlighting, but no character");
-		return 0;
-	}
-
-	sys_log(1, "chainlighting event %s", pkChr->GetName());
-
-	if (pkChrVictim->GetParty()) // 파티 먼저
-	{
-		pkTarget = pkChrVictim->GetParty()->GetNextOwnership(NULL, pkChrVictim->GetX(), pkChrVictim->GetY());
-		if (pkTarget == pkChrVictim || !number(0, 2) || pkChr->GetChainLightingExcept().find(pkTarget) != pkChr->GetChainLightingExcept().end())
-			pkTarget = NULL;
-	}
-
-	if (!pkTarget)
-	{
-		// 1. Find Next victim
-		FFindNearVictim f(pkChrVictim, pkChr, pkChr->GetChainLightingExcept());
-
-		if (pkChrVictim->GetSectree())
-		{
-			pkChrVictim->GetSectree()->ForEachAround(f);
-			// 2. If exist, compute it again
-			pkTarget = f.GetVictim();
-		}
-	}
-
-	if (pkTarget)
-	{
-		pkChrVictim->CreateFly(FLY_CHAIN_LIGHTNING, pkTarget);
-		pkChr->ComputeSkill(SKILL_CHAIN, pkTarget);
-		pkChr->AddChainLightningExcept(pkTarget);
-	}
-	else
-	{
-		sys_log(1, "%s use chainlighting, but find victim failed near %s", pkChr->GetName(), pkChrVictim->GetName());
-	}
-
-	return 0;
-}
-
-void SetPolyVarForAttack(LPCHARACTER ch, CSkillProto* pkSk, LPITEM pkWeapon)
-{
-	if (ch->IsPC())
-	{
-		if (pkWeapon && pkWeapon->GetType() == ITEM_WEAPON)
-		{
-			int iWep = number(pkWeapon->GetValue(3), pkWeapon->GetValue(4));
-			iWep += pkWeapon->GetValue(5);
-
-			int iMtk = number(pkWeapon->GetValue(1), pkWeapon->GetValue(2));
-			iMtk += pkWeapon->GetValue(5);
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-			iWep += ch->GetAcceWeaponAttack();
-			iMtk += ch->GetAcceWeaponMagicAttack();
-#endif
-
-			pkSk->SetPointVar("wep", iWep);
-			pkSk->SetPointVar("mtk", iMtk);
-			pkSk->SetPointVar("mwep", iMtk);
-		}
-		else
-		{
-			pkSk->SetPointVar("wep", 0);
-			pkSk->SetPointVar("mtk", 0);
-			pkSk->SetPointVar("mwep", 0);
-		}
-	}
-	else
-	{
-		int iWep = number(ch->GetMobDamageMin(), ch->GetMobDamageMax());
-		pkSk->SetPointVar("wep", iWep);
-		pkSk->SetPointVar("mwep", iWep);
-		pkSk->SetPointVar("mtk", iWep);
-	}
-}
-
-struct FuncSplashDamage
-{
-	FuncSplashDamage(int x, int y, CSkillProto* pkSk, LPCHARACTER pkChr, int iAmount, int iAG, int iMaxHit, LPITEM pkWeapon, bool bDisableCooltime, TSkillUseInfo* pInfo, BYTE bUseSkillPower)
-		:
-		m_x(x), m_y(y), m_pkSk(pkSk), m_pkChr(pkChr), m_iAmount(iAmount), m_iAG(iAG), m_iCount(0), m_iMaxHit(iMaxHit), m_pkWeapon(pkWeapon), m_bDisableCooltime(bDisableCooltime), m_pInfo(pInfo), m_bUseSkillPower(bUseSkillPower)
-	{
-	}
-
-	void operator () (LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_CHARACTER))
-		{
-			//if (m_pkSk->dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN target not character %s", m_pkChr->GetName());
-			return;
-		}
-
-		LPCHARACTER pkChrVictim = dynamic_cast<LPCHARACTER>(ent);
-
-		if (DISTANCE_APPROX(m_x - pkChrVictim->GetX(), m_y - pkChrVictim->GetY()) > m_pkSk->iSplashRange)
-		{
-			if (test_server)
-				sys_log(0, "XXX target too far %s", m_pkChr->GetName());
-			return;
-		}
-
-		if (!battle_is_attackable(m_pkChr, pkChrVictim))
-		{
-			if (test_server)
-				sys_log(0, "XXX target not attackable %s", m_pkChr->GetName());
-			return;
-		}
-
-		if (m_pkChr->IsPC())
-			// 길드 스킬은 쿨타임 처리를 하지 않는다.
-			if (!(m_pkSk->dwVnum >= GUILD_SKILL_START && m_pkSk->dwVnum <= GUILD_SKILL_END))
-				if (!m_bDisableCooltime && m_pInfo && !m_pInfo->HitOnce(m_pkSk->dwVnum) && m_pkSk->dwVnum != SKILL_MUYEONG
-#if defined(__PVP_BALANCE_IMPROVING__)
-					&& m_pkSk->dwVnum != SKILL_GYEONGGONG
-#endif
-					)
-				{
-					if (test_server)
-						sys_log(0, "check guild skill %s", m_pkChr->GetName());
-					return;
-				}
-
-		++m_iCount;
-
-		int iDam;
-
-		////////////////////////////////////////////////////////////////////////////////
-		//float k = 1.0f * m_pkChr->GetSkillPower(m_pkSk->dwVnum) * m_pkSk->bMaxLevel / 100;
-		//m_pkSk->kPointPoly2.SetVar("k", 1.0 * m_bUseSkillPower * m_pkSk->bMaxLevel / 100);
-		m_pkSk->SetPointVar("k", 1.0 * m_bUseSkillPower * m_pkSk->bMaxLevel / 100);
-		m_pkSk->SetPointVar("lv", m_pkChr->GetLevel());
-		m_pkSk->SetPointVar("iq", m_pkChr->GetPoint(POINT_IQ));
-		m_pkSk->SetPointVar("str", m_pkChr->GetPoint(POINT_ST));
-		m_pkSk->SetPointVar("dex", m_pkChr->GetPoint(POINT_DX));
-		m_pkSk->SetPointVar("con", m_pkChr->GetPoint(POINT_HT));
-		m_pkSk->SetPointVar("def", m_pkChr->GetPoint(POINT_DEF_GRADE));
-		m_pkSk->SetPointVar("odef", m_pkChr->GetPoint(POINT_DEF_GRADE) - m_pkChr->GetPoint(POINT_DEF_GRADE_BONUS));
-		m_pkSk->SetPointVar("horse_level", m_pkChr->GetHorseLevel());
-
-		//int iPenetratePct = (int)(1 + k * 4);
-		bool bIgnoreDefense = false;
-
-		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_PENETRATE))
-		{
-			int iPenetratePct = (int)m_pkSk->kPointPoly2.Eval();
-
-			if (number(1, 100) <= iPenetratePct)
-				bIgnoreDefense = true;
-		}
-
-		bool bIgnoreTargetRating = false;
-
-		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_IGNORE_TARGET_RATING))
-		{
-			int iPct = (int)m_pkSk->kPointPoly2.Eval();
-
-			if (number(1, 100) <= iPct)
-				bIgnoreTargetRating = true;
-		}
-
-		m_pkSk->SetPointVar("ar", CalcAttackRating(m_pkChr, pkChrVictim, bIgnoreTargetRating));
-
-		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_USE_MELEE_DAMAGE))
-			m_pkSk->SetPointVar("atk", CalcMeleeDamage(m_pkChr, pkChrVictim, true, bIgnoreTargetRating));
-		else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_USE_ARROW_DAMAGE))
-		{
-			LPITEM pkBow, pkArrow;
-
-			if (1 == m_pkChr->GetArrowAndBow(&pkBow, &pkArrow, 1))
-				m_pkSk->SetPointVar("atk", CalcArrowDamage(m_pkChr, pkChrVictim, pkBow, pkArrow, true));
-			else
-				m_pkSk->SetPointVar("atk", 0);
-		}
-
-		if (m_pkSk->wPointOn == POINT_MOV_SPEED)
-			m_pkSk->kPointPoly.SetVar("maxv", pkChrVictim->GetLimitPoint(POINT_MOV_SPEED));
-
-		m_pkSk->SetPointVar("maxhp", pkChrVictim->GetMaxHP());
-		m_pkSk->SetPointVar("maxsp", pkChrVictim->GetMaxSP());
-
-		m_pkSk->SetPointVar("chain", m_pkChr->GetChainLightningIndex());
-		m_pkChr->IncChainLightningIndex();
-
-		bool bUnderEunhyung = m_pkChr->GetAffectedEunhyung() > 0 ? true : false; // 이건 왜 여기서 하지??
-
-		m_pkSk->SetPointVar("ek", m_pkChr->GetAffectedEunhyung() * 1. / 100);
-		//m_pkChr->ClearAffectedEunhyung();
-		SetPolyVarForAttack(m_pkChr, m_pkSk, m_pkWeapon);
-
-		int iAmount = 0;
-
-		if (m_pkChr->GetUsedSkillMasterType(m_pkSk->dwVnum) >= SKILL_GRAND_MASTER)
-		{
-			iAmount = (int)m_pkSk->kMasterBonusPoly.Eval();
-		}
-		else
-		{
-			iAmount = (int)m_pkSk->kPointPoly.Eval();
-		}
-
-		if (test_server && iAmount == 0 && m_pkSk->wPointOn != POINT_NONE)
-		{
-			m_pkChr->ChatPacket(CHAT_TYPE_INFO, "효과가 없습니다. 스킬 공식을 확인하세요");
-		}
-		////////////////////////////////////////////////////////////////////////////////
-		iAmount = -iAmount;
-
-		if (m_pkSk->dwVnum == SKILL_AMSEOP)
-		{
-			float fDelta = GetDegreeDelta(m_pkChr->GetRotation(), pkChrVictim->GetRotation());
-			float adjust;
-
-			if (fDelta < 35.0f)
-			{
-				adjust = 1.5f;
-
-				if (bUnderEunhyung)
-					adjust += 0.5f;
-
-				if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER)
-				{
-					//if (!g_iUseLocale)
-					if (LC_IsYMIR())
-						adjust += 1.0f;
-					else
-						adjust += 0.5f;
-				}
-			}
-			else
-			{
-				adjust = 1.0f;
-
-				if (!LC_IsYMIR())
-				{
-					if (bUnderEunhyung)
-						adjust += 0.5f;
-
-					if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER)
-						adjust += 0.5f;
-				}
-			}
-
-			iAmount = (int)(iAmount * adjust);
-		}
-		else if (m_pkSk->dwVnum == SKILL_GUNGSIN)
-		{
-			float adjust = 1.0;
-
-			if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER)
-			{
-				//if (!g_iUseLocale)
-				if (LC_IsYMIR())
-					adjust = 1.4f;
-				else
-					adjust = 1.35f;
-			}
-
-			iAmount = (int)(iAmount * adjust);
-		}
-		else if (m_pkSk->dwVnum == SKILL_CHAYEOL)
-		{
-			if (number(1, 100) <= 20)
-			{
-				float adjust = 1.0f;
-				if (test_server)
-					m_pkChr->ChatPacket(CHAT_TYPE_PARTY, "CRITICAL SKILL VNUM %d ATTACK : NORMAL DMG %d, MULTIPLIED DMG %d, ADJUSTMENT (%.2f%%) FINAL %d",
-						m_pkSk->dwVnum,
-						iAmount,
-						(iAmount * 2),
-						adjust,
-						(int)((iAmount * 2) * adjust)
-					);
-
-				m_pkChr->EffectPacket(SE_CRITICAL);
-				iAmount *= 2;
-				iAmount = (int)(iAmount * adjust);
-			}
-		}
-		else if (m_pkSk->dwVnum == SKILL_GONGDAB)
-		{
-			float adjust = 1.0;
-
-			if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_CLAW)
-			{
-				adjust = 1.35f;
-			}
-
-			iAmount = (int)(iAmount * adjust);
-
-			if (number(1, 100) <= 20)
-			{
-				adjust = 1.0f;
-				if (test_server)
-					m_pkChr->ChatPacket(CHAT_TYPE_PARTY, "CRITICAL SKILL VNUM %d ATTACK : NORMAL DMG %d, MULTIPLIED DMG %d, ADJUSTMENT (%.2f%%) FINAL %d",
-						m_pkSk->dwVnum,
-						iAmount,
-						(iAmount * 2),
-						adjust,
-						(int)((iAmount * 2) * adjust)
-					);
-
-				m_pkChr->EffectPacket(SE_CRITICAL);
-				iAmount *= 2;
-				iAmount = (int)(iAmount * adjust);
-			}
-		}
-#if defined(__PVP_BALANCE_IMPROVING__)
-		else if (m_pkSk->dwVnum == SKILL_GYEONGGONG)
-			iAmount = m_iAmount;
-#endif
-
-		////////////////////////////////////////////////////////////////////////////////
-		//sys_log(0, "name: %s skill: %s amount %d to %s", m_pkChr->GetName(), m_pkSk->szName, iAmount, pkChrVictim->GetName());
-
-		iDam = CalcBattleDamage(iAmount, m_pkChr->GetLevel(), pkChrVictim->GetLevel());
-
-		if (m_pkChr->IsPC() && m_pkChr->m_SkillUseInfo[m_pkSk->dwVnum].GetMainTargetVID() != (DWORD)pkChrVictim->GetVID())
-		{
-			// 데미지 감소
-			iDam = (int)(iDam * m_pkSk->kSplashAroundDamageAdjustPoly.Eval());
-		}
-
-		// TODO 스킬에 따른 데미지 타입 기록해야한다.
-		EDamageType dt = DAMAGE_TYPE_NONE;
-
-		switch (m_pkSk->bSkillAttrType)
-		{
-			case SKILL_ATTR_TYPE_NORMAL:
-				break;
-
-			case SKILL_ATTR_TYPE_MELEE:
-			{
-				dt = DAMAGE_TYPE_MELEE;
-
-				LPITEM pkWeapon = m_pkChr->GetWear(WEAR_WEAPON);
-
-				if (pkWeapon)
-					switch (pkWeapon->GetSubType())
-					{
-						case WEAPON_SWORD:
-							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_SWORD)) / 100;
-							break;
-
-						case WEAPON_TWO_HANDED:
-							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_TWOHAND)) / 100;
-							// 양손검 페널티 10%
-							//iDam = iDam * 95 / 100;
-							break;
-
-						case WEAPON_DAGGER:
-							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_DAGGER)) / 100;
-							break;
-
-						case WEAPON_BELL:
-							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_BELL)) / 100;
-							break;
-
-						case WEAPON_FAN:
-							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_FAN)) / 100;
-							break;
-
-						case WEAPON_CLAW:
-							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_CLAW)) / 100;
-							break;
-
-					}
-
-				if (!bIgnoreDefense)
-					iDam -= pkChrVictim->GetPoint(POINT_DEF_GRADE);
-			}
-			break;
-
-			case SKILL_ATTR_TYPE_RANGE:
-				dt = DAMAGE_TYPE_RANGE;
-				// 으아아아악
-				// 예전에 적용안했던 버그가 있어서 방어력 계산을 다시하면 유저가 난리남
-				//iDam -= pkChrVictim->GetPoint(POINT_DEF_GRADE);
-				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_BOW)) / 100;
-				break;
-
-			case SKILL_ATTR_TYPE_MAGIC:
-				dt = DAMAGE_TYPE_MAGIC;
-				iDam = CalcAttBonus(m_pkChr, pkChrVictim, iDam);
-				// 으아아아악
-				// 예전에 적용안했던 버그가 있어서 방어력 계산을 다시하면 유저가 난리남
-				//iDam -= pkChrVictim->GetPoint(POINT_MAGIC_DEF_GRADE);
-#if defined(__MAGIC_REDUCTION__)
-				{
-					const int c_iResMagic = MINMAX(0, pkChrVictim->GetPoint(POINT_RESIST_MAGIC), 100);
-					const int c_iResMagicReduction = MINMAX(0, (m_pkChr->GetJob() == JOB_SURA) ? m_pkChr->GetPoint(POINT_RESIST_MAGIC_REDUCTION) / 2 : m_pkChr->GetPoint(POINT_RESIST_MAGIC_REDUCTION), 50);
-					const int c_iTotalMagicRes = MINMAX(0, c_iResMagic - c_iResMagicReduction, 100);
-					iDam = iDam * (100 - c_iTotalMagicRes) / 100;
-				}
-#else
-				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_MAGIC)) / 100;
-#endif
-				break;
-
-			default:
-				sys_err("Unknown skill attr type %u vnum %u", m_pkSk->bSkillAttrType, m_pkSk->dwVnum);
-				break;
-		}
-
-		//
-		// 20091109 독일 스킬 속성 요청 작업
-		// 기존 스킬 테이블에 SKILL_FLAG_WIND, SKILL_FLAG_ELEC, SKILL_FLAG_FIRE를 가진 스킬이
-		// 전혀 없었으므로 몬스터의 RESIST_WIND, RESIST_ELEC, RESIST_FIRE도 사용되지 않고 있었다.
-		//
-		// PvP와 PvE밸런스 분리를 위해 의도적으로 NPC만 적용하도록 했으며 기존 밸런스와 차이점을
-		// 느끼지 못하기 위해 mob_proto의 RESIST_MAGIC을 RESIST_WIND, RESIST_ELEC, RESIST_FIRE로
-		// 복사하였다.
-		//
-		if (pkChrVictim->IsNPC())
-		{
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_WIND))
-			{
-				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_WIND)) / 100;
-			}
-
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_ELEC))
-			{
-				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_ELEC)) / 100;
-			}
-
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_FIRE))
-			{
-				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_FIRE)) / 100;
-			}
-		}
-
-		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_COMPUTE_MAGIC_DAMAGE))
-			dt = DAMAGE_TYPE_MAGIC;
-
-		if (pkChrVictim->CanBeginFight())
-			pkChrVictim->BeginFight(m_pkChr);
-
-		if (m_pkSk->dwVnum == SKILL_CHAIN)
-			sys_log(0, "%s CHAIN INDEX %d DAM %d DT %d", m_pkChr->GetName(), m_pkChr->GetChainLightningIndex() - 1, iDam, dt);
-
-#if defined(__7AND8TH_SKILLS__)
-		{
-			BYTE HELP_SKILL_ID = 0;
-			switch (m_pkSk->dwVnum)
-			{
-				case SKILL_PALBANG:
-					HELP_SKILL_ID = SKILL_HELP_PALBANG;
-					break;
-				case SKILL_AMSEOP:
-					HELP_SKILL_ID = SKILL_HELP_AMSEOP;
-					break;
-				case SKILL_SWAERYUNG:
-					HELP_SKILL_ID = SKILL_HELP_SWAERYUNG;
-					break;
-				case SKILL_YONGBI:
-					HELP_SKILL_ID = SKILL_HELP_YONGBI;
-					break;
-				case SKILL_GIGONGCHAM:
-					HELP_SKILL_ID = SKILL_HELP_GIGONGCHAM;
-					break;
-				case SKILL_HWAJO:
-					HELP_SKILL_ID = SKILL_HELP_HWAJO;
-					break;
-				case SKILL_MARYUNG:
-					HELP_SKILL_ID = SKILL_HELP_MARYUNG;
-					break;
-				case SKILL_BYEURAK:
-					HELP_SKILL_ID = SKILL_HELP_BYEURAK;
-					break;
-				case SKILL_SALPOONG:
-					HELP_SKILL_ID = SKILL_HELP_SALPOONG;
-					break;
-				default:
-					break;
-			}
-
-			if (HELP_SKILL_ID != 0)
-			{
-				BYTE HELP_SKILL_LV = m_pkChr->GetSkillLevel(HELP_SKILL_ID);
-				if (HELP_SKILL_LV != 0)
-				{
-					CSkillProto* pkSk = CSkillManager::instance().Get(HELP_SKILL_ID);
-					if (!pkSk)
-						sys_err("Can't find %d skill in skill_proto.", HELP_SKILL_ID);
-					else
-					{
-						pkSk->SetPointVar("k", 1.0f * m_pkChr->GetSkillPower(HELP_SKILL_ID) * pkSk->bMaxLevel / 100);
-
-						double IncreaseAmount = pkSk->kPointPoly.Eval();
-						sys_log(0, "HELP_SKILL: increase amount: %lf, normal damage: %d, increased damage: %d.", IncreaseAmount, iDam, int(iDam * (IncreaseAmount / 100.0)));
-						iDam += iDam * (IncreaseAmount / 100.0);
-					}
-				}
-			}
-		}
-
-		{
-			BYTE ANTI_SKILL_ID = 0;
-			switch (m_pkSk->dwVnum)
-			{
-				case SKILL_PALBANG:
-					ANTI_SKILL_ID = SKILL_ANTI_PALBANG;
-					break;
-				case SKILL_AMSEOP:
-					ANTI_SKILL_ID = SKILL_ANTI_AMSEOP;
-					break;
-				case SKILL_SWAERYUNG:
-					ANTI_SKILL_ID = SKILL_ANTI_SWAERYUNG;
-					break;
-				case SKILL_YONGBI:
-					ANTI_SKILL_ID = SKILL_ANTI_YONGBI;
-					break;
-				case SKILL_GIGONGCHAM:
-					ANTI_SKILL_ID = SKILL_ANTI_GIGONGCHAM;
-					break;
-				case SKILL_HWAJO:
-					ANTI_SKILL_ID = SKILL_ANTI_HWAJO;
-					break;
-				case SKILL_MARYUNG:
-					ANTI_SKILL_ID = SKILL_ANTI_MARYUNG;
-					break;
-				case SKILL_BYEURAK:
-					ANTI_SKILL_ID = SKILL_ANTI_BYEURAK;
-					break;
-				case SKILL_SALPOONG:
-					ANTI_SKILL_ID = SKILL_ANTI_SALPOONG;
-					break;
-				default:
-					break;
-			}
-
-			if (ANTI_SKILL_ID != 0)
-			{
-				BYTE ANTI_SKILL_LV = pkChrVictim->GetSkillLevel(ANTI_SKILL_ID);
-				if (ANTI_SKILL_LV != 0)
-				{
-					CSkillProto* pkSk = CSkillManager::instance().Get(ANTI_SKILL_ID);
-					if (!pkSk)
-						sys_err("Can't find %d skill in skill_proto.", ANTI_SKILL_ID);
-					else
-					{
-						pkSk->SetPointVar("k", 1.0f * pkChrVictim->GetSkillPower(ANTI_SKILL_ID) * pkSk->bMaxLevel / 100);
-
-						double ResistAmount = pkSk->kPointPoly.Eval();
-						sys_log(0, "ANTI_SKILL: resist amount: %lf, normal damage: %d, reduced damage: %d.", ResistAmount, iDam, int(iDam * (ResistAmount / 100.0)));
-						iDam -= iDam * (ResistAmount / 100.0);
-					}
-				}
-			}
-		}
-#endif
-
-		{
-			BYTE AntiSkillID = 0;
-
-			switch (m_pkSk->dwVnum)
-			{
-				case SKILL_TANHWAN: AntiSkillID = SKILL_7_A_ANTI_TANHWAN; break;
-				case SKILL_AMSEOP: AntiSkillID = SKILL_7_B_ANTI_AMSEOP; break;
-				case SKILL_SWAERYUNG: AntiSkillID = SKILL_7_C_ANTI_SWAERYUNG; break;
-				case SKILL_YONGBI: AntiSkillID = SKILL_7_D_ANTI_YONGBI; break;
-				case SKILL_GIGONGCHAM: AntiSkillID = SKILL_8_A_ANTI_GIGONGCHAM; break;
-				case SKILL_YEONSA: AntiSkillID = SKILL_8_B_ANTI_YEONSA; break;
-				case SKILL_MAHWAN: AntiSkillID = SKILL_8_C_ANTI_MAHWAN; break;
-				case SKILL_BYEURAK: AntiSkillID = SKILL_8_D_ANTI_BYEURAK; break;
-			}
-
-			if (0 != AntiSkillID)
-			{
-				BYTE AntiSkillLevel = pkChrVictim->GetSkillLevel(AntiSkillID);
-
-				if (0 != AntiSkillLevel)
-				{
-					CSkillProto* pkSk = CSkillManager::instance().Get(AntiSkillID);
-					if (!pkSk)
-					{
-						sys_err("There is no anti skill(%d) in skill proto", AntiSkillID);
-					}
-					else
-					{
-						pkSk->SetPointVar("k", 1.0f * pkChrVictim->GetSkillPower(AntiSkillID) * pkSk->bMaxLevel / 100);
-
-						double ResistAmount = pkSk->kPointPoly.Eval();
-
-						sys_log(0, "ANTI_SKILL: Resist(%lf) Orig(%d) Reduce(%d)", ResistAmount, iDam, int(iDam * (ResistAmount / 100.0)));
-
-						iDam -= iDam * (ResistAmount / 100.0);
-					}
-				}
-			}
-		}
-
-		if (!pkChrVictim->Damage(m_pkChr, iDam, dt) && !pkChrVictim->IsStun())
-		{
-#if defined(__PVP_BALANCE_IMPROVING__)
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_KNOCKBACK))
-			{
-				float fKnockbackLength = 300; // Knockback distance.
-
-				if (pkChrVictim->IsStone())
-					fKnockbackLength = 0;
-
-#if defined(__DEFENSE_WAVE__)
-				if (CDefenseWaveManager::Instance().IsHydraSpawn(pkChrVictim->GetRaceNum()))
-					fKnockbackLength = 0;
-
-				if (CDefenseWaveManager::Instance().IsHydra(pkChrVictim->GetRaceNum()))
-					fKnockbackLength = 0;
-#endif
-
-				float fx, fy;
-				float degree = GetDegreeFromPositionXY(m_pkChr->GetX(), m_pkChr->GetY(), pkChrVictim->GetX(), pkChrVictim->GetY());
-
-				if (m_pkSk->dwVnum == SKILL_HORSE_WILDATTACK)
-				{
-					degree -= m_pkChr->GetRotation();
-					degree = fmod(degree, 360.0f) - 180.0f;
-
-					if (degree > 0)
-						degree = m_pkChr->GetRotation() + 90.0f;
-					else
-						degree = m_pkChr->GetRotation() - 90.0f;
-				}
-
-				if (fKnockbackLength > 0)
-				{
-					GetDeltaByDegree(degree, fKnockbackLength, &fx, &fy);
-					sys_log(0, "KNOCKBACK! %s -> %s (%d %d) -> (%d %d)",
-						m_pkChr->GetName(),
-						pkChrVictim->GetName(),
-						pkChrVictim->GetX(),
-						pkChrVictim->GetY(),
-						(long)(pkChrVictim->GetX() + fx),
-						(long)(pkChrVictim->GetY() + fy)
-					);
-
-					long tx = (long)(pkChrVictim->GetX() + fx);
-					long ty = (long)(pkChrVictim->GetY() + fy);
-
-					pkChrVictim->Sync(tx, ty);
-					pkChrVictim->Goto(tx, ty);
-					pkChrVictim->CalculateMoveDuration();
-
-					pkChrVictim->SyncPacket();
-				}
-			}
-#endif
-
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_REMOVE_GOOD_AFFECT))
-			{
-				int iAmount2 = (int)m_pkSk->kPointPoly2.Eval();
-				int iDur2 = (int)m_pkSk->kDurationPoly2.Eval();
-				iDur2 += m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-				int chance = iAmount2;
-
-				if (m_pkChr && m_pkChr->GetLevel() < pkChrVictim->GetLevel())
-				{
-					int delta = pkChrVictim->GetLevel() - m_pkChr->GetLevel();
-					if (delta >= 15)
-						chance = 0;
-				}
-
-				if (number(1, 100) <= chance)
-				{
-					pkChrVictim->RemoveGoodAffect();
-					pkChrVictim->AddAffect(m_pkSk->dwVnum, POINT_NONE, 0, AFF_PABEOP, iDur2, 0, true);
-				}
-			}
-
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_SLOW | SKILL_FLAG_STUN | SKILL_FLAG_FIRE_CONT | SKILL_FLAG_POISON | SKILL_FLAG_BLEEDING))
-			{
-				int iPct = (int)m_pkSk->kPointPoly2.Eval();
-				int iDur = (int)m_pkSk->kDurationPoly2.Eval();
-
-#if defined(__PVP_BALANCE_IMPROVING__)
-				const int iMaxStunDuration = 20;
-				if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_STUN))
-					iDur += MINMAX(static_cast<int>(m_pkSk->kDurationPoly2.Eval()), m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS), iMaxStunDuration);
-				else
-					iDur += m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
-#else
-				iDur += m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
-#endif
-
-				if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_STUN))
-				{
-					SkillAttackAffect(pkChrVictim, iPct, IMMUNE_STUN, AFFECT_STUN, POINT_NONE, 0, AFF_STUN, iDur, m_pkSk->szName);
-				}
-				else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_SLOW))
-				{
-					SkillAttackAffect(pkChrVictim, iPct, IMMUNE_SLOW, AFFECT_SLOW, POINT_MOV_SPEED, -30, AFF_SLOW, iDur, m_pkSk->szName);
-				}
-				else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_FIRE_CONT))
-				{
-					m_pkSk->SetDurationVar("k", 1.0 * m_bUseSkillPower * m_pkSk->bMaxLevel / 100);
-					m_pkSk->SetDurationVar("iq", m_pkChr->GetPoint(POINT_IQ));
-
-					iDur = (int)m_pkSk->kDurationPoly2.Eval();
-					int bonus = m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-					if (bonus != 0)
-					{
-						iDur += bonus / 2;
-					}
-
-					if (number(1, 100) <= iDur)
-					{
-						pkChrVictim->AttackedByFire(m_pkChr, iPct, 5);
-					}
-				}
-				else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_POISON))
-				{
-#if defined(__CONQUEROR_LEVEL__)
-					if (m_pkChr->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
-						iPct /= 2;
-#endif
-
-					if (number(1, 100) <= iPct)
-						pkChrVictim->AttackedByPoison(m_pkChr);
-				}
-			}
-
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_BLEEDING))
-			{
-				// NOTE : Wolfman `SKILL_CHAYEOL` (170) `SKILL_FLAG_BLEEDING` uses the
-				// `kDurationPoly2` column as the percentage value for bleeding chance.
-				int iPct = (int)m_pkSk->kDurationPoly2.Eval();
-#if defined(__CONQUEROR_LEVEL__)
-				if (m_pkChr->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
-					iPct /= 2;
-#endif
-
-				if (number(1, 100) <= iPct)
-					pkChrVictim->AttackedByBleeding(m_pkChr);
-			}
-
-			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_CRUSH | SKILL_FLAG_CRUSH_LONG) && !pkChrVictim->IsNoMove())
-			{
-				float fCrushSlidingLength = 200;
-
-				if (m_pkChr->IsNPC())
-					fCrushSlidingLength = 400;
-
-				if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_CRUSH_LONG))
-					fCrushSlidingLength *= 2;
-
-				if (g_bDisableBossKnockback)
-					if (m_pkChr->GetMobRank() > MOB_RANK_S_KNIGHT)
-						fCrushSlidingLength = 0;
-
-				float fx, fy;
-				float degree = GetDegreeFromPositionXY(m_pkChr->GetX(), m_pkChr->GetY(), pkChrVictim->GetX(), pkChrVictim->GetY());
-
-				if (m_pkSk->dwVnum == SKILL_HORSE_WILDATTACK)
-				{
-					degree -= m_pkChr->GetRotation();
-					degree = fmod(degree, 360.0f) - 180.0f;
-
-					if (degree > 0)
-						degree = m_pkChr->GetRotation() + 90.0f;
-					else
-						degree = m_pkChr->GetRotation() - 90.0f;
-				}
-
-				GetDeltaByDegree(degree, fCrushSlidingLength, &fx, &fy);
-				sys_log(0, "CRUSH! %s -> %s (%d %d) -> (%d %d)", m_pkChr->GetName(), pkChrVictim->GetName(),
-					pkChrVictim->GetX(), pkChrVictim->GetY(),
-					static_cast<long>(pkChrVictim->GetX() + fx), static_cast<long>(pkChrVictim->GetY() + fy));
-
-				long tx = static_cast<long>((pkChrVictim->GetX() + fx));
-				long ty = static_cast<long>((pkChrVictim->GetY() + fy));
-
-				// CRUSH_SKILL_WALL_KNOCKBACK_FIX
-				while (pkChrVictim->IsInBlockedArea(tx, ty) && fCrushSlidingLength > 0)
-				{
-					if (fCrushSlidingLength >= 10)
-						fCrushSlidingLength -= 10;
-					else
-						fCrushSlidingLength = 0;
-
-					GetDeltaByDegree(degree, fCrushSlidingLength, &fx, &fy);
-					tx = static_cast<long>((pkChrVictim->GetX() + fx));
-					ty = static_cast<long>((pkChrVictim->GetY() + fy));
-				}
-				// END_OF_CRUSH_SKILL_WALL_KNOCKBACK_FIX
-
-				pkChrVictim->Sync(tx, ty);
-				pkChrVictim->Goto(tx, ty);
-				pkChrVictim->CalculateMoveDuration();
-
-				if (m_pkChr->IsPC() && m_pkChr->m_SkillUseInfo[m_pkSk->dwVnum].GetMainTargetVID() == static_cast<DWORD>(pkChrVictim->GetVID()))
-				{
-					//if (!g_iUseLocale)
-					if (LC_IsYMIR())
-						SkillAttackAffect(pkChrVictim, 1000, IMMUNE_STUN, m_pkSk->dwVnum, POINT_NONE, 0, AFF_STUN, 3, m_pkSk->szName);
-					else
-						SkillAttackAffect(pkChrVictim, 1000, IMMUNE_STUN, m_pkSk->dwVnum, POINT_NONE, 0, AFF_STUN, 4, m_pkSk->szName);
-				}
-				else
-				{
-					pkChrVictim->SyncPacket();
-				}
-			}
-		}
-
-		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_HP_ABSORB))
-		{
-			int iPct = static_cast<int>(m_pkSk->kPointPoly2.Eval());
-			m_pkChr->PointChange(POINT_HP, iDam * iPct / 100);
-		}
-
-		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_SP_ABSORB))
-		{
-			int iPct = static_cast<int>(m_pkSk->kPointPoly2.Eval());
-			m_pkChr->PointChange(POINT_SP, iDam * iPct / 100);
-		}
-
-		if (m_pkSk->dwVnum == SKILL_CHAIN && m_pkChr->GetChainLightningIndex() < m_pkChr->GetChainLightningMaxCount())
-		{
-			chain_lightning_event_info* info = AllocEventInfo<chain_lightning_event_info>();
-
-			info->dwVictim = static_cast<DWORD>(pkChrVictim->GetVID());
-			info->dwChr = static_cast<DWORD>(m_pkChr->GetVID());
-
-			event_create(ChainLightningEvent, info, passes_per_sec / 5);
-		}
-		if (test_server)
-			sys_log(0, "FuncSplashDamage End :%s ", m_pkChr->GetName());
-	}
-
-	int m_x;
-	int m_y;
-	CSkillProto* m_pkSk;
-	LPCHARACTER m_pkChr;
-	int m_iAmount;
-	int m_iAG;
-	int m_iCount;
-	int m_iMaxHit;
-	LPITEM m_pkWeapon;
-	bool m_bDisableCooltime;
-	TSkillUseInfo* m_pInfo;
-	BYTE m_bUseSkillPower;
-};
-
-struct FuncSplashAffect
-{
-	FuncSplashAffect(LPCHARACTER ch, int x, int y, int iDist, DWORD dwVnum, POINT_TYPE wPointOn, int iAmount, DWORD dwAffectFlag, int iDuration, int iSPCost, bool bOverride, int iMaxHit)
-	{
-		m_x = x;
-		m_y = y;
-		m_iDist = iDist;
-		m_dwVnum = dwVnum;
-		m_wPointOn = wPointOn;
-		m_iAmount = iAmount;
-		m_dwAffectFlag = dwAffectFlag;
-		m_iDuration = iDuration;
-		m_iSPCost = iSPCost;
-		m_bOverride = bOverride;
-		m_pkChrAttacker = ch;
-		m_iMaxHit = iMaxHit;
-		m_iCount = 0;
-	}
-
-	void operator () (LPENTITY ent)
-	{
-		if (m_iMaxHit && m_iMaxHit <= m_iCount)
-			return;
-
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER pkChr = (LPCHARACTER)ent;
-
-			if (test_server)
-				sys_log(0, "FuncSplashAffect step 1 : name:%s vnum:%d iDur:%d", pkChr->GetName(), m_dwVnum, m_iDuration);
-
-			if (DISTANCE_APPROX(m_x - pkChr->GetX(), m_y - pkChr->GetY()) < m_iDist)
-			{
-				if (test_server)
-					sys_log(0, "FuncSplashAffect step 2 : name:%s vnum:%d iDur:%d", pkChr->GetName(), m_dwVnum, m_iDuration);
-
-				if (m_dwVnum == SKILL_TUSOK)
-					if (pkChr->CanBeginFight())
-						pkChr->BeginFight(m_pkChrAttacker);
-
-				if (pkChr->IsPC() && m_dwVnum == SKILL_TUSOK)
-					pkChr->AddAffect(m_dwVnum, m_wPointOn, m_iAmount, m_dwAffectFlag, m_iDuration / 3, m_iSPCost, m_bOverride);
-				else
-					pkChr->AddAffect(m_dwVnum, m_wPointOn, m_iAmount, m_dwAffectFlag, m_iDuration, m_iSPCost, m_bOverride);
-
-				m_iCount++;
-			}
-		}
-	}
-
-	LPCHARACTER m_pkChrAttacker;
-	int m_x;
-	int m_y;
-	int m_iDist;
-	DWORD m_dwVnum;
-	POINT_TYPE m_wPointOn;
-	int m_iAmount;
-	DWORD m_dwAffectFlag;
-	int m_iDuration;
-	int m_iSPCost;
-	bool m_bOverride;
-	int m_iMaxHit;
-	int m_iCount;
-};
-
-EVENTINFO(skill_gwihwan_info)
-{
-	DWORD pid;
-	BYTE bsklv;
-
-	skill_gwihwan_info()
-		: pid(0)
-		, bsklv(0)
-	{
-	}
-};
-
-EVENTFUNC(skill_gwihwan_event)
-{
-	skill_gwihwan_info* info = dynamic_cast<skill_gwihwan_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("skill_gwihwan_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	DWORD pid = info->pid;
-	BYTE sklv = info->bsklv;
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-	if (!ch)
-		return 0;
-
-	int percent = 20 * sklv - 1;
-
-	if (number(1, 100) <= percent)
-	{
-		PIXEL_POSITION pos;
-
-		// 성공
-		if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(ch->GetMapIndex(), ch->GetEmpire(), pos))
-		{
-			sys_log(1, "Recall: %s %d %d -> %d %d", ch->GetName(), ch->GetX(), ch->GetY(), pos.x, pos.y);
-			ch->WarpSet(pos.x, pos.y);
-		}
-		else
-		{
-			sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", ch->GetName(), ch->GetX(), ch->GetY());
-			ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-	}
-	else
-	{
-		// 실패
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("귀환에 실패하였습니다."));
-	}
-	return 0;
-}
-
-int CHARACTER::ComputeSkillAtPosition(DWORD dwVnum, const PIXEL_POSITION& posTarget, BYTE bSkillLevel)
-{
-	if (GetMountVnum())
-		return BATTLE_NONE;
-
-	if (IsPolymorphed())
-		return BATTLE_NONE;
-
-	if (g_bSkillDisable)
-		return BATTLE_NONE;
-
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-
-	if (!pkSk)
-		return BATTLE_NONE;
-
-	if (test_server)
-	{
-		sys_log(0, "ComputeSkillAtPosition %s vnum %d x %d y %d level %d",
-			GetName(), dwVnum, posTarget.x, posTarget.y, bSkillLevel);
-	}
-
-	// 나에게 쓰는 스킬은 내 위치를 쓴다.
-	//if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
-	//	posTarget = GetXYZ();
-
-	// 스플래쉬가 아닌 스킬은 주위이면 이상하다
-	if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-		return BATTLE_NONE;
-
-	if (0 == bSkillLevel)
-	{
-		if ((bSkillLevel = GetSkillLevel(pkSk->dwVnum)) == 0)
-		{
-			return BATTLE_NONE;
-		}
-	}
-
-	const float k = 1.0 * GetSkillPower(pkSk->dwVnum, bSkillLevel) * pkSk->bMaxLevel / 100;
-
-	pkSk->SetPointVar("k", k);
-	pkSk->kSplashAroundDamageAdjustPoly.SetVar("k", k);
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MELEE_DAMAGE))
-	{
-		pkSk->SetPointVar("atk", CalcMeleeDamage(this, this, true, false));
-	}
-	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MAGIC_DAMAGE))
-	{
-		pkSk->SetPointVar("atk", CalcMagicDamage(this, this));
-	}
-	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_ARROW_DAMAGE))
-	{
-		LPITEM pkBow, pkArrow;
-		if (1 == GetArrowAndBow(&pkBow, &pkArrow, 1))
-		{
-			pkSk->SetPointVar("atk", CalcArrowDamage(this, this, pkBow, pkArrow, true));
-		}
-		else
-		{
-			pkSk->SetPointVar("atk", 0);
-		}
-	}
-
-	if (pkSk->wPointOn == POINT_MOV_SPEED)
-	{
-		pkSk->SetPointVar("maxv", this->GetLimitPoint(POINT_MOV_SPEED));
-	}
-
-	pkSk->SetPointVar("lv", GetLevel());
-	pkSk->SetPointVar("iq", GetPoint(POINT_IQ));
-	pkSk->SetPointVar("str", GetPoint(POINT_ST));
-	pkSk->SetPointVar("dex", GetPoint(POINT_DX));
-	pkSk->SetPointVar("con", GetPoint(POINT_HT));
-	pkSk->SetPointVar("maxhp", this->GetMaxHP());
-	pkSk->SetPointVar("maxsp", this->GetMaxSP());
-	pkSk->SetPointVar("chain", 0);
-	pkSk->SetPointVar("ar", CalcAttackRating(this, this));
-	pkSk->SetPointVar("def", GetPoint(POINT_DEF_GRADE));
-	pkSk->SetPointVar("odef", GetPoint(POINT_DEF_GRADE) - GetPoint(POINT_DEF_GRADE_BONUS));
-	pkSk->SetPointVar("horse_level", GetHorseLevel());
-
-	if (pkSk->bSkillAttrType != SKILL_ATTR_TYPE_NORMAL)
-		OnMove(true);
-
-	LPITEM pkWeapon = GetWear(WEAR_WEAPON);
-
-	SetPolyVarForAttack(this, pkSk, pkWeapon);
-
-	pkSk->SetDurationVar("k", k/* bSkillLevel */);
-
-	int iAmount = (int)pkSk->kPointPoly.Eval();
-	int iAmount2 = (int)pkSk->kPointPoly2.Eval();
-
-	// ADD_GRANDMASTER_SKILL
-	int iAmount3 = (int)pkSk->kPointPoly3.Eval();
-
-	if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
-	{
-		/*
-		if (iAmount >= 0)
-			iAmount += (int)m_pkSk->kMasterBonusPoly.Eval();
-		else
-			iAmount -= (int)m_pkSk->kMasterBonusPoly.Eval();
-		*/
-		iAmount = (int)pkSk->kMasterBonusPoly.Eval();
-	}
-
-	if (test_server && iAmount == 0 && pkSk->wPointOn != POINT_NONE)
-	{
-		ChatPacket(CHAT_TYPE_INFO, "효과가 없습니다. 스킬 공식을 확인하세요");
-	}
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_REMOVE_BAD_AFFECT))
-	{
-		if (number(1, 100) <= iAmount2)
-		{
-			RemoveBadAffect();
-		}
-	}
-	// END_OF_ADD_GRANDMASTER_SKILL
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_ATTACK | SKILL_FLAG_USE_MELEE_DAMAGE | SKILL_FLAG_USE_MAGIC_DAMAGE))
-	{
-		//
-		// 공격 스킬일 경우
-		//
-		bool bAdded = false;
-
-		if (pkSk->wPointOn == POINT_HP && iAmount < 0)
-		{
-			int iAG = 0;
-
-			FuncSplashDamage f(posTarget.x, posTarget.y, pkSk, this, iAmount, iAG, pkSk->lMaxHit, pkWeapon, m_bDisableCooltime, IsPC() ? &m_SkillUseInfo[dwVnum] : NULL, GetSkillPower(dwVnum, bSkillLevel));
-
-			if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-			{
-				if (GetSectree())
-					GetSectree()->ForEachAround(f);
-			}
-			else
-			{
-				//if (dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN skill call FuncSplashDamage %s", GetName());
-				f(this);
-			}
-		}
-		else
-		{
-			//if (dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN skill no damage %d %s", iAmount, GetName());
-			int iDur = (int)pkSk->kDurationPoly.Eval();
-
-			if (IsPC())
-				if (!(dwVnum >= GUILD_SKILL_START && dwVnum <= GUILD_SKILL_END)) // 길드 스킬은 쿨타임 처리를 하지 않는다.
-					if (!m_bDisableCooltime && !m_SkillUseInfo[dwVnum].HitOnce(dwVnum) && dwVnum != SKILL_MUYEONG)
-					{
-						//if (dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN skill cannot hit %s", GetName());
-						return BATTLE_NONE;
-					}
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-					AddAffect(pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true);
-				else
-				{
-					if (GetSectree())
-					{
-						FuncSplashAffect f(this, posTarget.x, posTarget.y, pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true, pkSk->lMaxHit);
-						GetSectree()->ForEachAround(f);
-					}
-				}
-				bAdded = true;
-			}
-		}
-
-		if (pkSk->wPointOn2 != POINT_NONE)
-		{
-			int iDur = (int)pkSk->kDurationPoly2.Eval();
-
-			sys_log(1, "try second %u %d %d", pkSk->dwVnum, pkSk->wPointOn2, iDur);
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-					AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded);
-				else
-				{
-					if (GetSectree())
-					{
-						FuncSplashAffect f(this, posTarget.x, posTarget.y, pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded, pkSk->lMaxHit);
-						GetSectree()->ForEachAround(f);
-					}
-				}
-				bAdded = true;
-			}
-			else
-			{
-				PointChange(pkSk->wPointOn2, iAmount2);
-			}
-		}
-
-		// ADD_GRANDMASTER_SKILL
-		if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER && pkSk->wPointOn3 != POINT_NONE)
-		{
-			int iDur = (int)pkSk->kDurationPoly3.Eval();
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-					AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, 0 /* pkSk->dwAffectFlag3 */, iDur, 0, !bAdded);
-				else
-				{
-					if (GetSectree())
-					{
-						FuncSplashAffect f(this, posTarget.x, posTarget.y, pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn3, iAmount3, 0 /* pkSk->dwAffectFlag3 */, iDur, 0, !bAdded, pkSk->lMaxHit);
-						GetSectree()->ForEachAround(f);
-					}
-				}
-			}
-			else
-			{
-				PointChange(pkSk->wPointOn3, iAmount3);
-			}
-		}
-		// END_OF_ADD_GRANDMASTER_SKILL
-
-		return BATTLE_DAMAGE;
-	}
-	else
-	{
-		bool bAdded = false;
-		int iDur = (int)pkSk->kDurationPoly.Eval();
-
-		if (iDur > 0)
-		{
-			iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-			// AffectFlag가 없거나, toggle 하는 것이 아니라면..
-			pkSk->kDurationSPCostPoly.SetVar("k", k/* bSkillLevel */);
-
-			AddAffect(pkSk->dwVnum,
-				pkSk->wPointOn,
-				iAmount,
-				pkSk->dwAffectFlag,
-				iDur,
-				(long)pkSk->kDurationSPCostPoly.Eval(),
-				!bAdded);
-
-			bAdded = true;
-		}
-		else
-		{
-			PointChange(pkSk->wPointOn, iAmount);
-		}
-
-		if (pkSk->wPointOn2 != POINT_NONE)
-		{
-			int iDur = (int)pkSk->kDurationPoly2.Eval();
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-				AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded);
-				bAdded = true;
-			}
-			else
-			{
-				PointChange(pkSk->wPointOn2, iAmount2);
-			}
-		}
-
-		// ADD_GRANDMASTER_SKILL
-		if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER && pkSk->wPointOn3 != POINT_NONE)
-		{
-			int iDur = (int)pkSk->kDurationPoly3.Eval();
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-				AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, 0 /* pkSk->dwAffectFlag3 */, iDur, 0, !bAdded);
-			}
-			else
-			{
-				PointChange(pkSk->wPointOn3, iAmount3);
-			}
-		}
-		// END_OF_ADD_GRANDMASTER_SKILL
-
-		return BATTLE_NONE;
-	}
-}
-
-struct FComputeSkillParty
-{
-	FComputeSkillParty(DWORD dwVnum, LPCHARACTER pkAttacker, BYTE bSkillLevel = 0)
-		: m_dwVnum(dwVnum), m_pkAttacker(pkAttacker), m_bSkillLevel(bSkillLevel)
-	{
-	}
-
-	void operator () (LPCHARACTER ch)
-	{
-		if (ch->IsDead())
-			return;
-
-		m_pkAttacker->ComputeSkill(m_dwVnum, ch, m_bSkillLevel);
-	}
-
-	DWORD m_dwVnum;
-	LPCHARACTER m_pkAttacker;
-	BYTE m_bSkillLevel;
-};
-
-int CHARACTER::ComputeSkillParty(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
-{
-	FComputeSkillParty f(dwVnum, pkVictim, bSkillLevel);
-	if (GetParty() && GetParty()->GetNearMemberCount())
-		GetParty()->ForEachNearMember(f);
-	else
-		f(this);
-
-	return BATTLE_NONE;
-}
-
-#if defined(__PVP_BALANCE_IMPROVING__)
-int CHARACTER::ComputeGyeongGongSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
-{
-	if (IsPolymorphed())
-		return BATTLE_NONE;
-
-	if (g_bSkillDisable)
-		return BATTLE_NONE;
-
-	CSkillProto* pkSk = CSkillManager::Instance().Get(dwVnum);
-
-	if (!pkSk)
-		return BATTLE_NONE;
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
-		pkVictim = this;
-
-	if (!pkVictim)
-	{
-		if (test_server)
-			sys_log(0, "ComputeGyeongGongSkill: %s Victim == null, skill %d", GetName(), dwVnum);
-
-		return BATTLE_NONE;
-	}
-
-	if (0 == bSkillLevel)
-	{
-		if ((bSkillLevel = GetSkillLevel(pkSk->dwVnum)) == 0)
-		{
-			if (test_server)
-				sys_log(0, "ComputeGyeongGongSkill: name:%s vnum:%d skillLevelBySkill : %d ", GetName(), pkSk->dwVnum, bSkillLevel);
-			return BATTLE_NONE;
-		}
-	}
-
-	if (pkSk->bSkillAttrType != SKILL_ATTR_TYPE_NORMAL)
-		OnMove(true);
-
-	LPITEM pkWeapon = GetWear(WEAR_WEAPON);
-
-	SetPolyVarForAttack(this, pkSk, pkWeapon);
-	const int iAmount = static_cast<int>(pkSk->kPointPoly2.Eval());
-
-	EffectPacket(SE_FEATHER_WALK, SE_TYPE_POSITION, GetXYZ());
-
-	FuncSplashDamage f(pkVictim->GetX(), pkVictim->GetY(), pkSk, this, iAmount, 0, pkSk->lMaxHit, pkWeapon, m_bDisableCooltime, IsPC() ? &m_SkillUseInfo[dwVnum] : NULL, GetSkillPower(dwVnum, bSkillLevel));
-	if (pkVictim->GetSectree())
-		pkVictim->GetSectree()->ForEachAround(f);
-	else
-		f(pkVictim);
-
-	return BATTLE_DAMAGE;
-}
-#endif
-
-#ifdef ENABLE_QUEEN_NETHIS
-struct FuncSnakeSplashDamage
-{
-	FuncSnakeSplashDamage(int x, int y, LPCHARACTER pkChr, BYTE bUseSkillPower)
-		:
-		m_x(x), m_y(y), m_pkChr(pkChr), m_iCount(0), m_bUseSkillPower(bUseSkillPower)
-		{
-		}
-
-	void operator () (LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_CHARACTER))
-		{
-			return;
-		}
-
-		LPCHARACTER pkChrVictim = (LPCHARACTER) ent;
-
-		if (DISTANCE_APPROX(m_x - pkChrVictim->GetX(), m_y - pkChrVictim->GetY()) > 500)
-		{
-			if(test_server)
-				sys_log(0, "XXX target too far %s", m_pkChr->GetName());
-			return;
-		}
-
-		if (!pkChrVictim->IsPC())
-			return;
-
-		++m_iCount;
-
-		int iDam;
-
-		iDam = pkChrVictim->GetMaxHP()*0.2;
-
-		EDamageType dt = DAMAGE_TYPE_MELEE;
-		if (!pkChrVictim->Damage(m_pkChr, iDam, dt) && !pkChrVictim->IsStun())
-		{
-			float fCrushSlidingLength = 200;
-
-			if (m_pkChr->IsNPC())
-				fCrushSlidingLength = 400;
-
-			float fx, fy;
-			float degree = GetDegreeFromPositionXY(m_pkChr->GetX(), m_pkChr->GetY(), pkChrVictim->GetX(), pkChrVictim->GetY());
-
-			GetDeltaByDegree(degree, fCrushSlidingLength, &fx, &fy);
-			sys_log(0, "CRUSH! %s -> %s (%d %d) -> (%d %d)", m_pkChr->GetName(), pkChrVictim->GetName(), pkChrVictim->GetX(), pkChrVictim->GetY(), (long)(pkChrVictim->GetX()+fx), (long)(pkChrVictim->GetY()+fy));
-			long tx = (long)(pkChrVictim->GetX()+fx);
-			long ty = (long)(pkChrVictim->GetY()+fy);
-
-			pkChrVictim->Sync(tx, ty);
-			pkChrVictim->Goto(tx, ty);
-			pkChrVictim->CalculateMoveDuration();
-
-			pkChrVictim->SyncPacket();
-		}
-	}
-
-	int		m_x;
-	int		m_y;
-	LPCHARACTER	m_pkChr;
-	int		m_iCount;
-	BYTE m_bUseSkillPower;
-};
-
-EVENTINFO(r_snakeskill_info)
-{
-	int	x;
-	int	y;
-	LPCHARACTER pkVictim;
-	BYTE bUseSkillPower;
-};
-
-EVENTFUNC(r_snakeskill_event)
-{
-	r_snakeskill_info* pEventInfo = dynamic_cast<r_snakeskill_info*>(event->info);
-
-	if (!pEventInfo)
-		return 0;
-
-	if (!pEventInfo->pkVictim)
-		return 0;
-
-	FuncSnakeSplashDamage f(pEventInfo->x, pEventInfo->y, pEventInfo->pkVictim, 1);
-	if (pEventInfo->pkVictim->GetSectree())
-		pEventInfo->pkVictim->GetSectree()->ForEachAround(f);
-
-	return 0;
-}
-
-int CHARACTER::ComputeSnakeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
-{
-	if (!pkVictim)
-		return BATTLE_NONE;
-
-	if (m_pkSnakeSkillEvent != NULL)
-		event_cancel(&m_pkSnakeSkillEvent);
-	m_pkSnakeSkillEvent = NULL;
-
-	int iAG = 0;
-
-	r_snakeskill_info* pEventInfo = AllocEventInfo<r_snakeskill_info>();
-
-	pEventInfo->x =pkVictim->GetX();
-	pEventInfo->y =pkVictim->GetY();
-	pEventInfo->pkVictim =this;
-	pEventInfo->bUseSkillPower = 1;
-	m_pkSnakeSkillEvent = event_create(r_snakeskill_event, pEventInfo, PASSES_PER_SEC(2));
-
-	return BATTLE_NONE;	
-}
-#endif
-
-// bSkillLevel 인자가 0이 아닐 경우에는 m_abSkillLevels를 사용하지 않고 강제로
-// bSkillLevel로 계산한다.
-int CHARACTER::ComputeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
-{
-	const bool bCanUseHorseSkill = CanUseHorseSkill();
-
-	// 말을 타고있지만 스킬은 사용할 수 없는 상태라면 return
-#ifdef SORF_TAHTASI
-	if (GetMountVnum() != SURFBOARD)
-	{
-		{
-			if (false == bCanUseHorseSkill && true == IsRiding()) {
-				return BATTLE_NONE;
-			}
-		}
-	}
-#else
-	if (false == bCanUseHorseSkill && true == IsRiding())
-		return BATTLE_NONE;
-#endif
-
-	if (IsPolymorphed())
-		return BATTLE_NONE;
-
-	if (g_bSkillDisable)
-		return BATTLE_NONE;
-
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-
-	if (!pkSk)
-		return BATTLE_NONE;
-
-#ifdef SORF_TAHTASI
-	if (GetMountVnum() != SURFBOARD)
-	{
-		{
-			if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE) {
-				return BATTLE_NONE;
-			}
-		
-			if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE) {
-				return BATTLE_NONE;
-			}
-		}
-	}
-#else
-	if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE)
-		return BATTLE_NONE;
-
-	if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE)
-		return BATTLE_NONE;
-#endif
-
-	// 상대방에게 쓰는 것이 아니면 나에게 써야 한다.
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
-		pkVictim = this;
-
-	if (!pkVictim)
-	{
-		if (test_server)
-			sys_log(0, "ComputeSkill: %s Victim == null, skill %d", GetName(), dwVnum);
-
-		return BATTLE_NONE;
-	}
-
-	const DWORD dwDistance = static_cast<DWORD>(DISTANCE_SQRT(GetX() - pkVictim->GetX(), GetY() - pkVictim->GetY()));
-	if ((pkSk->dwTargetRange) && (dwDistance >= ((pkSk->dwTargetRange + 50 / 100) * pkVictim->GetMonsterHitRange())))
-	{
-		if (test_server)
-			sys_log(0, "ComputeSkill: Victim too far, skill %d : %s to %s (distance %u limit %u)",
-				dwVnum,
-				GetName(),
-				pkVictim->GetName(),
-				(long)DISTANCE_SQRT(GetX() - pkVictim->GetX(), GetY() - pkVictim->GetY()),
-				pkSk->dwTargetRange);
-
-		return BATTLE_NONE;
-	}
-
-	if (0 == bSkillLevel)
-	{
-		if ((bSkillLevel = GetSkillLevel(pkSk->dwVnum)) == 0)
-		{
-			if (test_server)
-				sys_log(0, "ComputeSkill : name:%s vnum:%d skillLevelBySkill : %d ", GetName(), pkSk->dwVnum, bSkillLevel);
-			return BATTLE_NONE;
-		}
-	}
-
-	if (pkVictim->IsAffectFlag(AFF_PABEOP) && pkVictim->IsGoodAffect((BYTE)dwVnum))
-	{
-		return BATTLE_NONE;
-	}
-
-	const float k = 1.0 * GetSkillPower(pkSk->dwVnum, bSkillLevel) * pkSk->bMaxLevel / 100;
-
-	pkSk->SetPointVar("k", k);
-	pkSk->kSplashAroundDamageAdjustPoly.SetVar("k", k);
-
-	if (pkSk->dwType == SKILL_TYPE_HORSE)
-	{
-		LPITEM pkBow, pkArrow;
-		if (1 == GetArrowAndBow(&pkBow, &pkArrow, 1))
-		{
-			pkSk->SetPointVar("atk", CalcArrowDamage(this, pkVictim, pkBow, pkArrow, true));
-		}
-		else
-		{
-			pkSk->SetPointVar("atk", CalcMeleeDamage(this, pkVictim, true, false));
-		}
-	}
-	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MELEE_DAMAGE))
-	{
-		pkSk->SetPointVar("atk", CalcMeleeDamage(this, pkVictim, true, false));
-	}
-	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MAGIC_DAMAGE))
-	{
-		pkSk->SetPointVar("atk", CalcMagicDamage(this, pkVictim));
-	}
-	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_ARROW_DAMAGE))
-	{
-		LPITEM pkBow, pkArrow;
-		if (1 == GetArrowAndBow(&pkBow, &pkArrow, 1))
-		{
-			pkSk->SetPointVar("atk", CalcArrowDamage(this, pkVictim, pkBow, pkArrow, true));
-		}
-		else
-		{
-			pkSk->SetPointVar("atk", 0);
-		}
-	}
-
-	if (pkSk->wPointOn == POINT_MOV_SPEED)
-	{
-		pkSk->SetPointVar("maxv", pkVictim->GetLimitPoint(POINT_MOV_SPEED));
-	}
-
-	pkSk->SetPointVar("lv", GetLevel());
-	pkSk->SetPointVar("iq", GetPoint(POINT_IQ));
-	pkSk->SetPointVar("str", GetPoint(POINT_ST));
-	pkSk->SetPointVar("dex", GetPoint(POINT_DX));
-	pkSk->SetPointVar("con", GetPoint(POINT_HT));
-	pkSk->SetPointVar("maxhp", pkVictim->GetMaxHP());
-	pkSk->SetPointVar("maxsp", pkVictim->GetMaxSP());
-	pkSk->SetPointVar("chain", 0);
-	pkSk->SetPointVar("ar", CalcAttackRating(this, pkVictim));
-	pkSk->SetPointVar("def", GetPoint(POINT_DEF_GRADE));
-	pkSk->SetPointVar("odef", GetPoint(POINT_DEF_GRADE) - GetPoint(POINT_DEF_GRADE_BONUS));
-	pkSk->SetPointVar("horse_level", GetHorseLevel());
-
-	if (pkSk->bSkillAttrType != SKILL_ATTR_TYPE_NORMAL)
-		OnMove(true);
-
-	LPITEM pkWeapon = GetWear(WEAR_WEAPON);
-
-	SetPolyVarForAttack(this, pkSk, pkWeapon);
-
-	pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
-	pkSk->kDurationPoly2.SetVar("k", k/* bSkillLevel */);
-
-	int iAmount = (int)pkSk->kPointPoly.Eval();
-	int iAmount2 = (int)pkSk->kPointPoly2.Eval();
-	int iAmount3 = (int)pkSk->kPointPoly3.Eval();
-
-	if (test_server && IsPC())
-		sys_log(0, "iAmount: %d %d %d , atk:%f skLevel:%f k:%f GetSkillPower(%d) MaxLevel:%d Per:%f",
-			iAmount, iAmount2, iAmount3,
-			pkSk->kPointPoly.GetVar("atk"),
-			pkSk->kPointPoly.GetVar("k"),
-			k,
-			GetSkillPower(pkSk->dwVnum, bSkillLevel),
-			pkSk->bMaxLevel,
-			pkSk->bMaxLevel / 100
-		);
-
-	// ADD_GRANDMASTER_SKILL
-	if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
-	{
-		iAmount = (int)pkSk->kMasterBonusPoly.Eval();
-	}
-
-	if (test_server && iAmount == 0 && pkSk->wPointOn != POINT_NONE)
-	{
-		ChatPacket(CHAT_TYPE_INFO, "효과가 없습니다. 스킬 공식을 확인하세요");
-	}
-	// END_OF_ADD_GRANDMASTER_SKILL
-
-	//sys_log(0, "XXX SKILL Calc %d Amount %d", dwVnum, iAmount);
-
-	if (IsPC() && pkSk->dwVnum == SKILL_EUNHYUNG)
-		ForgetMyAttacker(false);
-
-	// REMOVE_BAD_AFFECT_BUG_FIX
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_REMOVE_BAD_AFFECT))
-	{
-		if (number(1, 100) <= iAmount2)
-		{
-			pkVictim->RemoveBadAffect();
-		}
-	}
-	// END_OF_REMOVE_BAD_AFFECT_BUG_FIX
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_ATTACK | SKILL_FLAG_USE_MELEE_DAMAGE | SKILL_FLAG_USE_MAGIC_DAMAGE) &&
-		!(pkSk->dwVnum == SKILL_MUYEONG && pkVictim == this) && !(pkSk->IsChargeSkill() && pkVictim == this))
-	{
-		bool bAdded = false;
-
-		if (pkSk->wPointOn == POINT_HP && iAmount < 0)
-		{
-			int iAG = 0;
-
-			FuncSplashDamage f(pkVictim->GetX(), pkVictim->GetY(), pkSk, this, iAmount, iAG, pkSk->lMaxHit, pkWeapon, m_bDisableCooltime, IsPC() ? &m_SkillUseInfo[dwVnum] : NULL, GetSkillPower(dwVnum, bSkillLevel));
-			if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-			{
-				if (pkVictim->GetSectree())
-					pkVictim->GetSectree()->ForEachAround(f);
-			}
-			else
-			{
-				f(pkVictim);
-			}
-		}
-		else
-		{
-			pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
-			int iDur = (int)pkSk->kDurationPoly.Eval();
-
-			if (IsPC())
-				if (!(dwVnum >= GUILD_SKILL_START && dwVnum <= GUILD_SKILL_END)) // 길드 스킬은 쿨타임 처리를 하지 않는다.
-					if (!m_bDisableCooltime && !m_SkillUseInfo[dwVnum].HitOnce(dwVnum) && dwVnum != SKILL_MUYEONG)
-						return BATTLE_NONE;
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true);
-				else
-				{
-					if (pkVictim->GetSectree())
-					{
-						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true, pkSk->lMaxHit);
-						pkVictim->GetSectree()->ForEachAround(f);
-					}
-				}
-				bAdded = true;
-			}
-		}
-
-		if (pkSk->wPointOn2 != POINT_NONE && !pkSk->IsChargeSkill())
-		{
-			pkSk->kDurationPoly2.SetVar("k", k/* bSkillLevel */);
-			int iDur = (int)pkSk->kDurationPoly2.Eval();
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-#if defined(__9TH_SKILL__)
-				if (pkSk->wPointOn2 == POINT_HIT_PCT)
-					AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, AFF_NONE, iDur, 0, !bAdded);
-#endif
-
-				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded);
-				else
-				{
-					if (pkVictim->GetSectree())
-					{
-						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded, pkSk->lMaxHit);
-						pkVictim->GetSectree()->ForEachAround(f);
-					}
-				}
-
-				bAdded = true;
-			}
-			else
-			{
-				pkVictim->PointChange(pkSk->wPointOn2, iAmount2);
-			}
-		}
-
-		// ADD_GRANDMASTER_SKILL
-		if (pkSk->wPointOn3 != POINT_NONE && !pkSk->IsChargeSkill() && GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
-		{
-			pkSk->kDurationPoly3.SetVar("k", k /* bSkillLevel */);
-			int iDur = (int)pkSk->kDurationPoly3.Eval();
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded);
-				else
-				{
-					if (pkVictim->GetSectree())
-					{
-						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded, pkSk->lMaxHit);
-						pkVictim->GetSectree()->ForEachAround(f);
-					}
-				}
-
-				bAdded = true;
-			}
-			else
-			{
-				pkVictim->PointChange(pkSk->wPointOn3, iAmount3);
-			}
-		}
-		// END_OF_ADD_GRANDMASTER_SKILL
-
-		return BATTLE_DAMAGE;
-	}
-	else
-	{
-		if (dwVnum == SKILL_MUYEONG)
-		{
-			pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
-			pkSk->kDurationSPCostPoly.SetVar("k", k/* bSkillLevel */);
-
-			int iDur = (long)pkSk->kDurationPoly.Eval();
-			iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-			if (pkVictim == this)
-				AddAffect(dwVnum,
-					POINT_NONE, 0,
-					AFF_MUYEONG,
-					iDur,
-					(long)pkSk->kDurationSPCostPoly.Eval(),
-					true);
-
-			return BATTLE_NONE;
-		}
-
-		bool bAdded = false;
-		pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
-		int iDur = (int)pkSk->kDurationPoly.Eval();
-
-		if (iDur > 0)
-		{
-			if (pkSk->dwVnum == SKILL_JEUNGRYEOK) // Nature's Enchantment
-			{
-				if (pkVictim->GetJob() == JOB_SHAMAN)
-				{
-					iAmount *= 2;
-					if (test_server)
-						sys_log(0, "Buffed Nature's Enchantment to %d.", iAmount);
-				}
-			}
-
-			iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-			// AffectFlag가 없거나, toggle 하는 것이 아니라면..
-			pkSk->kDurationSPCostPoly.SetVar("k", k/* bSkillLevel */);
-
-			if (pkSk->wPointOn2 != POINT_NONE)
-			{
-				pkVictim->RemoveAffect(pkSk->dwVnum);
-
-				int iDur2 = (int)pkSk->kDurationPoly2.Eval();
-
-				if (iDur2 > 0)
-				{
-					if (test_server)
-						sys_log(0, "SKILL_AFFECT: %s %s Dur:%d To:%d Amount:%d",
-							GetName(),
-							pkSk->szName,
-							iDur2,
-							pkSk->wPointOn2,
-							iAmount2);
-
-					iDur2 += GetPoint(POINT_PARTY_BUFFER_BONUS);
-					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur2, 0, false);
-				}
-				else
-				{
-					pkVictim->PointChange(pkSk->wPointOn2, iAmount2);
-				}
-
-				DWORD affact_flag = pkSk->dwAffectFlag;
-
-				// ADD_GRANDMASTER_SKILL
-				if ((pkSk->dwVnum == SKILL_CHUNKEON && GetUsedSkillMasterType(pkSk->dwVnum) < SKILL_GRAND_MASTER))
-				{
-					affact_flag = AFF_CHEONGEUN_WITH_FALL;
-				}
-				// END_OF_ADD_GRANDMASTER_SKILL
-
-				pkVictim->AddAffect(pkSk->dwVnum,
-					pkSk->wPointOn,
-					iAmount,
-					affact_flag,
-					iDur,
-					(long)pkSk->kDurationSPCostPoly.Eval(),
-					false);
-			}
-			else
-			{
-				if (test_server)
-					sys_log(0, "SKILL_AFFECT: %s %s Dur:%d To:%d Amount:%d",
-						GetName(),
-						pkSk->szName,
-						iDur,
-						pkSk->wPointOn,
-						iAmount);
-
-#if defined(__9TH_SKILL__)
-				DWORD dwAffectFlag = pkSk->dwAffectFlag;
-
-				if (dwVnum == SKILL_CHEONUN)
-				{
-					int iSkillMasterType = GetSkillMasterType(pkSk->dwVnum);
-					switch (iSkillMasterType)
-					{
-						case SKILL_NORMAL:
-							dwAffectFlag = AFF_CHEONUN_NORMAL;
-							break;
-						case SKILL_MASTER:
-							dwAffectFlag = AFF_CHEONUN_MASTER;
-							break;
-						case SKILL_GRAND_MASTER:
-							dwAffectFlag = AFF_CHEONUN_GRAND_MASTER;
-							break;
-						case SKILL_PERFECT_MASTER:
-							dwAffectFlag = AFF_CHEONUN_PERFECT_MASTER;
-							break;
-						default:
-							dwAffectFlag = pkSk->dwAffectFlag;
-							break;
-					}
-				}
-
-				pkVictim->AddAffect(pkSk->dwVnum,
-					pkSk->wPointOn,
-					iAmount,
-					dwAffectFlag,
-					iDur,
-					(long)pkSk->kDurationSPCostPoly.Eval(),
-					// ADD_GRANDMASTER_SKILL
-					!bAdded, false,
-#if defined(__AFFECT_RENEWAL__)
-					false, /*bRealTime*/
-#endif
-					iAmount2
-				);
-				// END_OF_ADD_GRANDMASTER_SKILL
-#else
-
-				pkVictim->AddAffect(pkSk->dwVnum,
-					pkSk->wPointOn,
-					iAmount,
-					pkSk->dwAffectFlag,
-					iDur,
-					(long)pkSk->kDurationSPCostPoly.Eval(),
-					// ADD_GRANDMASTER_SKILL
-					!bAdded
-				);
-				// END_OF_ADD_GRANDMASTER_SKILL
-#endif
-			}
-
-			bAdded = true;
-		}
-		else
-		{
-			if (!pkSk->IsChargeSkill())
-				pkVictim->PointChange(pkSk->wPointOn, iAmount);
-
-			if (pkSk->wPointOn2 != POINT_NONE)
-			{
-				pkVictim->RemoveAffect(pkSk->dwVnum);
-
-				int iDur2 = (int)pkSk->kDurationPoly2.Eval();
-
-				if (iDur2 > 0)
-				{
-					iDur2 += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-					if (pkSk->IsChargeSkill())
-						pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, AFF_TANHWAN_DASH, iDur2, 0, false);
-					else
-						pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur2, 0, false);
-				}
-				else
-				{
-					pkVictim->PointChange(pkSk->wPointOn2, iAmount2);
-				}
-
-			}
-		}
-
-		// ADD_GRANDMASTER_SKILL
-		if (pkSk->wPointOn3 != POINT_NONE && !pkSk->IsChargeSkill() && GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
-		{
-			pkSk->kDurationPoly3.SetVar("k", k/* bSkillLevel */);
-			int iDur = (int)pkSk->kDurationPoly3.Eval();
-
-			sys_log(0, "try third %u %d %d %d 1894", pkSk->dwVnum, pkSk->wPointOn3, iDur, iAmount3);
-
-			if (iDur > 0)
-			{
-				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
-
-				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
-					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded);
-				else
-				{
-					if (pkVictim->GetSectree())
-					{
-						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded, pkSk->lMaxHit);
-						pkVictim->GetSectree()->ForEachAround(f);
-					}
-				}
-
-				bAdded = true;
-			}
-			else
-			{
-				pkVictim->PointChange(pkSk->wPointOn3, iAmount3);
-			}
-		}
-		// END_OF_ADD_GRANDMASTER_SKILL
-
-		return BATTLE_NONE;
-	}
-}
-
-bool CHARACTER::UseSkill(DWORD dwVnum, LPCHARACTER pkVictim, bool bUseGrandMaster)
-{
-	if (false == CanUseSkill(dwVnum))
-		return false;
-
-	if ((dwVnum == SKILL_GEOMKYUNG || dwVnum == SKILL_GWIGEOM) && !GetWear(WEAR_WEAPON))
-		return false;
-
-	// NO_GRANDMASTER
-	if (test_server)
-	{
-		if (quest::CQuestManager::instance().GetEventFlag("no_grand_master"))
-		{
-			bUseGrandMaster = false;
-		}
-	}
-	// END_OF_NO_GRANDMASTER
-
-	if (g_bSkillDisable)
-		return false;
-
-	if (IsObserverMode())
-		return false;
-
-	if (!CanMove())
-		return false;
-
-	if (IsPolymorphed())
-		return false;
-
-	const bool bCanUseHorseSkill = CanUseHorseSkill();
-
-	if (dwVnum == SKILL_HORSE_SUMMON)
-	{
-		if (GetSkillLevel(dwVnum) == 0)
-			return false;
-
-		if (GetHorseLevel() <= 0)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("말이 없습니다. 마굿간 경비병을 찾아가세요."));
-		else
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("말 소환 아이템을 사용하세요."));
-
-		return true;
-	}
-
-	// 말을 타고있지만 스킬은 사용할 수 없는 상태라면 return false
-#ifdef SORF_TAHTASI
-	if (GetMountVnum() != SURFBOARD)
-	{
-		if (false == bCanUseHorseSkill && true == IsRiding())
-			return false;
-	}
-#else
-	if (false == bCanUseHorseSkill && true == IsRiding())
-		return false;
-#endif
-
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-	sys_log(0, "%s: USE_SKILL: %d pkVictim %p", GetName(), dwVnum, get_pointer(pkVictim));
-
-	if (!pkSk)
-		return false;
-
-#ifdef SORF_TAHTASI
-	if (GetMountVnum() != SURFBOARD)
-	{
-		if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE)
-			return BATTLE_NONE;
-
-		if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE)
-			return BATTLE_NONE;
-	}
-#else
-	if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE)
-		return BATTLE_NONE;
-
-	if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE)
-		return BATTLE_NONE;
-#endif
-
-	if (GetSkillLevel(dwVnum) == 0)
-		return false;
-
-	// NO_GRANDMASTER
-	if (GetSkillMasterType(dwVnum) < SKILL_GRAND_MASTER)
-		bUseGrandMaster = false;
-	// END_OF_NO_GRANDMASTER
-
-	// MINING
-	if (GetWear(WEAR_WEAPON) && (GetWear(WEAR_WEAPON)->GetType() == ITEM_ROD || GetWear(WEAR_WEAPON)->GetType() == ITEM_PICK))
-		return false;
-	// END_OF_MINING
-
-	m_SkillUseInfo[dwVnum].TargetVIDMap.clear();
-
-	if (pkSk->IsChargeSkill())
-	{
-		if (IsAffectFlag(AFF_TANHWAN_DASH) || pkVictim && pkVictim != this)
-		{
-			if (!pkVictim)
-				return false;
-
-			if (!IsAffectFlag(AFF_TANHWAN_DASH))
-			{
-				if (!UseSkill(dwVnum, this))
-					return false;
-			}
-
-			m_SkillUseInfo[dwVnum].SetMainTargetVID(pkVictim->GetVID());
-			// DASH 상태의 탄환격은 공격기술
-			ComputeSkill(dwVnum, pkVictim);
-			RemoveAffect(dwVnum);
-			return true;
-		}
-	}
-
-	if (dwVnum == SKILL_COMBO)
-	{
-		if (m_bComboIndex)
-			m_bComboIndex = 0;
-		else
-			m_bComboIndex = GetSkillLevel(SKILL_COMBO);
-
-		ChatPacket(CHAT_TYPE_COMMAND, "combo %d", m_bComboIndex);
-		return true;
-	}
-
-	// Toggle 할 때는 SP를 쓰지 않음 (SelfOnly로 구분)
-	if ((0 != pkSk->dwAffectFlag || pkSk->dwVnum == SKILL_MUYEONG) && (pkSk->dwFlag & SKILL_FLAG_TOGGLE) && RemoveAffect(pkSk->dwVnum))
-	{
-		return true;
-	}
-
-	if (IsAffectFlag(AFF_REVIVE_INVISIBLE))
-		RemoveAffect(AFFECT_REVIVE_INVISIBLE);
-
-	const float k = GetSkillPower(pkSk->dwVnum) * pkSk->bMaxLevel / 100.0f;
-
-	pkSk->SetPointVar("k", k);
-	pkSk->kSplashAroundDamageAdjustPoly.SetVar("k", k);
-
-	// 쿨타임 체크
-	pkSk->kCooldownPoly.SetVar("k", k);
-	int iCooltime = (int)pkSk->kCooldownPoly.Eval();
-	int lMaxHit = pkSk->lMaxHit ? pkSk->lMaxHit : -1;
-
-	pkSk->SetSPCostVar("k", k);
-
-	DWORD dwCur = get_dword_time();
-
-	if (dwVnum == SKILL_TERROR && m_SkillUseInfo[dwVnum].bUsed && m_SkillUseInfo[dwVnum].dwNextSkillUsableTime > dwCur)
-	{
-		sys_log(0, " SKILL_TERROR's Cooltime is not delta over %u", m_SkillUseInfo[dwVnum].dwNextSkillUsableTime - dwCur);
-		return false;
-	}
-
-	int iNeededSP = 0;
-
-	//if (dwVnum == 51)
-	//	AddAffect(AFF_EUNHYUNG, POINT_NONE, 0, AFF_EUNHYUNG, 4, 0, true);
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_HP_AS_COST))
-	{
-		pkSk->SetSPCostVar("maxhp", GetMaxHP());
-		pkSk->SetSPCostVar("v", GetHP());
-		iNeededSP = (int)pkSk->kSPCostPoly.Eval();
-
-		// ADD_GRANDMASTER_SKILL
-		if (GetSkillMasterType(dwVnum) >= SKILL_GRAND_MASTER && bUseGrandMaster)
-		{
-			iNeededSP = (int)pkSk->kGrandMasterAddSPCostPoly.Eval();
-		}
-		// END_OF_ADD_GRANDMASTER_SKILL
-
-		if (GetHP() < iNeededSP)
-			return false;
-
-		PointChange(POINT_HP, -iNeededSP);
-	}
-	else
-	{
-		// SKILL_FOMULA_REFACTORING
-		pkSk->SetSPCostVar("maxhp", GetMaxHP());
-		pkSk->SetSPCostVar("maxv", GetMaxSP());
-		pkSk->SetSPCostVar("v", GetSP());
-
-		iNeededSP = (int)pkSk->kSPCostPoly.Eval();
-
-		if (GetSkillMasterType(dwVnum) >= SKILL_GRAND_MASTER && bUseGrandMaster)
-		{
-			iNeededSP = (int)pkSk->kGrandMasterAddSPCostPoly.Eval();
-		}
-		// END_OF_SKILL_FOMULA_REFACTORING
-
-		if (GetSP() < iNeededSP)
-			return false;
-
-		if (test_server)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s SP소모: %d", LC_SKILL(pkSk->dwVnum), iNeededSP));
-
-		PointChange(POINT_SP, -iNeededSP);
-	}
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
-		pkVictim = this;
-
-	if ((pkSk->dwVnum == SKILL_MUYEONG) || (pkSk->IsChargeSkill() && !IsAffectFlag(AFF_TANHWAN_DASH) && !pkVictim))
-	{
-		// 처음 사용하는 무영진은 자신에게 Affect를 붙인다.
-		pkVictim = this;
-	}
-
-	int iSplashCount = 1;
-
-	if (false == m_bDisableCooltime)
-	{
-		if (false ==
-			m_SkillUseInfo[dwVnum].UseSkill(
-				bUseGrandMaster,
-				(NULL != pkVictim && SKILL_HORSE_WILDATTACK != dwVnum) ? pkVictim->GetVID() : 0,
-				ComputeCooltime(iCooltime * 1000),
-				iSplashCount,
-				lMaxHit))
-		{
-			if (test_server)
-				ChatPacket(CHAT_TYPE_NOTICE, "cooltime not finished %s %d", pkSk->szName, iCooltime);
-
-			return false;
-		}
-	}
-
-	if (dwVnum == SKILL_CHAIN)
-	{
-		ResetChainLightningIndex();
-		AddChainLightningExcept(pkVictim);
-	}
-
-#if defined(__PVP_BALANCE_IMPROVING__)
-	if (dwVnum == SKILL_PAERYONG)
-		ComputeSkill(dwVnum, pkVictim);
-#endif
-
-#if defined(__9TH_SKILL__)
-	if (dwVnum == SKILL_METEO)
-		ComputeSkill(dwVnum, pkVictim);
-#endif
-
-	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
-		ComputeSkill(dwVnum, this);
-	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_PARTY))
-	{
-		ComputeSkillParty(dwVnum, this);
-
-		if (pkVictim)
-			ComputeSkill(dwVnum, pkVictim);
-	}
-	else if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_ATTACK))
-		ComputeSkill(dwVnum, pkVictim);
-	else if (dwVnum == SKILL_BYEURAK)
-		ComputeSkill(dwVnum, pkVictim);
-	else if (dwVnum == SKILL_MUYEONG || pkSk->IsChargeSkill())
-		ComputeSkill(dwVnum, pkVictim);
-
-	m_dwLastSkillTime = get_dword_time();
-
-	return true;
-}
-
-int CHARACTER::GetUsedSkillMasterType(DWORD dwVnum)
-{
-	const TSkillUseInfo& rInfo = m_SkillUseInfo[dwVnum];
-
-	if (GetSkillMasterType(dwVnum) < SKILL_GRAND_MASTER)
-		return GetSkillMasterType(dwVnum);
-
-	if (rInfo.isGrandMaster)
-		return GetSkillMasterType(dwVnum);
-
-	return MIN(GetSkillMasterType(dwVnum), SKILL_MASTER);
-}
-
-int CHARACTER::GetSkillMasterType(DWORD dwVnum) const
-{
-	if (!IsPC())
-		return 0;
-
-	if (dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
-		return 0;
-	}
-
-	return m_pSkillLevels ? m_pSkillLevels[dwVnum].bMasterType : SKILL_NORMAL;
-}
-
-#if defined(__CONQUEROR_LEVEL__)
-bool CHARACTER::IsConquerorSkill(DWORD dwVnum) const
-{
-	if (!IsPC())
-		return false;
-
-	if (dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
-		return false;
-	}
-
-	/*
-	* Since there is currently no way to check if the skills
-	* are conqueror level we have to hard code them.
-	*/
-
-	if (dwVnum >= SKILL_FINISH && dwVnum <= SKILL_ILIPUNGU)
-		return true;
-
-	return false;
-}
-#endif
-
-int CHARACTER::GetSkillPower(DWORD dwVnum, BYTE bLevel) const
-{
-	// 인어반지 아이템
-	if (dwVnum >= SKILL_LANGUAGE1 && dwVnum <= SKILL_LANGUAGE3 && IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-	{
-		return 100;
-	}
-
-	if (dwVnum >= GUILD_SKILL_START && dwVnum <= GUILD_SKILL_END)
-	{
-		if (GetGuild())
-			return 100 * GetGuild()->GetSkillLevel(dwVnum) / 7 / 7;
-		else
-			return 0;
-	}
-
-	if (bLevel)
-	{
-		// SKILL_POWER_BY_LEVEL
-		return GetSkillPowerByLevel(bLevel, true);
-		// END_SKILL_POWER_BY_LEVEL;
-	}
-
-	if (dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
-		return 0;
-	}
-
-	// SKILL_POWER_BY_LEVEL
-	return GetSkillPowerByLevel(GetSkillLevel(dwVnum));
-	// SKILL_POWER_BY_LEVEL
-}
-
-int CHARACTER::GetSkillLevel(DWORD dwVnum) const
-{
-	if (dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
-		sys_log(0, "%s skill vnum overflow %u", GetName(), dwVnum);
-		return 0;
-	}
-
-	return MIN(SKILL_MAX_LEVEL, m_pSkillLevels ? m_pSkillLevels[dwVnum].bLevel : 0);
-}
-
-EVENTFUNC(skill_muyoung_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("skill_muyoung_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = info->ch;
-
-	if (ch == NULL) // <Factor>
-		return 0;
-
-	if (!ch->IsAffectFlag(AFF_MUYEONG))
-	{
-		ch->StopMuyeongEvent();
-		return 0;
-	}
-
-	// 1. Find Victim
-	FFindNearVictim f(ch, ch);
-	if (ch->GetSectree())
-	{
-		ch->GetSectree()->ForEachAround(f);
-		// 2. Shoot!
-		if (f.GetVictim())
-		{
-			ch->CreateFly(FLY_SKILL_MUYEONG, f.GetVictim());
-			ch->ComputeSkill(SKILL_MUYEONG, f.GetVictim());
-		}
-	}
-
-	return PASSES_PER_SEC(3);
-}
-
-void CHARACTER::StartMuyeongEvent()
-{
-	if (m_pkMuyeongEvent)
-		return;
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-
-	info->ch = this;
-	m_pkMuyeongEvent = event_create(skill_muyoung_event, info, PASSES_PER_SEC(1));
-}
-
-void CHARACTER::StopMuyeongEvent()
-{
-	event_cancel(&m_pkMuyeongEvent);
-}
-
-#if defined(__PVP_BALANCE_IMPROVING__)
-EVENTFUNC(skill_gyeonggong_event)
-{
-	const char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("skill_gyeonggong_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = info->ch;
-	if (ch == NULL)
-		return 0;
-
-	if (!ch->IsAffectFlag(AFF_GYEONGGONG))
-	{
-		ch->StopGyeongGongEvent();
-		return 0;
-	}
-
-	ch->ComputeGyeongGongSkill(SKILL_GYEONGGONG, ch);
-
-	return PASSES_PER_SEC(1);
-}
-
-void CHARACTER::StartGyeongGongEvent()
-{
-	if (m_pkGyeongGongEvent)
-		return;
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-	info->ch = this;
-	m_pkGyeongGongEvent = event_create(skill_gyeonggong_event, info, PASSES_PER_SEC(1));
-}
-
-void CHARACTER::StopGyeongGongEvent()
-{
-	event_cancel(&m_pkGyeongGongEvent);
-}
-#endif
-
-#if defined(__9TH_SKILL__)
-struct FPartyAffect
-{
-	void operator() (LPCHARACTER ch)
-	{
-		ch->ExitToSavedLocation();
-	}
-};
-
-EVENTINFO(skill_cheonun_event_info)
-{
-	DynamicCharacterPtr ch;
-	BYTE prob, duration;
-};
-
-EVENTFUNC(skill_cheonun_event)
-{
-	skill_cheonun_event_info* info = dynamic_cast<skill_cheonun_event_info*>(event->info);
-	if (info == nullptr)
-	{
-		sys_err("skill_cheonun_event_info NULL");
-		return 0;
-	}
-
-	const LPCHARACTER ch = info->ch;
-	if (ch == nullptr)
-		return 0;
-
-	if (!ch->FindAffect(SKILL_CHEONUN /*AFFECT_SKILL_9_CHEONUN*/))
-	{
-		ch->StopCheonunEvent();
-		return 0;
-	}
-
-	const BYTE max_prob = 100;
-	const BYTE prob = number(1, max_prob);
-	if (prob >= max_prob - info->prob)
-	{
-		const LPPARTY party = ch->GetParty();
-		if (party)
-		{
-			auto FPartyAffect = [&info](const LPCHARACTER& ch)
-			{
-				ch->AddAffect(AFFECT_CHEONUN_INVINCIBILITY, APPLY_NONE, 1, AFF_CHEONUN_INVINCIBILITY, info->duration, 0, true);
-			};
-			party->ForEachNearMember(FPartyAffect);
-		}
-		else
-		{
-			ch->AddAffect(AFFECT_CHEONUN_INVINCIBILITY, APPLY_NONE, 1, AFF_CHEONUN_INVINCIBILITY, info->duration, 0, true);
-		}
-	}
-
-	return PASSES_PER_SEC(12);
-}
-
-void CHARACTER::StartCheonunEvent(BYTE bChance, BYTE bDuration)
-{
-	if (m_pkCheonunEvent)
-		return;
-
-	skill_cheonun_event_info* info = AllocEventInfo<skill_cheonun_event_info>();
-	info->ch = this;
-	info->prob = bChance;
-	info->duration = bDuration;
-	m_pkCheonunEvent = event_create(skill_cheonun_event, info, PASSES_PER_SEC(1));
-}
-
-void CHARACTER::StopCheonunEvent()
-{
-	event_cancel(&m_pkCheonunEvent);
-}
-#endif
-
-void CHARACTER::SkillLearnWaitMoreTimeMessage(DWORD ms)
-{
-	// const char* str = "";
-	//
-	if (ms < 3 * 60)
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("몸 속이 뜨겁군. 하지만 아주 편안해. 이대로 기를 안정시키자."));
-	else if (ms < 5 * 60)
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("그래, 천천히. 좀더 천천히, 그러나 막힘 없이 빠르게!"));
-	else if (ms < 10 * 60) // 10분
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("그래, 이 느낌이야. 체내에 기가 아주 충만해."));
-	else if (ms < 30 * 60) // 30분
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("다 읽었다! 이제 비급에 적혀있는 대로 전신에 기를 돌리기만 하면,"));
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("그것으로 수련은 끝난 거야!"));
-	}
-	else if (ms < 1 * 3600) // 1시간
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("이제 책의 마지막 장이야! 수련의 끝이 눈에 보이고 있어!"));
-	else if (ms < 2 * 3600) // 2시간
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("얼마 안 남았어! 조금만 더!"));
-	else if (ms < 3 * 3600)
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("좋았어! 조금만 더 읽으면 끝이다!"));
-	else if (ms < 6 * 3600)
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("책장도 이제 얼마 남지 않았군."));
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("뭔가 몸 안에 힘이 생기는 기분인 걸."));
-	}
-	else if (ms < 12 * 3600)
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("이제 좀 슬슬 가닥이 잡히는 것 같은데."));
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("좋아, 이 기세로 계속 나간다!"));
-	}
-	else if (ms < 18 * 3600)
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("아니 어떻게 된 게 종일 읽어도 머리에 안 들어오냐."));
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("공부하기 싫어지네."));
-	}
-	else //if (ms < 2 * 86400)
-	{
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("생각만큼 읽기가 쉽지가 않군. 이해도 어렵고 내용도 난해해."));
-		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("이래서야 공부가 안된다구."));
-	}
-
-	/*
-		str = "30%";
-	else if (ms < 3 * 86400)
-		str = "10%";
-	else if (ms < 4 * 86400)
-		str = "5%";
-	else
-		str = "0%";
-
-	ChatPacket(CHAT_TYPE_TALKING, "%s", str);
-	*/
-}
-
-void CHARACTER::DisableCooltime()
-{
-	m_bDisableCooltime = true;
-}
-
-bool CHARACTER::HasMobSkill() const
-{
-	return CountMobSkill() > 0;
-}
-
-size_t CHARACTER::CountMobSkill() const
-{
-	if (!m_pkMobData)
-		return 0;
-
-	size_t c = 0;
-
-	for (size_t i = 0; i < MOB_SKILL_MAX_NUM; ++i)
-		if (m_pkMobData->m_table.Skills[i].dwVnum)
-			++c;
-
-	return c;
-}
-
-const TMobSkillInfo* CHARACTER::GetMobSkill(unsigned int idx) const
-{
-	if (idx >= MOB_SKILL_MAX_NUM)
-		return NULL;
-
-	if (!m_pkMobData)
-		return NULL;
-
-	if (0 == m_pkMobData->m_table.Skills[idx].dwVnum)
-		return NULL;
-
-	return &m_pkMobData->m_mobSkillInfo[idx];
-}
-
-bool CHARACTER::CanUseMobSkill(unsigned int idx) const
-{
-	const TMobSkillInfo* pInfo = GetMobSkill(idx);
-
-	if (!pInfo)
-		return false;
-
-	if (m_adwMobSkillCooltime[idx] > get_dword_time())
-		return false;
-
-	if (number(0, 1))
-		return false;
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
-	{
-		CGuildDragonLair* pGuildDragonLair = GetGuildDragonLair();
-		if (pGuildDragonLair && pGuildDragonLair->GetSpecialAttack())
-			return false;
-	}
-#endif
-
-	return true;
-}
-
-EVENTINFO(mob_skill_event_info)
-{
-	DynamicCharacterPtr ch;
-	PIXEL_POSITION pos;
-	DWORD vnum;
-	int index;
-	BYTE level;
-
-	mob_skill_event_info()
-		: ch()
-		, pos()
-		, vnum(0)
-		, index(0)
-		, level(0)
-	{
-	}
-};
-
-EVENTFUNC(mob_skill_hit_event)
-{
-	mob_skill_event_info* info = dynamic_cast<mob_skill_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("mob_skill_event_info> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = info->ch;
-	if (ch == NULL) // <Factor>
-		return 0;
-
-	ch->ComputeSkillAtPosition(info->vnum, info->pos, info->level);
-
-	ch->m_mapMobSkillEvent.erase(info->index);
-
-	return 0;
-}
-
-#if defined(__DAWNMIST_DUNGEON__)
-struct FPartyHealer
-{
-	int m_iSkillLevel;
-	FPartyHealer(int iSkillLevel) : m_iSkillLevel(iSkillLevel) {}
-	void operator() (const LPENTITY pkEntity)
-	{
-		if (pkEntity && !pkEntity->IsType(ENTITY_CHARACTER))
-			return;
-
-		const LPCHARACTER pkChar = dynamic_cast<LPCHARACTER>(pkEntity);
-		if (pkChar == nullptr)
-			return;
-
-		if (!pkChar->IsMonster() || pkChar->IsDead())
-			return;
-
-		if (pkChar->GetHP() >= pkChar->GetMaxHP())
-			return;
-
-		CSkillProto* pkSkill = CSkillManager::instance().Get(SKILL_HEAL);
-		if (NULL != pkSkill)
-		{
-			pkSkill->SetPointVar("maxhp", pkChar->GetMaxHP());
-			pkSkill->SetPointVar("k", 1.0f * m_iSkillLevel / 100.0f);
-
-			int iAmount = static_cast<int>(pkSkill->kPointPoly.Eval());
-			
-			
-			pkChar->PointChange(pkSkill->wPointOn, iAmount);
-			pkChar->EffectPacket(SE_HEAL);
-		}
-		//pkChar->PointChange(POINT_HP, MAX(1, (pkChar->GetMaxHP() * pkChar->GetMobTable().bRegenPercent) / 100)); // Old
-	}
-};
-
-EVENTINFO(HealEventInfo)
-{
-	LPCHARACTER pHealer;
-	BYTE bSkillLevel;
-	int iCooltime;
-};
-
-EVENTFUNC(HealEvent)
-{
-	HealEventInfo* pInfo = dynamic_cast<HealEventInfo*>(event->info);
-	if (pInfo == nullptr)
-	{
-		sys_err("HealerEvent: <Factor> Null pointer");
-		return 0;
-	}
-
-	const LPCHARACTER pkHealer = pInfo->pHealer;
-	if ((pkHealer == nullptr) || (pkHealer->IsDead() || pkHealer->IsStun()))
-		return 0;
-
-	if (!pkHealer->IsHealer())
-		return 0;
-
-	const LPPARTY pkParty = pkHealer->GetParty();
-	if (pkParty == nullptr)
-		return 0;
-
-	FPartyHealer f(pInfo->bSkillLevel);
-	pkParty->ForEachMemberPtr(f);
-
-	return PASSES_PER_SEC(pInfo->iCooltime);
-};
-#endif
-
-bool CHARACTER::UseMobSkill(unsigned int idx)
-{
-	if (IsPC())
-		return false;
-
-	const TMobSkillInfo* pInfo = GetMobSkill(idx);
-
-	if (!pInfo)
-		return false;
-
-	DWORD dwVnum = pInfo->dwSkillVnum;
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-
-	if (!pkSk)
-		return false;
-
-	const float k = 1.0 * GetSkillPower(pkSk->dwVnum, pInfo->bSkillLevel) * pkSk->bMaxLevel / 100;
-
-	pkSk->kCooldownPoly.SetVar("k", k);
-	int iCooltime = (int)(pkSk->kCooldownPoly.Eval() * 1000);
-
-	m_adwMobSkillCooltime[idx] = get_dword_time() + iCooltime;
-
-	sys_log(0, "USE_MOB_SKILL: %s idx %d vnum %u cooltime %d", GetName(), idx, dwVnum, iCooltime);
-
-#if defined(__DAWNMIST_DUNGEON__)
-	if (IsHealer() && IS_SET(pkSk->dwFlag, SKILL_FLAG_PARTY))
-	{
-		if (m_pkHealEvent == NULL)
-		{
-			HealEventInfo* pHealEventInfo = AllocEventInfo<HealEventInfo>();
-			pHealEventInfo->pHealer = this;
-			pHealEventInfo->bSkillLevel = pInfo->bSkillLevel;
-			pHealEventInfo->iCooltime = iCooltime / 1000;
-			m_pkHealEvent = event_create(HealEvent, pHealEventInfo, PASSES_PER_SEC(1));
-		}
-		return true;
-	}
-#endif
-
-	sys_log(0, "USE_MOB_SKILL: %s idx %d vnum %u cooltime %d", GetName(), idx, dwVnum, iCooltime);
-
-	if (m_pkMobData->m_mobSkillInfo[idx].vecSplashAttack.empty())
-	{
-		sys_err("No skill hit data for mob %s index %d", GetName(), idx);
-		return false;
-	}
-
-	for (size_t i = 0; i < m_pkMobData->m_mobSkillInfo[idx].vecSplashAttack.size(); i++)
-	{
-		PIXEL_POSITION pos = GetXYZ();
-		const TMobSplashAttackInfo& rInfo = m_pkMobData->m_mobSkillInfo[idx].vecSplashAttack[i];
-
-		if (rInfo.dwHitDistance)
-		{
-			float fx, fy;
-			GetDeltaByDegree(GetRotation(), rInfo.dwHitDistance, &fx, &fy);
-			pos.x += (long)fx;
-			pos.y += (long)fy;
-		}
-
-		if (rInfo.dwTiming)
-		{
-			if (test_server)
-				sys_log(0, "               timing %ums", rInfo.dwTiming);
-
-			mob_skill_event_info* info = AllocEventInfo<mob_skill_event_info>();
-
-			info->ch = this;
-			info->pos = pos;
-			info->level = pInfo->bSkillLevel;
-			info->vnum = dwVnum;
-			info->index = i;
-
-			// <Factor> Cancel existing event first
-			auto it = m_mapMobSkillEvent.find(i);
-			if (it != m_mapMobSkillEvent.end())
-			{
-				LPEVENT existing = it->second;
-				event_cancel(&existing);
-				m_mapMobSkillEvent.erase(it);
-			}
-
-			m_mapMobSkillEvent.insert(std::make_pair(i, event_create(mob_skill_hit_event, info, PASSES_PER_SEC(rInfo.dwTiming) / 1000)));
-		}
-		else
-		{
-			ComputeSkillAtPosition(dwVnum, pos, pInfo->bSkillLevel);
-		}
-	}
-
-	return true;
-}
-
-void CHARACTER::ResetMobSkillCooltime()
-{
-	memset(m_adwMobSkillCooltime, 0, sizeof(m_adwMobSkillCooltime));
-}
-
-bool CHARACTER::IsUsableSkillMotion(DWORD dwMotionIndex) const
-{
-	DWORD selfJobGroup = (GetJob() + 1) * 10 + GetSkillGroup();
-
-	const DWORD SKILL_NUM = 184;
-	static DWORD s_anSkill2JobGroup[SKILL_NUM] = {
-		0, // common_skill 0
-		11, // job_skill(WARRIOR SKILL) 1
-		11, // job_skill(WARRIOR SKILL) 2
-		11, // job_skill(WARRIOR SKILL) 3
-		11, // job_skill(WARRIOR SKILL) 4
-		11, // job_skill(WARRIOR SKILL) 5
-		11, // job_skill(WARRIOR SKILL) 6
-		0, // common_skill 7
-		0, // common_skill 8
-		0, // common_skill 9
-		0, // common_skill 10
-		0, // common_skill 11
-		0, // common_skill 12
-		0, // common_skill 13
-		0, // common_skill 14
-		0, // common_skill 15
-		12, // job_skill(WARRIOR SKILL) 16
-		12, // job_skill(WARRIOR SKILL) 17
-		12, // job_skill(WARRIOR SKILL) 18
-		12, // job_skill(WARRIOR SKILL) 19
-		12, // job_skill(WARRIOR SKILL) 20
-		12, // job_skill(WARRIOR SKILL) 21
-		0, // common_skill 22
-		0, // common_skill 23
-		0, // common_skill 24
-		0, // common_skill 25
-		0, // common_skill 26
-		0, // common_skill 27
-		0, // common_skill 28
-		0, // common_skill 29
-		0, // common_skill 30
-		21, // job_skill(ASSASSIN SKILL) 31
-		21, // job_skill(ASSASSIN SKILL) 32
-		21, // job_skill(ASSASSIN SKILL) 33
-		21, // job_skill(ASSASSIN SKILL) 34
-		21, // job_skill(ASSASSIN SKILL) 35
-		21, // job_skill(ASSASSIN SKILL) 36
-		0, // common_skill 37
-		0, // common_skill 38
-		0, // common_skill 39
-		0, // common_skill 40
-		0, // common_skill 41
-		0, // common_skill 42
-		0, // common_skill 43
-		0, // common_skill 44
-		0, // common_skill 45
-		22, // job_skill(ASSASSIN SKILL) 46
-		22, // job_skill(ASSASSIN SKILL) 47
-		22, // job_skill(ASSASSIN SKILL) 48
-		22, // job_skill(ASSASSIN SKILL) 49
-		22, // job_skill(ASSASSIN SKILL) 50
-		22, // job_skill(ASSASSIN SKILL) 51
-		0, // common_skill 52
-		0, // common_skill 53
-		0, // common_skill 54
-		0, // common_skill 55
-		0, // common_skill 56
-		0, // common_skill 57
-		0, // common_skill 58
-		0, // common_skill 59
-		0, // common_skill 60
-		31, // job_skill(SURA SKILL) 61
-		31, // job_skill(SURA SKILL) 62
-		31, // job_skill(SURA SKILL) 63
-		31, // job_skill(SURA SKILL) 64
-		31, // job_skill(SURA SKILL) 65
-		31, // job_skill(SURA SKILL) 66
-		0, // common_skill 67
-		0, // common_skill 68
-		0, // common_skill 69
-		0, // common_skill 70
-		0, // common_skill 71
-		0, // common_skill 72
-		0, // common_skill 73
-		0, // common_skill 74
-		0, // common_skill 75
-		32, // job_skill(SURA SKILL) 76
-		32, // job_skill(SURA SKILL) 77
-		32, // job_skill(SURA SKILL) 78
-		32, // job_skill(SURA SKILL) 79
-		32, // job_skill(SURA SKILL) 80
-		32, // job_skill(SURA SKILL) 81
-		0, // common_skill 82
-		0, // common_skill 83
-		0, // common_skill 84
-		0, // common_skill 85
-		0, // common_skill 86
-		0, // common_skill 87
-		0, // common_skill 88
-		0, // common_skill 89
-		0, // common_skill 90
-		41, // job_skill(SHAMAN SKILL) 91
-		41, // job_skill(SHAMAN SKILL) 92
-		41, // job_skill(SHAMAN SKILL) 93
-		41, // job_skill(SHAMAN SKILL) 94
-		41, // job_skill(SHAMAN SKILL) 95
-		41, // job_skill(SHAMAN SKILL) 96
-		0, // common_skill 97
-		0, // common_skill 98
-		0, // common_skill 99
-		0, // common_skill 100
-		0, // common_skill 101
-		0, // common_skill 102
-		0, // common_skill 103
-		0, // common_skill 104
-		0, // common_skill 105
-		42, // job_skill(SHAMAN SKILL) 106
-		42, // job_skill(SHAMAN SKILL) 107
-		42, // job_skill(SHAMAN SKILL) 108
-		42, // job_skill(SHAMAN SKILL) 109
-		42, // job_skill(SHAMAN SKILL) 110
-		42, // job_skill(SHAMAN SKILL) 111
-		0, // common_skill 112
-		0, // common_skill 113
-		0, // common_skill 114
-		0, // common_skill 115
-		0, // common_skill 116
-		0, // common_skill 117
-		0, // common_skill 118
-		0, // common_skill 119
-		0, // common_skill 120
-		0, // common_skill 121
-		0, // common_skill 122
-		0, // common_skill 123
-		0, // common_skill 124
-		0, // common_skill 125
-		0, // common_skill 126
-		0, // common_skill 127
-		0, // common_skill 128
-		0, // common_skill 129
-		0, // common_skill 130
-		0, // common_skill 131
-		0, // common_skill 132
-		0, // common_skill 133
-		0, // common_skill 134
-		0, // common_skill 135
-		0, // common_skill 136
-		0, // job_skill 137
-		0, // job_skill 138
-		0, // job_skill 139
-		0, // job_skill 140
-		0, // common_skill 141
-		0, // common_skill 142
-		0, // common_skill 143
-		0, // common_skill 144
-		0, // common_skill 145
-		0, // common_skill 146
-		0, // common_skill 147
-		0, // common_skill 148
-		0, // common_skill 149
-		0, // common_skill 150
-		0, // common_skill 151
-		0, // job_skill 152
-		0, // job_skill 153
-		0, // job_skill 154
-		0, // job_skill 155
-		0, // job_skill 156
-		0, // job_skill 157
-		0, // empty(reserved) 158
-		0, // empty(reserved) 159
-		0, // empty(reserved) 160
-		0, // empty(reserved) 161
-		0, // empty(reserved) 162
-		0, // empty(reserved) 163
-		0, // empty(reserved) 164
-		0, // empty(reserved) 165
-		0, // empty(reserved) 166
-		0, // empty(reserved) 167
-		0, // empty(reserved) 168
-		0, // empty(reserved) 169
-		51, // job_skill(WOLFMAN SKILL) 170
-		51, // job_skill(WOLFMAN SKILL) 171
-		51, // job_skill(WOLFMAN SKILL) 172
-		51, // job_skill(WOLFMAN SKILL) 173
-		51, // job_skill(WOLFMAN SKILL) 174
-		51, // job_skill(WOLFMAN SKILL) 175
-		0, // job_skill(WARRIOR CONQUEROR SKILL) 176
-		0, // job_skill(ASSASSIN CONQUEROR SKILL) 177
-		0, // job_skill(ASSASSIN CONQUEROR SKILL) 178
-		0, // job_skill(SURA CONQUEROR SKILL) 179
-		0, // job_skill(SURA CONQUEROR SKILL) 180
-		0, // job_skill(SHAMAN CONQUEROR SKILL) 181
-		0, // job_skill(SHAMAN CONQUEROR SKILL) 182
-		0 // job_skill(WOLFMAN CONQUEROR SKILL) 183
-	}; // s_anSkill2JobGroup
-
-	const DWORD MOTION_MAX_NUM = 124;
-	const DWORD SKILL_LIST_MAX_COUNT = 6;
-
-	static DWORD s_anMotion2SkillVnumList[MOTION_MAX_NUM][SKILL_LIST_MAX_COUNT] =
-	{
-		//	스킬수	무사스킬ID	자객스킬ID	수라스킬ID	무당스킬ID	수인족(WOLFMAN) 스킬ID
-		{	0,		0,			0,			0,			0,			0		}, // 0 (RESERVED)
-
-		// 1번 직군 기본 스킬 SKILL GROUP 1 - TRAINING
-		{	5,		1,			31,			61,			91,			170		}, // 1
-		{	5,		2,			32,			62,			92,			171		}, // 2
-		{	5,		3,			33,			63,			93,			172		}, // 3
-		{	5,		4,			34,			64,			94,			173		}, // 4
-		{	5,		5,			35,			65,			95,			174		}, // 5
-		{	5,		6,			36,			66,			96,			175		}, // 6
-		{	0,		0,			0,			0,			0,			0		}, // 7
-		{	0,		0,			0,			0,			0,			0		}, // 8
-		{	5,		176,		177,		179,		181,		183		}, // 9
-		{	0,		0,			0,			0,			0,			0		}, // 10
-		// 1번 직군 기본 스킬 끝 END
-
-		// 여유분 MARGIN
-		{	0,		0,			0,			0,			0,			0		}, // 11
-		{	0,		0,			0,			0,			0,			0		}, // 12
-		{	0,		0,			0,			0,			0,			0		}, // 13
-		{	0,		0,			0,			0,			0,			0		}, // 14
-		{	0,		0,			0,			0,			0,			0		}, // 15
-		// 여유분 끝 END
-
-		// 2번 직군 기본 스킬 SKILL GROUP 2 - TRAINING
-		{	4,		16,			46,			76,			106,		0		}, // 16
-		{	4,		17,			47,			77,			107,		0		}, // 17
-		{	4,		18,			48,			78,			108,		0		}, // 18
-		{	4,		19,			49,			79,			109,		0		}, // 19
-		{	4,		20,			50,			80,			110,		0		}, // 20
-		{	4,		21,			51,			81,			111,		0		}, // 21
-		{	0,		0,			0,			0,			0,			0		}, // 22
-		{	0,		0,			0,			0,			0,			0		}, // 23
-		{	4,		176,		178,		180,		182,		0		}, // 24
-		{	0,		0,			0,			0,			0,			0		}, // 25
-		// 2번 직군 기본 스킬 끝 END
-
-		// 1번 직군 마스터 스킬 SKILL GROUP 1 - MASTER
-		{	5,		1,			31,			61,			91,			170		}, // 26
-		{	5,		2,			32,			62,			92,			171		}, // 27
-		{	5,		3,			33,			63,			93,			172		}, // 28
-		{	5,		4,			34,			64,			94,			173		}, // 29
-		{	5,		5,			35,			65,			95,			174		}, // 30
-		{	5,		6,			36,			66,			96,			175		}, // 31
-		{	0,		0,			0,			0,			0,			0		}, // 32
-		{	0,		0,			0,			0,			0,			0		}, // 33
-		{	5,		176,		177,		179,		181,		183		}, // 34
-		{	0,		0,			0,			0,			0,			0		}, // 35
-		// 1번 직군 마스터 스킬 끝 END
-
-		// 여유분 MARGIN
-		{	0,		0,			0,			0,			0,			0		}, // 36
-		{	0,		0,			0,			0,			0,			0		}, // 37
-		{	0,		0,			0,			0,			0,			0		}, // 38
-		{	0,		0,			0,			0,			0,			0		}, // 39
-		{	0,		0,			0,			0,			0,			0		}, // 40
-		// 여유분 끝 END
-
-		// 2번 직군 마스터 스킬 SKILL GROUP 2 - MASTER
-		{	4,		16,			46,			76,			106,		0		}, // 41
-		{	4,		17,			47,			77,			107,		0		}, // 42
-		{	4,		18,			48,			78,			108,		0		}, // 43
-		{	4,		19,			49,			79,			109,		0		}, // 44
-		{	4,		20,			50,			80,			110,		0		}, // 45
-		{	4,		21,			51,			81,			111,		0		}, // 46
-		{	0,		0,			0,			0,			0,			0		}, // 47
-		{	0,		0,			0,			0,			0,			0		}, // 48
-		{	4,		176,		178,		180,		182,		0		}, // 49
-		{	0,		0,			0,			0,			0,			0		}, // 50
-		// 2번 직군 마스터 스킬 끝 END
-
-		// 1번 직군 그랜드 마스터 스킬 SKILL GROUP 1 - GRAND MASTER
-		{	5,		1,			31,			61,			91,			170		}, // 51
-		{	5,		2,			32,			62,			92,			171		}, // 52
-		{	5,		3,			33,			63,			93,			172		}, // 53
-		{	5,		4,			34,			64,			94,			173		}, // 54
-		{	5,		5,			35,			65,			95,			174		}, // 55
-		{	5,		6,			36,			66,			96,			175		}, // 56
-		{	0,		0,			0,			0,			0,			0		}, // 57
-		{	0,		0,			0,			0,			0,			0		}, // 58
-		{	5,		176,		177,		179,		181,		183		}, // 59
-		{	0,		0,			0,			0,			0,			0		}, // 60
-		// 1번 직군 그랜드 마스터 스킬 끝 END
-
-		// 여유분 MARGIN
-		{	0,		0,			0,			0,			0,			0		}, // 61
-		{	0,		0,			0,			0,			0,			0		}, // 62
-		{	0,		0,			0,			0,			0,			0		}, // 63
-		{	0,		0,			0,			0,			0,			0		}, // 64
-		{	0,		0,			0,			0,			0,			0		}, // 65
-		// 여유분 끝 END
-
-		// 2번 직군 그랜드 마스터 스킬 SKILL GROUP 2 - GRAND MASTER
-		{	4,		16,			46,			76,			106,		0		}, // 66
-		{	4,		17,			47,			77,			107,		0		}, // 67
-		{	4,		18,			48,			78,			108,		0		}, // 68
-		{	4,		19,			49,			79,			109,		0		}, // 69
-		{	4,		20,			50,			80,			110,		0		}, // 70
-		{	4,		21,			51,			81,			111,		0		}, // 71
-		{	0,		0,			0,			0,			0,			0		}, // 72
-		{	0,		0,			0,			0,			0,			0		}, // 73
-		{	4,		176,		178,		180,		182,		0		}, // 74
-		{	0,		0,			0,			0,			0,			0		}, // 75
-		// 2번 직군 그랜드 마스터 스킬 끝 END
-
-		// 1번 직군 퍼펙트 마스터 스킬 SKILL GROUP 1 - PERFECT MASTER
-		{	5,		1,			31,			61,			91,			170		}, // 76
-		{	5,		2,			32,			62,			92,			171		}, // 77
-		{	5,		3,			33,			63,			93,			172		}, // 78
-		{	5,		4,			34,			64,			94,			173		}, // 79
-		{	5,		5,			35,			65,			95,			174		}, // 80
-		{	5,		6,			36,			66,			96,			175		}, // 81
-		{	0,		0,			0,			0,			0,			0		}, // 82
-		{	0,		0,			0,			0,			0,			0		}, // 83
-		{	5,		176,		177,		179,		181,		183		}, // 84
-		{	0,		0,			0,			0,			0,			0		}, // 85
-		// 1번 직군 퍼펙트 마스터 스킬 끝 END
-
-		// 여유분 MARGIN
-		{	0,		0,			0,			0,			0,			0		}, // 86
-		{	0,		0,			0,			0,			0,			0		}, // 87
-		{	0,		0,			0,			0,			0,			0		}, // 88
-		{	0,		0,			0,			0,			0,			0		}, // 89
-		{	0,		0,			0,			0,			0,			0		}, // 90
-		// 여유분 끝 END
-
-		// 2번 직군 퍼펙트 마스터 스킬 SKILL GROUP 2 - PERFECT MASTER
-		{	4,		16,			46,			76,			106,		0		}, // 91
-		{	4,		17,			47,			77,			107,		0		}, // 92
-		{	4,		18,			48,			78,			108,		0		}, // 93
-		{	4,		19,			49,			79,			109,		0		}, // 94
-		{	4,		20,			50,			80,			110,		0		}, // 95
-		{	4,		21,			51,			81,			111,		0		}, // 96
-		{	0,		0,			0,			0,			0,			0		}, // 97
-		{	0,		0,			0,			0,			0,			0		}, // 98
-		{	4,		176,		178,		180,		182,		0		}, // 99
-		{	0,		0,			0,			0,			0,			0		}, // 100
-		// 2번 직군 퍼펙트 마스터 스킬 끝 END
-
-		// 길드 스킬 GUILD SKILLS
-		{	1,		152,		0,			0,			0,			0		}, // 101
-		{	1,		153,		0,			0,			0,			0		}, // 102
-		{	1,		154,		0,			0,			0,			0		}, // 103
-		{	1,		155,		0,			0,			0,			0		}, // 104
-		{	1,		156,		0,			0,			0,			0		}, // 105
-		{	1,		157,		0,			0,			0,			0		}, // 106
-		// 길드 스킬 끝 END
-
-		// 여유분 MARGIN
-		{	0,		0,			0,			0,			0,			0		}, // 107
-		{	0,		0,			0,			0,			0,			0		}, // 108
-		{	0,		0,			0,			0,			0,			0		}, // 109
-		{	0,		0,			0,			0,			0,			0		}, // 110
-		{	0,		0,			0,			0,			0,			0		}, // 111
-		{	0,		0,			0,			0,			0,			0		}, // 112
-		{	0,		0,			0,			0,			0,			0		}, // 113
-		{	0,		0,			0,			0,			0,			0		}, // 114
-		{	0,		0,			0,			0,			0,			0		}, // 115
-		{	0,		0,			0,			0,			0,			0		}, // 116
-		{	0,		0,			0,			0,			0,			0		}, // 117
-		{	0,		0,			0,			0,			0,			0		}, // 118
-		{	0,		0,			0,			0,			0,			0		}, // 119
-		{	0,		0,			0,			0,			0,			0		}, // 120
-		// 여유분 끝 END
-
-		// 승마 스킬 HORSE SKILLS
-		{	2,		137,		140,		0,			0,			0		}, // 121
-		{	1,		138,		0,			0,			0,			0		}, // 122
-		{	1,		139,		0,			0,			0,			0		}, // 123
-		// 승마 스킬 끝 END
-	};
-
-	if (dwMotionIndex >= MOTION_MAX_NUM)
-	{
-		sys_err("OUT_OF_MOTION_VNUM: name=%s, motion=%d/%d", GetName(), dwMotionIndex, MOTION_MAX_NUM);
-		return false;
-	}
-
-	DWORD* skillVNums = s_anMotion2SkillVnumList[dwMotionIndex];
-
-	DWORD skillCount = *skillVNums++;
-	if (skillCount >= SKILL_LIST_MAX_COUNT)
-	{
-		sys_err("OUT_OF_SKILL_LIST: name=%s, count=%d/%d", GetName(), skillCount, SKILL_LIST_MAX_COUNT);
-		return false;
-	}
-
-	for (DWORD skillIndex = 0; skillIndex != skillCount + 2; ++skillIndex)
-	{
-		if (skillIndex >= SKILL_MAX_NUM)
-		{
-			sys_err("OUT_OF_SKILL_VNUM: name=%s, skill=%d/%d", GetName(), skillIndex, SKILL_MAX_NUM);
-			return false;
-		}
-
-		DWORD eachSkillVNum = skillVNums[skillIndex];
-
-		if (eachSkillVNum != 0)
-		{
-			DWORD eachJobGroup = s_anSkill2JobGroup[eachSkillVNum];
-
-			if (0 == eachJobGroup || eachJobGroup == selfJobGroup)
-			{
-				// GUILDSKILL_BUG_FIX
-				DWORD eachSkillLevel = 0;
-
-				if (eachSkillVNum >= GUILD_SKILL_START && eachSkillVNum <= GUILD_SKILL_END)
-				{
-					if (GetGuild())
-						eachSkillLevel = GetGuild()->GetSkillLevel(eachSkillVNum);
-					else
-						eachSkillLevel = 0;
-				}
-#if defined(__9TH_SKILL__)
-				// CONQUEROR_SKILL_BUG_FIX
-				else if (eachSkillVNum >= SKILL_FINISH && eachSkillVNum <= SKILL_ILIPUNGU)
-				{
-					eachSkillLevel = GetSkillLevel(eachSkillVNum);
-				}
-				// END_OF_CONQUEROR_SKILL_BUG_FIX
-#endif
-				else
-				{
-					eachSkillLevel = GetSkillLevel(eachSkillVNum);
-
-					if (test_server)
-					{
-						if (eachSkillLevel <= 0)
-						{
-							sys_err("SKILL_LEVEL: name=%s, skill=%d, level=%d", GetName(), skillIndex, eachSkillLevel);
-							return false;
-						}
-					}
-				}
-
-				if (eachSkillLevel > 0)
-				{
-					return true;
-				}
-
-				// END_OF_GUILDSKILL_BUG_FIX
-			}
-		}
-	}
-
-	return false;
-}
-
-void CHARACTER::ClearSkill()
-{
-	PointChange(POINT_SKILL, 4 + (GetLevel() - 5) - GetPoint(POINT_SKILL));
-
-	ResetSkill();
-}
-
-#if defined(__SKILL_COOLTIME_UPDATE__)
-void CHARACTER::ResetSkillCoolTimes()
-{
-	if (!GetSkillGroup() || m_SkillUseInfo.empty())
-		return;
-
-	for (std::map<int, TSkillUseInfo>::iterator it = m_SkillUseInfo.begin(); it != m_SkillUseInfo.end(); ++it)
-		it->second.dwNextSkillUsableTime = 0;
-}
-#endif
-
-void CHARACTER::ClearSubSkill()
-{
-	PointChange(POINT_SUB_SKILL, GetLevel() < 10 ? 0 : (GetLevel() - 9) - GetPoint(POINT_SUB_SKILL));
-
-	if (m_pSkillLevels == NULL)
-	{
-		sys_err("m_pSkillLevels nil (name: %s)", GetName());
-		return;
-	}
-
-	TPlayerSkill CleanSkill;
-	memset(&CleanSkill, 0, sizeof(TPlayerSkill));
-
-	size_t count = sizeof(s_adwSubSkillVnums) / sizeof(s_adwSubSkillVnums[0]);
-
-	for (size_t i = 0; i < count; ++i)
-	{
-		if (s_adwSubSkillVnums[i] >= SKILL_MAX_NUM)
-			continue;
-
-		m_pSkillLevels[s_adwSubSkillVnums[i]] = CleanSkill;
-	}
-
-	ComputePoints();
-	SkillLevelPacket();
-}
-
-bool CHARACTER::ResetOneSkill(DWORD dwVnum)
-{
-	if (NULL == m_pSkillLevels)
-	{
-		sys_err("m_pSkillLevels nil (name %s, vnum %u)", GetName(), dwVnum);
-		return false;
-	}
-
-	if (dwVnum >= SKILL_MAX_NUM)
-	{
-		sys_err("vnum overflow (name %s, vnum %u)", GetName(), dwVnum);
-		return false;
-	}
-
-	BYTE level = m_pSkillLevels[dwVnum].bLevel;
-
-	m_pSkillLevels[dwVnum].bLevel = 0;
-	m_pSkillLevels[dwVnum].bMasterType = 0;
-	m_pSkillLevels[dwVnum].tNextRead = 0;
-
-	if (level > 17)
-		level = 17;
-
-	PointChange(POINT_SKILL, level);
-
-	LogManager::instance().CharLog(this, dwVnum, "ONE_SKILL_RESET_BY_SCROLL", "");
-
-	ComputePoints();
-	SkillLevelPacket();
-
-	return true;
-}
-
-bool CHARACTER::CanUseSkill(DWORD dwSkillVnum) const
-{
-	if (0 == dwSkillVnum) return false;
-
-	if (0 < GetSkillGroup())
-	{
-		const int SKILL_COUNT = 7;
-		static const DWORD SkillList[JOB_MAX_NUM][SKILL_GROUP_MAX_NUM][SKILL_COUNT] =
-		{
-			{ { 1, 2, 3, 4, 5, 6, 176 }, { 16, 17, 18, 19, 20, 21, 176 } },
-			{ { 31, 32, 33, 34, 35, 36, 177 }, { 46, 47, 48, 49, 50, 51, 178 } },
-			{ { 61, 62, 63, 64, 65, 66, 179 }, { 76, 77, 78, 79, 80, 81, 180 } },
-			{ { 91, 92, 93, 94, 95, 96, 181 }, { 106, 107, 108, 109, 110, 111, 182 } },
-			{ { 170, 171, 172, 173, 174, 175, 183 }, { 0, 0, 0, 0, 0, 0, 0 } },
-		};
-
-		const DWORD* pSkill = SkillList[GetJob()][GetSkillGroup() - 1];
-
-		for (int i = 0; i < SKILL_COUNT; ++i)
-		{
-			if (pSkill[i] == dwSkillVnum) return true;
-		}
-	}
-
-	//if (true == IsHorseRiding())
-
-	if (true == IsRiding())
-	{
-		//마운트 탈것중 고급말만 스킬 사용가능
-		/*
-		if (GetMountVnum())
-		{
-			if (!((GetMountVnum() >= 20209 && GetMountVnum() <= 20212) ||
-				GetMountVnum() == 20215 || GetMountVnum() == 20218 || GetMountVnum() == 20225))
-				return false;
-		}
-		*/
-
-		switch (dwSkillVnum)
-		{
-			case SKILL_HORSE_WILDATTACK:
-			case SKILL_HORSE_CHARGE:
-			case SKILL_HORSE_ESCAPE:
-			case SKILL_HORSE_WILDATTACK_RANGE:
-				return true;
-		}
-	}
-
-	switch (dwSkillVnum)
-	{
-		case SKILL_LEADERSHIP:
-		case SKILL_COMBO:
-		case SKILL_CREATE:
-		case SKILL_MINING:
-		case SKILL_LANGUAGE1:
-		case SKILL_LANGUAGE2:
-		case SKILL_LANGUAGE3:
-		case SKILL_POLYMORPH:
-		case SKILL_HORSE:
-		case SKILL_HORSE_SUMMON:
-#if defined(__PARTY_PROFICY__)
-		case SKILL_ROLE_PROFICIENCY:
-#endif
-#if defined(__PARTY_INSIGHT__)
-		case SKILL_INSIGHT:
-#endif
-		case SKILL_HIT:
-		case SKILL_HORSE_WILDATTACK:
-		case SKILL_HORSE_CHARGE:
-		case SKILL_HORSE_ESCAPE:
-		case SKILL_HORSE_WILDATTACK_RANGE:
-		case SKILL_ADD_HP:
-		case SKILL_RESIST_PENETRATE:
-		case GUILD_SKILL_EYE:
-		case GUILD_SKILL_BLOOD:
-		case GUILD_SKILL_BLESS:
-		case GUILD_SKILL_SEONGHWI:
-		case GUILD_SKILL_ACCEL:
-		case GUILD_SKILL_BUNNO:
-		case GUILD_SKILL_JUMUN:
-		case GUILD_SKILL_TELEPORT:
-		case GUILD_SKILL_DOOR:
-			return true;
-	}
-
-	return false;
-}
-
-bool CHARACTER::CheckSkillHitCount(const BYTE SkillID, const VID TargetVID)
-{
-	std::map<int, TSkillUseInfo>::iterator iter = m_SkillUseInfo.find(SkillID);
-
-	if (iter == m_SkillUseInfo.end())
-	{
-		sys_log(0, "SkillHack: Skill(%u) is not in container", SkillID);
-		return false;
-	}
-
-	TSkillUseInfo& rSkillUseInfo = iter->second;
-
-	if (false == rSkillUseInfo.bUsed)
-	{
-		sys_log(0, "SkillHack: not used skill(%u)", SkillID);
-		return false;
-	}
-
-	switch (SkillID)
-	{
-		case SKILL_YONGKWON:
-		case SKILL_HWAYEOMPOK:
-		case SKILL_DAEJINGAK:
-		case SKILL_PAERYONG:
-#if defined(__9TH_SKILL__)
-		case SKILL_METEO:
-#endif
-			sys_log(0, "SkillHack: cannot use attack packet for skill(%u)", SkillID);
-			return false;
-	}
-
-	auto iterTargetMap = rSkillUseInfo.TargetVIDMap.find(TargetVID);
-
-	if (rSkillUseInfo.TargetVIDMap.end() != iterTargetMap)
-	{
-		size_t MaxAttackCountPerTarget = 1;
-
-		switch (SkillID)
-		{
-			case SKILL_SAMYEON:
-			case SKILL_CHARYUN:
-			case SKILL_CHAYEOL:
-				MaxAttackCountPerTarget = 3;
-				break;
-
-			case SKILL_HORSE_WILDATTACK_RANGE:
-				MaxAttackCountPerTarget = 5;
-				break;
-
-			case SKILL_YEONSA:
-				MaxAttackCountPerTarget = 7;
-				break;
-
-			case SKILL_HORSE_ESCAPE:
-				MaxAttackCountPerTarget = 10;
-				break;
-		}
-
-		if (iterTargetMap->second >= MaxAttackCountPerTarget)
-		{
-			sys_log(0, "SkillHack: Too Many Hit count from SkillID(%u) count(%u)", SkillID, iterTargetMap->second);
-			return false;
-		}
-
-		iterTargetMap->second++;
-	}
-	else
-	{
-		rSkillUseInfo.TargetVIDMap.insert(std::make_pair(TargetVID, 1));
-	}
-
-	return true;
-}
+#include "stdafx.h"
+#include <sstream>
+
+#include "utils.h"
+#include "config.h"
+#include "vector.h"
+#include "char.h"
+#include "char_manager.h"
+#include "battle.h"
+#include "desc.h"
+#include "desc_manager.h"
+#include "packet.h"
+#include "affect.h"
+#include "item.h"
+#include "sectree_manager.h"
+#include "mob_manager.h"
+#include "start_position.h"
+#include "party.h"
+#include "buffer_manager.h"
+#include "guild.h"
+#include "log.h"
+#include "unique_item.h"
+#include "questmanager.h"
+#if defined(__DAWNMIST_DUNGEON__)
+#	include "dawnmist_dungeon.h"
+#endif
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+extern int test_server;
+
+static const DWORD s_adwSubSkillVnums[] =
+{
+	SKILL_LEADERSHIP,
+	SKILL_COMBO,
+	SKILL_MINING,
+	SKILL_LANGUAGE1,
+	SKILL_LANGUAGE2,
+	SKILL_LANGUAGE3,
+	SKILL_POLYMORPH,
+	SKILL_HORSE,
+	SKILL_HORSE_SUMMON,
+	SKILL_HORSE_WILDATTACK,
+	SKILL_HORSE_CHARGE,
+	SKILL_HORSE_ESCAPE,
+	SKILL_HORSE_WILDATTACK_RANGE,
+	SKILL_ADD_HP,
+	SKILL_RESIST_PENETRATE,
+#if defined(__PARTY_PROFICY__)
+	SKILL_ROLE_PROFICIENCY,
+#endif
+#if defined(__PARTY_INSIGHT__)
+	SKILL_INSIGHT,
+#endif
+	SKILL_HIT,
+};
+
+struct FPartyPIDCollector
+{
+	std::vector<DWORD> vecPIDs;
+	FPartyPIDCollector() = default;
+	void operator () (LPCHARACTER ch)
+	{
+		vecPIDs.push_back(ch->GetPlayerID());
+	}
+};
+
+struct FPartyMOBCollector
+{
+	std::vector<DWORD> vecPIDs;
+	FPartyMOBCollector() = default;
+	void operator () (LPCHARACTER ch)
+	{
+		vecPIDs.push_back(ch->GetVID());
+	}
+};
+
+time_t CHARACTER::GetSkillNextReadTime(DWORD dwVnum) const
+{
+	if (dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("vnum overflow (vnum: %u)", dwVnum);
+		return 0;
+	}
+
+	return m_pSkillLevels ? m_pSkillLevels[dwVnum].tNextRead : 0;
+}
+
+void CHARACTER::SetSkillNextReadTime(DWORD dwVnum, time_t time)
+{
+	if (m_pSkillLevels && dwVnum < SKILL_MAX_NUM)
+		m_pSkillLevels[dwVnum].tNextRead = time;
+}
+
+bool TSkillUseInfo::HitOnce(DWORD dwVnum)
+{
+	// 刻  磯.
+	if (!bUsed)
+		return false;
+
+	sys_log(1, "__HitOnce NextUse %u current %u count %d scount %d", dwNextSkillUsableTime, get_dword_time(), iHitCount, iSplashCount);
+
+	if (dwNextSkillUsableTime && dwNextSkillUsableTime < get_dword_time()
+		&& dwVnum != SKILL_MUYEONG
+		&& dwVnum != SKILL_HORSE_WILDATTACK 
+#if defined(__PVP_BALANCE_IMPROVING__)
+		&& dwVnum != SKILL_GYEONGGONG
+#endif
+		)
+	{
+		sys_log(1, "__HitOnce can't hit");
+
+		return false;
+	}
+
+	if (iHitCount == -1)
+	{
+		sys_log(1, "__HitOnce OK %d %d %d", dwNextSkillUsableTime, get_dword_time(), iHitCount);
+		return true;
+	}
+
+	if (iHitCount)
+	{
+		sys_log(1, "__HitOnce OK %d %d %d", dwNextSkillUsableTime, get_dword_time(), iHitCount);
+		iHitCount--;
+		return true;
+	}
+	return false;
+}
+
+bool TSkillUseInfo::UseSkill(bool isGrandMaster, DWORD vid, DWORD dwCooltime, int splashcount, int hitcount, int range)
+{
+	this->isGrandMaster = isGrandMaster;
+	DWORD dwCur = get_dword_time();
+
+	//  타  刻年.
+	if (bUsed && dwNextSkillUsableTime > dwCur)
+	{
+		sys_log(0, "cooltime is not over delta %u", dwNextSkillUsableTime - dwCur);
+		iHitCount = 0;
+		return false;
+	}
+
+	bUsed = true;
+
+	if (dwCooltime)
+		dwNextSkillUsableTime = dwCur + dwCooltime;
+	else
+		dwNextSkillUsableTime = 0;
+
+	iRange = range;
+	iMaxHitCount = iHitCount = hitcount;
+
+	if (test_server)
+		sys_log(0, "UseSkill NextUse %u current %u cooltime %d hitcount %d/%d", dwNextSkillUsableTime, dwCur, dwCooltime, iHitCount, iMaxHitCount);
+
+	dwVID = vid;
+	iSplashCount = splashcount;
+	return true;
+}
+
+int CHARACTER::GetChainLightningMaxCount() const
+{
+	return aiChainLightningCountBySkillLevel[MIN(SKILL_MAX_LEVEL, GetSkillLevel(SKILL_CHAIN))];
+}
+
+void CHARACTER::SetAffectedEunhyung()
+{
+	m_dwAffectedEunhyungLevel = GetSkillPower(SKILL_EUNHYUNG);
+}
+
+void CHARACTER::SetSkillGroup(BYTE bSkillGroup)
+{
+	if (bSkillGroup > 2)
+		return;
+
+	if (GetLevel() < 5)
+		return;
+
+	m_points.bSkillGroup = bSkillGroup;
+
+	TPacketGCChangeSkillGroup p;
+	p.header = HEADER_GC_SKILL_GROUP;
+	p.skill_group = m_points.bSkillGroup;
+
+	GetDesc()->Packet(&p, sizeof(TPacketGCChangeSkillGroup));
+}
+
+int CHARACTER::ComputeCooltime(int time)
+{
+	return CalculateDuration(GetPoint(POINT_CASTING_SPEED), time);
+}
+
+void CHARACTER::SkillLevelPacket()
+{
+	if (!GetDesc())
+		return;
+
+	TPacketGCSkillLevel pack;
+
+	pack.bHeader = HEADER_GC_SKILL_LEVEL;
+	thecore_memcpy(&pack.skills, m_pSkillLevels, sizeof(TPlayerSkill) * SKILL_MAX_NUM);
+	GetDesc()->Packet(&pack, sizeof(TPacketGCSkillLevel));
+}
+
+void CHARACTER::SetSkillLevel(DWORD dwVnum, BYTE bLev)
+{
+	if (NULL == m_pSkillLevels)
+		return;
+
+	if (dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("vnum overflow (vnum %u)", dwVnum);
+		return;
+	}
+
+	m_pSkillLevels[dwVnum].bLevel = MIN(SKILL_MAX_LEVEL, bLev);
+
+	if (bLev >= 40)
+		m_pSkillLevels[dwVnum].bMasterType = SKILL_PERFECT_MASTER;
+	else if (bLev >= 30)
+		m_pSkillLevels[dwVnum].bMasterType = SKILL_GRAND_MASTER;
+	else if (bLev >= 20)
+		m_pSkillLevels[dwVnum].bMasterType = SKILL_MASTER;
+	else
+		m_pSkillLevels[dwVnum].bMasterType = SKILL_NORMAL;
+}
+
+bool CHARACTER::IsLearnableSkill(DWORD dwSkillVnum) const
+{
+	const CSkillProto* pkSkill = CSkillManager::instance().Get(dwSkillVnum);
+
+	if (!pkSkill)
+		return false;
+
+	if (GetSkillLevel(dwSkillVnum) >= SKILL_MAX_LEVEL)
+		return false;
+
+	if (pkSkill->dwType == SKILL_BOOK_TYPE_SUPPORT)
+	{
+		if (GetSkillLevel(dwSkillVnum) >= pkSkill->bMaxLevel)
+			return false;
+
+		return true;
+	}
+
+	if (pkSkill->dwType == SKILL_BOOK_TYPE_HORSE)
+	{
+		if (dwSkillVnum == SKILL_HORSE_WILDATTACK_RANGE && GetJob() != JOB_ASSASSIN)
+			return false;
+
+		return true;
+	}
+
+	if (GetSkillGroup() == 0)
+		return false;
+
+	if (pkSkill->dwType - 1 == GetJob())
+		return true;
+
+	if (SKILL_BOOK_TYPE_WOLFMAN == pkSkill->dwType && JOB_WOLFMAN == GetJob())
+		return true;
+
+	if (SKILL_BOOK_TYPE_PASSIVE == pkSkill->dwType)
+	{
+		if (SKILL_7_A_ANTI_TANHWAN <= dwSkillVnum && dwSkillVnum <= SKILL_7_D_ANTI_YONGBI)
+		{
+			for (int i = 0; i < 4; i++)
+			{
+				if (unsigned(SKILL_7_A_ANTI_TANHWAN + i) != dwSkillVnum)
+				{
+					if (0 != GetSkillLevel(SKILL_7_A_ANTI_TANHWAN + i))
+					{
+						return false;
+					}
+				}
+			}
+
+			return true;
+		}
+
+		if (SKILL_8_A_ANTI_GIGONGCHAM <= dwSkillVnum && dwSkillVnum <= SKILL_8_D_ANTI_BYEURAK)
+		{
+			for (int i = 0; i < 4; i++)
+			{
+				if (unsigned(SKILL_8_A_ANTI_GIGONGCHAM + i) != dwSkillVnum)
+				{
+					if (0 != GetSkillLevel(SKILL_8_A_ANTI_GIGONGCHAM + i))
+						return false;
+				}
+			}
+
+			return true;
+		}
+
+#if defined(__7AND8TH_SKILLS__)
+		if (dwSkillVnum >= SKILL_ANTI_PALBANG && dwSkillVnum <= SKILL_HELP_SALPOONG)
+		{
+			if (GetSkillLevel(dwSkillVnum) != 0)
+				return true;
+		}
+#endif
+	}
+
+	return false;
+}
+
+// ADD_GRANDMASTER_SKILL
+bool CHARACTER::LearnGrandMasterSkill(DWORD dwSkillVnum)
+{
+	const CSkillProto* pkSk = CSkillManager::instance().Get(dwSkillVnum);
+
+	if (!pkSk)
+		return false;
+
+	if (!IsLearnableSkill(dwSkillVnum))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("   킬都求."));
+		return false;
+	}
+
+	sys_log(0, "learn grand master skill[%d] cur %d, next %d", dwSkillVnum, get_global_time(), GetSkillNextReadTime(dwSkillVnum));
+
+	/*
+	if (get_global_time() < GetSkillNextReadTime(dwSkillVnum))
+	{
+		if (!(test_server && quest::CQuestManager::instance().GetEventFlag("no_read_delay")))
+		{
+			if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
+			{
+				// 羚횝 傷 챨  
+				RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("羚횝  화毒 督求."));
+			}
+			else
+			{
+				SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
+				return false;
+			}
+		}
+	}
+	*/
+
+	// bType  0見 처 책  
+	if (pkSk->dwType == SKILL_BOOK_TYPE_SUPPORT)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("瀏      킬都求."));
+		return false;
+	}
+
+	if (GetSkillMasterType(dwSkillVnum) != SKILL_GRAND_MASTER)
+	{
+		if (GetSkillMasterType(dwSkillVnum) > SKILL_GRAND_MASTER)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("트 孤 킬都求.  鵑    求."));
+		else
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 킬  瀏     見 刻努求."));
+		return false;
+	}
+
+	std::string strTrainSkill;
+	{
+		std::ostringstream os;
+		os << "training_grandmaster_skill.skill" << dwSkillVnum;
+		strTrainSkill = os.str();
+	}
+
+	// 茱 확 爛求.
+	BYTE bLastLevel = GetSkillLevel(dwSkillVnum);
+
+	int idx = MIN(9, GetSkillLevel(dwSkillVnum) - 30);
+
+	sys_log(0, "LearnGrandMasterSkill %s table idx %d value %d", GetName(), idx, aiGrandMasterSkillBookCountForLevelUp[idx]);
+
+	int iTotalReadCount = GetQuestFlag(strTrainSkill) + 1;
+	SetQuestFlag(strTrainSkill, iTotalReadCount);
+
+	int iMinReadCount = aiGrandMasterSkillBookMinCount[idx];
+	int iMaxReadCount = aiGrandMasterSkillBookMaxCount[idx];
+
+	int iBookCount = aiGrandMasterSkillBookCountForLevelUp[idx];
+
+	if (LC_IsYMIR() == true || LC_IsKorea() == true)
+	{
+		const int aiGrandMasterSkillBookCountForLevelUp_euckr[10] =
+		{
+			3, 3, 4, 5, 6, 7, 8, 9, 10, 15,
+		};
+
+		const int aiGrandMasterSkillBookMinCount_euckr[10] =
+		{
+			1, 1, 1, 2, 2, 2, 3, 3, 4, 5
+		};
+
+		const int aiGrandMasterSkillBookMaxCount_euckr[10] =
+		{
+			5, 7, 9, 11, 13, 15, 18, 23, 25, 30
+		};
+
+		iMinReadCount = aiGrandMasterSkillBookMinCount_euckr[idx];
+		iMaxReadCount = aiGrandMasterSkillBookMaxCount_euckr[idx];
+		iBookCount = aiGrandMasterSkillBookCountForLevelUp_euckr[idx];
+	}
+
+	if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
+	{
+		if (iBookCount & 1)
+			iBookCount = iBookCount / 2 + 1;
+		else
+			iBookCount = iBookCount / 2;
+
+		RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
+	}
+
+	int n = number(1, iBookCount);
+	sys_log(0, "Number(%d)", n);
+
+	DWORD nextTime = get_global_time() + number(28800, 43200);
+
+	sys_log(0, "GrandMaster SkillBookCount min %d cur %d max %d (next_time=%d)", iMinReadCount, iTotalReadCount, iMaxReadCount, nextTime);
+
+	bool bSuccess = n == 2;
+
+	if (iTotalReadCount < iMinReadCount)
+		bSuccess = false;
+	if (iTotalReadCount > iMaxReadCount)
+		bSuccess = true;
+
+	if (bSuccess)
+	{
+		SkillLevelUp(dwSkillVnum, SKILL_UP_BY_QUEST);
+	}
+
+	SetSkillNextReadTime(dwSkillVnum, nextTime);
+
+	if (bLastLevel == GetSkillLevel(dwSkillVnum))
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("크, 璲 構 羚! 隔  화毒寬!? !"));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鈞 求. 母 笭챰 帽求."));
+		LogManager::instance().CharLog(this, dwSkillVnum, "GM_READ_FAIL", "");
+		return false;
+	}
+
+	ChatPacket(CHAT_TYPE_TALKING, LC_STRING("     潔!"));
+	ChatPacket(CHAT_TYPE_TALKING, LC_STRING("煞탓   치 羚! 隔, 隔!"));
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("     決求."));
+	LogManager::instance().CharLog(this, dwSkillVnum, "GM_READ_SUCCESS", "");
+	return true;
+}
+// END_OF_ADD_GRANDMASTER_SKILL
+
+static bool FN_should_check_exp(LPCHARACTER ch)
+{
+	if (LC_IsCanada())
+		return ch->GetLevel() < gPlayerMaxLevel;
+
+	if (!LC_IsYMIR())
+		return true;
+
+	return false;
+}
+
+bool CHARACTER::LearnSkillByBook(DWORD dwSkillVnum, BYTE bProb)
+{
+	const CSkillProto* pkSk = CSkillManager::instance().Get(dwSkillVnum);
+	if (pkSk == nullptr)
+		return false;
+
+	if (!IsLearnableSkill(dwSkillVnum))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("   킬都求."));
+		return false;
+	}
+
+#if defined(__CONQUEROR_LEVEL__)
+	const bool bConquerorSkill = IsConquerorSkill(dwSkillVnum);
+	if (bConquerorSkill && GetConquerorLevel() <= 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can learn this after reaching the Champion Level."));
+		return false;
+	}
+#endif
+
+	POINT_VALUE need_exp = 0;
+
+	if (FN_should_check_exp(this))
+	{
+		need_exp = 20000;
+
+#if defined(__CONQUEROR_LEVEL__)
+		if (bConquerorSkill && GetConquerorExp() < need_exp)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("치 臼 책   求."));
+			return false;
+		}
+		else
+		{
+			if (GetExp() < need_exp)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("치 臼 책   求."));
+				return false;
+			}
+		}
+#else
+		if (GetExp() < need_exp)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("치 臼 책   求."));
+			return false;
+		}
+#endif
+	}
+
+	if (pkSk->dwType != SKILL_BOOK_TYPE_SUPPORT)
+	{
+		if (GetSkillMasterType(dwSkillVnum) != SKILL_MASTER)
+		{
+			if (GetSkillMasterType(dwSkillVnum) > SKILL_MASTER)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 킬 책 鵑   求."));
+				return false;
+			}
+			else
+			{
+				if (pkSk->dwType != SKILL_BOOK_TYPE_PASSIVE
+#if defined(__CONQUEROR_LEVEL__)
+					&& !bConquerorSkill
+#endif
+					)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 킬  책   見 刻努求."));
+					return false;
+				}
+			}
+		}
+	}
+
+	if (get_global_time() < GetSkillNextReadTime(dwSkillVnum))
+	{
+		if (!(test_server && quest::CQuestManager::instance().GetEventFlag("no_read_delay")))
+		{
+			if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
+			{
+				// 羚횝 傷 챨  
+				RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("羚횝  화毒 督求."));
+			}
+			else
+			{
+				SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
+				return false;
+			}
+		}
+	}
+
+	// 茱 확 爛求.
+	BYTE bLastLevel = GetSkillLevel(dwSkillVnum);
+
+	if (bProb != 0)
+	{
+		// SKILL_BOOK_BONUS
+		if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
+		{
+			bProb += bProb / 2;
+			RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
+		}
+		// END_OF_SKILL_BOOK_BONUS
+
+		sys_log(0, "LearnSkillByBook Pct %u prob %d", dwSkillVnum, bProb);
+
+		if (number(1, 100) <= bProb)
+		{
+			if (test_server)
+				sys_log(0, "LearnSkillByBook %u SUCC", dwSkillVnum);
+
+			SkillLevelUp(dwSkillVnum, SKILL_UP_BY_BOOK);
+		}
+		else
+		{
+			if (test_server)
+				sys_log(0, "LearnSkillByBook %u FAIL", dwSkillVnum);
+		}
+	}
+	else
+	{
+		int idx = MIN(9, GetSkillLevel(dwSkillVnum) - 20);
+
+		sys_log(0, "LearnSkillByBook %s table idx %d value %d", GetName(), idx, aiSkillBookCountForLevelUp[idx]);
+
+		if (!LC_IsYMIR())
+		{
+			int need_bookcount = GetSkillLevel(dwSkillVnum) - 20;
+
+#if defined(__CONQUEROR_LEVEL__)
+			PointChange(bConquerorSkill ? POINT_CONQUEROR_EXP : POINT_EXP, -need_exp);
+#else
+			PointChange(POINT_EXP, -need_exp);
+#endif
+
+			quest::CQuestManager& q = quest::CQuestManager::instance();
+			quest::PC* pPC = q.GetPC(GetPlayerID());
+
+			if (pPC)
+			{
+				char flag[128 + 1];
+				memset(flag, 0, sizeof(flag));
+				snprintf(flag, sizeof(flag), "traning_master_skill.%u.read_count", dwSkillVnum);
+
+				int read_count = pPC->GetFlag(flag);
+				int percent = 65;
+
+				if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
+				{
+					percent = 0;
+					RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
+				}
+
+				if (number(1, 100) > percent)
+				{
+					// 책閨藪 
+					if (read_count >= need_bookcount)
+					{
+						SkillLevelUp(dwSkillVnum, SKILL_UP_BY_BOOK);
+						pPC->SetFlag(flag, 0);
+
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("책      決求."));
+						LogManager::instance().CharLog(this, dwSkillVnum, "READ_SUCCESS", "");
+						return true;
+					}
+					else
+					{
+						pPC->SetFlag(flag, read_count + 1);
+
+						switch (number(1, 3))
+						{
+							case 1:
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("    莫 퓸  祁 祁.."));
+								break;
+
+							case 2:
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("  甄 품...    歐璲 賈 .."));
+								break;
+
+							case 3:
+							default:
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING(" 求   拷   獵  甄.."));
+								break;
+						}
+
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d   棘  狗   笭求.", need_bookcount - read_count));
+						return true;
+					}
+				}
+			}
+			else
+			{
+				//  트  琯 
+			}
+		}
+		// INTERNATIONAL_VERSION
+		else
+		{
+			int iBookCount = 99;
+
+			if (LC_IsYMIR() == true)
+			{
+				const int aiSkillBookCountForLevelUp_euckr[10] =
+				{
+					2, 2, 3, 3, 3, 3, 3, 3, 4, 5
+				};
+
+				iBookCount = aiSkillBookCountForLevelUp_euckr[idx];
+			}
+			else
+				iBookCount = aiSkillBookCountForLevelUp[idx];
+
+			if (FindAffect(AFFECT_SKILL_BOOK_BONUS))
+			{
+				if (iBookCount & 1) // iBookCount % 2
+					iBookCount = iBookCount / 2 + 1;
+				else
+					iBookCount = iBookCount / 2;
+
+				RemoveAffect(AFFECT_SKILL_BOOK_BONUS);
+			}
+
+			if (number(1, iBookCount) == 2)
+				SkillLevelUp(dwSkillVnum, SKILL_UP_BY_BOOK);
+		}
+		// END_OF_INTERNATIONAL_VERSION
+	}
+
+	if (bLastLevel != GetSkillLevel(dwSkillVnum))
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("     潔!"));
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("煞탓   치 羚! 隔, 隔!"));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("책      決求."));
+		LogManager::instance().CharLog(this, dwSkillVnum, "READ_SUCCESS", "");
+	}
+	else
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("크, 璲 構 羚! 隔  화毒寬!? !"));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鈞 求. 母 笭챰 帽求."));
+		LogManager::instance().CharLog(this, dwSkillVnum, "READ_FAIL", "");
+	}
+
+	return true;
+}
+
+bool CHARACTER::SkillLevelDown(DWORD dwVnum)
+{
+	if (NULL == m_pSkillLevels)
+		return false;
+
+	if (g_bSkillDisable)
+		return false;
+
+	if (IsPolymorphed())
+		return false;
+
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+
+	if (!pkSk)
+	{
+		sys_err("There is no such skill by number %u", dwVnum);
+		return false;
+	}
+
+	if (!IsLearnableSkill(dwVnum))
+		return false;
+
+	if (GetSkillMasterType(pkSk->dwVnum) != SKILL_NORMAL)
+		return false;
+
+	if (!GetSkillGroup())
+		return false;
+
+	if (pkSk->dwVnum >= SKILL_MAX_NUM)
+		return false;
+
+	if (m_pSkillLevels[pkSk->dwVnum].bLevel == 0)
+		return false;
+
+	int idx = POINT_SKILL;
+	switch (pkSk->dwType)
+	{
+		case 0:
+			idx = POINT_SUB_SKILL;
+			break;
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 6:
+		case 7:
+			idx = POINT_SKILL;
+			break;
+		case 5:
+			idx = POINT_HORSE_SKILL;
+			break;
+		default:
+			sys_err("Wrong skill type %d skill vnum %d", pkSk->dwType, pkSk->dwVnum);
+			return false;
+	}
+
+	PointChange(idx, +1);
+	SetSkillLevel(pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bLevel - 1);
+
+	sys_log(0, "SkillDown: %s %u %u %u type %u", GetName(), pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bMasterType, m_pSkillLevels[pkSk->dwVnum].bLevel, pkSk->dwType);
+	Save();
+
+	ComputePoints();
+	SkillLevelPacket();
+	return true;
+}
+
+void CHARACTER::SkillLevelUp(DWORD dwVnum, BYTE bMethod)
+{
+	if (NULL == m_pSkillLevels)
+		return;
+
+	if (g_bSkillDisable)
+		return;
+
+	if (IsPolymorphed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵 傷  첩  求."));
+		return;
+	}
+
+	if (SKILL_7_A_ANTI_TANHWAN <= dwVnum && dwVnum <= SKILL_8_D_ANTI_BYEURAK)
+	{
+		if (0 == GetSkillLevel(dwVnum))
+			return;
+	}
+
+	const CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+
+	if (!pkSk)
+	{
+		sys_err("There is no such skill by number (vnum %u)", dwVnum);
+		return;
+	}
+
+	if (pkSk->dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("Skill Vnum overflow (vnum %u)", dwVnum);
+		return;
+	}
+
+	if (!IsLearnableSkill(dwVnum))
+		return;
+
+	// 瀏 姑 트罐 析
+	if (pkSk->dwType != SKILL_BOOK_TYPE_SUPPORT && pkSk->dwType != SKILL_BOOK_TYPE_PASSIVE)
+	{
+		switch (GetSkillMasterType(pkSk->dwVnum))
+		{
+			case SKILL_GRAND_MASTER:
+				if (bMethod != SKILL_UP_BY_QUEST)
+					return;
+				break;
+
+			case SKILL_PERFECT_MASTER:
+				return;
+		}
+	}
+
+	if (bMethod == SKILL_UP_BY_POINT)
+	{
+		// 叩 틈 쩔 챨
+		if (GetSkillMasterType(pkSk->dwVnum) != SKILL_NORMAL)
+			return;
+
+		if (IS_SET(pkSk->dwFlag, SKILL_FLAG_DISABLE_BY_POINT_UP))
+			return;
+	}
+	else if (bMethod == SKILL_UP_BY_BOOK)
+	{
+		//   刻柰킬 트 첩  킬 처 책   獵.
+		if (pkSk->dwType != SKILL_BOOK_TYPE_SUPPORT && pkSk->dwType != SKILL_BOOK_TYPE_PASSIVE)
+			if (GetSkillMasterType(pkSk->dwVnum) != SKILL_MASTER
+#if defined(__CONQUEROR_LEVEL__)
+				&& !IsConquerorSkill(pkSk->dwVnum)
+#endif
+				)
+				return;
+	}
+
+	if (GetLevel() < pkSk->bLevelLimit)
+		return;
+
+	if (pkSk->preSkillVnum)
+	{
+		if (GetSkillMasterType(pkSk->preSkillVnum) == SKILL_NORMAL &&
+			GetSkillLevel(pkSk->preSkillVnum) < pkSk->preSkillLevel)
+			return;
+	}
+
+	if (bMethod == SKILL_UP_BY_POINT)
+	{
+		int idx;
+
+		switch (pkSk->dwType)
+		{
+			case 0:
+				idx = POINT_SUB_SKILL;
+				break;
+
+			case 1:
+			case 2:
+			case 3:
+			case 4:
+			case 6:
+			case 7:
+				idx = POINT_SKILL;
+				break;
+
+			case 5:
+				idx = POINT_HORSE_SKILL;
+				break;
+
+			default:
+				sys_err("Wrong skill type %d skill vnum %d", pkSk->dwType, pkSk->dwVnum);
+				return;
+		}
+
+		if (GetPoint(idx) < 1)
+			return;
+
+		PointChange(idx, -1);
+	}
+
+	int SkillPointBefore = GetSkillLevel(pkSk->dwVnum);
+	SetSkillLevel(pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bLevel + 1);
+
+	if (pkSk->dwType != 0)
+	{
+		// 未 瀏絹 求 湄
+		switch (GetSkillMasterType(pkSk->dwVnum))
+		{
+			case SKILL_NORMAL:
+				//  킬 瀏絹 17~20    
+				if (GetSkillLevel(pkSk->dwVnum) >= 17)
+				{
+					if (GetQuestFlag("reset_scroll.force_to_master_skill") > 0)
+					{
+						SetSkillLevel(pkSk->dwVnum, 20);
+						SetQuestFlag("reset_scroll.force_to_master_skill", 0);
+					}
+					else
+					{
+						if (number(1, 21 - MIN(20, GetSkillLevel(pkSk->dwVnum))) == 1)
+							SetSkillLevel(pkSk->dwVnum, 20);
+					}
+				}
+				break;
+
+			case SKILL_MASTER:
+				if (GetSkillLevel(pkSk->dwVnum) >= 30)
+				{
+					if (number(1, 31 - MIN(30, GetSkillLevel(pkSk->dwVnum))) == 1)
+						SetSkillLevel(pkSk->dwVnum, 30);
+				}
+				break;
+
+			case SKILL_GRAND_MASTER:
+				if (GetSkillLevel(pkSk->dwVnum) >= 40)
+				{
+					SetSkillLevel(pkSk->dwVnum, 40);
+				}
+				break;
+		}
+	}
+
+	char szSkillUp[1024];
+
+	snprintf(szSkillUp, sizeof(szSkillUp), "SkillUp: %s %u %d %d[Before:%d] type %u",
+		GetName(), pkSk->dwVnum, m_pSkillLevels[pkSk->dwVnum].bMasterType, m_pSkillLevels[pkSk->dwVnum].bLevel, SkillPointBefore, pkSk->dwType);
+
+	sys_log(0, "%s", szSkillUp);
+
+	LogManager::instance().CharLog(this, pkSk->dwVnum, "SKILLUP", szSkillUp);
+	Save();
+
+	ComputePoints();
+	SkillLevelPacket();
+}
+
+void CHARACTER::ComputeSkillPoints()
+{
+	if (g_bSkillDisable)
+		return;
+
+	PointChange(POINT_HIT_PCT, aiPrecisionPowerByLevel[MINMAX(0, GetSkillLevel(SKILL_HIT), SKILL_MAX_LEVEL)]);
+}
+
+void CHARACTER::ResetSkill()
+{
+	if (NULL == m_pSkillLevels)
+		return;
+
+	//  킬 쩍키 苛쨈
+	std::vector<std::pair<DWORD, TPlayerSkill>> vec;
+	size_t count = sizeof(s_adwSubSkillVnums) / sizeof(s_adwSubSkillVnums[0]);
+
+	for (size_t i = 0; i < count; ++i)
+	{
+		if (s_adwSubSkillVnums[i] >= SKILL_MAX_NUM)
+			continue;
+
+		vec.push_back(std::make_pair(s_adwSubSkillVnums[i], m_pSkillLevels[s_adwSubSkillVnums[i]]));
+	}
+
+	memset(m_pSkillLevels, 0, sizeof(TPlayerSkill) * SKILL_MAX_NUM);
+
+	std::vector<std::pair<DWORD, TPlayerSkill>>::const_iterator iter = vec.begin();
+
+	while (iter != vec.end())
+	{
+		const std::pair<DWORD, TPlayerSkill>& pair = *(iter++);
+		m_pSkillLevels[pair.first] = pair.second;
+	}
+
+	ComputePoints();
+	SkillLevelPacket();
+}
+
+void CHARACTER::ComputePassiveSkill(DWORD dwVnum)
+{
+	if (g_bSkillDisable)
+		return;
+
+	if (GetSkillLevel(dwVnum) == 0)
+		return;
+
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+	pkSk->SetPointVar("k", GetSkillLevel(dwVnum));
+	int iAmount = (int)pkSk->kPointPoly.Eval();
+
+	sys_log(2, "%s passive #%d on %d amount %d", GetName(), dwVnum, pkSk->wPointOn, iAmount);
+	PointChange(pkSk->wPointOn, iAmount);
+}
+
+struct FFindNearVictim
+{
+	FFindNearVictim(LPCHARACTER center, LPCHARACTER attacker, const CHARACTER_SET& excepts_set = empty_set_)
+		: m_pkChrCenter(center),
+		m_pkChrNextTarget(NULL),
+		m_pkChrAttacker(attacker),
+		m_count(0),
+		m_excepts_set(excepts_set)
+	{
+	}
+
+	void operator ()(LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_CHARACTER))
+			return;
+
+		LPCHARACTER pkChr = (LPCHARACTER)ent;
+
+		if (!m_excepts_set.empty())
+		{
+			if (m_excepts_set.find(pkChr) != m_excepts_set.end())
+				return;
+		}
+
+		if (m_pkChrCenter == pkChr)
+			return;
+
+		if (!battle_is_attackable(m_pkChrAttacker, pkChr))
+		{
+			return;
+		}
+
+		if (abs(m_pkChrCenter->GetX() - pkChr->GetX()) > 1000 || abs(m_pkChrCenter->GetY() - pkChr->GetY()) > 1000)
+			return;
+
+		float fDist = DISTANCE_APPROX(m_pkChrCenter->GetX() - pkChr->GetX(), m_pkChrCenter->GetY() - pkChr->GetY());
+
+		if (fDist < 1000)
+		{
+			++m_count;
+
+			if ((m_count == 1) || number(1, m_count) == 1)
+				m_pkChrNextTarget = pkChr;
+		}
+	}
+
+	LPCHARACTER GetVictim()
+	{
+		return m_pkChrNextTarget;
+	}
+
+	LPCHARACTER m_pkChrCenter;
+	LPCHARACTER m_pkChrNextTarget;
+	LPCHARACTER m_pkChrAttacker;
+	int m_count;
+	const CHARACTER_SET& m_excepts_set;
+
+private:
+	static CHARACTER_SET empty_set_;
+};
+
+CHARACTER_SET FFindNearVictim::empty_set_;
+
+EVENTINFO(chain_lightning_event_info)
+{
+	DWORD dwVictim;
+	DWORD dwChr;
+
+	chain_lightning_event_info()
+		: dwVictim(0)
+		, dwChr(0)
+	{
+	}
+};
+
+EVENTFUNC(ChainLightningEvent)
+{
+	chain_lightning_event_info* info = dynamic_cast<chain_lightning_event_info*>(event->info);
+
+	LPCHARACTER pkChrVictim = CHARACTER_MANAGER::instance().Find(info->dwVictim);
+	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().Find(info->dwChr);
+	LPCHARACTER pkTarget = NULL;
+
+	if (!pkChr || !pkChrVictim)
+	{
+		sys_log(1, "use chainlighting, but no character");
+		return 0;
+	}
+
+	sys_log(1, "chainlighting event %s", pkChr->GetName());
+
+	if (pkChrVictim->GetParty()) // 티 
+	{
+		pkTarget = pkChrVictim->GetParty()->GetNextOwnership(NULL, pkChrVictim->GetX(), pkChrVictim->GetY());
+		if (pkTarget == pkChrVictim || !number(0, 2) || pkChr->GetChainLightingExcept().find(pkTarget) != pkChr->GetChainLightingExcept().end())
+			pkTarget = NULL;
+	}
+
+	if (!pkTarget)
+	{
+		// 1. Find Next victim
+		FFindNearVictim f(pkChrVictim, pkChr, pkChr->GetChainLightingExcept());
+
+		if (pkChrVictim->GetSectree())
+		{
+			pkChrVictim->GetSectree()->ForEachAround(f);
+			// 2. If exist, compute it again
+			pkTarget = f.GetVictim();
+		}
+	}
+
+	if (pkTarget)
+	{
+		pkChrVictim->CreateFly(FLY_CHAIN_LIGHTNING, pkTarget);
+		pkChr->ComputeSkill(SKILL_CHAIN, pkTarget);
+		pkChr->AddChainLightningExcept(pkTarget);
+	}
+	else
+	{
+		sys_log(1, "%s use chainlighting, but find victim failed near %s", pkChr->GetName(), pkChrVictim->GetName());
+	}
+
+	return 0;
+}
+
+void SetPolyVarForAttack(LPCHARACTER ch, CSkillProto* pkSk, LPITEM pkWeapon)
+{
+	if (ch->IsPC())
+	{
+		if (pkWeapon && pkWeapon->GetType() == ITEM_WEAPON)
+		{
+			int iWep = number(pkWeapon->GetValue(3), pkWeapon->GetValue(4));
+			iWep += pkWeapon->GetValue(5);
+
+			int iMtk = number(pkWeapon->GetValue(1), pkWeapon->GetValue(2));
+			iMtk += pkWeapon->GetValue(5);
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+			iWep += ch->GetAcceWeaponAttack();
+			iMtk += ch->GetAcceWeaponMagicAttack();
+#endif
+
+			pkSk->SetPointVar("wep", iWep);
+			pkSk->SetPointVar("mtk", iMtk);
+			pkSk->SetPointVar("mwep", iMtk);
+		}
+		else
+		{
+			pkSk->SetPointVar("wep", 0);
+			pkSk->SetPointVar("mtk", 0);
+			pkSk->SetPointVar("mwep", 0);
+		}
+	}
+	else
+	{
+		int iWep = number(ch->GetMobDamageMin(), ch->GetMobDamageMax());
+		pkSk->SetPointVar("wep", iWep);
+		pkSk->SetPointVar("mwep", iWep);
+		pkSk->SetPointVar("mtk", iWep);
+	}
+}
+
+struct FuncSplashDamage
+{
+	FuncSplashDamage(int x, int y, CSkillProto* pkSk, LPCHARACTER pkChr, int iAmount, int iAG, int iMaxHit, LPITEM pkWeapon, bool bDisableCooltime, TSkillUseInfo* pInfo, BYTE bUseSkillPower)
+		:
+		m_x(x), m_y(y), m_pkSk(pkSk), m_pkChr(pkChr), m_iAmount(iAmount), m_iAG(iAG), m_iCount(0), m_iMaxHit(iMaxHit), m_pkWeapon(pkWeapon), m_bDisableCooltime(bDisableCooltime), m_pInfo(pInfo), m_bUseSkillPower(bUseSkillPower)
+	{
+	}
+
+	void operator () (LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_CHARACTER))
+		{
+			//if (m_pkSk->dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN target not character %s", m_pkChr->GetName());
+			return;
+		}
+
+		LPCHARACTER pkChrVictim = dynamic_cast<LPCHARACTER>(ent);
+
+		if (DISTANCE_APPROX(m_x - pkChrVictim->GetX(), m_y - pkChrVictim->GetY()) > m_pkSk->iSplashRange)
+		{
+			if (test_server)
+				sys_log(0, "XXX target too far %s", m_pkChr->GetName());
+			return;
+		}
+
+		if (!battle_is_attackable(m_pkChr, pkChrVictim))
+		{
+			if (test_server)
+				sys_log(0, "XXX target not attackable %s", m_pkChr->GetName());
+			return;
+		}
+
+		if (m_pkChr->IsPC())
+			//  킬 타 처  苛쨈.
+			if (!(m_pkSk->dwVnum >= GUILD_SKILL_START && m_pkSk->dwVnum <= GUILD_SKILL_END))
+				if (!m_bDisableCooltime && m_pInfo && !m_pInfo->HitOnce(m_pkSk->dwVnum) && m_pkSk->dwVnum != SKILL_MUYEONG
+#if defined(__PVP_BALANCE_IMPROVING__)
+					&& m_pkSk->dwVnum != SKILL_GYEONGGONG
+#endif
+					)
+				{
+					if (test_server)
+						sys_log(0, "check guild skill %s", m_pkChr->GetName());
+					return;
+				}
+
+		++m_iCount;
+
+		int iDam;
+
+		////////////////////////////////////////////////////////////////////////////////
+		//float k = 1.0f * m_pkChr->GetSkillPower(m_pkSk->dwVnum) * m_pkSk->bMaxLevel / 100;
+		//m_pkSk->kPointPoly2.SetVar("k", 1.0 * m_bUseSkillPower * m_pkSk->bMaxLevel / 100);
+		m_pkSk->SetPointVar("k", 1.0 * m_bUseSkillPower * m_pkSk->bMaxLevel / 100);
+		m_pkSk->SetPointVar("lv", m_pkChr->GetLevel());
+		m_pkSk->SetPointVar("iq", m_pkChr->GetPoint(POINT_IQ));
+		m_pkSk->SetPointVar("str", m_pkChr->GetPoint(POINT_ST));
+		m_pkSk->SetPointVar("dex", m_pkChr->GetPoint(POINT_DX));
+		m_pkSk->SetPointVar("con", m_pkChr->GetPoint(POINT_HT));
+		m_pkSk->SetPointVar("def", m_pkChr->GetPoint(POINT_DEF_GRADE));
+		m_pkSk->SetPointVar("odef", m_pkChr->GetPoint(POINT_DEF_GRADE) - m_pkChr->GetPoint(POINT_DEF_GRADE_BONUS));
+		m_pkSk->SetPointVar("horse_level", m_pkChr->GetHorseLevel());
+
+		//int iPenetratePct = (int)(1 + k * 4);
+		bool bIgnoreDefense = false;
+
+		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_PENETRATE))
+		{
+			int iPenetratePct = (int)m_pkSk->kPointPoly2.Eval();
+
+			if (number(1, 100) <= iPenetratePct)
+				bIgnoreDefense = true;
+		}
+
+		bool bIgnoreTargetRating = false;
+
+		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_IGNORE_TARGET_RATING))
+		{
+			int iPct = (int)m_pkSk->kPointPoly2.Eval();
+
+			if (number(1, 100) <= iPct)
+				bIgnoreTargetRating = true;
+		}
+
+		m_pkSk->SetPointVar("ar", CalcAttackRating(m_pkChr, pkChrVictim, bIgnoreTargetRating));
+
+		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_USE_MELEE_DAMAGE))
+			m_pkSk->SetPointVar("atk", CalcMeleeDamage(m_pkChr, pkChrVictim, true, bIgnoreTargetRating));
+		else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_USE_ARROW_DAMAGE))
+		{
+			LPITEM pkBow, pkArrow;
+
+			if (1 == m_pkChr->GetArrowAndBow(&pkBow, &pkArrow, 1))
+				m_pkSk->SetPointVar("atk", CalcArrowDamage(m_pkChr, pkChrVictim, pkBow, pkArrow, true));
+			else
+				m_pkSk->SetPointVar("atk", 0);
+		}
+
+		if (m_pkSk->wPointOn == POINT_MOV_SPEED)
+			m_pkSk->kPointPoly.SetVar("maxv", pkChrVictim->GetLimitPoint(POINT_MOV_SPEED));
+
+		m_pkSk->SetPointVar("maxhp", pkChrVictim->GetMaxHP());
+		m_pkSk->SetPointVar("maxsp", pkChrVictim->GetMaxSP());
+
+		m_pkSk->SetPointVar("chain", m_pkChr->GetChainLightningIndex());
+		m_pkChr->IncChainLightningIndex();
+
+		bool bUnderEunhyung = m_pkChr->GetAffectedEunhyung() > 0 ? true : false; // 隔  茱 ??
+
+		m_pkSk->SetPointVar("ek", m_pkChr->GetAffectedEunhyung() * 1. / 100);
+		//m_pkChr->ClearAffectedEunhyung();
+		SetPolyVarForAttack(m_pkChr, m_pkSk, m_pkWeapon);
+
+		int iAmount = 0;
+
+		if (m_pkChr->GetUsedSkillMasterType(m_pkSk->dwVnum) >= SKILL_GRAND_MASTER)
+		{
+			iAmount = (int)m_pkSk->kMasterBonusPoly.Eval();
+		}
+		else
+		{
+			iAmount = (int)m_pkSk->kPointPoly.Eval();
+		}
+
+		if (test_server && iAmount == 0 && m_pkSk->wPointOn != POINT_NONE)
+		{
+			m_pkChr->ChatPacket(CHAT_TYPE_INFO, "효 求. 킬  확究");
+		}
+		////////////////////////////////////////////////////////////////////////////////
+		iAmount = -iAmount;
+
+		if (m_pkSk->dwVnum == SKILL_AMSEOP)
+		{
+			float fDelta = GetDegreeDelta(m_pkChr->GetRotation(), pkChrVictim->GetRotation());
+			float adjust;
+
+			if (fDelta < 35.0f)
+			{
+				adjust = 1.5f;
+
+				if (bUnderEunhyung)
+					adjust += 0.5f;
+
+				if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER)
+				{
+					//if (!g_iUseLocale)
+					if (LC_IsYMIR())
+						adjust += 1.0f;
+					else
+						adjust += 0.5f;
+				}
+			}
+			else
+			{
+				adjust = 1.0f;
+
+				if (!LC_IsYMIR())
+				{
+					if (bUnderEunhyung)
+						adjust += 0.5f;
+
+					if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER)
+						adjust += 0.5f;
+				}
+			}
+
+			iAmount = (int)(iAmount * adjust);
+		}
+		else if (m_pkSk->dwVnum == SKILL_GUNGSIN)
+		{
+			float adjust = 1.0;
+
+			if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER)
+			{
+				//if (!g_iUseLocale)
+				if (LC_IsYMIR())
+					adjust = 1.4f;
+				else
+					adjust = 1.35f;
+			}
+
+			iAmount = (int)(iAmount * adjust);
+		}
+		else if (m_pkSk->dwVnum == SKILL_CHAYEOL)
+		{
+			if (number(1, 100) <= 20)
+			{
+				float adjust = 1.0f;
+				if (test_server)
+					m_pkChr->ChatPacket(CHAT_TYPE_PARTY, "CRITICAL SKILL VNUM %d ATTACK : NORMAL DMG %d, MULTIPLIED DMG %d, ADJUSTMENT (%.2f%%) FINAL %d",
+						m_pkSk->dwVnum,
+						iAmount,
+						(iAmount * 2),
+						adjust,
+						(int)((iAmount * 2) * adjust)
+					);
+
+				m_pkChr->EffectPacket(SE_CRITICAL);
+				iAmount *= 2;
+				iAmount = (int)(iAmount * adjust);
+			}
+		}
+		else if (m_pkSk->dwVnum == SKILL_GONGDAB)
+		{
+			float adjust = 1.0;
+
+			if (m_pkChr->GetWear(WEAR_WEAPON) && m_pkChr->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_CLAW)
+			{
+				adjust = 1.35f;
+			}
+
+			iAmount = (int)(iAmount * adjust);
+
+			if (number(1, 100) <= 20)
+			{
+				adjust = 1.0f;
+				if (test_server)
+					m_pkChr->ChatPacket(CHAT_TYPE_PARTY, "CRITICAL SKILL VNUM %d ATTACK : NORMAL DMG %d, MULTIPLIED DMG %d, ADJUSTMENT (%.2f%%) FINAL %d",
+						m_pkSk->dwVnum,
+						iAmount,
+						(iAmount * 2),
+						adjust,
+						(int)((iAmount * 2) * adjust)
+					);
+
+				m_pkChr->EffectPacket(SE_CRITICAL);
+				iAmount *= 2;
+				iAmount = (int)(iAmount * adjust);
+			}
+		}
+#if defined(__PVP_BALANCE_IMPROVING__)
+		else if (m_pkSk->dwVnum == SKILL_GYEONGGONG)
+			iAmount = m_iAmount;
+#endif
+
+		////////////////////////////////////////////////////////////////////////////////
+		//sys_log(0, "name: %s skill: %s amount %d to %s", m_pkChr->GetName(), m_pkSk->szName, iAmount, pkChrVictim->GetName());
+
+		iDam = CalcBattleDamage(iAmount, m_pkChr->GetLevel(), pkChrVictim->GetLevel());
+
+		if (m_pkChr->IsPC() && m_pkChr->m_SkillUseInfo[m_pkSk->dwVnum].GetMainTargetVID() != (DWORD)pkChrVictim->GetVID())
+		{
+			//  
+			iDam = (int)(iDam * m_pkSk->kSplashAroundDamageAdjustPoly.Eval());
+		}
+
+		// TODO 킬   타 瞞磯.
+		EDamageType dt = DAMAGE_TYPE_NONE;
+
+		switch (m_pkSk->bSkillAttrType)
+		{
+			case SKILL_ATTR_TYPE_NORMAL:
+				break;
+
+			case SKILL_ATTR_TYPE_MELEE:
+			{
+				dt = DAMAGE_TYPE_MELEE;
+
+				LPITEM pkWeapon = m_pkChr->GetWear(WEAR_WEAPON);
+
+				if (pkWeapon)
+					switch (pkWeapon->GetSubType())
+					{
+						case WEAPON_SWORD:
+							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_SWORD)) / 100;
+							break;
+
+						case WEAPON_TWO_HANDED:
+							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_TWOHAND)) / 100;
+							// 卵 티 10%
+							//iDam = iDam * 95 / 100;
+							break;
+
+						case WEAPON_DAGGER:
+							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_DAGGER)) / 100;
+							break;
+
+						case WEAPON_BELL:
+							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_BELL)) / 100;
+							break;
+
+						case WEAPON_FAN:
+							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_FAN)) / 100;
+							break;
+
+						case WEAPON_CLAW:
+							iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_CLAW)) / 100;
+							break;
+
+					}
+
+				if (!bIgnoreDefense)
+					iDam -= pkChrVictim->GetPoint(POINT_DEF_GRADE);
+			}
+			break;
+
+			case SKILL_ATTR_TYPE_RANGE:
+				dt = DAMAGE_TYPE_RANGE;
+				// 틴틴틴
+				//  杉 陋 羚底   母玖  
+				//iDam -= pkChrVictim->GetPoint(POINT_DEF_GRADE);
+				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_BOW)) / 100;
+				break;
+
+			case SKILL_ATTR_TYPE_MAGIC:
+				dt = DAMAGE_TYPE_MAGIC;
+				iDam = CalcAttBonus(m_pkChr, pkChrVictim, iDam);
+				// 틴틴틴
+				//  杉 陋 羚底   母玖  
+				//iDam -= pkChrVictim->GetPoint(POINT_MAGIC_DEF_GRADE);
+{
+					// [Fix] Safe magic resistance/penetration: clamp resist to [0..100] and apply penetration correctly
+					const int c_iResMagic = MINMAX(0, pkChrVictim->GetPoint(POINT_RESIST_MAGIC), 100);
+					const int c_iResMagicReduction = MINMAX(0, (m_pkChr->GetJob() == JOB_SURA) ? m_pkChr->GetPoint(POINT_RESIST_MAGIC_REDUCTION) / 2 : m_pkChr->GetPoint(POINT_RESIST_MAGIC_REDUCTION), 50);
+					const int c_iTotalMagicRes = MINMAX(0, c_iResMagic - c_iResMagicReduction, 100);
+					iDam = iDam * (100 - c_iTotalMagicRes) / 100;
+				}
+				break;
+
+			default:
+				sys_err("Unknown skill attr type %u vnum %u", m_pkSk->bSkillAttrType, m_pkSk->dwVnum);
+				break;
+		}
+
+		//
+		// 20091109  킬 憺 청 訪
+		//  킬 遣 SKILL_FLAG_WIND, SKILL_FLAG_ELEC, SKILL_FLAG_FIRE  킬
+		//  퓐  RESIST_WIND, RESIST_ELEC, RESIST_FIRE  歌 羚.
+		//
+		// PvP PvE酉 龜  풩 NPC 溝   酉 
+		//  歐  mob_proto RESIST_MAGIC RESIST_WIND, RESIST_ELEC, RESIST_FIRE
+		// 臼.
+		//
+		if (pkChrVictim->IsNPC())
+		{
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_WIND))
+			{
+				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_WIND)) / 100;
+			}
+
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_ELEC))
+			{
+				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_ELEC)) / 100;
+			}
+
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_FIRE))
+			{
+				iDam = iDam * (100 - pkChrVictim->GetPoint(POINT_RESIST_FIRE)) / 100;
+			}
+		}
+
+		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_COMPUTE_MAGIC_DAMAGE))
+			dt = DAMAGE_TYPE_MAGIC;
+
+		if (pkChrVictim->CanBeginFight())
+			pkChrVictim->BeginFight(m_pkChr);
+
+		if (m_pkSk->dwVnum == SKILL_CHAIN)
+			sys_log(0, "%s CHAIN INDEX %d DAM %d DT %d", m_pkChr->GetName(), m_pkChr->GetChainLightningIndex() - 1, iDam, dt);
+
+#if defined(__7AND8TH_SKILLS__)
+		{
+			BYTE HELP_SKILL_ID = 0;
+			switch (m_pkSk->dwVnum)
+			{
+				case SKILL_PALBANG:
+					HELP_SKILL_ID = SKILL_HELP_PALBANG;
+					break;
+				case SKILL_AMSEOP:
+					HELP_SKILL_ID = SKILL_HELP_AMSEOP;
+					break;
+				case SKILL_SWAERYUNG:
+					HELP_SKILL_ID = SKILL_HELP_SWAERYUNG;
+					break;
+				case SKILL_YONGBI:
+					HELP_SKILL_ID = SKILL_HELP_YONGBI;
+					break;
+				case SKILL_GIGONGCHAM:
+					HELP_SKILL_ID = SKILL_HELP_GIGONGCHAM;
+					break;
+				case SKILL_HWAJO:
+					HELP_SKILL_ID = SKILL_HELP_HWAJO;
+					break;
+				case SKILL_MARYUNG:
+					HELP_SKILL_ID = SKILL_HELP_MARYUNG;
+					break;
+				case SKILL_BYEURAK:
+					HELP_SKILL_ID = SKILL_HELP_BYEURAK;
+					break;
+				case SKILL_SALPOONG:
+					HELP_SKILL_ID = SKILL_HELP_SALPOONG;
+					break;
+				default:
+					break;
+			}
+
+			if (HELP_SKILL_ID != 0)
+			{
+				BYTE HELP_SKILL_LV = m_pkChr->GetSkillLevel(HELP_SKILL_ID);
+				if (HELP_SKILL_LV != 0)
+				{
+					CSkillProto* pkSk = CSkillManager::instance().Get(HELP_SKILL_ID);
+					if (!pkSk)
+						sys_err("Can't find %d skill in skill_proto.", HELP_SKILL_ID);
+					else
+					{
+						pkSk->SetPointVar("k", 1.0f * m_pkChr->GetSkillPower(HELP_SKILL_ID) * pkSk->bMaxLevel / 100);
+
+						double IncreaseAmount = pkSk->kPointPoly.Eval();
+						sys_log(0, "HELP_SKILL: increase amount: %lf, normal damage: %d, increased damage: %d.", IncreaseAmount, iDam, int(iDam * (IncreaseAmount / 100.0)));
+						iDam += iDam * (IncreaseAmount / 100.0);
+					}
+				}
+			}
+		}
+
+		{
+			BYTE ANTI_SKILL_ID = 0;
+			switch (m_pkSk->dwVnum)
+			{
+				case SKILL_PALBANG:
+					ANTI_SKILL_ID = SKILL_ANTI_PALBANG;
+					break;
+				case SKILL_AMSEOP:
+					ANTI_SKILL_ID = SKILL_ANTI_AMSEOP;
+					break;
+				case SKILL_SWAERYUNG:
+					ANTI_SKILL_ID = SKILL_ANTI_SWAERYUNG;
+					break;
+				case SKILL_YONGBI:
+					ANTI_SKILL_ID = SKILL_ANTI_YONGBI;
+					break;
+				case SKILL_GIGONGCHAM:
+					ANTI_SKILL_ID = SKILL_ANTI_GIGONGCHAM;
+					break;
+				case SKILL_HWAJO:
+					ANTI_SKILL_ID = SKILL_ANTI_HWAJO;
+					break;
+				case SKILL_MARYUNG:
+					ANTI_SKILL_ID = SKILL_ANTI_MARYUNG;
+					break;
+				case SKILL_BYEURAK:
+					ANTI_SKILL_ID = SKILL_ANTI_BYEURAK;
+					break;
+				case SKILL_SALPOONG:
+					ANTI_SKILL_ID = SKILL_ANTI_SALPOONG;
+					break;
+				default:
+					break;
+			}
+
+			if (ANTI_SKILL_ID != 0)
+			{
+				BYTE ANTI_SKILL_LV = pkChrVictim->GetSkillLevel(ANTI_SKILL_ID);
+				if (ANTI_SKILL_LV != 0)
+				{
+					CSkillProto* pkSk = CSkillManager::instance().Get(ANTI_SKILL_ID);
+					if (!pkSk)
+						sys_err("Can't find %d skill in skill_proto.", ANTI_SKILL_ID);
+					else
+					{
+						pkSk->SetPointVar("k", 1.0f * pkChrVictim->GetSkillPower(ANTI_SKILL_ID) * pkSk->bMaxLevel / 100);
+
+						double ResistAmount = pkSk->kPointPoly.Eval();
+						sys_log(0, "ANTI_SKILL: resist amount: %lf, normal damage: %d, reduced damage: %d.", ResistAmount, iDam, int(iDam * (ResistAmount / 100.0)));
+						iDam -= iDam * (ResistAmount / 100.0);
+					}
+				}
+			}
+		}
+#endif
+
+		{
+			BYTE AntiSkillID = 0;
+
+			switch (m_pkSk->dwVnum)
+			{
+				case SKILL_TANHWAN: AntiSkillID = SKILL_7_A_ANTI_TANHWAN; break;
+				case SKILL_AMSEOP: AntiSkillID = SKILL_7_B_ANTI_AMSEOP; break;
+				case SKILL_SWAERYUNG: AntiSkillID = SKILL_7_C_ANTI_SWAERYUNG; break;
+				case SKILL_YONGBI: AntiSkillID = SKILL_7_D_ANTI_YONGBI; break;
+				case SKILL_GIGONGCHAM: AntiSkillID = SKILL_8_A_ANTI_GIGONGCHAM; break;
+				case SKILL_YEONSA: AntiSkillID = SKILL_8_B_ANTI_YEONSA; break;
+				case SKILL_MAHWAN: AntiSkillID = SKILL_8_C_ANTI_MAHWAN; break;
+				case SKILL_BYEURAK: AntiSkillID = SKILL_8_D_ANTI_BYEURAK; break;
+			}
+
+			if (0 != AntiSkillID)
+			{
+				BYTE AntiSkillLevel = pkChrVictim->GetSkillLevel(AntiSkillID);
+
+				if (0 != AntiSkillLevel)
+				{
+					CSkillProto* pkSk = CSkillManager::instance().Get(AntiSkillID);
+					if (!pkSk)
+					{
+						sys_err("There is no anti skill(%d) in skill proto", AntiSkillID);
+					}
+					else
+					{
+						pkSk->SetPointVar("k", 1.0f * pkChrVictim->GetSkillPower(AntiSkillID) * pkSk->bMaxLevel / 100);
+
+						double ResistAmount = pkSk->kPointPoly.Eval();
+
+						sys_log(0, "ANTI_SKILL: Resist(%lf) Orig(%d) Reduce(%d)", ResistAmount, iDam, int(iDam * (ResistAmount / 100.0)));
+
+						iDam -= iDam * (ResistAmount / 100.0);
+					}
+				}
+			}
+		}
+
+		if (!pkChrVictim->Damage(m_pkChr, iDam, dt) && !pkChrVictim->IsStun())
+		{
+#if defined(__PVP_BALANCE_IMPROVING__)
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_KNOCKBACK))
+			{
+				float fKnockbackLength = 300; // Knockback distance.
+
+				if (pkChrVictim->IsStone())
+					fKnockbackLength = 0;
+
+#if defined(__DEFENSE_WAVE__)
+				if (CDefenseWaveManager::Instance().IsHydraSpawn(pkChrVictim->GetRaceNum()))
+					fKnockbackLength = 0;
+
+				if (CDefenseWaveManager::Instance().IsHydra(pkChrVictim->GetRaceNum()))
+					fKnockbackLength = 0;
+#endif
+
+				float fx, fy;
+				float degree = GetDegreeFromPositionXY(m_pkChr->GetX(), m_pkChr->GetY(), pkChrVictim->GetX(), pkChrVictim->GetY());
+
+				if (m_pkSk->dwVnum == SKILL_HORSE_WILDATTACK)
+				{
+					degree -= m_pkChr->GetRotation();
+					degree = fmod(degree, 360.0f) - 180.0f;
+
+					if (degree > 0)
+						degree = m_pkChr->GetRotation() + 90.0f;
+					else
+						degree = m_pkChr->GetRotation() - 90.0f;
+				}
+
+				if (fKnockbackLength > 0)
+				{
+					GetDeltaByDegree(degree, fKnockbackLength, &fx, &fy);
+					sys_log(0, "KNOCKBACK! %s -> %s (%d %d) -> (%d %d)",
+						m_pkChr->GetName(),
+						pkChrVictim->GetName(),
+						pkChrVictim->GetX(),
+						pkChrVictim->GetY(),
+						(long)(pkChrVictim->GetX() + fx),
+						(long)(pkChrVictim->GetY() + fy)
+					);
+
+					long tx = (long)(pkChrVictim->GetX() + fx);
+					long ty = (long)(pkChrVictim->GetY() + fy);
+
+					pkChrVictim->Sync(tx, ty);
+					pkChrVictim->Goto(tx, ty);
+					pkChrVictim->CalculateMoveDuration();
+
+					pkChrVictim->SyncPacket();
+				}
+			}
+#endif
+
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_REMOVE_GOOD_AFFECT))
+			{
+				int iAmount2 = (int)m_pkSk->kPointPoly2.Eval();
+				int iDur2 = (int)m_pkSk->kDurationPoly2.Eval();
+				iDur2 += m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+				int chance = iAmount2;
+
+				if (m_pkChr && m_pkChr->GetLevel() < pkChrVictim->GetLevel())
+				{
+					int delta = pkChrVictim->GetLevel() - m_pkChr->GetLevel();
+					if (delta >= 15)
+						chance = 0;
+				}
+
+				if (number(1, 100) <= chance)
+				{
+					pkChrVictim->RemoveGoodAffect();
+					pkChrVictim->AddAffect(m_pkSk->dwVnum, POINT_NONE, 0, AFF_PABEOP, iDur2, 0, true);
+				}
+			}
+
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_SLOW | SKILL_FLAG_STUN | SKILL_FLAG_FIRE_CONT | SKILL_FLAG_POISON | SKILL_FLAG_BLEEDING))
+			{
+				int iPct = (int)m_pkSk->kPointPoly2.Eval();
+				int iDur = (int)m_pkSk->kDurationPoly2.Eval();
+
+#if defined(__PVP_BALANCE_IMPROVING__)
+				const int iMaxStunDuration = 20;
+				if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_STUN))
+					iDur += MINMAX(static_cast<int>(m_pkSk->kDurationPoly2.Eval()), m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS), iMaxStunDuration);
+				else
+					iDur += m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
+#else
+				iDur += m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
+#endif
+
+				if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_STUN))
+				{
+					SkillAttackAffect(pkChrVictim, iPct, IMMUNE_STUN, AFFECT_STUN, POINT_NONE, 0, AFF_STUN, iDur, m_pkSk->szName);
+				}
+				else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_SLOW))
+				{
+					SkillAttackAffect(pkChrVictim, iPct, IMMUNE_SLOW, AFFECT_SLOW, POINT_MOV_SPEED, -30, AFF_SLOW, iDur, m_pkSk->szName);
+				}
+				else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_FIRE_CONT))
+				{
+					m_pkSk->SetDurationVar("k", 1.0 * m_bUseSkillPower * m_pkSk->bMaxLevel / 100);
+					m_pkSk->SetDurationVar("iq", m_pkChr->GetPoint(POINT_IQ));
+
+					iDur = (int)m_pkSk->kDurationPoly2.Eval();
+					int bonus = m_pkChr->GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+					if (bonus != 0)
+					{
+						iDur += bonus / 2;
+					}
+
+					if (number(1, 100) <= iDur)
+					{
+						pkChrVictim->AttackedByFire(m_pkChr, iPct, 5);
+					}
+				}
+				else if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_POISON))
+				{
+#if defined(__CONQUEROR_LEVEL__)
+					if (m_pkChr->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
+						iPct /= 2;
+#endif
+
+					if (number(1, 100) <= iPct)
+						pkChrVictim->AttackedByPoison(m_pkChr);
+				}
+			}
+
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_BLEEDING))
+			{
+				// NOTE : Wolfman `SKILL_CHAYEOL` (170) `SKILL_FLAG_BLEEDING` uses the
+				// `kDurationPoly2` column as the percentage value for bleeding chance.
+				int iPct = (int)m_pkSk->kDurationPoly2.Eval();
+#if defined(__CONQUEROR_LEVEL__)
+				if (m_pkChr->IsSungMaCursed(POINT_SUNGMA_IMMUNE))
+					iPct /= 2;
+#endif
+
+				if (number(1, 100) <= iPct)
+					pkChrVictim->AttackedByBleeding(m_pkChr);
+			}
+
+			if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_CRUSH | SKILL_FLAG_CRUSH_LONG) && !pkChrVictim->IsNoMove())
+			{
+				float fCrushSlidingLength = 200;
+
+				if (m_pkChr->IsNPC())
+					fCrushSlidingLength = 400;
+
+				if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_CRUSH_LONG))
+					fCrushSlidingLength *= 2;
+
+				if (g_bDisableBossKnockback)
+					if (m_pkChr->GetMobRank() > MOB_RANK_S_KNIGHT)
+						fCrushSlidingLength = 0;
+
+				float fx, fy;
+				float degree = GetDegreeFromPositionXY(m_pkChr->GetX(), m_pkChr->GetY(), pkChrVictim->GetX(), pkChrVictim->GetY());
+
+				if (m_pkSk->dwVnum == SKILL_HORSE_WILDATTACK)
+				{
+					degree -= m_pkChr->GetRotation();
+					degree = fmod(degree, 360.0f) - 180.0f;
+
+					if (degree > 0)
+						degree = m_pkChr->GetRotation() + 90.0f;
+					else
+						degree = m_pkChr->GetRotation() - 90.0f;
+				}
+
+				GetDeltaByDegree(degree, fCrushSlidingLength, &fx, &fy);
+				sys_log(0, "CRUSH! %s -> %s (%d %d) -> (%d %d)", m_pkChr->GetName(), pkChrVictim->GetName(),
+					pkChrVictim->GetX(), pkChrVictim->GetY(),
+					static_cast<long>(pkChrVictim->GetX() + fx), static_cast<long>(pkChrVictim->GetY() + fy));
+
+				long tx = static_cast<long>((pkChrVictim->GetX() + fx));
+				long ty = static_cast<long>((pkChrVictim->GetY() + fy));
+
+				// CRUSH_SKILL_WALL_KNOCKBACK_FIX
+				while (pkChrVictim->IsInBlockedArea(tx, ty) && fCrushSlidingLength > 0)
+				{
+					if (fCrushSlidingLength >= 10)
+						fCrushSlidingLength -= 10;
+					else
+						fCrushSlidingLength = 0;
+
+					GetDeltaByDegree(degree, fCrushSlidingLength, &fx, &fy);
+					tx = static_cast<long>((pkChrVictim->GetX() + fx));
+					ty = static_cast<long>((pkChrVictim->GetY() + fy));
+				}
+				// END_OF_CRUSH_SKILL_WALL_KNOCKBACK_FIX
+
+				pkChrVictim->Sync(tx, ty);
+				pkChrVictim->Goto(tx, ty);
+				pkChrVictim->CalculateMoveDuration();
+
+				if (m_pkChr->IsPC() && m_pkChr->m_SkillUseInfo[m_pkSk->dwVnum].GetMainTargetVID() == static_cast<DWORD>(pkChrVictim->GetVID()))
+				{
+					//if (!g_iUseLocale)
+					if (LC_IsYMIR())
+						SkillAttackAffect(pkChrVictim, 1000, IMMUNE_STUN, m_pkSk->dwVnum, POINT_NONE, 0, AFF_STUN, 3, m_pkSk->szName);
+					else
+						SkillAttackAffect(pkChrVictim, 1000, IMMUNE_STUN, m_pkSk->dwVnum, POINT_NONE, 0, AFF_STUN, 4, m_pkSk->szName);
+				}
+				else
+				{
+					pkChrVictim->SyncPacket();
+				}
+			}
+		}
+
+		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_HP_ABSORB))
+		{
+			int iPct = static_cast<int>(m_pkSk->kPointPoly2.Eval());
+			m_pkChr->PointChange(POINT_HP, iDam * iPct / 100);
+		}
+
+		if (IS_SET(m_pkSk->dwFlag, SKILL_FLAG_SP_ABSORB))
+		{
+			int iPct = static_cast<int>(m_pkSk->kPointPoly2.Eval());
+			m_pkChr->PointChange(POINT_SP, iDam * iPct / 100);
+		}
+
+		if (m_pkSk->dwVnum == SKILL_CHAIN && m_pkChr->GetChainLightningIndex() < m_pkChr->GetChainLightningMaxCount())
+		{
+			chain_lightning_event_info* info = AllocEventInfo<chain_lightning_event_info>();
+
+			info->dwVictim = static_cast<DWORD>(pkChrVictim->GetVID());
+			info->dwChr = static_cast<DWORD>(m_pkChr->GetVID());
+
+			event_create(ChainLightningEvent, info, passes_per_sec / 5);
+		}
+		if (test_server)
+			sys_log(0, "FuncSplashDamage End :%s ", m_pkChr->GetName());
+	}
+
+	int m_x;
+	int m_y;
+	CSkillProto* m_pkSk;
+	LPCHARACTER m_pkChr;
+	int m_iAmount;
+	int m_iAG;
+	int m_iCount;
+	int m_iMaxHit;
+	LPITEM m_pkWeapon;
+	bool m_bDisableCooltime;
+	TSkillUseInfo* m_pInfo;
+	BYTE m_bUseSkillPower;
+};
+
+struct FuncSplashAffect
+{
+	FuncSplashAffect(LPCHARACTER ch, int x, int y, int iDist, DWORD dwVnum, POINT_TYPE wPointOn, int iAmount, DWORD dwAffectFlag, int iDuration, int iSPCost, bool bOverride, int iMaxHit)
+	{
+		m_x = x;
+		m_y = y;
+		m_iDist = iDist;
+		m_dwVnum = dwVnum;
+		m_wPointOn = wPointOn;
+		m_iAmount = iAmount;
+		m_dwAffectFlag = dwAffectFlag;
+		m_iDuration = iDuration;
+		m_iSPCost = iSPCost;
+		m_bOverride = bOverride;
+		m_pkChrAttacker = ch;
+		m_iMaxHit = iMaxHit;
+		m_iCount = 0;
+	}
+
+	void operator () (LPENTITY ent)
+	{
+		if (m_iMaxHit && m_iMaxHit <= m_iCount)
+			return;
+
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER pkChr = (LPCHARACTER)ent;
+
+			if (test_server)
+				sys_log(0, "FuncSplashAffect step 1 : name:%s vnum:%d iDur:%d", pkChr->GetName(), m_dwVnum, m_iDuration);
+
+			if (DISTANCE_APPROX(m_x - pkChr->GetX(), m_y - pkChr->GetY()) < m_iDist)
+			{
+				if (test_server)
+					sys_log(0, "FuncSplashAffect step 2 : name:%s vnum:%d iDur:%d", pkChr->GetName(), m_dwVnum, m_iDuration);
+
+				if (m_dwVnum == SKILL_TUSOK)
+					if (pkChr->CanBeginFight())
+						pkChr->BeginFight(m_pkChrAttacker);
+
+				if (pkChr->IsPC() && m_dwVnum == SKILL_TUSOK)
+					pkChr->AddAffect(m_dwVnum, m_wPointOn, m_iAmount, m_dwAffectFlag, m_iDuration / 3, m_iSPCost, m_bOverride);
+				else
+					pkChr->AddAffect(m_dwVnum, m_wPointOn, m_iAmount, m_dwAffectFlag, m_iDuration, m_iSPCost, m_bOverride);
+
+				m_iCount++;
+			}
+		}
+	}
+
+	LPCHARACTER m_pkChrAttacker;
+	int m_x;
+	int m_y;
+	int m_iDist;
+	DWORD m_dwVnum;
+	POINT_TYPE m_wPointOn;
+	int m_iAmount;
+	DWORD m_dwAffectFlag;
+	int m_iDuration;
+	int m_iSPCost;
+	bool m_bOverride;
+	int m_iMaxHit;
+	int m_iCount;
+};
+
+EVENTINFO(skill_gwihwan_info)
+{
+	DWORD pid;
+	BYTE bsklv;
+
+	skill_gwihwan_info()
+		: pid(0)
+		, bsklv(0)
+	{
+	}
+};
+
+EVENTFUNC(skill_gwihwan_event)
+{
+	skill_gwihwan_info* info = dynamic_cast<skill_gwihwan_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("skill_gwihwan_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	DWORD pid = info->pid;
+	BYTE sklv = info->bsklv;
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+	if (!ch)
+		return 0;
+
+	int percent = 20 * sklv - 1;
+
+	if (number(1, 100) <= percent)
+	{
+		PIXEL_POSITION pos;
+
+		// 
+		if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(ch->GetMapIndex(), ch->GetEmpire(), pos))
+		{
+			sys_log(1, "Recall: %s %d %d -> %d %d", ch->GetName(), ch->GetX(), ch->GetY(), pos.x, pos.y);
+			ch->WarpSet(pos.x, pos.y);
+		}
+		else
+		{
+			sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", ch->GetName(), ch->GetX(), ch->GetY());
+			ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+	}
+	else
+	{
+		// 
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("환 臼求."));
+	}
+	return 0;
+}
+
+int CHARACTER::ComputeSkillAtPosition(DWORD dwVnum, const PIXEL_POSITION& posTarget, BYTE bSkillLevel)
+{
+	if (GetMountVnum())
+		return BATTLE_NONE;
+
+	if (IsPolymorphed())
+		return BATTLE_NONE;
+
+	if (g_bSkillDisable)
+		return BATTLE_NONE;
+
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+
+	if (!pkSk)
+		return BATTLE_NONE;
+
+	if (test_server)
+	{
+		sys_log(0, "ComputeSkillAtPosition %s vnum %d x %d y %d level %d",
+			GetName(), dwVnum, posTarget.x, posTarget.y, bSkillLevel);
+	}
+
+	//   킬  치 .
+	//if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
+	//	posTarget = GetXYZ();
+
+	// 첨 틈 킬 見 鵑求
+	if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+		return BATTLE_NONE;
+
+	if (0 == bSkillLevel)
+	{
+		if ((bSkillLevel = GetSkillLevel(pkSk->dwVnum)) == 0)
+		{
+			return BATTLE_NONE;
+		}
+	}
+
+	const float k = 1.0 * GetSkillPower(pkSk->dwVnum, bSkillLevel) * pkSk->bMaxLevel / 100;
+
+	pkSk->SetPointVar("k", k);
+	pkSk->kSplashAroundDamageAdjustPoly.SetVar("k", k);
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MELEE_DAMAGE))
+	{
+		pkSk->SetPointVar("atk", CalcMeleeDamage(this, this, true, false));
+	}
+	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MAGIC_DAMAGE))
+	{
+		pkSk->SetPointVar("atk", CalcMagicDamage(this, this));
+	}
+	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_ARROW_DAMAGE))
+	{
+		LPITEM pkBow, pkArrow;
+		if (1 == GetArrowAndBow(&pkBow, &pkArrow, 1))
+		{
+			pkSk->SetPointVar("atk", CalcArrowDamage(this, this, pkBow, pkArrow, true));
+		}
+		else
+		{
+			pkSk->SetPointVar("atk", 0);
+		}
+	}
+
+	if (pkSk->wPointOn == POINT_MOV_SPEED)
+	{
+		pkSk->SetPointVar("maxv", this->GetLimitPoint(POINT_MOV_SPEED));
+	}
+
+	pkSk->SetPointVar("lv", GetLevel());
+	pkSk->SetPointVar("iq", GetPoint(POINT_IQ));
+	pkSk->SetPointVar("str", GetPoint(POINT_ST));
+	pkSk->SetPointVar("dex", GetPoint(POINT_DX));
+	pkSk->SetPointVar("con", GetPoint(POINT_HT));
+	pkSk->SetPointVar("maxhp", this->GetMaxHP());
+	pkSk->SetPointVar("maxsp", this->GetMaxSP());
+	pkSk->SetPointVar("chain", 0);
+	pkSk->SetPointVar("ar", CalcAttackRating(this, this));
+	pkSk->SetPointVar("def", GetPoint(POINT_DEF_GRADE));
+	pkSk->SetPointVar("odef", GetPoint(POINT_DEF_GRADE) - GetPoint(POINT_DEF_GRADE_BONUS));
+	pkSk->SetPointVar("horse_level", GetHorseLevel());
+
+	if (pkSk->bSkillAttrType != SKILL_ATTR_TYPE_NORMAL)
+		OnMove(true);
+
+	LPITEM pkWeapon = GetWear(WEAR_WEAPON);
+
+	SetPolyVarForAttack(this, pkSk, pkWeapon);
+
+	pkSk->SetDurationVar("k", k/* bSkillLevel */);
+
+	int iAmount = (int)pkSk->kPointPoly.Eval();
+	int iAmount2 = (int)pkSk->kPointPoly2.Eval();
+
+	// ADD_GRANDMASTER_SKILL
+	int iAmount3 = (int)pkSk->kPointPoly3.Eval();
+
+	if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
+	{
+		/*
+		if (iAmount >= 0)
+			iAmount += (int)m_pkSk->kMasterBonusPoly.Eval();
+		else
+			iAmount -= (int)m_pkSk->kMasterBonusPoly.Eval();
+		*/
+		iAmount = (int)pkSk->kMasterBonusPoly.Eval();
+	}
+
+	if (test_server && iAmount == 0 && pkSk->wPointOn != POINT_NONE)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "효 求. 킬  확究");
+	}
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_REMOVE_BAD_AFFECT))
+	{
+		if (number(1, 100) <= iAmount2)
+		{
+			RemoveBadAffect();
+		}
+	}
+	// END_OF_ADD_GRANDMASTER_SKILL
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_ATTACK | SKILL_FLAG_USE_MELEE_DAMAGE | SKILL_FLAG_USE_MAGIC_DAMAGE))
+	{
+		//
+		//  킬 
+		//
+		bool bAdded = false;
+
+		if (pkSk->wPointOn == POINT_HP && iAmount < 0)
+		{
+			int iAG = 0;
+
+			FuncSplashDamage f(posTarget.x, posTarget.y, pkSk, this, iAmount, iAG, pkSk->lMaxHit, pkWeapon, m_bDisableCooltime, IsPC() ? &m_SkillUseInfo[dwVnum] : NULL, GetSkillPower(dwVnum, bSkillLevel));
+
+			if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+			{
+				if (GetSectree())
+					GetSectree()->ForEachAround(f);
+			}
+			else
+			{
+				//if (dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN skill call FuncSplashDamage %s", GetName());
+				f(this);
+			}
+		}
+		else
+		{
+			//if (dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN skill no damage %d %s", iAmount, GetName());
+			int iDur = (int)pkSk->kDurationPoly.Eval();
+
+			if (IsPC())
+				if (!(dwVnum >= GUILD_SKILL_START && dwVnum <= GUILD_SKILL_END)) //  킬 타 처  苛쨈.
+					if (!m_bDisableCooltime && !m_SkillUseInfo[dwVnum].HitOnce(dwVnum) && dwVnum != SKILL_MUYEONG)
+					{
+						//if (dwVnum == SKILL_CHAIN) sys_log(0, "CHAIN skill cannot hit %s", GetName());
+						return BATTLE_NONE;
+					}
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+					AddAffect(pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true);
+				else
+				{
+					if (GetSectree())
+					{
+						FuncSplashAffect f(this, posTarget.x, posTarget.y, pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true, pkSk->lMaxHit);
+						GetSectree()->ForEachAround(f);
+					}
+				}
+				bAdded = true;
+			}
+		}
+
+		if (pkSk->wPointOn2 != POINT_NONE)
+		{
+			int iDur = (int)pkSk->kDurationPoly2.Eval();
+
+			sys_log(1, "try second %u %d %d", pkSk->dwVnum, pkSk->wPointOn2, iDur);
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+					AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded);
+				else
+				{
+					if (GetSectree())
+					{
+						FuncSplashAffect f(this, posTarget.x, posTarget.y, pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded, pkSk->lMaxHit);
+						GetSectree()->ForEachAround(f);
+					}
+				}
+				bAdded = true;
+			}
+			else
+			{
+				PointChange(pkSk->wPointOn2, iAmount2);
+			}
+		}
+
+		// ADD_GRANDMASTER_SKILL
+		if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER && pkSk->wPointOn3 != POINT_NONE)
+		{
+			int iDur = (int)pkSk->kDurationPoly3.Eval();
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+					AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, 0 /* pkSk->dwAffectFlag3 */, iDur, 0, !bAdded);
+				else
+				{
+					if (GetSectree())
+					{
+						FuncSplashAffect f(this, posTarget.x, posTarget.y, pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn3, iAmount3, 0 /* pkSk->dwAffectFlag3 */, iDur, 0, !bAdded, pkSk->lMaxHit);
+						GetSectree()->ForEachAround(f);
+					}
+				}
+			}
+			else
+			{
+				PointChange(pkSk->wPointOn3, iAmount3);
+			}
+		}
+		// END_OF_ADD_GRANDMASTER_SKILL
+
+		return BATTLE_DAMAGE;
+	}
+	else
+	{
+		bool bAdded = false;
+		int iDur = (int)pkSk->kDurationPoly.Eval();
+
+		if (iDur > 0)
+		{
+			iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+			// AffectFlag 킬, toggle 求  틈灸..
+			pkSk->kDurationSPCostPoly.SetVar("k", k/* bSkillLevel */);
+
+			AddAffect(pkSk->dwVnum,
+				pkSk->wPointOn,
+				iAmount,
+				pkSk->dwAffectFlag,
+				iDur,
+				(long)pkSk->kDurationSPCostPoly.Eval(),
+				!bAdded);
+
+			bAdded = true;
+		}
+		else
+		{
+			PointChange(pkSk->wPointOn, iAmount);
+		}
+
+		if (pkSk->wPointOn2 != POINT_NONE)
+		{
+			int iDur = (int)pkSk->kDurationPoly2.Eval();
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+				AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded);
+				bAdded = true;
+			}
+			else
+			{
+				PointChange(pkSk->wPointOn2, iAmount2);
+			}
+		}
+
+		// ADD_GRANDMASTER_SKILL
+		if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER && pkSk->wPointOn3 != POINT_NONE)
+		{
+			int iDur = (int)pkSk->kDurationPoly3.Eval();
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+				AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, 0 /* pkSk->dwAffectFlag3 */, iDur, 0, !bAdded);
+			}
+			else
+			{
+				PointChange(pkSk->wPointOn3, iAmount3);
+			}
+		}
+		// END_OF_ADD_GRANDMASTER_SKILL
+
+		return BATTLE_NONE;
+	}
+}
+
+struct FComputeSkillParty
+{
+	FComputeSkillParty(DWORD dwVnum, LPCHARACTER pkAttacker, BYTE bSkillLevel = 0)
+		: m_dwVnum(dwVnum), m_pkAttacker(pkAttacker), m_bSkillLevel(bSkillLevel)
+	{
+	}
+
+	void operator () (LPCHARACTER ch)
+	{
+		if (ch->IsDead())
+			return;
+
+		m_pkAttacker->ComputeSkill(m_dwVnum, ch, m_bSkillLevel);
+	}
+
+	DWORD m_dwVnum;
+	LPCHARACTER m_pkAttacker;
+	BYTE m_bSkillLevel;
+};
+
+int CHARACTER::ComputeSkillParty(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
+{
+	FComputeSkillParty f(dwVnum, pkVictim, bSkillLevel);
+	if (GetParty() && GetParty()->GetNearMemberCount())
+		GetParty()->ForEachNearMember(f);
+	else
+		f(this);
+
+	return BATTLE_NONE;
+}
+
+#if defined(__PVP_BALANCE_IMPROVING__)
+int CHARACTER::ComputeGyeongGongSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
+{
+	if (IsPolymorphed())
+		return BATTLE_NONE;
+
+	if (g_bSkillDisable)
+		return BATTLE_NONE;
+
+	CSkillProto* pkSk = CSkillManager::Instance().Get(dwVnum);
+
+	if (!pkSk)
+		return BATTLE_NONE;
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
+		pkVictim = this;
+
+	if (!pkVictim)
+	{
+		if (test_server)
+			sys_log(0, "ComputeGyeongGongSkill: %s Victim == null, skill %d", GetName(), dwVnum);
+
+		return BATTLE_NONE;
+	}
+
+	if (0 == bSkillLevel)
+	{
+		if ((bSkillLevel = GetSkillLevel(pkSk->dwVnum)) == 0)
+		{
+			if (test_server)
+				sys_log(0, "ComputeGyeongGongSkill: name:%s vnum:%d skillLevelBySkill : %d ", GetName(), pkSk->dwVnum, bSkillLevel);
+			return BATTLE_NONE;
+		}
+	}
+
+	if (pkSk->bSkillAttrType != SKILL_ATTR_TYPE_NORMAL)
+		OnMove(true);
+
+	LPITEM pkWeapon = GetWear(WEAR_WEAPON);
+
+	SetPolyVarForAttack(this, pkSk, pkWeapon);
+	const int iAmount = static_cast<int>(pkSk->kPointPoly2.Eval());
+
+	EffectPacket(SE_FEATHER_WALK, SE_TYPE_POSITION, GetXYZ());
+
+	FuncSplashDamage f(pkVictim->GetX(), pkVictim->GetY(), pkSk, this, iAmount, 0, pkSk->lMaxHit, pkWeapon, m_bDisableCooltime, IsPC() ? &m_SkillUseInfo[dwVnum] : NULL, GetSkillPower(dwVnum, bSkillLevel));
+	if (pkVictim->GetSectree())
+		pkVictim->GetSectree()->ForEachAround(f);
+	else
+		f(pkVictim);
+
+	return BATTLE_DAMAGE;
+}
+#endif
+
+#ifdef ENABLE_QUEEN_NETHIS
+struct FuncSnakeSplashDamage
+{
+	FuncSnakeSplashDamage(int x, int y, LPCHARACTER pkChr, BYTE bUseSkillPower)
+		:
+		m_x(x), m_y(y), m_pkChr(pkChr), m_iCount(0), m_bUseSkillPower(bUseSkillPower)
+		{
+		}
+
+	void operator () (LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_CHARACTER))
+		{
+			return;
+		}
+
+		LPCHARACTER pkChrVictim = (LPCHARACTER) ent;
+
+		if (DISTANCE_APPROX(m_x - pkChrVictim->GetX(), m_y - pkChrVictim->GetY()) > 500)
+		{
+			if(test_server)
+				sys_log(0, "XXX target too far %s", m_pkChr->GetName());
+			return;
+		}
+
+		if (!pkChrVictim->IsPC())
+			return;
+
+		++m_iCount;
+
+		int iDam;
+
+		iDam = pkChrVictim->GetMaxHP()*0.2;
+
+		EDamageType dt = DAMAGE_TYPE_MELEE;
+		if (!pkChrVictim->Damage(m_pkChr, iDam, dt) && !pkChrVictim->IsStun())
+		{
+			float fCrushSlidingLength = 200;
+
+			if (m_pkChr->IsNPC())
+				fCrushSlidingLength = 400;
+
+			float fx, fy;
+			float degree = GetDegreeFromPositionXY(m_pkChr->GetX(), m_pkChr->GetY(), pkChrVictim->GetX(), pkChrVictim->GetY());
+
+			GetDeltaByDegree(degree, fCrushSlidingLength, &fx, &fy);
+			sys_log(0, "CRUSH! %s -> %s (%d %d) -> (%d %d)", m_pkChr->GetName(), pkChrVictim->GetName(), pkChrVictim->GetX(), pkChrVictim->GetY(), (long)(pkChrVictim->GetX()+fx), (long)(pkChrVictim->GetY()+fy));
+			long tx = (long)(pkChrVictim->GetX()+fx);
+			long ty = (long)(pkChrVictim->GetY()+fy);
+
+			pkChrVictim->Sync(tx, ty);
+			pkChrVictim->Goto(tx, ty);
+			pkChrVictim->CalculateMoveDuration();
+
+			pkChrVictim->SyncPacket();
+		}
+	}
+
+	int		m_x;
+	int		m_y;
+	LPCHARACTER	m_pkChr;
+	int		m_iCount;
+	BYTE m_bUseSkillPower;
+};
+
+EVENTINFO(r_snakeskill_info)
+{
+	int	x;
+	int	y;
+	LPCHARACTER pkVictim;
+	BYTE bUseSkillPower;
+};
+
+EVENTFUNC(r_snakeskill_event)
+{
+	r_snakeskill_info* pEventInfo = dynamic_cast<r_snakeskill_info*>(event->info);
+
+	if (!pEventInfo)
+		return 0;
+
+	if (!pEventInfo->pkVictim)
+		return 0;
+
+	FuncSnakeSplashDamage f(pEventInfo->x, pEventInfo->y, pEventInfo->pkVictim, 1);
+	if (pEventInfo->pkVictim->GetSectree())
+		pEventInfo->pkVictim->GetSectree()->ForEachAround(f);
+
+	return 0;
+}
+
+int CHARACTER::ComputeSnakeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
+{
+	if (!pkVictim)
+		return BATTLE_NONE;
+
+	if (m_pkSnakeSkillEvent != NULL)
+		event_cancel(&m_pkSnakeSkillEvent);
+	m_pkSnakeSkillEvent = NULL;
+
+	int iAG = 0;
+
+	r_snakeskill_info* pEventInfo = AllocEventInfo<r_snakeskill_info>();
+
+	pEventInfo->x =pkVictim->GetX();
+	pEventInfo->y =pkVictim->GetY();
+	pEventInfo->pkVictim =this;
+	pEventInfo->bUseSkillPower = 1;
+	m_pkSnakeSkillEvent = event_create(r_snakeskill_event, pEventInfo, PASSES_PER_SEC(2));
+
+	return BATTLE_NONE;	
+}
+#endif
+
+// bSkillLevel 微 0 틈 荑 m_abSkillLevels  歌 
+// bSkillLevel 磯.
+int CHARACTER::ComputeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel)
+{
+	const bool bCanUseHorseSkill = CanUseHorseSkill();
+
+	//  타 킬    쨋 return
+#ifdef SORF_TAHTASI
+	if (GetMountVnum() != SURFBOARD)
+	{
+		{
+			if (false == bCanUseHorseSkill && true == IsRiding()) {
+				return BATTLE_NONE;
+			}
+		}
+	}
+#else
+	if (false == bCanUseHorseSkill && true == IsRiding())
+		return BATTLE_NONE;
+#endif
+
+	if (IsPolymorphed())
+		return BATTLE_NONE;
+
+	if (g_bSkillDisable)
+		return BATTLE_NONE;
+
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+
+	if (!pkSk)
+		return BATTLE_NONE;
+
+#ifdef SORF_TAHTASI
+	if (GetMountVnum() != SURFBOARD)
+	{
+		{
+			if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE) {
+				return BATTLE_NONE;
+			}
+		
+			if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE) {
+				return BATTLE_NONE;
+			}
+		}
+	}
+#else
+	if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE)
+		return BATTLE_NONE;
+
+	if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE)
+		return BATTLE_NONE;
+#endif
+
+	// 嚥   틈玖   磯.
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
+		pkVictim = this;
+
+	if (!pkVictim)
+	{
+		if (test_server)
+			sys_log(0, "ComputeSkill: %s Victim == null, skill %d", GetName(), dwVnum);
+
+		return BATTLE_NONE;
+	}
+
+	const DWORD dwDistance = static_cast<DWORD>(DISTANCE_SQRT(GetX() - pkVictim->GetX(), GetY() - pkVictim->GetY()));
+	if ((pkSk->dwTargetRange) && (dwDistance >= ((pkSk->dwTargetRange + 50 / 100) * pkVictim->GetMonsterHitRange())))
+	{
+		if (test_server)
+			sys_log(0, "ComputeSkill: Victim too far, skill %d : %s to %s (distance %u limit %u)",
+				dwVnum,
+				GetName(),
+				pkVictim->GetName(),
+				(long)DISTANCE_SQRT(GetX() - pkVictim->GetX(), GetY() - pkVictim->GetY()),
+				pkSk->dwTargetRange);
+
+		return BATTLE_NONE;
+	}
+
+	if (0 == bSkillLevel)
+	{
+		if ((bSkillLevel = GetSkillLevel(pkSk->dwVnum)) == 0)
+		{
+			if (test_server)
+				sys_log(0, "ComputeSkill : name:%s vnum:%d skillLevelBySkill : %d ", GetName(), pkSk->dwVnum, bSkillLevel);
+			return BATTLE_NONE;
+		}
+	}
+
+	if (pkVictim->IsAffectFlag(AFF_PABEOP) && pkVictim->IsGoodAffect((BYTE)dwVnum))
+	{
+		return BATTLE_NONE;
+	}
+
+	const float k = 1.0 * GetSkillPower(pkSk->dwVnum, bSkillLevel) * pkSk->bMaxLevel / 100;
+
+	pkSk->SetPointVar("k", k);
+	pkSk->kSplashAroundDamageAdjustPoly.SetVar("k", k);
+
+	if (pkSk->dwType == SKILL_TYPE_HORSE)
+	{
+		LPITEM pkBow, pkArrow;
+		if (1 == GetArrowAndBow(&pkBow, &pkArrow, 1))
+		{
+			pkSk->SetPointVar("atk", CalcArrowDamage(this, pkVictim, pkBow, pkArrow, true));
+		}
+		else
+		{
+			pkSk->SetPointVar("atk", CalcMeleeDamage(this, pkVictim, true, false));
+		}
+	}
+	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MELEE_DAMAGE))
+	{
+		pkSk->SetPointVar("atk", CalcMeleeDamage(this, pkVictim, true, false));
+	}
+	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_MAGIC_DAMAGE))
+	{
+		pkSk->SetPointVar("atk", CalcMagicDamage(this, pkVictim));
+	}
+	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_ARROW_DAMAGE))
+	{
+		LPITEM pkBow, pkArrow;
+		if (1 == GetArrowAndBow(&pkBow, &pkArrow, 1))
+		{
+			pkSk->SetPointVar("atk", CalcArrowDamage(this, pkVictim, pkBow, pkArrow, true));
+		}
+		else
+		{
+			pkSk->SetPointVar("atk", 0);
+		}
+	}
+
+	if (pkSk->wPointOn == POINT_MOV_SPEED)
+	{
+		pkSk->SetPointVar("maxv", pkVictim->GetLimitPoint(POINT_MOV_SPEED));
+	}
+
+	pkSk->SetPointVar("lv", GetLevel());
+	pkSk->SetPointVar("iq", GetPoint(POINT_IQ));
+	pkSk->SetPointVar("str", GetPoint(POINT_ST));
+	pkSk->SetPointVar("dex", GetPoint(POINT_DX));
+	pkSk->SetPointVar("con", GetPoint(POINT_HT));
+	pkSk->SetPointVar("maxhp", pkVictim->GetMaxHP());
+	pkSk->SetPointVar("maxsp", pkVictim->GetMaxSP());
+	pkSk->SetPointVar("chain", 0);
+	pkSk->SetPointVar("ar", CalcAttackRating(this, pkVictim));
+	pkSk->SetPointVar("def", GetPoint(POINT_DEF_GRADE));
+	pkSk->SetPointVar("odef", GetPoint(POINT_DEF_GRADE) - GetPoint(POINT_DEF_GRADE_BONUS));
+	pkSk->SetPointVar("horse_level", GetHorseLevel());
+
+	if (pkSk->bSkillAttrType != SKILL_ATTR_TYPE_NORMAL)
+		OnMove(true);
+
+	LPITEM pkWeapon = GetWear(WEAR_WEAPON);
+
+	SetPolyVarForAttack(this, pkSk, pkWeapon);
+
+	pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
+	pkSk->kDurationPoly2.SetVar("k", k/* bSkillLevel */);
+
+	int iAmount = (int)pkSk->kPointPoly.Eval();
+	int iAmount2 = (int)pkSk->kPointPoly2.Eval();
+	int iAmount3 = (int)pkSk->kPointPoly3.Eval();
+
+	if (test_server && IsPC())
+		sys_log(0, "iAmount: %d %d %d , atk:%f skLevel:%f k:%f GetSkillPower(%d) MaxLevel:%d Per:%f",
+			iAmount, iAmount2, iAmount3,
+			pkSk->kPointPoly.GetVar("atk"),
+			pkSk->kPointPoly.GetVar("k"),
+			k,
+			GetSkillPower(pkSk->dwVnum, bSkillLevel),
+			pkSk->bMaxLevel,
+			pkSk->bMaxLevel / 100
+		);
+
+	// ADD_GRANDMASTER_SKILL
+	if (GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
+	{
+		iAmount = (int)pkSk->kMasterBonusPoly.Eval();
+	}
+
+	if (test_server && iAmount == 0 && pkSk->wPointOn != POINT_NONE)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "효 求. 킬  확究");
+	}
+	// END_OF_ADD_GRANDMASTER_SKILL
+
+	//sys_log(0, "XXX SKILL Calc %d Amount %d", dwVnum, iAmount);
+
+	if (IsPC() && pkSk->dwVnum == SKILL_EUNHYUNG)
+		ForgetMyAttacker(false);
+
+	// REMOVE_BAD_AFFECT_BUG_FIX
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_REMOVE_BAD_AFFECT))
+	{
+		if (number(1, 100) <= iAmount2)
+		{
+			pkVictim->RemoveBadAffect();
+		}
+	}
+	// END_OF_REMOVE_BAD_AFFECT_BUG_FIX
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_ATTACK | SKILL_FLAG_USE_MELEE_DAMAGE | SKILL_FLAG_USE_MAGIC_DAMAGE) &&
+		!(pkSk->dwVnum == SKILL_MUYEONG && pkVictim == this) && !(pkSk->IsChargeSkill() && pkVictim == this))
+	{
+		bool bAdded = false;
+
+		if (pkSk->wPointOn == POINT_HP && iAmount < 0)
+		{
+			int iAG = 0;
+
+			FuncSplashDamage f(pkVictim->GetX(), pkVictim->GetY(), pkSk, this, iAmount, iAG, pkSk->lMaxHit, pkWeapon, m_bDisableCooltime, IsPC() ? &m_SkillUseInfo[dwVnum] : NULL, GetSkillPower(dwVnum, bSkillLevel));
+			if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+			{
+				if (pkVictim->GetSectree())
+					pkVictim->GetSectree()->ForEachAround(f);
+			}
+			else
+			{
+				f(pkVictim);
+			}
+		}
+		else
+		{
+			pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
+			int iDur = (int)pkSk->kDurationPoly.Eval();
+
+			if (IsPC())
+				if (!(dwVnum >= GUILD_SKILL_START && dwVnum <= GUILD_SKILL_END)) //  킬 타 처  苛쨈.
+					if (!m_bDisableCooltime && !m_SkillUseInfo[dwVnum].HitOnce(dwVnum) && dwVnum != SKILL_MUYEONG)
+						return BATTLE_NONE;
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true);
+				else
+				{
+					if (pkVictim->GetSectree())
+					{
+						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn, iAmount, pkSk->dwAffectFlag, iDur, 0, true, pkSk->lMaxHit);
+						pkVictim->GetSectree()->ForEachAround(f);
+					}
+				}
+				bAdded = true;
+			}
+		}
+
+		if (pkSk->wPointOn2 != POINT_NONE && !pkSk->IsChargeSkill())
+		{
+			pkSk->kDurationPoly2.SetVar("k", k/* bSkillLevel */);
+			int iDur = (int)pkSk->kDurationPoly2.Eval();
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+#if defined(__9TH_SKILL__)
+				if (pkSk->wPointOn2 == POINT_HIT_PCT)
+					AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, AFF_NONE, iDur, 0, !bAdded);
+#endif
+
+				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded);
+				else
+				{
+					if (pkVictim->GetSectree())
+					{
+						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur, 0, !bAdded, pkSk->lMaxHit);
+						pkVictim->GetSectree()->ForEachAround(f);
+					}
+				}
+
+				bAdded = true;
+			}
+			else
+			{
+				pkVictim->PointChange(pkSk->wPointOn2, iAmount2);
+			}
+		}
+
+		// ADD_GRANDMASTER_SKILL
+		if (pkSk->wPointOn3 != POINT_NONE && !pkSk->IsChargeSkill() && GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
+		{
+			pkSk->kDurationPoly3.SetVar("k", k /* bSkillLevel */);
+			int iDur = (int)pkSk->kDurationPoly3.Eval();
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded);
+				else
+				{
+					if (pkVictim->GetSectree())
+					{
+						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded, pkSk->lMaxHit);
+						pkVictim->GetSectree()->ForEachAround(f);
+					}
+				}
+
+				bAdded = true;
+			}
+			else
+			{
+				pkVictim->PointChange(pkSk->wPointOn3, iAmount3);
+			}
+		}
+		// END_OF_ADD_GRANDMASTER_SKILL
+
+		return BATTLE_DAMAGE;
+	}
+	else
+	{
+		if (dwVnum == SKILL_MUYEONG)
+		{
+			pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
+			pkSk->kDurationSPCostPoly.SetVar("k", k/* bSkillLevel */);
+
+			int iDur = (long)pkSk->kDurationPoly.Eval();
+			iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+			if (pkVictim == this)
+				AddAffect(dwVnum,
+					POINT_NONE, 0,
+					AFF_MUYEONG,
+					iDur,
+					(long)pkSk->kDurationSPCostPoly.Eval(),
+					true);
+
+			return BATTLE_NONE;
+		}
+
+		bool bAdded = false;
+		pkSk->kDurationPoly.SetVar("k", k/* bSkillLevel */);
+		int iDur = (int)pkSk->kDurationPoly.Eval();
+
+		if (iDur > 0)
+		{
+			if (pkSk->dwVnum == SKILL_JEUNGRYEOK) // Nature's Enchantment
+			{
+				if (pkVictim->GetJob() == JOB_SHAMAN)
+				{
+					iAmount *= 2;
+					if (test_server)
+						sys_log(0, "Buffed Nature's Enchantment to %d.", iAmount);
+				}
+			}
+
+			iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+			// AffectFlag 킬, toggle 求  틈灸..
+			pkSk->kDurationSPCostPoly.SetVar("k", k/* bSkillLevel */);
+
+			if (pkSk->wPointOn2 != POINT_NONE)
+			{
+				pkVictim->RemoveAffect(pkSk->dwVnum);
+
+				int iDur2 = (int)pkSk->kDurationPoly2.Eval();
+
+				if (iDur2 > 0)
+				{
+					if (test_server)
+						sys_log(0, "SKILL_AFFECT: %s %s Dur:%d To:%d Amount:%d",
+							GetName(),
+							pkSk->szName,
+							iDur2,
+							pkSk->wPointOn2,
+							iAmount2);
+
+					iDur2 += GetPoint(POINT_PARTY_BUFFER_BONUS);
+					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur2, 0, false);
+				}
+				else
+				{
+					pkVictim->PointChange(pkSk->wPointOn2, iAmount2);
+				}
+
+				DWORD affact_flag = pkSk->dwAffectFlag;
+
+				// ADD_GRANDMASTER_SKILL
+				if ((pkSk->dwVnum == SKILL_CHUNKEON && GetUsedSkillMasterType(pkSk->dwVnum) < SKILL_GRAND_MASTER))
+				{
+					affact_flag = AFF_CHEONGEUN_WITH_FALL;
+				}
+				// END_OF_ADD_GRANDMASTER_SKILL
+
+				pkVictim->AddAffect(pkSk->dwVnum,
+					pkSk->wPointOn,
+					iAmount,
+					affact_flag,
+					iDur,
+					(long)pkSk->kDurationSPCostPoly.Eval(),
+					false);
+			}
+			else
+			{
+				if (test_server)
+					sys_log(0, "SKILL_AFFECT: %s %s Dur:%d To:%d Amount:%d",
+						GetName(),
+						pkSk->szName,
+						iDur,
+						pkSk->wPointOn,
+						iAmount);
+
+#if defined(__9TH_SKILL__)
+				DWORD dwAffectFlag = pkSk->dwAffectFlag;
+
+				if (dwVnum == SKILL_CHEONUN)
+				{
+					int iSkillMasterType = GetSkillMasterType(pkSk->dwVnum);
+					switch (iSkillMasterType)
+					{
+						case SKILL_NORMAL:
+							dwAffectFlag = AFF_CHEONUN_NORMAL;
+							break;
+						case SKILL_MASTER:
+							dwAffectFlag = AFF_CHEONUN_MASTER;
+							break;
+						case SKILL_GRAND_MASTER:
+							dwAffectFlag = AFF_CHEONUN_GRAND_MASTER;
+							break;
+						case SKILL_PERFECT_MASTER:
+							dwAffectFlag = AFF_CHEONUN_PERFECT_MASTER;
+							break;
+						default:
+							dwAffectFlag = pkSk->dwAffectFlag;
+							break;
+					}
+				}
+
+				pkVictim->AddAffect(pkSk->dwVnum,
+					pkSk->wPointOn,
+					iAmount,
+					dwAffectFlag,
+					iDur,
+					(long)pkSk->kDurationSPCostPoly.Eval(),
+					// ADD_GRANDMASTER_SKILL
+					!bAdded, false,
+#if defined(__AFFECT_RENEWAL__)
+					false, /*bRealTime*/
+#endif
+					iAmount2
+				);
+				// END_OF_ADD_GRANDMASTER_SKILL
+#else
+
+				pkVictim->AddAffect(pkSk->dwVnum,
+					pkSk->wPointOn,
+					iAmount,
+					pkSk->dwAffectFlag,
+					iDur,
+					(long)pkSk->kDurationSPCostPoly.Eval(),
+					// ADD_GRANDMASTER_SKILL
+					!bAdded
+				);
+				// END_OF_ADD_GRANDMASTER_SKILL
+#endif
+			}
+
+			bAdded = true;
+		}
+		else
+		{
+			if (!pkSk->IsChargeSkill())
+				pkVictim->PointChange(pkSk->wPointOn, iAmount);
+
+			if (pkSk->wPointOn2 != POINT_NONE)
+			{
+				pkVictim->RemoveAffect(pkSk->dwVnum);
+
+				int iDur2 = (int)pkSk->kDurationPoly2.Eval();
+
+				if (iDur2 > 0)
+				{
+					iDur2 += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+					if (pkSk->IsChargeSkill())
+						pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, AFF_TANHWAN_DASH, iDur2, 0, false);
+					else
+						pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn2, iAmount2, pkSk->dwAffectFlag2, iDur2, 0, false);
+				}
+				else
+				{
+					pkVictim->PointChange(pkSk->wPointOn2, iAmount2);
+				}
+
+			}
+		}
+
+		// ADD_GRANDMASTER_SKILL
+		if (pkSk->wPointOn3 != POINT_NONE && !pkSk->IsChargeSkill() && GetUsedSkillMasterType(pkSk->dwVnum) >= SKILL_GRAND_MASTER)
+		{
+			pkSk->kDurationPoly3.SetVar("k", k/* bSkillLevel */);
+			int iDur = (int)pkSk->kDurationPoly3.Eval();
+
+			sys_log(0, "try third %u %d %d %d 1894", pkSk->dwVnum, pkSk->wPointOn3, iDur, iAmount3);
+
+			if (iDur > 0)
+			{
+				iDur += GetPoint(POINT_PARTY_BUFFER_BONUS);
+
+				if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_SPLASH))
+					pkVictim->AddAffect(pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded);
+				else
+				{
+					if (pkVictim->GetSectree())
+					{
+						FuncSplashAffect f(this, pkVictim->GetX(), pkVictim->GetY(), pkSk->iSplashRange, pkSk->dwVnum, pkSk->wPointOn3, iAmount3, /* pkSk->dwAffectFlag3 */ 0, iDur, 0, !bAdded, pkSk->lMaxHit);
+						pkVictim->GetSectree()->ForEachAround(f);
+					}
+				}
+
+				bAdded = true;
+			}
+			else
+			{
+				pkVictim->PointChange(pkSk->wPointOn3, iAmount3);
+			}
+		}
+		// END_OF_ADD_GRANDMASTER_SKILL
+
+		return BATTLE_NONE;
+	}
+}
+
+bool CHARACTER::UseSkill(DWORD dwVnum, LPCHARACTER pkVictim, bool bUseGrandMaster)
+{
+	if (false == CanUseSkill(dwVnum))
+		return false;
+
+	if ((dwVnum == SKILL_GEOMKYUNG || dwVnum == SKILL_GWIGEOM) && !GetWear(WEAR_WEAPON))
+		return false;
+
+	// NO_GRANDMASTER
+	if (test_server)
+	{
+		if (quest::CQuestManager::instance().GetEventFlag("no_grand_master"))
+		{
+			bUseGrandMaster = false;
+		}
+	}
+	// END_OF_NO_GRANDMASTER
+
+	if (g_bSkillDisable)
+		return false;
+
+	if (IsObserverMode())
+		return false;
+
+	if (!CanMove())
+		return false;
+
+	if (IsPolymorphed())
+		return false;
+
+	const bool bCanUseHorseSkill = CanUseHorseSkill();
+
+	if (dwVnum == SKILL_HORSE_SUMMON)
+	{
+		if (GetSkillLevel(dwVnum) == 0)
+			return false;
+
+		if (GetHorseLevel() <= 0)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 求. 째  찾튼."));
+		else
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 환  究."));
+
+		return true;
+	}
+
+	//  타 킬    쨋 return false
+#ifdef SORF_TAHTASI
+	if (GetMountVnum() != SURFBOARD)
+	{
+		if (false == bCanUseHorseSkill && true == IsRiding())
+			return false;
+	}
+#else
+	if (false == bCanUseHorseSkill && true == IsRiding())
+		return false;
+#endif
+
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+	sys_log(0, "%s: USE_SKILL: %d pkVictim %p", GetName(), dwVnum, get_pointer(pkVictim));
+
+	if (!pkSk)
+		return false;
+
+#ifdef SORF_TAHTASI
+	if (GetMountVnum() != SURFBOARD)
+	{
+		if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE)
+			return BATTLE_NONE;
+
+		if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE)
+			return BATTLE_NONE;
+	}
+#else
+	if (bCanUseHorseSkill && pkSk->dwType != SKILL_TYPE_HORSE)
+		return BATTLE_NONE;
+
+	if (!bCanUseHorseSkill && pkSk->dwType == SKILL_TYPE_HORSE)
+		return BATTLE_NONE;
+#endif
+
+	if (GetSkillLevel(dwVnum) == 0)
+		return false;
+
+	// NO_GRANDMASTER
+	if (GetSkillMasterType(dwVnum) < SKILL_GRAND_MASTER)
+		bUseGrandMaster = false;
+	// END_OF_NO_GRANDMASTER
+
+	// MINING
+	if (GetWear(WEAR_WEAPON) && (GetWear(WEAR_WEAPON)->GetType() == ITEM_ROD || GetWear(WEAR_WEAPON)->GetType() == ITEM_PICK))
+		return false;
+	// END_OF_MINING
+
+	m_SkillUseInfo[dwVnum].TargetVIDMap.clear();
+
+	if (pkSk->IsChargeSkill())
+	{
+		if (IsAffectFlag(AFF_TANHWAN_DASH) || pkVictim && pkVictim != this)
+		{
+			if (!pkVictim)
+				return false;
+
+			if (!IsAffectFlag(AFF_TANHWAN_DASH))
+			{
+				if (!UseSkill(dwVnum, this))
+					return false;
+			}
+
+			m_SkillUseInfo[dwVnum].SetMainTargetVID(pkVictim->GetVID());
+			// DASH  탄환 膚
+			ComputeSkill(dwVnum, pkVictim);
+			RemoveAffect(dwVnum);
+			return true;
+		}
+	}
+
+	if (dwVnum == SKILL_COMBO)
+	{
+		if (m_bComboIndex)
+			m_bComboIndex = 0;
+		else
+			m_bComboIndex = GetSkillLevel(SKILL_COMBO);
+
+		ChatPacket(CHAT_TYPE_COMMAND, "combo %d", m_bComboIndex);
+		return true;
+	}
+
+	// Toggle   SP   (SelfOnly )
+	if ((0 != pkSk->dwAffectFlag || pkSk->dwVnum == SKILL_MUYEONG) && (pkSk->dwFlag & SKILL_FLAG_TOGGLE) && RemoveAffect(pkSk->dwVnum))
+	{
+		return true;
+	}
+
+	if (IsAffectFlag(AFF_REVIVE_INVISIBLE))
+		RemoveAffect(AFFECT_REVIVE_INVISIBLE);
+
+	const float k = GetSkillPower(pkSk->dwVnum) * pkSk->bMaxLevel / 100.0f;
+
+	pkSk->SetPointVar("k", k);
+	pkSk->kSplashAroundDamageAdjustPoly.SetVar("k", k);
+
+	// 타 체크
+	pkSk->kCooldownPoly.SetVar("k", k);
+	int iCooltime = (int)pkSk->kCooldownPoly.Eval();
+	int lMaxHit = pkSk->lMaxHit ? pkSk->lMaxHit : -1;
+
+	pkSk->SetSPCostVar("k", k);
+
+	DWORD dwCur = get_dword_time();
+
+	if (dwVnum == SKILL_TERROR && m_SkillUseInfo[dwVnum].bUsed && m_SkillUseInfo[dwVnum].dwNextSkillUsableTime > dwCur)
+	{
+		sys_log(0, " SKILL_TERROR's Cooltime is not delta over %u", m_SkillUseInfo[dwVnum].dwNextSkillUsableTime - dwCur);
+		return false;
+	}
+
+	int iNeededSP = 0;
+
+	//if (dwVnum == 51)
+	//	AddAffect(AFF_EUNHYUNG, POINT_NONE, 0, AFF_EUNHYUNG, 4, 0, true);
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_USE_HP_AS_COST))
+	{
+		pkSk->SetSPCostVar("maxhp", GetMaxHP());
+		pkSk->SetSPCostVar("v", GetHP());
+		iNeededSP = (int)pkSk->kSPCostPoly.Eval();
+
+		// ADD_GRANDMASTER_SKILL
+		if (GetSkillMasterType(dwVnum) >= SKILL_GRAND_MASTER && bUseGrandMaster)
+		{
+			iNeededSP = (int)pkSk->kGrandMasterAddSPCostPoly.Eval();
+		}
+		// END_OF_ADD_GRANDMASTER_SKILL
+
+		if (GetHP() < iNeededSP)
+			return false;
+
+		PointChange(POINT_HP, -iNeededSP);
+	}
+	else
+	{
+		// SKILL_FOMULA_REFACTORING
+		pkSk->SetSPCostVar("maxhp", GetMaxHP());
+		pkSk->SetSPCostVar("maxv", GetMaxSP());
+		pkSk->SetSPCostVar("v", GetSP());
+
+		iNeededSP = (int)pkSk->kSPCostPoly.Eval();
+
+		if (GetSkillMasterType(dwVnum) >= SKILL_GRAND_MASTER && bUseGrandMaster)
+		{
+			iNeededSP = (int)pkSk->kGrandMasterAddSPCostPoly.Eval();
+		}
+		// END_OF_SKILL_FOMULA_REFACTORING
+
+		if (GetSP() < iNeededSP)
+			return false;
+
+		if (test_server)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s SP恬: %d", LC_SKILL(pkSk->dwVnum), iNeededSP));
+
+		PointChange(POINT_SP, -iNeededSP);
+	}
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
+		pkVictim = this;
+
+	if ((pkSk->dwVnum == SKILL_MUYEONG) || (pkSk->IsChargeSkill() && !IsAffectFlag(AFF_TANHWAN_DASH) && !pkVictim))
+	{
+		// 처 求  黴탓 Affect 灌.
+		pkVictim = this;
+	}
+
+	int iSplashCount = 1;
+
+	if (false == m_bDisableCooltime)
+	{
+		if (false ==
+			m_SkillUseInfo[dwVnum].UseSkill(
+				bUseGrandMaster,
+				(NULL != pkVictim && SKILL_HORSE_WILDATTACK != dwVnum) ? pkVictim->GetVID() : 0,
+				ComputeCooltime(iCooltime * 1000),
+				iSplashCount,
+				lMaxHit))
+		{
+			if (test_server)
+				ChatPacket(CHAT_TYPE_NOTICE, "cooltime not finished %s %d", pkSk->szName, iCooltime);
+
+			return false;
+		}
+	}
+
+	if (dwVnum == SKILL_CHAIN)
+	{
+		ResetChainLightningIndex();
+		AddChainLightningExcept(pkVictim);
+	}
+
+#if defined(__PVP_BALANCE_IMPROVING__)
+	if (dwVnum == SKILL_PAERYONG)
+		ComputeSkill(dwVnum, pkVictim);
+#endif
+
+#if defined(__9TH_SKILL__)
+	if (dwVnum == SKILL_METEO)
+		ComputeSkill(dwVnum, pkVictim);
+#endif
+
+	if (IS_SET(pkSk->dwFlag, SKILL_FLAG_SELFONLY))
+		ComputeSkill(dwVnum, this);
+	else if (IS_SET(pkSk->dwFlag, SKILL_FLAG_PARTY))
+	{
+		ComputeSkillParty(dwVnum, this);
+
+		if (pkVictim)
+			ComputeSkill(dwVnum, pkVictim);
+	}
+	else if (!IS_SET(pkSk->dwFlag, SKILL_FLAG_ATTACK))
+		ComputeSkill(dwVnum, pkVictim);
+	else if (dwVnum == SKILL_BYEURAK)
+		ComputeSkill(dwVnum, pkVictim);
+	else if (dwVnum == SKILL_MUYEONG || pkSk->IsChargeSkill())
+		ComputeSkill(dwVnum, pkVictim);
+
+	m_dwLastSkillTime = get_dword_time();
+
+	return true;
+}
+
+int CHARACTER::GetUsedSkillMasterType(DWORD dwVnum)
+{
+	const TSkillUseInfo& rInfo = m_SkillUseInfo[dwVnum];
+
+	if (GetSkillMasterType(dwVnum) < SKILL_GRAND_MASTER)
+		return GetSkillMasterType(dwVnum);
+
+	if (rInfo.isGrandMaster)
+		return GetSkillMasterType(dwVnum);
+
+	return MIN(GetSkillMasterType(dwVnum), SKILL_MASTER);
+}
+
+int CHARACTER::GetSkillMasterType(DWORD dwVnum) const
+{
+	if (!IsPC())
+		return 0;
+
+	if (dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
+		return 0;
+	}
+
+	return m_pSkillLevels ? m_pSkillLevels[dwVnum].bMasterType : SKILL_NORMAL;
+}
+
+#if defined(__CONQUEROR_LEVEL__)
+bool CHARACTER::IsConquerorSkill(DWORD dwVnum) const
+{
+	if (!IsPC())
+		return false;
+
+	if (dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
+		return false;
+	}
+
+	/*
+	* Since there is currently no way to check if the skills
+	* are conqueror level we have to hard code them.
+	*/
+
+	if (dwVnum >= SKILL_FINISH && dwVnum <= SKILL_ILIPUNGU)
+		return true;
+
+	return false;
+}
+#endif
+
+int CHARACTER::GetSkillPower(DWORD dwVnum, BYTE bLevel) const
+{
+	// 刮 
+	if (dwVnum >= SKILL_LANGUAGE1 && dwVnum <= SKILL_LANGUAGE3 && IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+	{
+		return 100;
+	}
+
+	if (dwVnum >= GUILD_SKILL_START && dwVnum <= GUILD_SKILL_END)
+	{
+		if (GetGuild())
+			return 100 * GetGuild()->GetSkillLevel(dwVnum) / 7 / 7;
+		else
+			return 0;
+	}
+
+	if (bLevel)
+	{
+		// SKILL_POWER_BY_LEVEL
+		return GetSkillPowerByLevel(bLevel, true);
+		// END_SKILL_POWER_BY_LEVEL;
+	}
+
+	if (dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
+		return 0;
+	}
+
+	// SKILL_POWER_BY_LEVEL
+	return GetSkillPowerByLevel(GetSkillLevel(dwVnum));
+	// SKILL_POWER_BY_LEVEL
+}
+
+int CHARACTER::GetSkillLevel(DWORD dwVnum) const
+{
+	if (dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("%s skill vnum overflow %u", GetName(), dwVnum);
+		sys_log(0, "%s skill vnum overflow %u", GetName(), dwVnum);
+		return 0;
+	}
+
+	return MIN(SKILL_MAX_LEVEL, m_pSkillLevels ? m_pSkillLevels[dwVnum].bLevel : 0);
+}
+
+EVENTFUNC(skill_muyoung_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("skill_muyoung_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = info->ch;
+
+	if (ch == NULL) // <Factor>
+		return 0;
+
+	if (!ch->IsAffectFlag(AFF_MUYEONG))
+	{
+		ch->StopMuyeongEvent();
+		return 0;
+	}
+
+	// 1. Find Victim
+	FFindNearVictim f(ch, ch);
+	if (ch->GetSectree())
+	{
+		ch->GetSectree()->ForEachAround(f);
+		// 2. Shoot!
+		if (f.GetVictim())
+		{
+			ch->CreateFly(FLY_SKILL_MUYEONG, f.GetVictim());
+			ch->ComputeSkill(SKILL_MUYEONG, f.GetVictim());
+		}
+	}
+
+	return PASSES_PER_SEC(3);
+}
+
+void CHARACTER::StartMuyeongEvent()
+{
+	if (m_pkMuyeongEvent)
+		return;
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+
+	info->ch = this;
+	m_pkMuyeongEvent = event_create(skill_muyoung_event, info, PASSES_PER_SEC(1));
+}
+
+void CHARACTER::StopMuyeongEvent()
+{
+	event_cancel(&m_pkMuyeongEvent);
+}
+
+#if defined(__PVP_BALANCE_IMPROVING__)
+EVENTFUNC(skill_gyeonggong_event)
+{
+	const char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("skill_gyeonggong_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = info->ch;
+	if (ch == NULL)
+		return 0;
+
+	if (!ch->IsAffectFlag(AFF_GYEONGGONG))
+	{
+		ch->StopGyeongGongEvent();
+		return 0;
+	}
+
+	ch->ComputeGyeongGongSkill(SKILL_GYEONGGONG, ch);
+
+	return PASSES_PER_SEC(1);
+}
+
+void CHARACTER::StartGyeongGongEvent()
+{
+	if (m_pkGyeongGongEvent)
+		return;
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+	info->ch = this;
+	m_pkGyeongGongEvent = event_create(skill_gyeonggong_event, info, PASSES_PER_SEC(1));
+}
+
+void CHARACTER::StopGyeongGongEvent()
+{
+	event_cancel(&m_pkGyeongGongEvent);
+}
+#endif
+
+#if defined(__9TH_SKILL__)
+struct FPartyAffect
+{
+	void operator() (LPCHARACTER ch)
+	{
+		ch->ExitToSavedLocation();
+	}
+};
+
+EVENTINFO(skill_cheonun_event_info)
+{
+	DynamicCharacterPtr ch;
+	BYTE prob, duration;
+};
+
+EVENTFUNC(skill_cheonun_event)
+{
+	skill_cheonun_event_info* info = dynamic_cast<skill_cheonun_event_info*>(event->info);
+	if (info == nullptr)
+	{
+		sys_err("skill_cheonun_event_info NULL");
+		return 0;
+	}
+
+	const LPCHARACTER ch = info->ch;
+	if (ch == nullptr)
+		return 0;
+
+	if (!ch->FindAffect(SKILL_CHEONUN /*AFFECT_SKILL_9_CHEONUN*/))
+	{
+		ch->StopCheonunEvent();
+		return 0;
+	}
+
+	const BYTE max_prob = 100;
+	const BYTE prob = number(1, max_prob);
+	if (prob >= max_prob - info->prob)
+	{
+		const LPPARTY party = ch->GetParty();
+		if (party)
+		{
+			auto FPartyAffect = [&info](const LPCHARACTER& ch)
+			{
+				ch->AddAffect(AFFECT_CHEONUN_INVINCIBILITY, APPLY_NONE, 1, AFF_CHEONUN_INVINCIBILITY, info->duration, 0, true);
+			};
+			party->ForEachNearMember(FPartyAffect);
+		}
+		else
+		{
+			ch->AddAffect(AFFECT_CHEONUN_INVINCIBILITY, APPLY_NONE, 1, AFF_CHEONUN_INVINCIBILITY, info->duration, 0, true);
+		}
+	}
+
+	return PASSES_PER_SEC(12);
+}
+
+void CHARACTER::StartCheonunEvent(BYTE bChance, BYTE bDuration)
+{
+	if (m_pkCheonunEvent)
+		return;
+
+	skill_cheonun_event_info* info = AllocEventInfo<skill_cheonun_event_info>();
+	info->ch = this;
+	info->prob = bChance;
+	info->duration = bDuration;
+	m_pkCheonunEvent = event_create(skill_cheonun_event, info, PASSES_PER_SEC(1));
+}
+
+void CHARACTER::StopCheonunEvent()
+{
+	event_cancel(&m_pkCheonunEvent);
+}
+#endif
+
+void CHARACTER::SkillLearnWaitMoreTimeMessage(DWORD ms)
+{
+	// const char* str = "";
+	//
+	if (ms < 3 * 60)
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("  煞堅.   . 甄 綬 키."));
+	else if (ms < 5 * 60)
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("瀏, 천천.  천천, 瀏   !"));
+	else if (ms < 10 * 60) // 10
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("瀏,  潔. 체 璲  歷."));
+	else if (ms < 30 * 60) // 30
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING(" 棘!  乍 獵  탓 綬 綬 玖,"));
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("陋   탑!"));
+	}
+	else if (ms < 1 * 3600) // 1챨
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING(" 책  潔!    隔 羚!"));
+	else if (ms < 2 * 3600) // 2챨
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("  勞! 賻 !"));
+	else if (ms < 3 * 3600)
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("勞! 賻   甄!"));
+	else if (ms < 6 * 3600)
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("책葯    刻耐."));
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("  효    ."));
+	}
+	else if (ms < 12 * 3600)
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("      ."));
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING(",  茱  !"));
+	}
+	else if (ms < 18 * 3600)
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("틈 錚    棘諍 疸  ."));
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("歐 횡."));
+	}
+	else //if (ms < 2 * 86400)
+	{
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("큼 閨璲  珂. 巒 튼 逾 ."));
+		ChatPacket(CHAT_TYPE_TALKING, LC_STRING("肩 寬 홴홱袂."));
+	}
+
+	/*
+		str = "30%";
+	else if (ms < 3 * 86400)
+		str = "10%";
+	else if (ms < 4 * 86400)
+		str = "5%";
+	else
+		str = "0%";
+
+	ChatPacket(CHAT_TYPE_TALKING, "%s", str);
+	*/
+}
+
+void CHARACTER::DisableCooltime()
+{
+	m_bDisableCooltime = true;
+}
+
+bool CHARACTER::HasMobSkill() const
+{
+	return CountMobSkill() > 0;
+}
+
+size_t CHARACTER::CountMobSkill() const
+{
+	if (!m_pkMobData)
+		return 0;
+
+	size_t c = 0;
+
+	for (size_t i = 0; i < MOB_SKILL_MAX_NUM; ++i)
+		if (m_pkMobData->m_table.Skills[i].dwVnum)
+			++c;
+
+	return c;
+}
+
+const TMobSkillInfo* CHARACTER::GetMobSkill(unsigned int idx) const
+{
+	if (idx >= MOB_SKILL_MAX_NUM)
+		return NULL;
+
+	if (!m_pkMobData)
+		return NULL;
+
+	if (0 == m_pkMobData->m_table.Skills[idx].dwVnum)
+		return NULL;
+
+	return &m_pkMobData->m_mobSkillInfo[idx];
+}
+
+bool CHARACTER::CanUseMobSkill(unsigned int idx) const
+{
+	const TMobSkillInfo* pInfo = GetMobSkill(idx);
+
+	if (!pInfo)
+		return false;
+
+	if (m_adwMobSkillCooltime[idx] > get_dword_time())
+		return false;
+
+	if (number(0, 1))
+		return false;
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
+	{
+		CGuildDragonLair* pGuildDragonLair = GetGuildDragonLair();
+		if (pGuildDragonLair && pGuildDragonLair->GetSpecialAttack())
+			return false;
+	}
+#endif
+
+	return true;
+}
+
+EVENTINFO(mob_skill_event_info)
+{
+	DynamicCharacterPtr ch;
+	PIXEL_POSITION pos;
+	DWORD vnum;
+	int index;
+	BYTE level;
+
+	mob_skill_event_info()
+		: ch()
+		, pos()
+		, vnum(0)
+		, index(0)
+		, level(0)
+	{
+	}
+};
+
+EVENTFUNC(mob_skill_hit_event)
+{
+	mob_skill_event_info* info = dynamic_cast<mob_skill_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("mob_skill_event_info> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = info->ch;
+	if (ch == NULL) // <Factor>
+		return 0;
+
+	ch->ComputeSkillAtPosition(info->vnum, info->pos, info->level);
+
+	ch->m_mapMobSkillEvent.erase(info->index);
+
+	return 0;
+}
+
+#if defined(__DAWNMIST_DUNGEON__)
+struct FPartyHealer
+{
+	int m_iSkillLevel;
+	FPartyHealer(int iSkillLevel) : m_iSkillLevel(iSkillLevel) {}
+	void operator() (const LPENTITY pkEntity)
+	{
+		if (pkEntity && !pkEntity->IsType(ENTITY_CHARACTER))
+			return;
+
+		const LPCHARACTER pkChar = dynamic_cast<LPCHARACTER>(pkEntity);
+		if (pkChar == nullptr)
+			return;
+
+		if (!pkChar->IsMonster() || pkChar->IsDead())
+			return;
+
+		if (pkChar->GetHP() >= pkChar->GetMaxHP())
+			return;
+
+		CSkillProto* pkSkill = CSkillManager::instance().Get(SKILL_HEAL);
+		if (NULL != pkSkill)
+		{
+			pkSkill->SetPointVar("maxhp", pkChar->GetMaxHP());
+			pkSkill->SetPointVar("k", 1.0f * m_iSkillLevel / 100.0f);
+
+			int iAmount = static_cast<int>(pkSkill->kPointPoly.Eval());
+			
+			
+			pkChar->PointChange(pkSkill->wPointOn, iAmount);
+			pkChar->EffectPacket(SE_HEAL);
+		}
+		//pkChar->PointChange(POINT_HP, MAX(1, (pkChar->GetMaxHP() * pkChar->GetMobTable().bRegenPercent) / 100)); // Old
+	}
+};
+
+EVENTINFO(HealEventInfo)
+{
+	LPCHARACTER pHealer;
+	BYTE bSkillLevel;
+	int iCooltime;
+};
+
+EVENTFUNC(HealEvent)
+{
+	HealEventInfo* pInfo = dynamic_cast<HealEventInfo*>(event->info);
+	if (pInfo == nullptr)
+	{
+		sys_err("HealerEvent: <Factor> Null pointer");
+		return 0;
+	}
+
+	const LPCHARACTER pkHealer = pInfo->pHealer;
+	if ((pkHealer == nullptr) || (pkHealer->IsDead() || pkHealer->IsStun()))
+		return 0;
+
+	if (!pkHealer->IsHealer())
+		return 0;
+
+	const LPPARTY pkParty = pkHealer->GetParty();
+	if (pkParty == nullptr)
+		return 0;
+
+	FPartyHealer f(pInfo->bSkillLevel);
+	pkParty->ForEachMemberPtr(f);
+
+	return PASSES_PER_SEC(pInfo->iCooltime);
+};
+#endif
+
+bool CHARACTER::UseMobSkill(unsigned int idx)
+{
+	if (IsPC())
+		return false;
+
+	const TMobSkillInfo* pInfo = GetMobSkill(idx);
+
+	if (!pInfo)
+		return false;
+
+	DWORD dwVnum = pInfo->dwSkillVnum;
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+
+	if (!pkSk)
+		return false;
+
+	const float k = 1.0 * GetSkillPower(pkSk->dwVnum, pInfo->bSkillLevel) * pkSk->bMaxLevel / 100;
+
+	pkSk->kCooldownPoly.SetVar("k", k);
+	int iCooltime = (int)(pkSk->kCooldownPoly.Eval() * 1000);
+
+	m_adwMobSkillCooltime[idx] = get_dword_time() + iCooltime;
+
+	sys_log(0, "USE_MOB_SKILL: %s idx %d vnum %u cooltime %d", GetName(), idx, dwVnum, iCooltime);
+
+#if defined(__DAWNMIST_DUNGEON__)
+	if (IsHealer() && IS_SET(pkSk->dwFlag, SKILL_FLAG_PARTY))
+	{
+		if (m_pkHealEvent == NULL)
+		{
+			HealEventInfo* pHealEventInfo = AllocEventInfo<HealEventInfo>();
+			pHealEventInfo->pHealer = this;
+			pHealEventInfo->bSkillLevel = pInfo->bSkillLevel;
+			pHealEventInfo->iCooltime = iCooltime / 1000;
+			m_pkHealEvent = event_create(HealEvent, pHealEventInfo, PASSES_PER_SEC(1));
+		}
+		return true;
+	}
+#endif
+
+	sys_log(0, "USE_MOB_SKILL: %s idx %d vnum %u cooltime %d", GetName(), idx, dwVnum, iCooltime);
+
+	if (m_pkMobData->m_mobSkillInfo[idx].vecSplashAttack.empty())
+	{
+		sys_err("No skill hit data for mob %s index %d", GetName(), idx);
+		return false;
+	}
+
+	for (size_t i = 0; i < m_pkMobData->m_mobSkillInfo[idx].vecSplashAttack.size(); i++)
+	{
+		PIXEL_POSITION pos = GetXYZ();
+		const TMobSplashAttackInfo& rInfo = m_pkMobData->m_mobSkillInfo[idx].vecSplashAttack[i];
+
+		if (rInfo.dwHitDistance)
+		{
+			float fx, fy;
+			GetDeltaByDegree(GetRotation(), rInfo.dwHitDistance, &fx, &fy);
+			pos.x += (long)fx;
+			pos.y += (long)fy;
+		}
+
+		if (rInfo.dwTiming)
+		{
+			if (test_server)
+				sys_log(0, "               timing %ums", rInfo.dwTiming);
+
+			mob_skill_event_info* info = AllocEventInfo<mob_skill_event_info>();
+
+			info->ch = this;
+			info->pos = pos;
+			info->level = pInfo->bSkillLevel;
+			info->vnum = dwVnum;
+			info->index = i;
+
+			// <Factor> Cancel existing event first
+			auto it = m_mapMobSkillEvent.find(i);
+			if (it != m_mapMobSkillEvent.end())
+			{
+				LPEVENT existing = it->second;
+				event_cancel(&existing);
+				m_mapMobSkillEvent.erase(it);
+			}
+
+			m_mapMobSkillEvent.insert(std::make_pair(i, event_create(mob_skill_hit_event, info, PASSES_PER_SEC(rInfo.dwTiming) / 1000)));
+		}
+		else
+		{
+			ComputeSkillAtPosition(dwVnum, pos, pInfo->bSkillLevel);
+		}
+	}
+
+	return true;
+}
+
+void CHARACTER::ResetMobSkillCooltime()
+{
+	memset(m_adwMobSkillCooltime, 0, sizeof(m_adwMobSkillCooltime));
+}
+
+bool CHARACTER::IsUsableSkillMotion(DWORD dwMotionIndex) const
+{
+	DWORD selfJobGroup = (GetJob() + 1) * 10 + GetSkillGroup();
+
+	const DWORD SKILL_NUM = 184;
+	static DWORD s_anSkill2JobGroup[SKILL_NUM] = {
+		0, // common_skill 0
+		11, // job_skill(WARRIOR SKILL) 1
+		11, // job_skill(WARRIOR SKILL) 2
+		11, // job_skill(WARRIOR SKILL) 3
+		11, // job_skill(WARRIOR SKILL) 4
+		11, // job_skill(WARRIOR SKILL) 5
+		11, // job_skill(WARRIOR SKILL) 6
+		0, // common_skill 7
+		0, // common_skill 8
+		0, // common_skill 9
+		0, // common_skill 10
+		0, // common_skill 11
+		0, // common_skill 12
+		0, // common_skill 13
+		0, // common_skill 14
+		0, // common_skill 15
+		12, // job_skill(WARRIOR SKILL) 16
+		12, // job_skill(WARRIOR SKILL) 17
+		12, // job_skill(WARRIOR SKILL) 18
+		12, // job_skill(WARRIOR SKILL) 19
+		12, // job_skill(WARRIOR SKILL) 20
+		12, // job_skill(WARRIOR SKILL) 21
+		0, // common_skill 22
+		0, // common_skill 23
+		0, // common_skill 24
+		0, // common_skill 25
+		0, // common_skill 26
+		0, // common_skill 27
+		0, // common_skill 28
+		0, // common_skill 29
+		0, // common_skill 30
+		21, // job_skill(ASSASSIN SKILL) 31
+		21, // job_skill(ASSASSIN SKILL) 32
+		21, // job_skill(ASSASSIN SKILL) 33
+		21, // job_skill(ASSASSIN SKILL) 34
+		21, // job_skill(ASSASSIN SKILL) 35
+		21, // job_skill(ASSASSIN SKILL) 36
+		0, // common_skill 37
+		0, // common_skill 38
+		0, // common_skill 39
+		0, // common_skill 40
+		0, // common_skill 41
+		0, // common_skill 42
+		0, // common_skill 43
+		0, // common_skill 44
+		0, // common_skill 45
+		22, // job_skill(ASSASSIN SKILL) 46
+		22, // job_skill(ASSASSIN SKILL) 47
+		22, // job_skill(ASSASSIN SKILL) 48
+		22, // job_skill(ASSASSIN SKILL) 49
+		22, // job_skill(ASSASSIN SKILL) 50
+		22, // job_skill(ASSASSIN SKILL) 51
+		0, // common_skill 52
+		0, // common_skill 53
+		0, // common_skill 54
+		0, // common_skill 55
+		0, // common_skill 56
+		0, // common_skill 57
+		0, // common_skill 58
+		0, // common_skill 59
+		0, // common_skill 60
+		31, // job_skill(SURA SKILL) 61
+		31, // job_skill(SURA SKILL) 62
+		31, // job_skill(SURA SKILL) 63
+		31, // job_skill(SURA SKILL) 64
+		31, // job_skill(SURA SKILL) 65
+		31, // job_skill(SURA SKILL) 66
+		0, // common_skill 67
+		0, // common_skill 68
+		0, // common_skill 69
+		0, // common_skill 70
+		0, // common_skill 71
+		0, // common_skill 72
+		0, // common_skill 73
+		0, // common_skill 74
+		0, // common_skill 75
+		32, // job_skill(SURA SKILL) 76
+		32, // job_skill(SURA SKILL) 77
+		32, // job_skill(SURA SKILL) 78
+		32, // job_skill(SURA SKILL) 79
+		32, // job_skill(SURA SKILL) 80
+		32, // job_skill(SURA SKILL) 81
+		0, // common_skill 82
+		0, // common_skill 83
+		0, // common_skill 84
+		0, // common_skill 85
+		0, // common_skill 86
+		0, // common_skill 87
+		0, // common_skill 88
+		0, // common_skill 89
+		0, // common_skill 90
+		41, // job_skill(SHAMAN SKILL) 91
+		41, // job_skill(SHAMAN SKILL) 92
+		41, // job_skill(SHAMAN SKILL) 93
+		41, // job_skill(SHAMAN SKILL) 94
+		41, // job_skill(SHAMAN SKILL) 95
+		41, // job_skill(SHAMAN SKILL) 96
+		0, // common_skill 97
+		0, // common_skill 98
+		0, // common_skill 99
+		0, // common_skill 100
+		0, // common_skill 101
+		0, // common_skill 102
+		0, // common_skill 103
+		0, // common_skill 104
+		0, // common_skill 105
+		42, // job_skill(SHAMAN SKILL) 106
+		42, // job_skill(SHAMAN SKILL) 107
+		42, // job_skill(SHAMAN SKILL) 108
+		42, // job_skill(SHAMAN SKILL) 109
+		42, // job_skill(SHAMAN SKILL) 110
+		42, // job_skill(SHAMAN SKILL) 111
+		0, // common_skill 112
+		0, // common_skill 113
+		0, // common_skill 114
+		0, // common_skill 115
+		0, // common_skill 116
+		0, // common_skill 117
+		0, // common_skill 118
+		0, // common_skill 119
+		0, // common_skill 120
+		0, // common_skill 121
+		0, // common_skill 122
+		0, // common_skill 123
+		0, // common_skill 124
+		0, // common_skill 125
+		0, // common_skill 126
+		0, // common_skill 127
+		0, // common_skill 128
+		0, // common_skill 129
+		0, // common_skill 130
+		0, // common_skill 131
+		0, // common_skill 132
+		0, // common_skill 133
+		0, // common_skill 134
+		0, // common_skill 135
+		0, // common_skill 136
+		0, // job_skill 137
+		0, // job_skill 138
+		0, // job_skill 139
+		0, // job_skill 140
+		0, // common_skill 141
+		0, // common_skill 142
+		0, // common_skill 143
+		0, // common_skill 144
+		0, // common_skill 145
+		0, // common_skill 146
+		0, // common_skill 147
+		0, // common_skill 148
+		0, // common_skill 149
+		0, // common_skill 150
+		0, // common_skill 151
+		0, // job_skill 152
+		0, // job_skill 153
+		0, // job_skill 154
+		0, // job_skill 155
+		0, // job_skill 156
+		0, // job_skill 157
+		0, // empty(reserved) 158
+		0, // empty(reserved) 159
+		0, // empty(reserved) 160
+		0, // empty(reserved) 161
+		0, // empty(reserved) 162
+		0, // empty(reserved) 163
+		0, // empty(reserved) 164
+		0, // empty(reserved) 165
+		0, // empty(reserved) 166
+		0, // empty(reserved) 167
+		0, // empty(reserved) 168
+		0, // empty(reserved) 169
+		51, // job_skill(WOLFMAN SKILL) 170
+		51, // job_skill(WOLFMAN SKILL) 171
+		51, // job_skill(WOLFMAN SKILL) 172
+		51, // job_skill(WOLFMAN SKILL) 173
+		51, // job_skill(WOLFMAN SKILL) 174
+		51, // job_skill(WOLFMAN SKILL) 175
+		0, // job_skill(WARRIOR CONQUEROR SKILL) 176
+		0, // job_skill(ASSASSIN CONQUEROR SKILL) 177
+		0, // job_skill(ASSASSIN CONQUEROR SKILL) 178
+		0, // job_skill(SURA CONQUEROR SKILL) 179
+		0, // job_skill(SURA CONQUEROR SKILL) 180
+		0, // job_skill(SHAMAN CONQUEROR SKILL) 181
+		0, // job_skill(SHAMAN CONQUEROR SKILL) 182
+		0 // job_skill(WOLFMAN CONQUEROR SKILL) 183
+	}; // s_anSkill2JobGroup
+
+	const DWORD MOTION_MAX_NUM = 124;
+	const DWORD SKILL_LIST_MAX_COUNT = 6;
+
+	static DWORD s_anMotion2SkillVnumList[MOTION_MAX_NUM][SKILL_LIST_MAX_COUNT] =
+	{
+		//	킬	營뵀ID	微킬ID	킬ID	營뵀ID	(WOLFMAN) 킬ID
+		{	0,		0,			0,			0,			0,			0		}, // 0 (RESERVED)
+
+		// 1  羞 킬 SKILL GROUP 1 - TRAINING
+		{	5,		1,			31,			61,			91,			170		}, // 1
+		{	5,		2,			32,			62,			92,			171		}, // 2
+		{	5,		3,			33,			63,			93,			172		}, // 3
+		{	5,		4,			34,			64,			94,			173		}, // 4
+		{	5,		5,			35,			65,			95,			174		}, // 5
+		{	5,		6,			36,			66,			96,			175		}, // 6
+		{	0,		0,			0,			0,			0,			0		}, // 7
+		{	0,		0,			0,			0,			0,			0		}, // 8
+		{	5,		176,		177,		179,		181,		183		}, // 9
+		{	0,		0,			0,			0,			0,			0		}, // 10
+		// 1  羞 킬  END
+
+		//  MARGIN
+		{	0,		0,			0,			0,			0,			0		}, // 11
+		{	0,		0,			0,			0,			0,			0		}, // 12
+		{	0,		0,			0,			0,			0,			0		}, // 13
+		{	0,		0,			0,			0,			0,			0		}, // 14
+		{	0,		0,			0,			0,			0,			0		}, // 15
+		//   END
+
+		// 2  羞 킬 SKILL GROUP 2 - TRAINING
+		{	4,		16,			46,			76,			106,		0		}, // 16
+		{	4,		17,			47,			77,			107,		0		}, // 17
+		{	4,		18,			48,			78,			108,		0		}, // 18
+		{	4,		19,			49,			79,			109,		0		}, // 19
+		{	4,		20,			50,			80,			110,		0		}, // 20
+		{	4,		21,			51,			81,			111,		0		}, // 21
+		{	0,		0,			0,			0,			0,			0		}, // 22
+		{	0,		0,			0,			0,			0,			0		}, // 23
+		{	4,		176,		178,		180,		182,		0		}, // 24
+		{	0,		0,			0,			0,			0,			0		}, // 25
+		// 2  羞 킬  END
+
+		// 1   킬 SKILL GROUP 1 - MASTER
+		{	5,		1,			31,			61,			91,			170		}, // 26
+		{	5,		2,			32,			62,			92,			171		}, // 27
+		{	5,		3,			33,			63,			93,			172		}, // 28
+		{	5,		4,			34,			64,			94,			173		}, // 29
+		{	5,		5,			35,			65,			95,			174		}, // 30
+		{	5,		6,			36,			66,			96,			175		}, // 31
+		{	0,		0,			0,			0,			0,			0		}, // 32
+		{	0,		0,			0,			0,			0,			0		}, // 33
+		{	5,		176,		177,		179,		181,		183		}, // 34
+		{	0,		0,			0,			0,			0,			0		}, // 35
+		// 1   킬  END
+
+		//  MARGIN
+		{	0,		0,			0,			0,			0,			0		}, // 36
+		{	0,		0,			0,			0,			0,			0		}, // 37
+		{	0,		0,			0,			0,			0,			0		}, // 38
+		{	0,		0,			0,			0,			0,			0		}, // 39
+		{	0,		0,			0,			0,			0,			0		}, // 40
+		//   END
+
+		// 2   킬 SKILL GROUP 2 - MASTER
+		{	4,		16,			46,			76,			106,		0		}, // 41
+		{	4,		17,			47,			77,			107,		0		}, // 42
+		{	4,		18,			48,			78,			108,		0		}, // 43
+		{	4,		19,			49,			79,			109,		0		}, // 44
+		{	4,		20,			50,			80,			110,		0		}, // 45
+		{	4,		21,			51,			81,			111,		0		}, // 46
+		{	0,		0,			0,			0,			0,			0		}, // 47
+		{	0,		0,			0,			0,			0,			0		}, // 48
+		{	4,		176,		178,		180,		182,		0		}, // 49
+		{	0,		0,			0,			0,			0,			0		}, // 50
+		// 2   킬  END
+
+		// 1  瀏  킬 SKILL GROUP 1 - GRAND MASTER
+		{	5,		1,			31,			61,			91,			170		}, // 51
+		{	5,		2,			32,			62,			92,			171		}, // 52
+		{	5,		3,			33,			63,			93,			172		}, // 53
+		{	5,		4,			34,			64,			94,			173		}, // 54
+		{	5,		5,			35,			65,			95,			174		}, // 55
+		{	5,		6,			36,			66,			96,			175		}, // 56
+		{	0,		0,			0,			0,			0,			0		}, // 57
+		{	0,		0,			0,			0,			0,			0		}, // 58
+		{	5,		176,		177,		179,		181,		183		}, // 59
+		{	0,		0,			0,			0,			0,			0		}, // 60
+		// 1  瀏  킬  END
+
+		//  MARGIN
+		{	0,		0,			0,			0,			0,			0		}, // 61
+		{	0,		0,			0,			0,			0,			0		}, // 62
+		{	0,		0,			0,			0,			0,			0		}, // 63
+		{	0,		0,			0,			0,			0,			0		}, // 64
+		{	0,		0,			0,			0,			0,			0		}, // 65
+		//   END
+
+		// 2  瀏  킬 SKILL GROUP 2 - GRAND MASTER
+		{	4,		16,			46,			76,			106,		0		}, // 66
+		{	4,		17,			47,			77,			107,		0		}, // 67
+		{	4,		18,			48,			78,			108,		0		}, // 68
+		{	4,		19,			49,			79,			109,		0		}, // 69
+		{	4,		20,			50,			80,			110,		0		}, // 70
+		{	4,		21,			51,			81,			111,		0		}, // 71
+		{	0,		0,			0,			0,			0,			0		}, // 72
+		{	0,		0,			0,			0,			0,			0		}, // 73
+		{	4,		176,		178,		180,		182,		0		}, // 74
+		{	0,		0,			0,			0,			0,			0		}, // 75
+		// 2  瀏  킬  END
+
+		// 1  트  킬 SKILL GROUP 1 - PERFECT MASTER
+		{	5,		1,			31,			61,			91,			170		}, // 76
+		{	5,		2,			32,			62,			92,			171		}, // 77
+		{	5,		3,			33,			63,			93,			172		}, // 78
+		{	5,		4,			34,			64,			94,			173		}, // 79
+		{	5,		5,			35,			65,			95,			174		}, // 80
+		{	5,		6,			36,			66,			96,			175		}, // 81
+		{	0,		0,			0,			0,			0,			0		}, // 82
+		{	0,		0,			0,			0,			0,			0		}, // 83
+		{	5,		176,		177,		179,		181,		183		}, // 84
+		{	0,		0,			0,			0,			0,			0		}, // 85
+		// 1  트  킬  END
+
+		//  MARGIN
+		{	0,		0,			0,			0,			0,			0		}, // 86
+		{	0,		0,			0,			0,			0,			0		}, // 87
+		{	0,		0,			0,			0,			0,			0		}, // 88
+		{	0,		0,			0,			0,			0,			0		}, // 89
+		{	0,		0,			0,			0,			0,			0		}, // 90
+		//   END
+
+		// 2  트  킬 SKILL GROUP 2 - PERFECT MASTER
+		{	4,		16,			46,			76,			106,		0		}, // 91
+		{	4,		17,			47,			77,			107,		0		}, // 92
+		{	4,		18,			48,			78,			108,		0		}, // 93
+		{	4,		19,			49,			79,			109,		0		}, // 94
+		{	4,		20,			50,			80,			110,		0		}, // 95
+		{	4,		21,			51,			81,			111,		0		}, // 96
+		{	0,		0,			0,			0,			0,			0		}, // 97
+		{	0,		0,			0,			0,			0,			0		}, // 98
+		{	4,		176,		178,		180,		182,		0		}, // 99
+		{	0,		0,			0,			0,			0,			0		}, // 100
+		// 2  트  킬  END
+
+		//  킬 GUILD SKILLS
+		{	1,		152,		0,			0,			0,			0		}, // 101
+		{	1,		153,		0,			0,			0,			0		}, // 102
+		{	1,		154,		0,			0,			0,			0		}, // 103
+		{	1,		155,		0,			0,			0,			0		}, // 104
+		{	1,		156,		0,			0,			0,			0		}, // 105
+		{	1,		157,		0,			0,			0,			0		}, // 106
+		//  킬  END
+
+		//  MARGIN
+		{	0,		0,			0,			0,			0,			0		}, // 107
+		{	0,		0,			0,			0,			0,			0		}, // 108
+		{	0,		0,			0,			0,			0,			0		}, // 109
+		{	0,		0,			0,			0,			0,			0		}, // 110
+		{	0,		0,			0,			0,			0,			0		}, // 111
+		{	0,		0,			0,			0,			0,			0		}, // 112
+		{	0,		0,			0,			0,			0,			0		}, // 113
+		{	0,		0,			0,			0,			0,			0		}, // 114
+		{	0,		0,			0,			0,			0,			0		}, // 115
+		{	0,		0,			0,			0,			0,			0		}, // 116
+		{	0,		0,			0,			0,			0,			0		}, // 117
+		{	0,		0,			0,			0,			0,			0		}, // 118
+		{	0,		0,			0,			0,			0,			0		}, // 119
+		{	0,		0,			0,			0,			0,			0		}, // 120
+		//   END
+
+		// 쨍 킬 HORSE SKILLS
+		{	2,		137,		140,		0,			0,			0		}, // 121
+		{	1,		138,		0,			0,			0,			0		}, // 122
+		{	1,		139,		0,			0,			0,			0		}, // 123
+		// 쨍 킬  END
+	};
+
+	if (dwMotionIndex >= MOTION_MAX_NUM)
+	{
+		sys_err("OUT_OF_MOTION_VNUM: name=%s, motion=%d/%d", GetName(), dwMotionIndex, MOTION_MAX_NUM);
+		return false;
+	}
+
+	DWORD* skillVNums = s_anMotion2SkillVnumList[dwMotionIndex];
+
+	DWORD skillCount = *skillVNums++;
+	if (skillCount >= SKILL_LIST_MAX_COUNT)
+	{
+		sys_err("OUT_OF_SKILL_LIST: name=%s, count=%d/%d", GetName(), skillCount, SKILL_LIST_MAX_COUNT);
+		return false;
+	}
+
+	for (DWORD skillIndex = 0; skillIndex != skillCount + 2; ++skillIndex)
+	{
+		if (skillIndex >= SKILL_MAX_NUM)
+		{
+			sys_err("OUT_OF_SKILL_VNUM: name=%s, skill=%d/%d", GetName(), skillIndex, SKILL_MAX_NUM);
+			return false;
+		}
+
+		DWORD eachSkillVNum = skillVNums[skillIndex];
+
+		if (eachSkillVNum != 0)
+		{
+			DWORD eachJobGroup = s_anSkill2JobGroup[eachSkillVNum];
+
+			if (0 == eachJobGroup || eachJobGroup == selfJobGroup)
+			{
+				// GUILDSKILL_BUG_FIX
+				DWORD eachSkillLevel = 0;
+
+				if (eachSkillVNum >= GUILD_SKILL_START && eachSkillVNum <= GUILD_SKILL_END)
+				{
+					if (GetGuild())
+						eachSkillLevel = GetGuild()->GetSkillLevel(eachSkillVNum);
+					else
+						eachSkillLevel = 0;
+				}
+#if defined(__9TH_SKILL__)
+				// CONQUEROR_SKILL_BUG_FIX
+				else if (eachSkillVNum >= SKILL_FINISH && eachSkillVNum <= SKILL_ILIPUNGU)
+				{
+					eachSkillLevel = GetSkillLevel(eachSkillVNum);
+				}
+				// END_OF_CONQUEROR_SKILL_BUG_FIX
+#endif
+				else
+				{
+					eachSkillLevel = GetSkillLevel(eachSkillVNum);
+
+					if (test_server)
+					{
+						if (eachSkillLevel <= 0)
+						{
+							sys_err("SKILL_LEVEL: name=%s, skill=%d, level=%d", GetName(), skillIndex, eachSkillLevel);
+							return false;
+						}
+					}
+				}
+
+				if (eachSkillLevel > 0)
+				{
+					return true;
+				}
+
+				// END_OF_GUILDSKILL_BUG_FIX
+			}
+		}
+	}
+
+	return false;
+}
+
+void CHARACTER::ClearSkill()
+{
+	PointChange(POINT_SKILL, 4 + (GetLevel() - 5) - GetPoint(POINT_SKILL));
+
+	ResetSkill();
+}
+
+#if defined(__SKILL_COOLTIME_UPDATE__)
+void CHARACTER::ResetSkillCoolTimes()
+{
+	if (!GetSkillGroup() || m_SkillUseInfo.empty())
+		return;
+
+	for (std::map<int, TSkillUseInfo>::iterator it = m_SkillUseInfo.begin(); it != m_SkillUseInfo.end(); ++it)
+		it->second.dwNextSkillUsableTime = 0;
+}
+#endif
+
+void CHARACTER::ClearSubSkill()
+{
+	PointChange(POINT_SUB_SKILL, GetLevel() < 10 ? 0 : (GetLevel() - 9) - GetPoint(POINT_SUB_SKILL));
+
+	if (m_pSkillLevels == NULL)
+	{
+		sys_err("m_pSkillLevels nil (name: %s)", GetName());
+		return;
+	}
+
+	TPlayerSkill CleanSkill;
+	memset(&CleanSkill, 0, sizeof(TPlayerSkill));
+
+	size_t count = sizeof(s_adwSubSkillVnums) / sizeof(s_adwSubSkillVnums[0]);
+
+	for (size_t i = 0; i < count; ++i)
+	{
+		if (s_adwSubSkillVnums[i] >= SKILL_MAX_NUM)
+			continue;
+
+		m_pSkillLevels[s_adwSubSkillVnums[i]] = CleanSkill;
+	}
+
+	ComputePoints();
+	SkillLevelPacket();
+}
+
+bool CHARACTER::ResetOneSkill(DWORD dwVnum)
+{
+	if (NULL == m_pSkillLevels)
+	{
+		sys_err("m_pSkillLevels nil (name %s, vnum %u)", GetName(), dwVnum);
+		return false;
+	}
+
+	if (dwVnum >= SKILL_MAX_NUM)
+	{
+		sys_err("vnum overflow (name %s, vnum %u)", GetName(), dwVnum);
+		return false;
+	}
+
+	BYTE level = m_pSkillLevels[dwVnum].bLevel;
+
+	m_pSkillLevels[dwVnum].bLevel = 0;
+	m_pSkillLevels[dwVnum].bMasterType = 0;
+	m_pSkillLevels[dwVnum].tNextRead = 0;
+
+	if (level > 17)
+		level = 17;
+
+	PointChange(POINT_SKILL, level);
+
+	LogManager::instance().CharLog(this, dwVnum, "ONE_SKILL_RESET_BY_SCROLL", "");
+
+	ComputePoints();
+	SkillLevelPacket();
+
+	return true;
+}
+
+bool CHARACTER::CanUseSkill(DWORD dwSkillVnum) const
+{
+	if (0 == dwSkillVnum) return false;
+
+	if (0 < GetSkillGroup())
+	{
+		const int SKILL_COUNT = 7;
+		static const DWORD SkillList[JOB_MAX_NUM][SKILL_GROUP_MAX_NUM][SKILL_COUNT] =
+		{
+			{ { 1, 2, 3, 4, 5, 6, 176 }, { 16, 17, 18, 19, 20, 21, 176 } },
+			{ { 31, 32, 33, 34, 35, 36, 177 }, { 46, 47, 48, 49, 50, 51, 178 } },
+			{ { 61, 62, 63, 64, 65, 66, 179 }, { 76, 77, 78, 79, 80, 81, 180 } },
+			{ { 91, 92, 93, 94, 95, 96, 181 }, { 106, 107, 108, 109, 110, 111, 182 } },
+			{ { 170, 171, 172, 173, 174, 175, 183 }, { 0, 0, 0, 0, 0, 0, 0 } },
+		};
+
+		const BYTE bJob = GetJob();
+		const BYTE bGroup = GetSkillGroup();
+		if (bJob >= JOB_MAX_NUM)
+			return false;
+		if (bGroup == 0 || bGroup > SKILL_GROUP_MAX_NUM)
+			return false;
+
+		const DWORD* pSkill = SkillList[bJob][bGroup - 1];
+
+		for (int i = 0; i < SKILL_COUNT; ++i)
+		{
+			if (pSkill[i] == dwSkillVnum) return true;
+		}
+	}
+
+	//if (true == IsHorseRiding())
+
+	if (true == IsRiding())
+	{
+		//트 탈 貧 킬 諛
+		/*
+		if (GetMountVnum())
+		{
+			if (!((GetMountVnum() >= 20209 && GetMountVnum() <= 20212) ||
+				GetMountVnum() == 20215 || GetMountVnum() == 20218 || GetMountVnum() == 20225))
+				return false;
+		}
+		*/
+
+		switch (dwSkillVnum)
+		{
+			case SKILL_HORSE_WILDATTACK:
+			case SKILL_HORSE_CHARGE:
+			case SKILL_HORSE_ESCAPE:
+			case SKILL_HORSE_WILDATTACK_RANGE:
+				return true;
+		}
+	}
+
+	switch (dwSkillVnum)
+	{
+		case SKILL_LEADERSHIP:
+		case SKILL_COMBO:
+		case SKILL_CREATE:
+		case SKILL_MINING:
+		case SKILL_LANGUAGE1:
+		case SKILL_LANGUAGE2:
+		case SKILL_LANGUAGE3:
+		case SKILL_POLYMORPH:
+		case SKILL_HORSE:
+		case SKILL_HORSE_SUMMON:
+#if defined(__PARTY_PROFICY__)
+		case SKILL_ROLE_PROFICIENCY:
+#endif
+#if defined(__PARTY_INSIGHT__)
+		case SKILL_INSIGHT:
+#endif
+		case SKILL_HIT:
+		case SKILL_ADD_HP:
+		case SKILL_RESIST_PENETRATE:
+		case GUILD_SKILL_EYE:
+		case GUILD_SKILL_BLOOD:
+		case GUILD_SKILL_BLESS:
+		case GUILD_SKILL_SEONGHWI:
+		case GUILD_SKILL_ACCEL:
+		case GUILD_SKILL_BUNNO:
+		case GUILD_SKILL_JUMUN:
+		case GUILD_SKILL_TELEPORT:
+		case GUILD_SKILL_DOOR:
+			return true;
+
+		// [Security Fix] Horse combat skills must not be usable while not mounted (prevents packet injection)
+		case SKILL_HORSE_WILDATTACK:
+		case SKILL_HORSE_CHARGE:
+		case SKILL_HORSE_ESCAPE:
+		case SKILL_HORSE_WILDATTACK_RANGE:
+			return IsRiding();
+	}
+
+	return false;
+}
+
+bool CHARACTER::CheckSkillHitCount(const BYTE SkillID, const VID TargetVID)
+{
+	std::map<int, TSkillUseInfo>::iterator iter = m_SkillUseInfo.find(SkillID);
+
+	if (iter == m_SkillUseInfo.end())
+	{
+		sys_log(0, "SkillHack: Skill(%u) is not in container", SkillID);
+		return false;
+	}
+
+	TSkillUseInfo& rSkillUseInfo = iter->second;
+
+	if (false == rSkillUseInfo.bUsed)
+	{
+		sys_log(0, "SkillHack: not used skill(%u)", SkillID);
+		return false;
+	}
+
+	switch (SkillID)
+	{
+		case SKILL_YONGKWON:
+		case SKILL_HWAYEOMPOK:
+		case SKILL_DAEJINGAK:
+		case SKILL_PAERYONG:
+#if defined(__9TH_SKILL__)
+		case SKILL_METEO:
+#endif
+			sys_log(0, "SkillHack: cannot use attack packet for skill(%u)", SkillID);
+			return false;
+	}
+
+	auto iterTargetMap = rSkillUseInfo.TargetVIDMap.find(TargetVID);
+
+	if (rSkillUseInfo.TargetVIDMap.end() != iterTargetMap)
+	{
+		size_t MaxAttackCountPerTarget = 1;
+
+		switch (SkillID)
+		{
+			case SKILL_SAMYEON:
+			case SKILL_CHARYUN:
+			case SKILL_CHAYEOL:
+				MaxAttackCountPerTarget = 3;
+				break;
+
+			case SKILL_HORSE_WILDATTACK_RANGE:
+				MaxAttackCountPerTarget = 5;
+				break;
+
+			case SKILL_YEONSA:
+				MaxAttackCountPerTarget = 7;
+				break;
+
+			case SKILL_HORSE_ESCAPE:
+				MaxAttackCountPerTarget = 10;
+				break;
+		}
+
+		if (iterTargetMap->second >= MaxAttackCountPerTarget)
+		{
+			sys_log(0, "SkillHack: Too Many Hit count from SkillID(%u) count(%u)", SkillID, iterTargetMap->second);
+			return false;
+		}
+
+		iterTargetMap->second++;
+	}
+	else
+	{
+		rSkillUseInfo.TargetVIDMap.insert(std::make_pair(TargetVID, 1));
+	}
+
+	return true;
+}
diff --git a/server/metin2/Source/Server/game/src/cube.cpp b/server/metin2/Source/Server/game/src/cube.cpp
index d9b72d9..061c059 100644
--- a/server/metin2/Source/Server/game/src/cube.cpp
+++ b/server/metin2/Source/Server/game/src/cube.cpp
@@ -1,1536 +1,1552 @@
-#include "stdafx.h"
-
-#if defined(__CUBE_RENEWAL__)
-/**
-* Filename: cube.cpp
-* Author: Owsap
-**/
-
-#include "cube.h"
-#include "char.h"
-#include "item.h"
-#include "desc.h"
-#include "locale_service.h"
-#include "utils.h"
-#if defined(__QUEST_EVENT_CRAFT__)
-#	include "questmanager.h"
-#endif
-
-#include <fstream>
-#include <cryptopp/crc.h>
-#include <cryptopp/files.h>
-#include <cryptopp/filters.h>
-
-CCubeManager::CCubeManager()
-{
-	m_vCubeData.clear();
-	m_dwFileCrc = 0;
-}
-
-CCubeManager::~CCubeManager()
-{
-	m_vCubeData.clear();
-	m_dwFileCrc = 0;
-}
-
-void CCubeManager::Initialize()
-{
-	char szCubeFileTable[256 + 1];
-	snprintf(szCubeFileTable, sizeof(szCubeFileTable), "%s/cube.txt", LocaleService_GetBasePath().c_str());
-
-	LoadCubeTable(szCubeFileTable);
-	sys_log(0, "cube: initialize");
-}
-
-void CCubeManager::LoadCubeTable(const char* szFileName)
-{
-	m_vCubeData.clear();
-
-	std::ifstream ifStream(szFileName);
-	if (!ifStream.is_open())
-	{
-		sys_err("cube: load cube table error: failed to open %s", szFileName);
-		return;
-	}
-
-	{
-		CryptoPP::CRC32 Crc32;
-		CryptoPP::byte szBuffer[4096];
-
-		std::ifstream ifStream(szFileName, std::ios::binary);
-		while (!ifStream.eof())
-		{
-			ifStream.read(reinterpret_cast<char*>(szBuffer), sizeof(szBuffer));
-			Crc32.Update(szBuffer, ifStream.gcount());
-		}
-
-		CryptoPP::byte bDigest[CryptoPP::CRC32::DIGESTSIZE];
-		Crc32.Final(bDigest);
-
-		m_dwFileCrc = *reinterpret_cast<DWORD*>(bDigest);
-	}
-
-	CubeDataPtr pCubeData = nullptr;
-	SCubeValue CubeValue = { 0, 0 };
-	UINT iCubeIndex = 0;
-
-	std::string stLine;
-	while (std::getline(ifStream, stLine))
-	{
-		if (stLine.empty() || stLine[0] == '#')
-			continue;
-
-		std::istringstream isStream(stLine);
-		std::string stToken;
-		isStream >> stToken;
-
-		if (stToken == "section")
-			pCubeData = std::make_unique<SCubeData>();
-		else if (stToken == "npc")
-			isStream >> pCubeData->dwNPCVnum;
-		else if (stToken == "item")
-		{
-			isStream >> CubeValue.dwVnum >> CubeValue.iCount;
-			pCubeData->vItem.emplace_back(CubeValue);
-		}
-		else if (stToken == "reward")
-		{
-			isStream >> CubeValue.dwVnum >> CubeValue.iCount;
-			pCubeData->Reward = CubeValue;
-		}
-		else if (stToken == "percent")
-			isStream >> pCubeData->iPercent;
-		else if (stToken == "gold")
-			isStream >> pCubeData->iGold;
-		else if (stToken == "gem")
-			isStream >> pCubeData->iGem;
-#if defined(__SET_ITEM__)
-		else if (stToken == "set_value")
-			isStream >> pCubeData->iSetValue;
-		else if (stToken == "not_remove")
-			isStream >> pCubeData->dwNotRemove;
-#endif
-		else if (stToken == "category")
-		{
-			std::string stCategory;
-			isStream >> stCategory;
-			pCubeData->iCategory = GetCubeCategory(stCategory);
-		}
-		else if (stToken == "subcategory")
-			isStream >> pCubeData->iSubCategory;
-		else if (stToken == "end")
-		{
-			if (pCubeData && CheckCubeData(pCubeData))
-			{
-				pCubeData->iIndex = ++iCubeIndex;
-				m_vCubeData.emplace_back(std::move(pCubeData));
-			}
-			else
-			{
-				pCubeData.reset();
-				continue;
-			}
-		}
-	}
-
-	ifStream.close();
-}
-
-bool CCubeManager::CheckCubeData(const CubeDataPtr& pkCubeData)
-{
-	std::size_t dwIndex = 0;
-	std::size_t dwEndIndex = 0;
-
-	if (pkCubeData->dwNPCVnum == 0)
-		return false;
-
-	dwEndIndex = pkCubeData->vItem.size();
-	for (dwIndex = 0; dwIndex < dwEndIndex; ++dwIndex)
-	{
-		if (pkCubeData->vItem[dwIndex].dwVnum == 0)
-			return false;
-
-		if (pkCubeData->vItem[dwIndex].iCount == 0)
-			return false;
-	}
-
-	if (pkCubeData->Reward.dwVnum == 0)
-		return false;
-
-	if (pkCubeData->Reward.iCount == 0)
-		return false;
-
-	return true;
-}
-
-const CCubeManager::SCubeData& CCubeManager::GetCubeData(const DWORD dwNPCVnum, const UINT iCubeIndex)
-{
-	for (const CubeDataPtr& pkCubeData : m_vCubeData)
-	{
-		if (pkCubeData->dwNPCVnum == dwNPCVnum && pkCubeData->iIndex == iCubeIndex)
-			return *pkCubeData;
-	}
-	throw std::runtime_error("cube data not found");
-}
-
-bool CCubeManager::CheckValidNPC(const DWORD dwNPCVnum)
-{
-	for (const CubeDataPtr& pkCubeData : m_vCubeData)
-	{
-		if (pkCubeData->dwNPCVnum == dwNPCVnum)
-			return true;
-	}
-	return false;
-}
-
-void CCubeManager::OpenCube(const LPCHARACTER pChar)
-{
-	if (pChar == nullptr)
-		return;
-
-	const LPDESC pDesc = pChar->GetDesc();
-	if (pDesc == nullptr)
-		return;
-
-	if (pChar->IsCubeOpen())
-		return;
-
-	const LPCHARACTER pNPC = pChar->GetQuestNPC();
-	if (pNPC == nullptr)
-	{
-		if (test_server)
-			sys_log(0, "cube: ch %s error: cannot find quest npc", pChar->GetName());
-		return;
-	}
-
-	if (CheckValidNPC(pNPC->GetRaceNum()) == false)
-	{
-		if (test_server)
-		{
-			sys_log(0, "cube: npc %d ch %s error: cannot find cube for npc",
-				pNPC->GetRaceNum(), pChar->GetName());
-		}
-		return;
-	}
-
-	if (pChar->PreventTradeWindow(WND_CUBE, true/*except*/))
-	{
-		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중일경우 개인상점을 열수가 없습니다."));
-		return;
-	}
-
-	if (pChar->IsCubeOpen())
-	{
-		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("제조창이 열려있지 않습니다"));
-		return;
-	}
-
-	int iDistance = DISTANCE_APPROX(pChar->GetX() - pNPC->GetX(), pChar->GetY() - pNPC->GetY());
-	if (iDistance >= CUBE_MAX_DISTANCE)
-	{
-		sys_log(0, "cube: npc %d ch %s distance %d error: too far to open",
-			pNPC->GetRaceNum(), pChar->GetName(), iDistance);
-		return;
-	}
-
-	pChar->SetCubeNpc(pNPC);
-	Process(pChar->GetDesc(), SUBHEADER_GC_CUBE_OPEN, pNPC->GetRaceNum());
-}
-
-void CCubeManager::CloseCube(const LPCHARACTER pChar)
-{
-	if (pChar->IsCubeOpen())
-		pChar->SetCubeNpc(nullptr);
-}
-
-std::vector<TItemData> GenerateRewardItems(const CCubeManager::SCubeData& pkCube, const LPCHARACTER pChar, const INT iMultiplier)
-{
-	std::vector<TItemData> vRewardItem;
-	for (INT iCount = 0; iCount < pkCube.Reward.iCount * iMultiplier;)
-	{
-		const TItemTable* pItemTable = ITEM_MANAGER::Instance().GetTable(pkCube.Reward.dwVnum);
-		if (!pItemTable)
-		{
-			sys_log(0, "cube: npc %d index(%d) ch %s error: failed to create item",
-				pkCube.dwNPCVnum, pkCube.iIndex, pChar->GetName());
-			throw std::runtime_error("failed to get item table");
-		}
-
-		TItemData ItemData;
-		ItemData.dwVnum = pItemTable->dwVnum;
-
-		if (IS_SET(pItemTable->dwFlags, ITEM_FLAG_STACKABLE))
-		{
-			ItemData.dwCount = MIN(ITEM_MAX_COUNT, pkCube.Reward.iCount * iMultiplier - iCount);
-			iCount += ItemData.dwCount;
-		}
-		else
-		{
-			ItemData.dwCount = 1;
-			iCount += 1;
-		}
-
-		vRewardItem.emplace_back(ItemData);
-	}
-
-	return vRewardItem;
-}
-
-void CCubeManager::MakeCube(const LPCHARACTER pChar, const UINT iCubeIndex, INT iMultiplier, const INT iImproveItemPos)
-{
-	if (pChar->IsCubeOpen() == false)
-		return;
-
-	const LPCHARACTER pNPC = pChar->GetQuestNPC();
-	if (pNPC == nullptr)
-		return;
-
-	try
-	{
-		const SCubeData& pkCube = GetCubeData(pNPC->GetRaceNum(), iCubeIndex);
-
-#if defined(__SET_ITEM__)
-		if (IsCubeSetAddCategory(pkCube.iCategory) && pkCube.iSetValue)
-		{
-			if (iMultiplier != 1)
-			{
-				sys_log(0, "cube: npc %d index(%d) ch %s warning: cannot craft multiple set items",
-					pkCube.dwNPCVnum, pkCube.iIndex, pChar->GetName());
-			}
-			iMultiplier = 1;
-		}
-#endif
-
-		if (pChar->GetGold() < pkCube.iGold * iMultiplier)
-		{
-			pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang."));
-			return;
-		}
-
-		if (pChar->GetGem() < pkCube.iGem * iMultiplier)
-		{
-			pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Gaya."));
-			return;
-		}
-
-		for (const SCubeValue& kMaterial : pkCube.vItem)
-		{
-			INT iCount = pChar->CountSpecifyItem(kMaterial.dwVnum, -1
-#if defined(__SOUL_BIND_SYSTEM__)
-				, true /* bIgnoreSealedItem */
-#endif
-#if defined(__SET_ITEM__)
-				, pkCube.iSetValue ? true : false /* bIgnoreSetValue */
-#endif
-			);
-
-			INT iMaterialCount = MINMAX(1, kMaterial.iCount * iMultiplier, CUBE_MAX_MATERIAL_QUANTITY);
-			if (iCount < iMaterialCount)
-			{
-				pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have insufficient materials for the upgrade. (Soulbound items cannot be used.)"));
-				return;
-			}
-		}
-
-		std::vector<TItemData> vRewardItem = GenerateRewardItems(pkCube, pChar, iMultiplier);
-		if (vRewardItem.empty())
-		{
-			sys_log(0, "cube: npc %d index(%d) ch %s error: failed to generate reward item",
-				pkCube.dwNPCVnum, pkCube.iIndex, pChar->GetName());
-			return;
-		}
-
-		if (pChar->HasEnoughInventorySpace(vRewardItem) == false)
-		{
-			pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("There isn't enough space in your inventory."));
-			sys_log(0, "cube: npc %d index(%d) ch %s error: no inventory space reward",
-				pNPC->GetRaceNum(), iCubeIndex, pChar->GetName());
-			return;
-		}
-
-		LPITEM pNotRemoveItem = nullptr;
-		for (const SCubeValue& kMaterial : pkCube.vItem)
-		{
-			if (pkCube.dwNotRemove == kMaterial.dwVnum)
-			{
-				pNotRemoveItem = pChar->FindSpecifyItem(pkCube.dwNotRemove
-#if defined(__SOUL_BIND_SYSTEM__)
-					, true /* bIgnoreSealedItem */
-#endif
-#if defined(__SET_ITEM__)
-					, pkCube.iSetValue ? true : false /* bIgnoreSetValue */
-#endif
-				);
-				continue;
-			}
-
-			INT iMaterialCount = MINMAX(1, kMaterial.iCount * iMultiplier, CUBE_MAX_MATERIAL_QUANTITY);
-			pChar->RemoveSpecifyItem(kMaterial.dwVnum, iMaterialCount, -1
-#if defined(__SOUL_BIND_SYSTEM__)
-				, true /* bIgnoreSealedItem */
-#endif
-#if defined(__SET_ITEM__)
-				, pkCube.iSetValue ? true : false /* bIgnoreSetValue */
-#endif
-			);
-		}
-
-		if (pkCube.iGold > 0)
-			pChar->PointChange(POINT_GOLD, -(pkCube.iGold * iMultiplier), false);
-
-		if (pkCube.iGem > 0)
-			pChar->PointChange(POINT_GEM, -(pkCube.iGem * iMultiplier), false);
-
-		INT iImprovePercent = 0;
-		LPITEM pImproveItem = nullptr;
-		if (iImproveItemPos != -1)
-		{
-			pImproveItem = pChar->GetItem(TItemPos(INVENTORY, iImproveItemPos));
-			if (pImproveItem && pkCube.iPercent < 100)
-			{
-				if (pImproveItem->GetSubType() == pkCube.iCategory)
-				{
-					if (pImproveItem->GetCount() < iMultiplier)
-					{
-						sys_log(0, "cube: npc %d index(%d) ch %s error: not enough catalyst for multiplier",
-							pNPC->GetRaceNum(), iCubeIndex, pChar->GetName());
-						return;
-					}
-
-					iImprovePercent = pImproveItem->GetValue(0);
-					pImproveItem->SetCount(pImproveItem->GetCount() - iMultiplier);
-
-					if (test_server)
-						pChar->ChatPacket(CHAT_TYPE_INFO, "cube using catalyst pct %d total success pct %d",
-							iImprovePercent, pkCube.iPercent + iImprovePercent);
-				}
-				else
-				{
-					sys_log(0, "cube: npc %d index(%d) ch %s (possible cheat) error: using catalyst wrong category",
-						pNPC->GetRaceNum(), iCubeIndex, pChar->GetName());
-				}
-			}
-		}
-
-#if defined(__QUEST_EVENT_CRAFT__)
-		LPITEM pLastRewardItem = nullptr;
-#endif
-		for (const TItemData& kRewardItem : vRewardItem)
-		{
-			BYTE bPercent = number(1, 100);
-			if (bPercent > pkCube.iPercent + iImprovePercent)
-			{
-				Process(pChar->GetDesc(), SUBHEADER_GC_CUBE_RESULT, 0, false);
-				continue;
-			}
-
-			LPITEM pRewardItem = ITEM_MANAGER::Instance().CreateItem(kRewardItem.dwVnum, kRewardItem.dwCount);
-			if (pRewardItem == nullptr)
-				continue;
-
-			if (pRewardItem->GetVnum() == pkCube.dwNotRemove)
-			{
-				if (pNotRemoveItem == nullptr)
-				{
-					sys_log(0, "cube: npc %d index(%d) ch %s (possible cheat) error: cannot find material %d",
-						pNPC->GetRaceNum(), iCubeIndex, pChar->GetName(), pkCube.dwNotRemove);
-					continue;
-				}
-
-				ITEM_MANAGER::CopyAllAttrTo(pNotRemoveItem, pRewardItem);
-#if defined(__ITEM_APPLY_RANDOM__)
-				TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-				pNotRemoveItem->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_CURRENT);
-				if (aApplyRandom)
-					pRewardItem->SetRandomApplies(aApplyRandom);
-#endif
-#if defined(__SET_ITEM__)
-				pRewardItem->SetItemSetValue(pkCube.iSetValue);
-#endif
-				ITEM_MANAGER::instance().RemoveItem(pNotRemoveItem, "CUBE COPY");
-			}
-			else
-			{
-				// NOTE : Removes the `not_remove` item if the craft succeeds.
-				// This condition is only true if `reward` != `not_remove`.
-				if (pNotRemoveItem != nullptr)
-					ITEM_MANAGER::instance().RemoveItem(pNotRemoveItem, "CUBE");
-			}
-
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			pChar->AutoGiveItem(pRewardItem, false, true, true);
-#else
-			pChar->AutoGiveItem(pRewardItem);
-#endif
-
-#if defined(__QUEST_EVENT_CRAFT__)
-			pLastRewardItem = pRewardItem;
-#endif
-
-			Process(pChar->GetDesc(), SUBHEADER_GC_CUBE_RESULT, 0, true);
-		}
-
-#if defined(__QUEST_EVENT_CRAFT__)
-		if (pLastRewardItem != nullptr)
-		{
-			pChar->SetQuestNPCID(pNPC->GetVID());
-			quest::CQuestManager::instance().CraftItem(pChar->GetPlayerID(), pNPC->GetRaceNum(), pLastRewardItem);
-		}
-#endif
-	}
-	catch (const std::runtime_error& kError)
-	{
-		sys_err("cube: npc %d index(%d) ch %s error: %s",
-			pNPC->GetRaceNum(), iCubeIndex, pChar->GetName(), kError.what());
-		return;
-	}
-}
-
-void CCubeManager::Process(LPDESC pDesc, BYTE bSubHeader, DWORD dwNPCVnum, bool bSuccess)
-{
-	if (pDesc)
-	{
-		TPacketGCCube Packet;
-		Packet.bHeader = HEADER_GC_CUBE;
-		Packet.bSubHeader = bSubHeader;
-		Packet.dwNPCVnum = dwNPCVnum;
-		Packet.bSuccess = bSuccess;
-		Packet.dwFileCrc = m_dwFileCrc;
-		pDesc->Packet(&Packet, sizeof(TPacketGCCube));
-	}
-}
-
-bool CCubeManager::IsCubeSetAddCategory(const BYTE bCategory) const
-{
-	switch (bCategory)
-	{
-		case CUBE_SETADD_WEAPON:
-		case CUBE_SETADD_ARMOR_BODY:
-		case CUBE_SETADD_ARMOR_HELMET:
-			return true;
-	}
-	return false;
-}
-
-INT CCubeManager::GetCubeCategory(const std::string& rkCategory) const
-{
-	CategoryNameMap::const_iterator it = g_map_CubeCategoryName.find(rkCategory);
-	return (it != g_map_CubeCategoryName.end() ? it->second : -1);
-}
-#else
-/**
-* File : cube.cpp
-* Date : 2006.11.20
-* Author : mhh
-* Description :
-**/
-
-#include "constants.h"
-#include "utils.h"
-#include "log.h"
-#include "char.h"
-#include "dev_log.h"
-#include "locale_service.h"
-#include "item.h"
-#include "item_manager.h"
-#if defined(__QUEST_EVENT_CRAFT__)
-#	include "questmanager.h"
-#endif
-
-#include <sstream>
-
-extern int test_server;
-
-#define RETURN_IF_CUBE_IS_NOT_OPENED(ch) if (!(ch)->IsCubeOpen()) return
-
-/*
-* Global Variables
-*/
-static std::vector<CUBE_DATA*> s_cube_proto;
-static bool s_isInitializedCubeMaterialInformation = false;
-
-/*
-* Cube Material Information
-*/
-enum ECubeResultCategory
-{
-	CUBE_CATEGORY_POTION, // 약초, 진액 등등.. (포션으로 특정할 수 없으니 사용 안 함. 약초같은건 다 걍 기타)
-	CUBE_CATEGORY_WEAPON, // 무기
-	CUBE_CATEGORY_ARMOR, // 방어구
-	CUBE_CATEGORY_ACCESSORY, // 장신구
-	CUBE_CATEGORY_ETC, // 기타 등등...
-};
-
-typedef std::vector<CUBE_VALUE> TCubeValueVector;
-
-struct SCubeMaterialInfo
-{
-	SCubeMaterialInfo()
-	{
-		bHaveComplicateMaterial = false;
-	};
-
-	CUBE_VALUE reward; // 보상이 뭐냐
-	TCubeValueVector material; // 재료들은 뭐냐
-	DWORD gold; // 돈은 얼마드냐
-	TCubeValueVector complicateMaterial; // 복잡한-_- 재료들
-
-	// .. 클라이언트에서 재료를 보여주기 위하여 약속한 포맷
-	// 72723,1&72724,2&72730,1
-	// 52001,1|52002,1|52003,1&72723,1&72724,5
-	// => ( 52001,1 or 52002,1 or 52003,1 ) and 72723,1 and 72724,5
-	std::string infoText;
-	bool bHaveComplicateMaterial; //
-};
-
-struct SItemNameAndLevel
-{
-	SItemNameAndLevel() { level = 0; }
-
-	std::string name;
-	int level;
-};
-
-// 자료구조나 이런거 병신인건 이해좀... 누구땜에 영혼이 없는 상태에서 만들었씀
-typedef std::vector<SCubeMaterialInfo> TCubeResultList;
-typedef std::unordered_map<DWORD, TCubeResultList> TCubeMapByNPC; // 각각의 NPC별로 어떤 걸 만들 수 있고 재료가 뭔지...
-typedef std::unordered_map<DWORD, std::string> TCubeResultInfoTextByNPC; // 각각의 NPC별로 만들 수 있는 목록을 정해진 포맷으로 정리한 정보
-
-TCubeMapByNPC cube_info_map;
-TCubeResultInfoTextByNPC cube_result_info_map_by_npc; // 네이밍 존나 병신같다 ㅋㅋㅋ
-
-class CCubeMaterialInfoHelper
-{
-public:
-public:
-};
-
-/*
-* Static Functions
-*/
-// 필요한 아이템 개수를 가지고있는가?
-static bool FN_check_item_count(LPITEM* items, DWORD item_vnum, int need_count)
-{
-	int count = 0;
-
-	// for all cube
-	for (int i = 0; i < CUBE_MAX_NUM; ++i)
-	{
-		if (NULL == items[i]) continue;
-
-		if (item_vnum == items[i]->GetVnum())
-		{
-			count += items[i]->GetCount();
-		}
-	}
-
-	return (count >= need_count);
-}
-
-// 큐브내의 재료를 지운다.
-static void FN_remove_material(LPITEM* items, DWORD item_vnum, int need_count)
-{
-	int count = 0;
-	LPITEM item = NULL;
-
-	// for all cube
-	for (int i = 0; i < CUBE_MAX_NUM; ++i)
-	{
-		if (NULL == items[i]) continue;
-
-		item = items[i];
-
-		if (item->IsEquipped() == true)
-			continue;
-
-		if (item_vnum == item->GetVnum())
-		{
-			count += item->GetCount();
-
-			if (count > need_count)
-			{
-				item->SetCount(count - need_count);
-				return;
-			}
-			else
-			{
-				item->SetCount(0);
-				items[i] = NULL;
-			}
-		}
-	}
-}
-
-static CUBE_DATA* FN_find_cube(LPITEM* items, WORD npc_vnum)
-{
-	DWORD i, end_index;
-
-	if (0 == npc_vnum) return NULL;
-
-	// FOR ALL CUBE_PROTO
-	end_index = s_cube_proto.size();
-	for (i = 0; i < end_index; ++i)
-	{
-		if (s_cube_proto[i]->can_make_item(items, npc_vnum))
-			return s_cube_proto[i];
-	}
-
-	return NULL;
-}
-
-static bool FN_check_valid_npc(WORD vnum)
-{
-	for (std::vector<CUBE_DATA*>::iterator iter = s_cube_proto.begin(); iter != s_cube_proto.end(); iter++)
-	{
-		if (std::find((*iter)->npc_vnum.begin(), (*iter)->npc_vnum.end(), vnum) != (*iter)->npc_vnum.end())
-			return true;
-	}
-
-	return false;
-}
-
-// 큐브데이타가 올바르게 초기화 되었는지 체크한다.
-static bool FN_check_cube_data(CUBE_DATA* cube_data)
-{
-	DWORD i = 0;
-	DWORD end_index = 0;
-
-	end_index = cube_data->npc_vnum.size();
-	for (i = 0; i < end_index; ++i)
-	{
-		if (cube_data->npc_vnum[i] == 0) return false;
-	}
-
-	end_index = cube_data->item.size();
-	for (i = 0; i < end_index; ++i)
-	{
-		if (cube_data->item[i].vnum == 0) return false;
-		if (cube_data->item[i].count == 0) return false;
-	}
-
-	end_index = cube_data->reward.size();
-	for (i = 0; i < end_index; ++i)
-	{
-		if (cube_data->reward[i].vnum == 0) return false;
-		if (cube_data->reward[i].count == 0) return false;
-	}
-
-	return true;
-}
-
-CUBE_DATA::CUBE_DATA()
-{
-	this->percent = 0;
-	this->gold = 0;
-#if defined(__CUBE_RENEWAL__)
-	this->not_remove = 0; // nothing to remove
-#endif
-}
-
-// 필요한 재료의 수량을 만족하는지 체크한다.
-bool CUBE_DATA::can_make_item(LPITEM* items, WORD npc_vnum)
-{
-	// 필요한 재료, 수량을 만족하는지 체크한다.
-	DWORD i, end_index;
-	DWORD need_vnum;
-	int need_count;
-	int found_npc = false;
-
-	// check npc_vnum
-	end_index = this->npc_vnum.size();
-	for (i = 0; i < end_index; ++i)
-	{
-		if (npc_vnum == this->npc_vnum[i])
-			found_npc = true;
-	}
-	if (false == found_npc) return false;
-
-	end_index = this->item.size();
-	for (i = 0; i < end_index; ++i)
-	{
-		need_vnum = this->item[i].vnum;
-		need_count = this->item[i].count;
-
-		if (false == FN_check_item_count(items, need_vnum, need_count))
-			return false;
-	}
-
-	return true;
-}
-
-// 큐브를 돌렸을때 나오는 아이템의 종류를 결정함
-CUBE_VALUE* CUBE_DATA::reward_value()
-{
-	int end_index = 0;
-	DWORD reward_index = 0;
-
-	end_index = this->reward.size();
-	reward_index = number(0, end_index);
-	reward_index = number(0, end_index - 1);
-
-	return &this->reward[reward_index];
-}
-
-// 큐브에 들어있는 재료를 지운다
-void CUBE_DATA::remove_material(LPCHARACTER ch)
-{
-	DWORD i, end_index;
-	DWORD need_vnum;
-	int need_count;
-	LPITEM* items = ch->GetCubeItem();
-
-	end_index = this->item.size();
-	for (i = 0; i < end_index; ++i)
-	{
-		need_vnum = this->item[i].vnum;
-		need_count = this->item[i].count;
-
-#if defined(__CUBE_RENEWAL__)
-		if (this->not_remove == need_vnum)
-			continue;
-#endif
-
-		FN_remove_material(items, need_vnum, need_count);
-	}
-}
-
-void Cube_clean_item(LPCHARACTER ch)
-{
-	LPITEM* cube_item;
-
-	cube_item = ch->GetCubeItem();
-
-	for (int i = 0; i < CUBE_MAX_NUM; ++i)
-	{
-		if (NULL == cube_item[i])
-			continue;
-
-		cube_item[i] = NULL;
-	}
-}
-
-// 큐브창 열기
-void Cube_open(LPCHARACTER ch)
-{
-	const auto reload = !s_isInitializedCubeMaterialInformation;
-
-	if (false == s_isInitializedCubeMaterialInformation)
-	{
-		Cube_InformationInitialize();
-	}
-
-	if (NULL == ch)
-		return;
-
-	LPCHARACTER npc;
-	npc = ch->GetQuestNPC();
-	if (NULL == npc)
-	{
-		if (test_server)
-			dev_log(LOG_DEB0, "cube_npc is NULL");
-		return;
-	}
-
-	if (FN_check_valid_npc(npc->GetRaceNum()) == false)
-	{
-		if (test_server == true)
-		{
-			dev_log(LOG_DEB0, "cube not valid NPC");
-		}
-		return;
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (ch->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || ch->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
-		return;
-	}
-#endif
-
-	if (ch->IsCubeOpen())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 제조창이 열려있습니다."));
-		return;
-	}
-
-	if (ch->PreventTradeWindow(WND_ALL))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중(창고,교환,상점)에는 사용할 수 없습니다."));
-		return;
-	}
-
-	long distance = DISTANCE_APPROX(ch->GetX() - npc->GetX(), ch->GetY() - npc->GetY());
-
-	if (distance >= CUBE_MAX_DISTANCE)
-	{
-		sys_log(1, "CUBE: TOO_FAR: %s distance %d", ch->GetName(), distance);
-		return;
-	}
-
-	Cube_clean_item(ch);
-	ch->SetCubeNpc(npc);
-	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube open %d %d", npc->GetRaceNum(), reload);
-}
-
-// 큐브 캔슬
-void Cube_close(LPCHARACTER ch)
-{
-	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
-	Cube_clean_item(ch);
-	ch->SetCubeNpc(NULL);
-	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube close");
-	dev_log(LOG_DEB0, "<CUBE> close (%s)", ch->GetName());
-}
-
-void Cube_init()
-{
-	CUBE_DATA* p_cube = NULL;
-	std::vector<CUBE_DATA*>::iterator iter;
-
-	char file_name[256 + 1];
-	snprintf(file_name, sizeof(file_name), "%s/cube.txt", LocaleService_GetBasePath().c_str());
-
-	sys_log(0, "Cube_Init %s", file_name);
-
-	for (iter = s_cube_proto.begin(); iter != s_cube_proto.end(); iter++)
-	{
-		p_cube = *iter;
-		M2_DELETE(p_cube);
-	}
-
-	s_cube_proto.clear();
-
-	cube_info_map.clear();
-	cube_result_info_map_by_npc.clear();
-	s_isInitializedCubeMaterialInformation = false;
-
-	if (false == Cube_load(file_name))
-		sys_err("Cube_Init failed");
-}
-
-bool Cube_load(const char* file)
-{
-	FILE* fp;
-	char one_line[512];
-	int value1, value2;
-	const char* delim = " \t\r\n";
-	char* v, * token_string;
-	CUBE_DATA* cube_data = NULL;
-	CUBE_VALUE cube_value = { 0,0 };
-
-	if (0 == file || 0 == file[0])
-		return false;
-
-	if ((fp = fopen(file, "r")) == 0)
-		return false;
-
-	while (fgets(one_line, 512, fp))
-	{
-		value1 = value2 = 0;
-
-		if (one_line[0] == '#')
-			continue;
-
-		token_string = strtok(one_line, delim);
-
-		if (NULL == token_string)
-			continue;
-
-		// set value1, value2
-		if ((v = strtok(NULL, delim)))
-			str_to_number(value1, v);
-
-		if ((v = strtok(NULL, delim)))
-			str_to_number(value2, v);
-
-		TOKEN("section")
-		{
-			cube_data = M2_NEW CUBE_DATA;
-		}
-		else TOKEN("npc")
-		{
-			cube_data->npc_vnum.push_back((WORD)value1);
-		}
-		else TOKEN("item")
-		{
-			cube_value.vnum = value1;
-			cube_value.count = value2;
-
-			cube_data->item.push_back(cube_value);
-		}
-		else TOKEN("reward")
-		{
-			cube_value.vnum = value1;
-			cube_value.count = value2;
-
-			cube_data->reward.push_back(cube_value);
-		}
-		else TOKEN("percent")
-		{
-			cube_data->percent = value1;
-		}
-	else TOKEN("gold")
-	{
-		// 제조에 필요한 금액
-		cube_data->gold = value1;
-	}
-#if defined(__CUBE_RENEWAL__)
-	else TOKEN("not_remove")
-	{
-		// 제조에 필요한 금액
-		cube_data->not_remove = value1;
-	}
-#endif
-else TOKEN("end")
-{
-	// TODO : check cube data
-	if (false == FN_check_cube_data(cube_data))
-	{
-		dev_log(LOG_DEB0, "something wrong");
-		M2_DELETE(cube_data);
-		continue;
-	}
-	s_cube_proto.push_back(cube_data);
-}
-	}
-
-	fclose(fp);
-	return true;
-}
-
-static void FN_cube_print(CUBE_DATA* data, DWORD index)
-{
-	DWORD i;
-	dev_log(LOG_DEB0, "--------------------------------");
-	dev_log(LOG_DEB0, "CUBE_DATA[%d]", index);
-
-	for (i = 0; i < data->npc_vnum.size(); ++i)
-	{
-		dev_log(LOG_DEB0, "\tNPC_VNUM[%d] = %d", i, data->npc_vnum[i]);
-	}
-	for (i = 0; i < data->item.size(); ++i)
-	{
-		dev_log(LOG_DEB0, "\tITEM[%d] = (%d, %d)", i, data->item[i].vnum, data->item[i].count);
-	}
-	for (i = 0; i < data->reward.size(); ++i)
-	{
-		dev_log(LOG_DEB0, "\tREWARD[%d] = (%d, %d)", i, data->reward[i].vnum, data->reward[i].count);
-	}
-	dev_log(LOG_DEB0, "\tPERCENT = %d", data->percent);
-	dev_log(LOG_DEB0, "--------------------------------");
-}
-
-void Cube_print()
-{
-	for (DWORD i = 0; i < s_cube_proto.size(); ++i)
-	{
-		FN_cube_print(s_cube_proto[i], i);
-	}
-}
-
-static bool FN_update_cube_status(LPCHARACTER ch)
-{
-	if (NULL == ch)
-		return false;
-
-	if (!ch->IsCubeOpen())
-		return false;
-
-	LPCHARACTER npc = ch->GetQuestNPC();
-	if (NULL == npc)
-		return false;
-
-	CUBE_DATA* cube = FN_find_cube(ch->GetCubeItem(), npc->GetRaceNum());
-
-	if (NULL == cube)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "cube info 0 0 0");
-		return false;
-	}
-
-	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube info %d %d %d", cube->gold, 0, 0);
-	return true;
-}
-
-// return new item
-bool Cube_make(LPCHARACTER ch)
-{
-	// 주어진 아이템을 필요로하는 조합을 찾는다. (큐브데이타로 칭함)
-	// 큐브 데이타가 있다면 아이템의 재료를 체크한다.
-	// 새로운 아이템을 만든다.
-	// 새로운 아이템 지급
-
-	LPCHARACTER npc;
-	int percent_number = 0;
-	CUBE_DATA* cube_proto;
-	LPITEM* items;
-	LPITEM new_item;
-
-	if (!(ch)->IsCubeOpen())
-	{
-		(ch)->ChatPacket(CHAT_TYPE_INFO, LC_STRING("제조창이 열려있지 않습니다"));
-		return false;
-	}
-
-	npc = ch->GetQuestNPC();
-	if (NULL == npc)
-	{
-		return false;
-	}
-
-	items = ch->GetCubeItem();
-	cube_proto = FN_find_cube(items, npc->GetRaceNum());
-
-	if (NULL == cube_proto)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("제조 재료가 부족합니다"));
-		return false;
-	}
-
-	if (ch->GetGold() < 0)
-	{
-		sys_err("Player %s with negative gold is trying to use cube!", ch->GetName());
-		return false;
-	}
-
-	unsigned long long gold = ch->GetGold();
-	if (gold < static_cast<unsigned long long>(cube_proto->gold))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("돈이 부족하거나 아이템이 제자리에 없습니다."));	// 이 텍스트는 이미 널리 쓰이는거라 추가번역 필요 없음
-		return false;
-	}
-
-	CUBE_VALUE* reward_value = cube_proto->reward_value();
-
-	// 사용되었던 재료아이템 삭제
-	cube_proto->remove_material(ch);
-
-	// 제조시 필요한 골드 차감
-	if (cube_proto->gold > 0)
-		ch->PointChange(POINT_GOLD, -(long long)cube_proto->gold, false);
-
-	percent_number = number(1, 100);
-	if (percent_number <= cube_proto->percent)
-	{
-		// 성공
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "cube success %d %d", reward_value->vnum, reward_value->count);
-		new_item = ch->AutoGiveItem(reward_value->vnum, reward_value->count);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		ch->UpdateExtBattlePassMissionProgress(BP_ITEM_CRAFT, reward_value->count, reward_value->vnum);
-#endif
-
-#if defined(__QUEST_EVENT_CRAFT__)
-		ch->SetQuestNPCID(npc->GetVID());
-		quest::CQuestManager::instance().CraftItem(ch->GetPlayerID(), npc->GetRaceNum(), new_item);
-#endif
-
-		LogManager::instance().CubeLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(),
-			reward_value->vnum, new_item->GetID(), reward_value->count, 1);
-		return true;
-	}
-	else
-	{
-		// 실패
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("제조에 실패하였습니다.")); // 2012.11.12 새로 추가된 메세지 (locale_string.txt 에 추가해야 함)
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "cube fail");
-		LogManager::instance().CubeLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(),
-			reward_value->vnum, 0, 0, 0);
-		return false;
-	}
-
-	return false;
-}
-
-// 큐브에 있는 아이템들을 표시
-void Cube_show_list(LPCHARACTER ch)
-{
-	LPITEM* cube_item;
-	LPITEM item;
-
-	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
-
-	cube_item = ch->GetCubeItem();
-
-	for (int i = 0; i < CUBE_MAX_NUM; ++i)
-	{
-		item = cube_item[i];
-		if (NULL == item) continue;
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "cube[%d]: inventory[%d]: %s", i, item->GetCell(), item->GetName());
-	}
-}
-
-// 인벤토리에 있는 아이템을 큐브에 등록
-void Cube_add_item(LPCHARACTER ch, int cube_index, int inven_index)
-{
-	// 아이템이 있는가?
-	// 큐브내의 빈자리 찾기
-	// 큐브세팅
-	// 메시지 전송
-	LPITEM item;
-	LPITEM* cube_item;
-
-	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
-
-	if (inven_index < 0 || INVENTORY_MAX_NUM <= inven_index)
-		return;
-
-	if (cube_index < 0 || CUBE_MAX_NUM <= cube_index)
-		return;
-
-	item = ch->GetInventoryItem(inven_index);
-
-	if (NULL == item) return;
-
-	cube_item = ch->GetCubeItem();
-
-	// 이미 다른위치에 등록되었던 아이템이면 기존 indext삭제
-	for (int i = 0; i < CUBE_MAX_NUM; ++i)
-	{
-		if (item == cube_item[i])
-		{
-			cube_item[i] = NULL;
-			break;
-		}
-	}
-
-	cube_item[cube_index] = item;
-
-	if (test_server)
-		ch->ChatPacket(CHAT_TYPE_INFO, "cube[%d]: inventory[%d]: %s added", cube_index, inven_index, item->GetName());
-
-	// 현재 상자에 올라온 아이템들로 무엇을 만들 수 있는지 클라이언트에 정보 전달
-	// 을 하고싶었으나 그냥 필요한 골드가 얼마인지 전달
-	FN_update_cube_status(ch);
-
-	return;
-}
-
-// 큐브에있는 아이템을 제거
-void Cube_delete_item(LPCHARACTER ch, int cube_index)
-{
-	LPITEM item;
-	LPITEM* cube_item;
-
-	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
-
-	if (cube_index < 0 || CUBE_MAX_NUM <= cube_index) return;
-
-	cube_item = ch->GetCubeItem();
-
-	if (NULL == cube_item[cube_index]) return;
-
-	item = cube_item[cube_index];
-	cube_item[cube_index] = NULL;
-
-	if (test_server)
-		ch->ChatPacket(CHAT_TYPE_INFO, "cube[%d]: cube[%d]: %s deleted", cube_index, item->GetCell(), item->GetName());
-
-	// 현재 상자에 올라온 아이템들로 무엇을 만들 수 있는지 클라이언트에 정보 전달
-	// 을 하고싶었으나 그냥 필요한 골드가 얼마인지 전달
-	FN_update_cube_status(ch);
-
-	return;
-}
-
-// 아이템 이름을 통해서 순수 이름과 강화레벨을 분리하는 함수 (무쌍검+5 -> 무쌍검, 5)
-SItemNameAndLevel SplitItemNameAndLevelFromName(const std::string& name)
-{
-	int level = 0;
-	SItemNameAndLevel info;
-	info.name = name;
-
-	size_t pos = name.find("+");
-
-	if (std::string::npos != pos)
-	{
-		const std::string levelStr = name.substr(pos + 1, name.size() - pos - 1);
-		str_to_number(level, levelStr.c_str());
-
-		info.name = name.substr(0, pos);
-	}
-
-	info.level = level;
-
-	return info;
-};
-
-bool FIsEqualCubeValue(const CUBE_VALUE& a, const CUBE_VALUE& b)
-{
-	return (a.vnum == b.vnum) && (a.count == b.count);
-}
-
-bool FIsLessCubeValue(const CUBE_VALUE& a, const CUBE_VALUE& b)
-{
-	return a.vnum < b.vnum;
-}
-
-void Cube_MakeCubeInformationText()
-{
-	// 이제 정리된 큐브 결과 및 재료들의 정보로 클라이언트에 보내 줄 정보로 변환함.
-	for (TCubeMapByNPC::iterator iter = cube_info_map.begin(); cube_info_map.end() != iter; ++iter)
-	{
-		const DWORD& npcVNUM = iter->first;
-		TCubeResultList& resultList = iter->second;
-
-		for (TCubeResultList::iterator resultIter = resultList.begin(); resultList.end() != resultIter; ++resultIter)
-		{
-			SCubeMaterialInfo& materialInfo = *resultIter;
-			std::string& infoText = materialInfo.infoText;
-
-			// 이놈이 나쁜놈이야
-			if (0 < materialInfo.complicateMaterial.size())
-			{
-				std::sort(materialInfo.complicateMaterial.begin(), materialInfo.complicateMaterial.end(), FIsLessCubeValue);
-				std::sort(materialInfo.material.begin(), materialInfo.material.end(), FIsLessCubeValue);
-
-				//// 중복되는 재료들을 지움
-				for (TCubeValueVector::iterator iter = materialInfo.complicateMaterial.begin(); materialInfo.complicateMaterial.end() != iter; ++iter)
-				{
-					for (TCubeValueVector::iterator targetIter = materialInfo.material.begin(); materialInfo.material.end() != targetIter; ++targetIter)
-					{
-						if (*targetIter == *iter)
-						{
-							targetIter = materialInfo.material.erase(targetIter);
-						}
-					}
-				}
-
-				// 72723,1 or 72725,1 or ... 이런 식의 약속된 포맷을 지키는 텍스트를 생성
-				for (TCubeValueVector::iterator iter = materialInfo.complicateMaterial.begin(); materialInfo.complicateMaterial.end() != iter; ++iter)
-				{
-					char tempBuffer[128];
-					sprintf(tempBuffer, "%d,%d|", iter->vnum, iter->count);
-
-					infoText += std::string(tempBuffer);
-				}
-
-				infoText.erase(infoText.size() - 1);
-
-				if (0 < materialInfo.material.size())
-					infoText.push_back('&');
-			}
-
-			// 중복되지 않는 일반 재료들도 포맷 생성
-			for (TCubeValueVector::iterator iter = materialInfo.material.begin(); materialInfo.material.end() != iter; ++iter)
-			{
-				char tempBuffer[128];
-				sprintf(tempBuffer, "%d,%d&", iter->vnum, iter->count);
-				infoText += std::string(tempBuffer);
-			}
-
-			infoText.erase(infoText.size() - 1);
-
-			// 만들 때 골드가 필요하다면 골드정보 추가
-			if (0 < materialInfo.gold)
-			{
-				char temp[128];
-				sprintf(temp, "%d", materialInfo.gold);
-				infoText += std::string("/") + temp;
-			}
-
-			//sys_err("\t\tNPC: %d, Reward: %d(%s)\n\t\t\tInfo: %s", npcVNUM, materialInfo.reward.vnum, ITEM_MANAGER::Instance().GetTable(materialInfo.reward.vnum)->szName, materialInfo.infoText.c_str());
-		} // for resultList
-	} // for npc
-}
-
-bool Cube_InformationInitialize()
-{
-	for (int i = 0; i < s_cube_proto.size(); ++i)
-	{
-		CUBE_DATA* cubeData = s_cube_proto[i];
-
-		const std::vector<CUBE_VALUE>& rewards = cubeData->reward;
-
-		// 하드코딩 ㅈㅅ
-		if (1 != rewards.size())
-		{
-			sys_err("[CubeInfo] WARNING! Does not support multiple rewards (count: %d)", rewards.size());
-			continue;
-		}
-		/*
-		if (1 != cubeData->npc_vnum.size())
-		{
-			sys_err("[CubeInfo] WARNING! Does not support multiple NPC (count: %d)", cubeData->npc_vnum.size());
-			continue;
-		}
-		*/
-
-		const CUBE_VALUE& reward = rewards.at(0);
-		const WORD& npcVNUM = cubeData->npc_vnum.at(0);
-		bool bComplicate = false;
-
-		TCubeMapByNPC& cubeMap = cube_info_map;
-		TCubeResultList& resultList = cubeMap[npcVNUM];
-		SCubeMaterialInfo materialInfo;
-
-		materialInfo.reward = reward;
-		materialInfo.gold = cubeData->gold;
-		materialInfo.material = cubeData->item;
-
-		for (TCubeResultList::iterator iter = resultList.begin(); resultList.end() != iter; ++iter)
-		{
-			SCubeMaterialInfo& existInfo = *iter;
-
-			// 이미 중복되는 보상이 등록되어 있다면 아예 다른 조합으로 만드는 것인지,
-			// 거의 같은 조합인데 특정 부분만 틀린 것인지 구분함.
-			// 예를들면 특정 부분만 틀린 아이템들은 아래처럼 하나로 묶어서 하나의 결과로 보여주기 위함임:
-			// 용신지검:
-			//		무쌍검+5 ~ +9 x 1
-			//		붉은 칼자루 조각 x1
-			//		녹색 검장식 조각 x1
-			if (reward.vnum == existInfo.reward.vnum)
-			{
-				for (TCubeValueVector::iterator existMaterialIter = existInfo.material.begin(); existInfo.material.end() != existMaterialIter; ++existMaterialIter)
-				{
-					TItemTable* existMaterialProto = ITEM_MANAGER::Instance().GetTable(existMaterialIter->vnum);
-					if (NULL == existMaterialProto)
-					{
-						sys_err("There is no item(%u)", existMaterialIter->vnum);
-						return false;
-					}
-					SItemNameAndLevel existItemInfo = SplitItemNameAndLevelFromName(existMaterialProto->szName);
-
-					if (0 < existItemInfo.level)
-					{
-						// 지금 추가하는 큐브 결과물의 재료와, 기존에 등록되어있던 큐브 결과물의 재료 중
-						// 중복되는 부분이 있는지 검색한다
-						for (TCubeValueVector::iterator currentMaterialIter = materialInfo.material.begin(); materialInfo.material.end() != currentMaterialIter; ++currentMaterialIter)
-						{
-							TItemTable* currentMaterialProto = ITEM_MANAGER::Instance().GetTable(currentMaterialIter->vnum);
-							SItemNameAndLevel currentItemInfo = SplitItemNameAndLevelFromName(currentMaterialProto->szName);
-
-							if (currentItemInfo.name == existItemInfo.name)
-							{
-								bComplicate = true;
-								existInfo.complicateMaterial.push_back(*currentMaterialIter);
-
-								if (std::find(existInfo.complicateMaterial.begin(), existInfo.complicateMaterial.end(), *existMaterialIter) == existInfo.complicateMaterial.end())
-									existInfo.complicateMaterial.push_back(*existMaterialIter);
-
-								//currentMaterialIter = materialInfo.material.erase(currentMaterialIter);
-
-								// TODO : 중복되는 아이템 두 개 이상 검출해야 될 수도 있음
-								break;
-							}
-						} // for currentMaterialIter
-					} // if level
-				} // for existMaterialInfo
-			} // if (reward.vnum == existInfo.reward.vnum)
-
-		} // for resultList
-
-		if (false == bComplicate)
-			resultList.push_back(materialInfo);
-	}
-
-	Cube_MakeCubeInformationText();
-
-	s_isInitializedCubeMaterialInformation = true;
-	return true;
-}
-
-// 클라이언트에서 서버로 : 현재 NPC가 만들 수 있는 아이템들의 정보(목록)를 요청
-void Cube_request_result_list(LPCHARACTER ch)
-{
-	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
-
-	LPCHARACTER npc = ch->GetQuestNPC();
-	if (NULL == npc)
-		return;
-
-	DWORD npcVNUM = npc->GetRaceNum();
-	size_t resultCount = 0;
-
-	std::string& resultText = cube_result_info_map_by_npc[npcVNUM];
-
-	// 해당 NPC가 만들 수 있는 목록이 정리된 게 없다면 캐시를 생성
-	if (resultText.length() == 0)
-	{
-		resultText.clear();
-
-		const TCubeResultList& resultList = cube_info_map[npcVNUM];
-		for (TCubeResultList::const_iterator iter = resultList.begin(); resultList.end() != iter; ++iter)
-		{
-			const SCubeMaterialInfo& materialInfo = *iter;
-			char temp[128];
-			sprintf(temp, "%d,%d", materialInfo.reward.vnum, materialInfo.reward.count);
-
-			resultText += std::string(temp) + "/";
-		}
-
-		resultCount = resultList.size();
-
-		resultText.erase(resultText.size() - 1);
-
-		// 채팅 패킷의 한계를 넘어가면 에러 남김... 기획자 분들 께 조정해달라고 요청하거나, 나중에 다른 방식으로 바꾸거나...
-		if (resultText.size() - 20 >= CHAT_MAX_LEN)
-		{
-			sys_err("[CubeInfo] Too long cube result list text. (NPC: %d, length: %d)", npcVNUM, resultText.size());
-			resultText.clear();
-			resultCount = 0;
-		}
-
-	}
-
-	// 현재 NPC가 만들 수 있는 아이템들의 목록을 아래 포맷으로 전송한다.
-	// (Server -> Client) /cube r_list npcVNUM resultCount vnum1,count1/vnum2,count2,/vnum3,count3/...
-	// (Server -> Client) /cube r_list 20383 4 123,1/125,1/128,1/130,5
-
-	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube r_list %d %d %s", npcVNUM, resultCount, resultText.c_str());
-}
-
-//
-void Cube_request_material_info(LPCHARACTER ch, int requestStartIndex, int requestCount)
-{
-	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
-
-	LPCHARACTER npc = ch->GetQuestNPC();
-	if (NULL == npc)
-		return;
-
-	DWORD npcVNUM = npc->GetRaceNum();
-	std::string materialInfoText = "";
-
-	int index = 0;
-	bool bCatchInfo = false;
-
-	const TCubeResultList& resultList = cube_info_map[npcVNUM];
-	for (TCubeResultList::const_iterator iter = resultList.begin(); resultList.end() != iter; ++iter)
-	{
-		const SCubeMaterialInfo& materialInfo = *iter;
-
-		if (index++ == requestStartIndex)
-		{
-			bCatchInfo = true;
-		}
-
-		if (bCatchInfo)
-		{
-			materialInfoText += materialInfo.infoText + "@";
-		}
-
-		if (index >= requestStartIndex + requestCount)
-			break;
-	}
-
-	if (false == bCatchInfo)
-	{
-		sys_err("[CubeInfo] Can't find matched material info (NPC: %d, index: %d, request count: %d)", npcVNUM, requestStartIndex, requestCount);
-		return;
-	}
-
-	materialInfoText.erase(materialInfoText.size() - 1);
-
-	//
-	// (Server -> Client) /cube m_info start_index count 125,1|126,2|127,2|123,5&555,5&555,4/120000
-	if (materialInfoText.size() - 20 >= CHAT_MAX_LEN)
-	{
-		sys_err("[CubeInfo] Too long material info. (NPC: %d, requestStart: %d, requestCount: %d, length: %d)", npcVNUM, requestStartIndex, requestCount, materialInfoText.size());
-	}
-
-	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube m_info %d %d %s", requestStartIndex, requestCount, materialInfoText.c_str());
-}
-#endif
+#include "stdafx.h"
+
+#if defined(__CUBE_RENEWAL__)
+/**
+* Filename: cube.cpp
+* Author: Owsap
+**/
+
+#include "cube.h"
+#include "char.h"
+#include "item.h"
+#include "desc.h"
+#include "locale_service.h"
+#include "utils.h"
+#if defined(__QUEST_EVENT_CRAFT__)
+#	include "questmanager.h"
+#endif
+
+#include <fstream>
+#include <cryptopp/crc.h>
+#include <cryptopp/files.h>
+#include <cryptopp/filters.h>
+
+CCubeManager::CCubeManager()
+{
+	m_vCubeData.clear();
+	m_dwFileCrc = 0;
+}
+
+CCubeManager::~CCubeManager()
+{
+	m_vCubeData.clear();
+	m_dwFileCrc = 0;
+}
+
+void CCubeManager::Initialize()
+{
+	char szCubeFileTable[256 + 1];
+	snprintf(szCubeFileTable, sizeof(szCubeFileTable), "%s/cube.txt", LocaleService_GetBasePath().c_str());
+
+	LoadCubeTable(szCubeFileTable);
+	sys_log(0, "cube: initialize");
+}
+
+void CCubeManager::LoadCubeTable(const char* szFileName)
+{
+	m_vCubeData.clear();
+
+	std::ifstream ifStream(szFileName);
+	if (!ifStream.is_open())
+	{
+		sys_err("cube: load cube table error: failed to open %s", szFileName);
+		return;
+	}
+
+	{
+		CryptoPP::CRC32 Crc32;
+		CryptoPP::byte szBuffer[4096];
+
+		std::ifstream ifStream(szFileName, std::ios::binary);
+		while (!ifStream.eof())
+		{
+			ifStream.read(reinterpret_cast<char*>(szBuffer), sizeof(szBuffer));
+			Crc32.Update(szBuffer, ifStream.gcount());
+		}
+
+		CryptoPP::byte bDigest[CryptoPP::CRC32::DIGESTSIZE];
+		Crc32.Final(bDigest);
+
+		m_dwFileCrc = *reinterpret_cast<DWORD*>(bDigest);
+	}
+
+	CubeDataPtr pCubeData = nullptr;
+	SCubeValue CubeValue = { 0, 0 };
+	UINT iCubeIndex = 0;
+
+	std::string stLine;
+	while (std::getline(ifStream, stLine))
+	{
+		if (stLine.empty() || stLine[0] == '#')
+			continue;
+
+		std::istringstream isStream(stLine);
+		std::string stToken;
+		isStream >> stToken;
+
+		if (stToken == "section")
+			pCubeData = std::make_unique<SCubeData>();
+		else if (stToken == "npc")
+			isStream >> pCubeData->dwNPCVnum;
+		else if (stToken == "item")
+		{
+			isStream >> CubeValue.dwVnum >> CubeValue.iCount;
+			pCubeData->vItem.emplace_back(CubeValue);
+		}
+		else if (stToken == "reward")
+		{
+			isStream >> CubeValue.dwVnum >> CubeValue.iCount;
+			pCubeData->Reward = CubeValue;
+		}
+		else if (stToken == "percent")
+			isStream >> pCubeData->iPercent;
+		else if (stToken == "gold")
+			isStream >> pCubeData->iGold;
+		else if (stToken == "gem")
+			isStream >> pCubeData->iGem;
+#if defined(__SET_ITEM__)
+		else if (stToken == "set_value")
+			isStream >> pCubeData->iSetValue;
+		else if (stToken == "not_remove")
+			isStream >> pCubeData->dwNotRemove;
+#endif
+		else if (stToken == "category")
+		{
+			std::string stCategory;
+			isStream >> stCategory;
+			pCubeData->iCategory = GetCubeCategory(stCategory);
+		}
+		else if (stToken == "subcategory")
+			isStream >> pCubeData->iSubCategory;
+		else if (stToken == "end")
+		{
+			if (pCubeData && CheckCubeData(pCubeData))
+			{
+				pCubeData->iIndex = ++iCubeIndex;
+				m_vCubeData.emplace_back(std::move(pCubeData));
+			}
+			else
+			{
+				pCubeData.reset();
+				continue;
+			}
+		}
+	}
+
+	ifStream.close();
+}
+
+bool CCubeManager::CheckCubeData(const CubeDataPtr& pkCubeData)
+{
+	std::size_t dwIndex = 0;
+	std::size_t dwEndIndex = 0;
+
+	if (pkCubeData->dwNPCVnum == 0)
+		return false;
+
+	dwEndIndex = pkCubeData->vItem.size();
+	for (dwIndex = 0; dwIndex < dwEndIndex; ++dwIndex)
+	{
+		if (pkCubeData->vItem[dwIndex].dwVnum == 0)
+			return false;
+
+		if (pkCubeData->vItem[dwIndex].iCount == 0)
+			return false;
+	}
+
+	if (pkCubeData->Reward.dwVnum == 0)
+		return false;
+
+	if (pkCubeData->Reward.iCount == 0)
+		return false;
+
+	return true;
+}
+
+const CCubeManager::SCubeData& CCubeManager::GetCubeData(const DWORD dwNPCVnum, const UINT iCubeIndex)
+{
+	for (const CubeDataPtr& pkCubeData : m_vCubeData)
+	{
+		if (pkCubeData->dwNPCVnum == dwNPCVnum && pkCubeData->iIndex == iCubeIndex)
+			return *pkCubeData;
+	}
+	throw std::runtime_error("cube data not found");
+}
+
+bool CCubeManager::CheckValidNPC(const DWORD dwNPCVnum)
+{
+	for (const CubeDataPtr& pkCubeData : m_vCubeData)
+	{
+		if (pkCubeData->dwNPCVnum == dwNPCVnum)
+			return true;
+	}
+	return false;
+}
+
+void CCubeManager::OpenCube(const LPCHARACTER pChar)
+{
+	if (pChar == nullptr)
+		return;
+
+	const LPDESC pDesc = pChar->GetDesc();
+	if (pDesc == nullptr)
+		return;
+
+	if (pChar->IsCubeOpen())
+		return;
+
+	const LPCHARACTER pNPC = pChar->GetQuestNPC();
+	if (pNPC == nullptr)
+	{
+		if (test_server)
+			sys_log(0, "cube: ch %s error: cannot find quest npc", pChar->GetName());
+		return;
+	}
+
+	if (CheckValidNPC(pNPC->GetRaceNum()) == false)
+	{
+		if (test_server)
+		{
+			sys_log(0, "cube: npc %d ch %s error: cannot find cube for npc",
+				pNPC->GetRaceNum(), pChar->GetName());
+		}
+		return;
+	}
+
+	if (pChar->PreventTradeWindow(WND_CUBE, true/*except*/))
+	{
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹構 貫  求."));
+		return;
+	}
+
+	if (pChar->IsCubeOpen())
+	{
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창  駕求"));
+		return;
+	}
+
+	int iDistance = DISTANCE_APPROX(pChar->GetX() - pNPC->GetX(), pChar->GetY() - pNPC->GetY());
+	if (iDistance >= CUBE_MAX_DISTANCE)
+	{
+		sys_log(0, "cube: npc %d ch %s distance %d error: too far to open",
+			pNPC->GetRaceNum(), pChar->GetName(), iDistance);
+		return;
+	}
+
+	pChar->SetCubeNpc(pNPC);
+	Process(pChar->GetDesc(), SUBHEADER_GC_CUBE_OPEN, pNPC->GetRaceNum());
+}
+
+void CCubeManager::CloseCube(const LPCHARACTER pChar)
+{
+	if (pChar->IsCubeOpen())
+		pChar->SetCubeNpc(nullptr);
+}
+
+std::vector<TItemData> GenerateRewardItems(const CCubeManager::SCubeData& pkCube, const LPCHARACTER pChar, const INT iMultiplier)
+{
+	std::vector<TItemData> vRewardItem;
+	for (INT iCount = 0; iCount < pkCube.Reward.iCount * iMultiplier;)
+	{
+		const TItemTable* pItemTable = ITEM_MANAGER::Instance().GetTable(pkCube.Reward.dwVnum);
+		if (!pItemTable)
+		{
+			sys_log(0, "cube: npc %d index(%d) ch %s error: failed to create item",
+				pkCube.dwNPCVnum, pkCube.iIndex, pChar->GetName());
+			throw std::runtime_error("failed to get item table");
+		}
+
+		TItemData ItemData;
+		ItemData.dwVnum = pItemTable->dwVnum;
+
+		if (IS_SET(pItemTable->dwFlags, ITEM_FLAG_STACKABLE))
+		{
+			ItemData.dwCount = MIN(ITEM_MAX_COUNT, pkCube.Reward.iCount * iMultiplier - iCount);
+			iCount += ItemData.dwCount;
+		}
+		else
+		{
+			ItemData.dwCount = 1;
+			iCount += 1;
+		}
+
+		vRewardItem.emplace_back(ItemData);
+	}
+
+	return vRewardItem;
+}
+
+void CCubeManager::MakeCube(const LPCHARACTER pChar, const UINT iCubeIndex, INT iMultiplier, const INT iImproveItemPos)
+{
+	if (pChar->IsCubeOpen() == false)
+		return;
+
+	const LPCHARACTER pNPC = pChar->GetCubeNpc();
+	if (pNPC == nullptr)
+		return;
+
+	// [Security] Re-validate proximity to the cube NPC on every craft (prevents remote crafting via packet injection)
+	if (pNPC->GetMapIndex() != pChar->GetMapIndex())
+	{
+		CCubeManager::Instance().CloseCube(pChar);
+		return;
+	}
+
+	const int kMaxCubeDistance = 500;
+	if (DISTANCE_APPROX(pChar->GetX() - pNPC->GetX(), pChar->GetY() - pNPC->GetY()) > kMaxCubeDistance)
+	{
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You are too far away from the crafting NPC."));
+		CCubeManager::Instance().CloseCube(pChar);
+		return;
+	}
+
+	try
+	{
+		const SCubeData& pkCube = GetCubeData(pNPC->GetRaceNum(), iCubeIndex);
+
+#if defined(__SET_ITEM__)
+		if (IsCubeSetAddCategory(pkCube.iCategory) && pkCube.iSetValue)
+		{
+			if (iMultiplier != 1)
+			{
+				sys_log(0, "cube: npc %d index(%d) ch %s warning: cannot craft multiple set items",
+					pkCube.dwNPCVnum, pkCube.iIndex, pChar->GetName());
+			}
+			iMultiplier = 1;
+		}
+#endif
+
+		if (pChar->GetGold() < pkCube.iGold * iMultiplier)
+		{
+			pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang."));
+			return;
+		}
+
+		if (pChar->GetGem() < pkCube.iGem * iMultiplier)
+		{
+			pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Gaya."));
+			return;
+		}
+
+		for (const SCubeValue& kMaterial : pkCube.vItem)
+		{
+			INT iCount = pChar->CountSpecifyItem(kMaterial.dwVnum, -1
+#if defined(__SOUL_BIND_SYSTEM__)
+				, true /* bIgnoreSealedItem */
+#endif
+#if defined(__SET_ITEM__)
+				, pkCube.iSetValue ? true : false /* bIgnoreSetValue */
+#endif
+			);
+
+			INT iMaterialCount = MINMAX(1, kMaterial.iCount * iMultiplier, CUBE_MAX_MATERIAL_QUANTITY);
+			if (iCount < iMaterialCount)
+			{
+				pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have insufficient materials for the upgrade. (Soulbound items cannot be used.)"));
+				return;
+			}
+		}
+
+		std::vector<TItemData> vRewardItem = GenerateRewardItems(pkCube, pChar, iMultiplier);
+		if (vRewardItem.empty())
+		{
+			sys_log(0, "cube: npc %d index(%d) ch %s error: failed to generate reward item",
+				pkCube.dwNPCVnum, pkCube.iIndex, pChar->GetName());
+			return;
+		}
+
+		if (pChar->HasEnoughInventorySpace(vRewardItem) == false)
+		{
+			pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("There isn't enough space in your inventory."));
+			sys_log(0, "cube: npc %d index(%d) ch %s error: no inventory space reward",
+				pNPC->GetRaceNum(), iCubeIndex, pChar->GetName());
+			return;
+		}
+
+		LPITEM pNotRemoveItem = nullptr;
+		for (const SCubeValue& kMaterial : pkCube.vItem)
+		{
+			if (pkCube.dwNotRemove == kMaterial.dwVnum)
+			{
+				pNotRemoveItem = pChar->FindSpecifyItem(pkCube.dwNotRemove
+#if defined(__SOUL_BIND_SYSTEM__)
+					, true /* bIgnoreSealedItem */
+#endif
+#if defined(__SET_ITEM__)
+					, pkCube.iSetValue ? true : false /* bIgnoreSetValue */
+#endif
+				);
+				continue;
+			}
+
+			INT iMaterialCount = MINMAX(1, kMaterial.iCount * iMultiplier, CUBE_MAX_MATERIAL_QUANTITY);
+			pChar->RemoveSpecifyItem(kMaterial.dwVnum, iMaterialCount, -1
+#if defined(__SOUL_BIND_SYSTEM__)
+				, true /* bIgnoreSealedItem */
+#endif
+#if defined(__SET_ITEM__)
+				, pkCube.iSetValue ? true : false /* bIgnoreSetValue */
+#endif
+			);
+		}
+
+		if (pkCube.iGold > 0)
+			pChar->PointChange(POINT_GOLD, -(pkCube.iGold * iMultiplier), false);
+
+		if (pkCube.iGem > 0)
+			pChar->PointChange(POINT_GEM, -(pkCube.iGem * iMultiplier), false);
+
+		INT iImprovePercent = 0;
+		LPITEM pImproveItem = nullptr;
+		if (iImproveItemPos != -1)
+		{
+			pImproveItem = pChar->GetItem(TItemPos(INVENTORY, iImproveItemPos));
+			if (pImproveItem && pkCube.iPercent < 100)
+			{
+				if (pImproveItem->GetSubType() == pkCube.iCategory)
+				{
+					if (pImproveItem->GetCount() < iMultiplier)
+					{
+						sys_log(0, "cube: npc %d index(%d) ch %s error: not enough catalyst for multiplier",
+							pNPC->GetRaceNum(), iCubeIndex, pChar->GetName());
+						return;
+					}
+
+					iImprovePercent = pImproveItem->GetValue(0);
+					pImproveItem->SetCount(pImproveItem->GetCount() - iMultiplier);
+
+					if (test_server)
+						pChar->ChatPacket(CHAT_TYPE_INFO, "cube using catalyst pct %d total success pct %d",
+							iImprovePercent, pkCube.iPercent + iImprovePercent);
+				}
+				else
+				{
+					sys_log(0, "cube: npc %d index(%d) ch %s (possible cheat) error: using catalyst wrong category",
+						pNPC->GetRaceNum(), iCubeIndex, pChar->GetName());
+				}
+			}
+		}
+
+#if defined(__QUEST_EVENT_CRAFT__)
+		LPITEM pLastRewardItem = nullptr;
+#endif
+		for (const TItemData& kRewardItem : vRewardItem)
+		{
+			BYTE bPercent = number(1, 100);
+			if (bPercent > pkCube.iPercent + iImprovePercent)
+			{
+				Process(pChar->GetDesc(), SUBHEADER_GC_CUBE_RESULT, 0, false);
+				continue;
+			}
+
+			LPITEM pRewardItem = ITEM_MANAGER::Instance().CreateItem(kRewardItem.dwVnum, kRewardItem.dwCount);
+			if (pRewardItem == nullptr)
+				continue;
+
+			if (pRewardItem->GetVnum() == pkCube.dwNotRemove)
+			{
+				if (pNotRemoveItem == nullptr)
+				{
+					sys_log(0, "cube: npc %d index(%d) ch %s (possible cheat) error: cannot find material %d",
+						pNPC->GetRaceNum(), iCubeIndex, pChar->GetName(), pkCube.dwNotRemove);
+					continue;
+				}
+
+				ITEM_MANAGER::CopyAllAttrTo(pNotRemoveItem, pRewardItem);
+#if defined(__ITEM_APPLY_RANDOM__)
+				TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+				pNotRemoveItem->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_CURRENT);
+				if (aApplyRandom)
+					pRewardItem->SetRandomApplies(aApplyRandom);
+#endif
+#if defined(__SET_ITEM__)
+				pRewardItem->SetItemSetValue(pkCube.iSetValue);
+#endif
+				ITEM_MANAGER::instance().RemoveItem(pNotRemoveItem, "CUBE COPY");
+				pNotRemoveItem = nullptr;
+			}
+			else
+			{
+				// NOTE : Removes the `not_remove` item if the craft succeeds.
+				// This condition is only true if `reward` != `not_remove`.
+				if (pNotRemoveItem != nullptr)
+					ITEM_MANAGER::instance().RemoveItem(pNotRemoveItem, "CUBE");
+			}
+
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			pChar->AutoGiveItem(pRewardItem, false, true, true);
+#else
+			pChar->AutoGiveItem(pRewardItem);
+#endif
+
+#if defined(__QUEST_EVENT_CRAFT__)
+			pLastRewardItem = pRewardItem;
+#endif
+
+			Process(pChar->GetDesc(), SUBHEADER_GC_CUBE_RESULT, 0, true);
+		}
+
+#if defined(__QUEST_EVENT_CRAFT__)
+		if (pLastRewardItem != nullptr)
+		{
+			pChar->SetQuestNPCID(pNPC->GetVID());
+			quest::CQuestManager::instance().CraftItem(pChar->GetPlayerID(), pNPC->GetRaceNum(), pLastRewardItem);
+		}
+#endif
+	}
+	catch (const std::runtime_error& kError)
+	{
+		sys_err("cube: npc %d index(%d) ch %s error: %s",
+			pNPC->GetRaceNum(), iCubeIndex, pChar->GetName(), kError.what());
+		return;
+	}
+}
+
+void CCubeManager::Process(LPDESC pDesc, BYTE bSubHeader, DWORD dwNPCVnum, bool bSuccess)
+{
+	if (pDesc)
+	{
+		TPacketGCCube Packet;
+		Packet.bHeader = HEADER_GC_CUBE;
+		Packet.bSubHeader = bSubHeader;
+		Packet.dwNPCVnum = dwNPCVnum;
+		Packet.bSuccess = bSuccess;
+		Packet.dwFileCrc = m_dwFileCrc;
+		pDesc->Packet(&Packet, sizeof(TPacketGCCube));
+	}
+}
+
+bool CCubeManager::IsCubeSetAddCategory(const BYTE bCategory) const
+{
+	switch (bCategory)
+	{
+		case CUBE_SETADD_WEAPON:
+		case CUBE_SETADD_ARMOR_BODY:
+		case CUBE_SETADD_ARMOR_HELMET:
+			return true;
+	}
+	return false;
+}
+
+INT CCubeManager::GetCubeCategory(const std::string& rkCategory) const
+{
+	CategoryNameMap::const_iterator it = g_map_CubeCategoryName.find(rkCategory);
+	return (it != g_map_CubeCategoryName.end() ? it->second : -1);
+}
+#else
+/**
+* File : cube.cpp
+* Date : 2006.11.20
+* Author : mhh
+* Description :
+**/
+
+#include "constants.h"
+#include "utils.h"
+#include "log.h"
+#include "char.h"
+#include "dev_log.h"
+#include "locale_service.h"
+#include "item.h"
+#include "item_manager.h"
+#if defined(__QUEST_EVENT_CRAFT__)
+#	include "questmanager.h"
+#endif
+
+#include <sstream>
+
+extern int test_server;
+
+#define RETURN_IF_CUBE_IS_NOT_OPENED(ch) if (!(ch)->IsCubeOpen()) return
+
+/*
+* Global Variables
+*/
+static std::vector<CUBE_DATA*> s_cube_proto;
+static bool s_isInitializedCubeMaterialInformation = false;
+
+/*
+* Cube Material Information
+*/
+enum ECubeResultCategory
+{
+	CUBE_CATEGORY_POTION, // ,  .. ( 특     . 歌   타)
+	CUBE_CATEGORY_WEAPON, // 
+	CUBE_CATEGORY_ARMOR, // 齋
+	CUBE_CATEGORY_ACCESSORY, // 킥
+	CUBE_CATEGORY_ETC, // 타 ...
+};
+
+typedef std::vector<CUBE_VALUE> TCubeValueVector;
+
+struct SCubeMaterialInfo
+{
+	SCubeMaterialInfo()
+	{
+		bHaveComplicateMaterial = false;
+	};
+
+	CUBE_VALUE reward; //  
+	TCubeValueVector material; //  
+	DWORD gold; //  窄떫
+	TCubeValueVector complicateMaterial; // -_- 
+
+	// .. 클潔트 搔 殮 臼  
+	// 72723,1&72724,2&72730,1
+	// 52001,1|52002,1|52003,1&72723,1&72724,5
+	// => ( 52001,1 or 52002,1 or 52003,1 ) and 72723,1 and 72724,5
+	std::string infoText;
+	bool bHaveComplicateMaterial; //
+};
+
+struct SItemNameAndLevel
+{
+	SItemNameAndLevel() { level = 0; }
+
+	std::string name;
+	int level;
+};
+
+// 米塑 肩 寬 ...  혼  쩔 
+typedef std::vector<SCubeMaterialInfo> TCubeResultList;
+typedef std::unordered_map<DWORD, TCubeResultList> TCubeMapByNPC; //  NPC 錚    斂 嘯 ...
+typedef std::unordered_map<DWORD, std::string> TCubeResultInfoTextByNPC; //  NPC   獵     
+
+TCubeMapByNPC cube_info_map;
+TCubeResultInfoTextByNPC cube_result_info_map_by_npc; // 譴  키 
+
+class CCubeMaterialInfoHelper
+{
+public:
+public:
+};
+
+/*
+* Static Functions
+*/
+// 却   獵째?
+static bool FN_check_item_count(LPITEM* items, DWORD item_vnum, int need_count)
+{
+	int count = 0;
+
+	// for all cube
+	for (int i = 0; i < CUBE_MAX_NUM; ++i)
+	{
+		if (NULL == items[i]) continue;
+
+		if (item_vnum == items[i]->GetVnum())
+		{
+			count += items[i]->GetCount();
+		}
+	}
+
+	return (count >= need_count);
+}
+
+// 큐怨 搔 .
+static void FN_remove_material(LPITEM* items, DWORD item_vnum, int need_count)
+{
+	int count = 0;
+	LPITEM item = NULL;
+
+	// for all cube
+	for (int i = 0; i < CUBE_MAX_NUM; ++i)
+	{
+		if (NULL == items[i]) continue;
+
+		item = items[i];
+
+		if (item->IsEquipped() == true)
+			continue;
+
+		if (item_vnum == item->GetVnum())
+		{
+			count += item->GetCount();
+
+			if (count > need_count)
+			{
+				item->SetCount(count - need_count);
+				return;
+			}
+			else
+			{
+				item->SetCount(0);
+				items[i] = NULL;
+			}
+		}
+	}
+}
+
+static CUBE_DATA* FN_find_cube(LPITEM* items, WORD npc_vnum)
+{
+	DWORD i, end_index;
+
+	if (0 == npc_vnum) return NULL;
+
+	// FOR ALL CUBE_PROTO
+	end_index = s_cube_proto.size();
+	for (i = 0; i < end_index; ++i)
+	{
+		if (s_cube_proto[i]->can_make_item(items, npc_vnum))
+			return s_cube_proto[i];
+	}
+
+	return NULL;
+}
+
+static bool FN_check_valid_npc(WORD vnum)
+{
+	for (std::vector<CUBE_DATA*>::iterator iter = s_cube_proto.begin(); iter != s_cube_proto.end(); iter++)
+	{
+		if (std::find((*iter)->npc_vnum.begin(), (*iter)->npc_vnum.end(), vnum) != (*iter)->npc_vnum.end())
+			return true;
+	}
+
+	return false;
+}
+
+// 큐援Ε 첫摸 珂화 퓸 체크磯.
+static bool FN_check_cube_data(CUBE_DATA* cube_data)
+{
+	DWORD i = 0;
+	DWORD end_index = 0;
+
+	end_index = cube_data->npc_vnum.size();
+	for (i = 0; i < end_index; ++i)
+	{
+		if (cube_data->npc_vnum[i] == 0) return false;
+	}
+
+	end_index = cube_data->item.size();
+	for (i = 0; i < end_index; ++i)
+	{
+		if (cube_data->item[i].vnum == 0) return false;
+		if (cube_data->item[i].count == 0) return false;
+	}
+
+	end_index = cube_data->reward.size();
+	for (i = 0; i < end_index; ++i)
+	{
+		if (cube_data->reward[i].vnum == 0) return false;
+		if (cube_data->reward[i].count == 0) return false;
+	}
+
+	return true;
+}
+
+CUBE_DATA::CUBE_DATA()
+{
+	this->percent = 0;
+	this->gold = 0;
+#if defined(__CUBE_RENEWAL__)
+	this->not_remove = 0; // nothing to remove
+#endif
+}
+
+// 却   求 체크磯.
+bool CUBE_DATA::can_make_item(LPITEM* items, WORD npc_vnum)
+{
+	// 却 ,  求 체크磯.
+	DWORD i, end_index;
+	DWORD need_vnum;
+	int need_count;
+	int found_npc = false;
+
+	// check npc_vnum
+	end_index = this->npc_vnum.size();
+	for (i = 0; i < end_index; ++i)
+	{
+		if (npc_vnum == this->npc_vnum[i])
+			found_npc = true;
+	}
+	if (false == found_npc) return false;
+
+	end_index = this->item.size();
+	for (i = 0; i < end_index; ++i)
+	{
+		need_vnum = this->item[i].vnum;
+		need_count = this->item[i].count;
+
+		if (false == FN_check_item_count(items, need_vnum, need_count))
+			return false;
+	}
+
+	return true;
+}
+
+// 큐湲     
+CUBE_VALUE* CUBE_DATA::reward_value()
+{
+	int end_index = 0;
+	DWORD reward_index = 0;
+
+	end_index = this->reward.size();
+	reward_index = number(0, end_index);
+	reward_index = number(0, end_index - 1);
+
+	return &this->reward[reward_index];
+}
+
+// 큐轅 獵 搔 
+void CUBE_DATA::remove_material(LPCHARACTER ch)
+{
+	DWORD i, end_index;
+	DWORD need_vnum;
+	int need_count;
+	LPITEM* items = ch->GetCubeItem();
+
+	end_index = this->item.size();
+	for (i = 0; i < end_index; ++i)
+	{
+		need_vnum = this->item[i].vnum;
+		need_count = this->item[i].count;
+
+#if defined(__CUBE_RENEWAL__)
+		if (this->not_remove == need_vnum)
+			continue;
+#endif
+
+		FN_remove_material(items, need_vnum, need_count);
+	}
+}
+
+void Cube_clean_item(LPCHARACTER ch)
+{
+	LPITEM* cube_item;
+
+	cube_item = ch->GetCubeItem();
+
+	for (int i = 0; i < CUBE_MAX_NUM; ++i)
+	{
+		if (NULL == cube_item[i])
+			continue;
+
+		cube_item[i] = NULL;
+	}
+}
+
+// 큐창 
+void Cube_open(LPCHARACTER ch)
+{
+	const auto reload = !s_isInitializedCubeMaterialInformation;
+
+	if (false == s_isInitializedCubeMaterialInformation)
+	{
+		Cube_InformationInitialize();
+	}
+
+	if (NULL == ch)
+		return;
+
+	LPCHARACTER npc;
+	npc = ch->GetQuestNPC();
+	if (NULL == npc)
+	{
+		if (test_server)
+			dev_log(LOG_DEB0, "cube_npc is NULL");
+		return;
+	}
+
+	if (FN_check_valid_npc(npc->GetRaceNum()) == false)
+	{
+		if (test_server == true)
+		{
+			dev_log(LOG_DEB0, "cube not valid NPC");
+		}
+		return;
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (ch->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || ch->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
+		return;
+	}
+#endif
+
+	if (ch->IsCubeOpen())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 창 笭求."));
+		return;
+	}
+
+	if (ch->PreventTradeWindow(WND_ALL))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹(창,환,)   求."));
+		return;
+	}
+
+	long distance = DISTANCE_APPROX(ch->GetX() - npc->GetX(), ch->GetY() - npc->GetY());
+
+	if (distance >= CUBE_MAX_DISTANCE)
+	{
+		sys_log(1, "CUBE: TOO_FAR: %s distance %d", ch->GetName(), distance);
+		return;
+	}
+
+	Cube_clean_item(ch);
+	ch->SetCubeNpc(npc);
+	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube open %d %d", npc->GetRaceNum(), reload);
+}
+
+// 큐 캔
+void Cube_close(LPCHARACTER ch)
+{
+	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
+	Cube_clean_item(ch);
+	ch->SetCubeNpc(NULL);
+	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube close");
+	dev_log(LOG_DEB0, "<CUBE> close (%s)", ch->GetName());
+}
+
+void Cube_init()
+{
+	CUBE_DATA* p_cube = NULL;
+	std::vector<CUBE_DATA*>::iterator iter;
+
+	char file_name[256 + 1];
+	snprintf(file_name, sizeof(file_name), "%s/cube.txt", LocaleService_GetBasePath().c_str());
+
+	sys_log(0, "Cube_Init %s", file_name);
+
+	for (iter = s_cube_proto.begin(); iter != s_cube_proto.end(); iter++)
+	{
+		p_cube = *iter;
+		M2_DELETE(p_cube);
+	}
+
+	s_cube_proto.clear();
+
+	cube_info_map.clear();
+	cube_result_info_map_by_npc.clear();
+	s_isInitializedCubeMaterialInformation = false;
+
+	if (false == Cube_load(file_name))
+		sys_err("Cube_Init failed");
+}
+
+bool Cube_load(const char* file)
+{
+	FILE* fp;
+	char one_line[512];
+	int value1, value2;
+	const char* delim = " \t\r\n";
+	char* v, * token_string;
+	CUBE_DATA* cube_data = NULL;
+	CUBE_VALUE cube_value = { 0,0 };
+
+	if (0 == file || 0 == file[0])
+		return false;
+
+	if ((fp = fopen(file, "r")) == 0)
+		return false;
+
+	while (fgets(one_line, 512, fp))
+	{
+		value1 = value2 = 0;
+
+		if (one_line[0] == '#')
+			continue;
+
+		token_string = strtok(one_line, delim);
+
+		if (NULL == token_string)
+			continue;
+
+		// set value1, value2
+		if ((v = strtok(NULL, delim)))
+			str_to_number(value1, v);
+
+		if ((v = strtok(NULL, delim)))
+			str_to_number(value2, v);
+
+		TOKEN("section")
+		{
+			cube_data = M2_NEW CUBE_DATA;
+		}
+		else TOKEN("npc")
+		{
+			cube_data->npc_vnum.push_back((WORD)value1);
+		}
+		else TOKEN("item")
+		{
+			cube_value.vnum = value1;
+			cube_value.count = value2;
+
+			cube_data->item.push_back(cube_value);
+		}
+		else TOKEN("reward")
+		{
+			cube_value.vnum = value1;
+			cube_value.count = value2;
+
+			cube_data->reward.push_back(cube_value);
+		}
+		else TOKEN("percent")
+		{
+			cube_data->percent = value1;
+		}
+	else TOKEN("gold")
+	{
+		//  却 附
+		cube_data->gold = value1;
+	}
+#if defined(__CUBE_RENEWAL__)
+	else TOKEN("not_remove")
+	{
+		//  却 附
+		cube_data->not_remove = value1;
+	}
+#endif
+else TOKEN("end")
+{
+	// TODO : check cube data
+	if (false == FN_check_cube_data(cube_data))
+	{
+		dev_log(LOG_DEB0, "something wrong");
+		M2_DELETE(cube_data);
+		continue;
+	}
+	s_cube_proto.push_back(cube_data);
+}
+	}
+
+	fclose(fp);
+	return true;
+}
+
+static void FN_cube_print(CUBE_DATA* data, DWORD index)
+{
+	DWORD i;
+	dev_log(LOG_DEB0, "--------------------------------");
+	dev_log(LOG_DEB0, "CUBE_DATA[%d]", index);
+
+	for (i = 0; i < data->npc_vnum.size(); ++i)
+	{
+		dev_log(LOG_DEB0, "\tNPC_VNUM[%d] = %d", i, data->npc_vnum[i]);
+	}
+	for (i = 0; i < data->item.size(); ++i)
+	{
+		dev_log(LOG_DEB0, "\tITEM[%d] = (%d, %d)", i, data->item[i].vnum, data->item[i].count);
+	}
+	for (i = 0; i < data->reward.size(); ++i)
+	{
+		dev_log(LOG_DEB0, "\tREWARD[%d] = (%d, %d)", i, data->reward[i].vnum, data->reward[i].count);
+	}
+	dev_log(LOG_DEB0, "\tPERCENT = %d", data->percent);
+	dev_log(LOG_DEB0, "--------------------------------");
+}
+
+void Cube_print()
+{
+	for (DWORD i = 0; i < s_cube_proto.size(); ++i)
+	{
+		FN_cube_print(s_cube_proto[i], i);
+	}
+}
+
+static bool FN_update_cube_status(LPCHARACTER ch)
+{
+	if (NULL == ch)
+		return false;
+
+	if (!ch->IsCubeOpen())
+		return false;
+
+	LPCHARACTER npc = ch->GetQuestNPC();
+	if (NULL == npc)
+		return false;
+
+	CUBE_DATA* cube = FN_find_cube(ch->GetCubeItem(), npc->GetRaceNum());
+
+	if (NULL == cube)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "cube info 0 0 0");
+		return false;
+	}
+
+	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube info %d %d %d", cube->gold, 0, 0);
+	return true;
+}
+
+// return new item
+bool Cube_make(LPCHARACTER ch)
+{
+	// 羚  却求  찾쨈. (큐援Ε 칭)
+	// 큐 타 獵摸  搔 체크磯.
+	// 恝  .
+	// 恝  
+
+	LPCHARACTER npc;
+	int percent_number = 0;
+	CUBE_DATA* cube_proto;
+	LPITEM* items;
+	LPITEM new_item;
+
+	if (!(ch)->IsCubeOpen())
+	{
+		(ch)->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창  駕求"));
+		return false;
+	}
+
+	npc = ch->GetQuestNPC();
+	if (NULL == npc)
+	{
+		return false;
+	}
+
+	items = ch->GetCubeItem();
+	cube_proto = FN_find_cube(items, npc->GetRaceNum());
+
+	if (NULL == cube_proto)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 嘯 爛求"));
+		return false;
+	}
+
+	if (ch->GetGold() < 0)
+	{
+		sys_err("Player %s with negative gold is trying to use cube!", ch->GetName());
+		return false;
+	}
+
+	unsigned long long gold = ch->GetGold();
+	if (gold < static_cast<unsigned long long>(cube_proto->gold))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 構킬  美 求."));	//  灣트 譴 罐 甄째킷 煞 却 
+		return false;
+	}
+
+	CUBE_VALUE* reward_value = cube_proto->reward_value();
+
+	// 퓸  
+	cube_proto->remove_material(ch);
+
+	//  却  
+	if (cube_proto->gold > 0)
+		ch->PointChange(POINT_GOLD, -(long long)cube_proto->gold, false);
+
+	percent_number = number(1, 100);
+	if (percent_number <= cube_proto->percent)
+	{
+		// 
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "cube success %d %d", reward_value->vnum, reward_value->count);
+		new_item = ch->AutoGiveItem(reward_value->vnum, reward_value->count);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		ch->UpdateExtBattlePassMissionProgress(BP_ITEM_CRAFT, reward_value->count, reward_value->vnum);
+#endif
+
+#if defined(__QUEST_EVENT_CRAFT__)
+		ch->SetQuestNPCID(npc->GetVID());
+		quest::CQuestManager::instance().CraftItem(ch->GetPlayerID(), npc->GetRaceNum(), new_item);
+#endif
+
+		LogManager::instance().CubeLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(),
+			reward_value->vnum, new_item->GetID(), reward_value->count, 1);
+		return true;
+	}
+	else
+	{
+		// 
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 臼求.")); // 2012.11.12  煞 氷 (locale_string.txt  煞瞞 )
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "cube fail");
+		LogManager::instance().CubeLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(),
+			reward_value->vnum, 0, 0, 0);
+		return false;
+	}
+
+	return false;
+}
+
+// 큐轅 獵 滂 표
+void Cube_show_list(LPCHARACTER ch)
+{
+	LPITEM* cube_item;
+	LPITEM item;
+
+	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
+
+	cube_item = ch->GetCubeItem();
+
+	for (int i = 0; i < CUBE_MAX_NUM; ++i)
+	{
+		item = cube_item[i];
+		if (NULL == item) continue;
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "cube[%d]: inventory[%d]: %s", i, item->GetCell(), item->GetName());
+	}
+}
+
+// 觀訝 獵  큐轅 
+void Cube_add_item(LPCHARACTER ch, int cube_index, int inven_index)
+{
+	//  獵째?
+	// 큐怨 美 찾
+	// 큐瑗
+	// 聘 
+	LPITEM item;
+	LPITEM* cube_item;
+
+	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
+
+	if (inven_index < 0 || INVENTORY_MAX_NUM <= inven_index)
+		return;
+
+	if (cube_index < 0 || CUBE_MAX_NUM <= cube_index)
+		return;
+
+	item = ch->GetInventoryItem(inven_index);
+
+	if (NULL == item) return;
+
+	cube_item = ch->GetCubeItem();
+
+	// 譴 摸치 溝퓸 見  indext
+	for (int i = 0; i < CUBE_MAX_NUM; ++i)
+	{
+		if (item == cube_item[i])
+		{
+			cube_item[i] = NULL;
+			break;
+		}
+	}
+
+	cube_item[cube_index] = item;
+
+	if (test_server)
+		ch->ChatPacket(CHAT_TYPE_INFO, "cube[%d]: inventory[%d]: %s added", cube_index, inven_index, item->GetName());
+
+	//  悶 철 滂    獵 클潔트  
+	//  構槁 柳 却 弱  
+	FN_update_cube_status(ch);
+
+	return;
+}
+
+// 큐轅≒  
+void Cube_delete_item(LPCHARACTER ch, int cube_index)
+{
+	LPITEM item;
+	LPITEM* cube_item;
+
+	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
+
+	if (cube_index < 0 || CUBE_MAX_NUM <= cube_index) return;
+
+	cube_item = ch->GetCubeItem();
+
+	if (NULL == cube_item[cube_index]) return;
+
+	item = cube_item[cube_index];
+	cube_item[cube_index] = NULL;
+
+	if (test_server)
+		ch->ChatPacket(CHAT_TYPE_INFO, "cube[%d]: cube[%d]: %s deleted", cube_index, item->GetCell(), item->GetName());
+
+	//  悶 철 滂    獵 클潔트  
+	//  構槁 柳 却 弱  
+	FN_update_cube_status(ch);
+
+	return;
+}
+
+//  見 漫  見 화 龜求 獨 (斂+5 -> 斂, 5)
+SItemNameAndLevel SplitItemNameAndLevelFromName(const std::string& name)
+{
+	int level = 0;
+	SItemNameAndLevel info;
+	info.name = name;
+
+	size_t pos = name.find("+");
+
+	if (std::string::npos != pos)
+	{
+		const std::string levelStr = name.substr(pos + 1, name.size() - pos - 1);
+		str_to_number(level, levelStr.c_str());
+
+		info.name = name.substr(0, pos);
+	}
+
+	info.level = level;
+
+	return info;
+};
+
+bool FIsEqualCubeValue(const CUBE_VALUE& a, const CUBE_VALUE& b)
+{
+	return (a.vnum == b.vnum) && (a.count == b.count);
+}
+
+bool FIsLessCubeValue(const CUBE_VALUE& a, const CUBE_VALUE& b)
+{
+	return a.vnum < b.vnum;
+}
+
+void Cube_MakeCubeInformationText()
+{
+	//   큐     클潔트    환.
+	for (TCubeMapByNPC::iterator iter = cube_info_map.begin(); cube_info_map.end() != iter; ++iter)
+	{
+		const DWORD& npcVNUM = iter->first;
+		TCubeResultList& resultList = iter->second;
+
+		for (TCubeResultList::iterator resultIter = resultList.begin(); resultList.end() != resultIter; ++resultIter)
+		{
+			SCubeMaterialInfo& materialInfo = *resultIter;
+			std::string& infoText = materialInfo.infoText;
+
+			// 犬 枋潔
+			if (0 < materialInfo.complicateMaterial.size())
+			{
+				std::sort(materialInfo.complicateMaterial.begin(), materialInfo.complicateMaterial.end(), FIsLessCubeValue);
+				std::sort(materialInfo.material.begin(), materialInfo.material.end(), FIsLessCubeValue);
+
+				//// 揷풔  
+				for (TCubeValueVector::iterator iter = materialInfo.complicateMaterial.begin(); materialInfo.complicateMaterial.end() != iter; ++iter)
+				{
+					for (TCubeValueVector::iterator targetIter = materialInfo.material.begin(); materialInfo.material.end() != targetIter; ++targetIter)
+					{
+						if (*targetIter == *iter)
+						{
+							targetIter = materialInfo.material.erase(targetIter);
+						}
+					}
+				}
+
+				// 72723,1 or 72725,1 or ... 肩  撻  키 灣트 
+				for (TCubeValueVector::iterator iter = materialInfo.complicateMaterial.begin(); materialInfo.complicateMaterial.end() != iter; ++iter)
+				{
+					char tempBuffer[128];
+					snprintf(tempBuffer, sizeof(tempBuffer), "%d,%d|", iter->vnum, iter->count);
+
+					infoText += std::string(tempBuffer);
+				}
+
+				infoText.erase(infoText.size() - 1);
+
+				if (0 < materialInfo.material.size())
+					infoText.push_back('&');
+			}
+
+			// 揷 苛 球 俑  
+			for (TCubeValueVector::iterator iter = materialInfo.material.begin(); materialInfo.material.end() != iter; ++iter)
+			{
+				char tempBuffer[128];
+				snprintf(tempBuffer, sizeof(tempBuffer), "%d,%d&", iter->vnum, iter->count);
+				infoText += std::string(tempBuffer);
+			}
+
+			infoText.erase(infoText.size() - 1);
+
+			//   弱 却求摸  煞
+			if (0 < materialInfo.gold)
+			{
+				char temp[128];
+				snprintf(temp, sizeof(temp), "%d", materialInfo.gold);
+				infoText += std::string("/") + temp;
+			}
+
+			//sys_err("\t\tNPC: %d, Reward: %d(%s)\n\t\t\tInfo: %s", npcVNUM, materialInfo.reward.vnum, ITEM_MANAGER::Instance().GetTable(materialInfo.reward.vnum)->szName, materialInfo.infoText.c_str());
+		} // for resultList
+	} // for npc
+}
+
+bool Cube_InformationInitialize()
+{
+	for (int i = 0; i < s_cube_proto.size(); ++i)
+	{
+		CUBE_DATA* cubeData = s_cube_proto[i];
+
+		const std::vector<CUBE_VALUE>& rewards = cubeData->reward;
+
+		// 溝湄 
+		if (1 != rewards.size())
+		{
+			sys_err("[CubeInfo] WARNING! Does not support multiple rewards (count: %d)", rewards.size());
+			continue;
+		}
+		/*
+		if (1 != cubeData->npc_vnum.size())
+		{
+			sys_err("[CubeInfo] WARNING! Does not support multiple NPC (count: %d)", cubeData->npc_vnum.size());
+			continue;
+		}
+		*/
+
+		const CUBE_VALUE& reward = rewards.at(0);
+		const WORD& npcVNUM = cubeData->npc_vnum.at(0);
+		bool bComplicate = false;
+
+		TCubeMapByNPC& cubeMap = cube_info_map;
+		TCubeResultList& resultList = cubeMap[npcVNUM];
+		SCubeMaterialInfo materialInfo;
+
+		materialInfo.reward = reward;
+		materialInfo.gold = cubeData->gold;
+		materialInfo.material = cubeData->item;
+
+		for (TCubeResultList::iterator iter = resultList.begin(); resultList.end() != iter; ++iter)
+		{
+			SCubeMaterialInfo& existInfo = *iter;
+
+			// 譴 揷풔  溝퓸 獵摸 틸 摸   ,
+			//   琯 특 觀龜 틀  .
+			//  특 觀龜 틀 滂 틔처 毬 底 毬  殮 :
+			// :
+			//		斂+5 ~ +9 x 1
+			//		 칼米  x1
+			//		   x1
+			if (reward.vnum == existInfo.reward.vnum)
+			{
+				for (TCubeValueVector::iterator existMaterialIter = existInfo.material.begin(); existInfo.material.end() != existMaterialIter; ++existMaterialIter)
+				{
+					TItemTable* existMaterialProto = ITEM_MANAGER::Instance().GetTable(existMaterialIter->vnum);
+					if (NULL == existMaterialProto)
+					{
+						sys_err("There is no item(%u)", existMaterialIter->vnum);
+						return false;
+					}
+					SItemNameAndLevel existItemInfo = SplitItemNameAndLevelFromName(existMaterialProto->szName);
+
+					if (0 < existItemInfo.level)
+					{
+						//  煞求 큐  ,  溝퓸獵 큐   
+						// 揷풔 觀 獵 講磯
+						for (TCubeValueVector::iterator currentMaterialIter = materialInfo.material.begin(); materialInfo.material.end() != currentMaterialIter; ++currentMaterialIter)
+						{
+							TItemTable* currentMaterialProto = ITEM_MANAGER::Instance().GetTable(currentMaterialIter->vnum);
+							SItemNameAndLevel currentItemInfo = SplitItemNameAndLevelFromName(currentMaterialProto->szName);
+
+							if (currentItemInfo.name == existItemInfo.name)
+							{
+								bComplicate = true;
+								existInfo.complicateMaterial.push_back(*currentMaterialIter);
+
+								if (std::find(existInfo.complicateMaterial.begin(), existInfo.complicateMaterial.end(), *existMaterialIter) == existInfo.complicateMaterial.end())
+									existInfo.complicateMaterial.push_back(*existMaterialIter);
+
+								//currentMaterialIter = materialInfo.material.erase(currentMaterialIter);
+
+								// TODO : 揷풔    鵑 瞞   
+								break;
+							}
+						} // for currentMaterialIter
+					} // if level
+				} // for existMaterialInfo
+			} // if (reward.vnum == existInfo.reward.vnum)
+
+		} // for resultList
+
+		if (false == bComplicate)
+			resultList.push_back(materialInfo);
+	}
+
+	Cube_MakeCubeInformationText();
+
+	s_isInitializedCubeMaterialInformation = true;
+	return true;
+}
+
+// 클潔트  :  NPC   獵 滂 () 청
+void Cube_request_result_list(LPCHARACTER ch)
+{
+	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
+
+	LPCHARACTER npc = ch->GetQuestNPC();
+	if (NULL == npc)
+		return;
+
+	DWORD npcVNUM = npc->GetRaceNum();
+	size_t resultCount = 0;
+
+	std::string& resultText = cube_result_info_map_by_npc[npcVNUM];
+
+	// 娩 NPC   獵    摸 캐첩 
+	if (resultText.length() == 0)
+	{
+		resultText.clear();
+
+		const TCubeResultList& resultList = cube_info_map[npcVNUM];
+		for (TCubeResultList::const_iterator iter = resultList.begin(); resultList.end() != iter; ++iter)
+		{
+			const SCubeMaterialInfo& materialInfo = *iter;
+			char temp[128];
+			snprintf(temp, sizeof(temp), "%d,%d", materialInfo.reward.vnum, materialInfo.reward.count);
+
+			resultText += std::string(temp) + "/";
+		}
+
+		resultCount = resultList.size();
+
+		resultText.erase(resultText.size() - 1);
+
+		// 채 킷 璣甕 耭載  ... 획 筠  娩牝 청構킬, 傷 摸  侮鳴킬...
+		if (resultText.size() - 20 >= CHAT_MAX_LEN)
+		{
+			sys_err("[CubeInfo] Too long cube result list text. (NPC: %d, length: %d)", npcVNUM, resultText.size());
+			resultText.clear();
+			resultCount = 0;
+		}
+
+	}
+
+	//  NPC   獵 滂  틔  磯.
+	// (Server -> Client) /cube r_list npcVNUM resultCount vnum1,count1/vnum2,count2,/vnum3,count3/...
+	// (Server -> Client) /cube r_list 20383 4 123,1/125,1/128,1/130,5
+
+	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube r_list %d %d %s", npcVNUM, resultCount, resultText.c_str());
+}
+
+//
+void Cube_request_material_info(LPCHARACTER ch, int requestStartIndex, int requestCount)
+{
+	RETURN_IF_CUBE_IS_NOT_OPENED(ch);
+
+	LPCHARACTER npc = ch->GetQuestNPC();
+	if (NULL == npc)
+		return;
+
+	DWORD npcVNUM = npc->GetRaceNum();
+	std::string materialInfoText = "";
+
+	int index = 0;
+	bool bCatchInfo = false;
+
+	const TCubeResultList& resultList = cube_info_map[npcVNUM];
+	for (TCubeResultList::const_iterator iter = resultList.begin(); resultList.end() != iter; ++iter)
+	{
+		const SCubeMaterialInfo& materialInfo = *iter;
+
+		if (index++ == requestStartIndex)
+		{
+			bCatchInfo = true;
+		}
+
+		if (bCatchInfo)
+		{
+			materialInfoText += materialInfo.infoText + "@";
+		}
+
+		if (index >= requestStartIndex + requestCount)
+			break;
+	}
+
+	if (false == bCatchInfo)
+	{
+		sys_err("[CubeInfo] Can't find matched material info (NPC: %d, index: %d, request count: %d)", npcVNUM, requestStartIndex, requestCount);
+		return;
+	}
+
+	materialInfoText.erase(materialInfoText.size() - 1);
+
+	//
+	// (Server -> Client) /cube m_info start_index count 125,1|126,2|127,2|123,5&555,5&555,4/120000
+	if (materialInfoText.size() - 20 >= CHAT_MAX_LEN)
+	{
+		sys_err("[CubeInfo] Too long material info. (NPC: %d, requestStart: %d, requestCount: %d, length: %d)", npcVNUM, requestStartIndex, requestCount, materialInfoText.size());
+	}
+
+	ch->ChatPacket(CHAT_TYPE_COMMAND, "cube m_info %d %d %s", requestStartIndex, requestCount, materialInfoText.c_str());
+}
+#endif
diff --git a/server/metin2/Source/Server/game/src/desc.cpp b/server/metin2/Source/Server/game/src/desc.cpp
index 26b137a..b9cd691 100644
--- a/server/metin2/Source/Server/game/src/desc.cpp
+++ b/server/metin2/Source/Server/game/src/desc.cpp
@@ -1,1125 +1,1195 @@
-#include "stdafx.h"
-#include "config.h"
-#include "utils.h"
-#include "desc.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "protocol.h"
-#include "packet.h"
-#include "messenger_manager.h"
-#include "sectree_manager.h"
-#include "p2p.h"
-#include "buffer_manager.h"
-#if defined(__SEND_SEQUENCE__)
-#	include "sequence.h"
-#endif
-#include "guild.h"
-#include "guild_manager.h"
-#include "TrafficProfiler.h"
-#include "locale_service.h"
-#include "log.h"
-
-extern int max_bytes_written;
-extern int current_bytes_written;
-extern int total_bytes_written;
-
-DESC::DESC()
-{
-	Initialize();
-}
-
-DESC::~DESC()
-{
-}
-
-void DESC::Initialize()
-{
-	m_bDestroyed = false;
-
-	m_pInputProcessor = NULL;
-	m_lpFdw = NULL;
-	m_sock = INVALID_SOCKET;
-	m_iPhase = PHASE_CLOSE;
-	m_dwHandle = 0;
-
-	m_wPort = 0;
-	m_LastTryToConnectTime = 0;
-
-	m_lpInputBuffer = NULL;
-	m_iMinInputBufferLen = 0;
-
-	m_dwHandshake = 0;
-	m_dwHandshakeSentTime = 0;
-	m_iHandshakeRetry = 0;
-	m_dwClientTime = 0;
-	m_bHandshaking = false;
-
-	m_lpBufferedOutputBuffer = NULL;
-	m_lpOutputBuffer = NULL;
-
-	m_pkPingEvent = NULL;
-	m_lpCharacter = NULL;
-	memset(&m_accountTable, 0, sizeof(m_accountTable));
-
-	memset(&m_SockAddr, 0, sizeof(m_SockAddr));
-	memset(&m_UDPSockAddr, 0, sizeof(m_UDPSockAddr));
-
-	m_pLogFile = NULL;
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	m_bEncrypted = false;
-#endif
-
-	m_wP2PPort = 0;
-	m_bP2PChannel = 0;
-
-	m_bAdminMode = false;
-	m_bPong = true;
-	m_bChannelStatusRequested = false;
-
-#if defined(__SEND_SEQUENCE__)
-	m_iCurrentSequence = 0;
-	m_seq_vector.clear();
-#endif
-
-	m_pkLoginKey = NULL;
-	m_dwLoginKey = 0;
-	m_dwPanamaKey = 0;
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	memset(m_adwDecryptionKey, 0, sizeof(m_adwDecryptionKey));
-	memset(m_adwEncryptionKey, 0, sizeof(m_adwEncryptionKey));
-#endif
-
-	m_bCRCMagicCubeIdx = 0;
-	m_dwProcCRC = 0;
-	m_dwFileCRC = 0;
-	m_bHackCRCQuery = 0;
-
-	m_outtime = 0;
-	m_playtime = 0;
-	m_offtime = 0;
-
-	m_pkDisconnectEvent = NULL;
-}
-
-void DESC::Destroy()
-{
-	if (m_bDestroyed)
-		return;
-
-	m_bDestroyed = true;
-
-	if (m_pkLoginKey)
-		m_pkLoginKey->Expire();
-
-	if (GetAccountTable().id)
-		DESC_MANAGER::instance().DisconnectAccount(GetAccountTable().login);
-
-	if (m_pLogFile)
-	{
-		fclose(m_pLogFile);
-		m_pLogFile = NULL;
-	}
-
-	if (m_lpCharacter)
-	{
-		m_lpCharacter->Disconnect("DESC::~DESC");
-		m_lpCharacter = NULL;
-	}
-
-	SAFE_BUFFER_DELETE(m_lpOutputBuffer);
-	SAFE_BUFFER_DELETE(m_lpInputBuffer);
-
-	event_cancel(&m_pkPingEvent);
-	event_cancel(&m_pkDisconnectEvent);
-
-	if (!g_bAuthServer)
-	{
-		if (m_accountTable.login[0] && m_accountTable.passwd[0])
-		{
-			TLogoutPacket pack;
-
-			strlcpy(pack.login, m_accountTable.login, sizeof(pack.login));
-			strlcpy(pack.passwd, m_accountTable.passwd, sizeof(pack.passwd));
-
-			db_clientdesc->DBPacket(HEADER_GD_LOGOUT, m_dwHandle, &pack, sizeof(TLogoutPacket));
-		}
-	}
-
-	if (m_sock != INVALID_SOCKET)
-	{
-		sys_log(0, "SYSTEM: closing socket. DESC #%d", m_sock);
-		Log("SYSTEM: closing socket. DESC #%d", m_sock);
-		fdwatch_del_fd(m_lpFdw, m_sock);
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-		cipher_.CleanUp();
-#endif
-
-		socket_close(m_sock);
-		m_sock = INVALID_SOCKET;
-	}
-
-#if defined(__SEND_SEQUENCE__)
-	m_seq_vector.clear();
-#endif
-}
-
-EVENTFUNC(ping_event)
-{
-	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("ping_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPDESC desc = info->desc;
-
-	if (desc->IsAdminMode())
-		return (ping_event_second_cycle);
-
-	if (!desc->IsPong())
-	{
-		sys_log(0, "PING_EVENT: no pong %s", desc->GetHostName());
-
-		desc->SetPhase(PHASE_CLOSE);
-
-		return (ping_event_second_cycle);
-	}
-	else
-	{
-		TPacketGCPing p;
-		p.header = HEADER_GC_PING;
-		desc->Packet(&p, sizeof(struct packet_ping));
-		desc->SetPong(false);
-	}
-
-	desc->SendHandshake(get_dword_time(), 0);
-
-	return (ping_event_second_cycle);
-}
-
-bool DESC::IsPong()
-{
-	return m_bPong;
-}
-
-void DESC::SetPong(bool b)
-{
-	m_bPong = b;
-}
-
-bool DESC::Setup(LPFDWATCH _fdw, socket_t _fd, const struct sockaddr_in& c_rSockAddr, DWORD _handle, DWORD _handshake)
-{
-	m_lpFdw = _fdw;
-	m_sock = _fd;
-
-	m_stHost = inet_ntoa(c_rSockAddr.sin_addr);
-	m_wPort = c_rSockAddr.sin_port;
-	m_dwHandle = _handle;
-
-	//if (LC_IsEurope() == true || LC_IsNewCIBN())
-	//	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
-	//else
-	// NOTE: 이걸 나라별로 다르게 잡아야할 이유가 있나?
-	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
-
-	m_iMinInputBufferLen = MAX_INPUT_LEN >> 1;
-	m_lpInputBuffer = buffer_new(MAX_INPUT_LEN);
-
-	m_SockAddr = c_rSockAddr;
-
-	fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_READ, false);
-
-	// Ping Event 
-	desc_event_info* info = AllocEventInfo<desc_event_info>();
-
-	info->desc = this;
-	assert(m_pkPingEvent == NULL);
-
-	m_pkPingEvent = event_create(ping_event, info, ping_event_second_cycle);
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	thecore_memcpy(m_adwEncryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
-	thecore_memcpy(m_adwDecryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
-#endif
-
-	// Set Phase to handshake
-	SetPhase(PHASE_HANDSHAKE);
-	StartHandshake(_handshake);
-
-	sys_log(0, "SYSTEM: new connection from [%s] fd: %d handshake %u output input_len %d, ptr %p",
-		m_stHost.c_str(), m_sock, m_dwHandshake, buffer_size(m_lpInputBuffer), this);
-
-	Log("SYSTEM: new connection from [%s] fd: %d handshake %u ptr %p", m_stHost.c_str(), m_sock, m_dwHandshake, this);
-	return true;
-}
-
-int DESC::ProcessInput()
-{
-	ssize_t bytes_read;
-
-	if (!m_lpInputBuffer)
-	{
-		sys_err("DESC::ProcessInput : nil input buffer");
-		return -1;
-	}
-
-	buffer_adjust_size(m_lpInputBuffer, m_iMinInputBufferLen);
-	bytes_read = socket_read(m_sock, (char*)buffer_write_peek(m_lpInputBuffer), buffer_has_space(m_lpInputBuffer));
-
-	if (bytes_read < 0)
-		return -1;
-	else if (bytes_read == 0)
-		return 0;
-
-	buffer_write_proceed(m_lpInputBuffer, bytes_read);
-
-	if (!m_pInputProcessor)
-		sys_err("no input processor");
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	else
-	{
-		// making a temporary buffer used to decrypt memory
-		TEMP_BUFFER temporary;
-
-		// checking for non read byes on decrypted buffer
-		// moving the stored buffer to the temporary one
-		if(m_lpInputDecryptedBuffer.size() != 0)
-			temporary.write(m_lpInputDecryptedBuffer.read_peek(), m_lpInputDecryptedBuffer.size());
-
-		// adding the readable memory from the input buffer
-		auto readableInput = buffer_size(m_lpInputBuffer);
-		if(readableInput > temporary.size())
-		{
-			const auto readPoint = (const char*) buffer_read_peek(m_lpInputBuffer);
-			temporary.write(readPoint + temporary.size(), readableInput - temporary.size());
-		}
-
-		if(temporary.size() == 0)
-			return 0;
-
-		// decrypting only non decrypted chunk of memory
-		if (cipher_.activated())
-		{
-			const auto decryptPoint = ((const char*)temporary.read_peek()) + m_lpInputDecryptedBuffer.size();
-			cipher_.Decrypt((void*)(decryptPoint), readableInput - m_lpInputDecryptedBuffer.size());
-		}
-
-		auto processingPoint = (const char*) temporary.read_peek();
-		auto processingRemainSize = temporary.size();
-		auto processingTotalSize = 0;
-
-		int iBytesProceed = 0;
-
-		// false가 리턴 되면 다른 phase로 바뀐 것이므로 다시 프로세스로 돌입한다!
-		while (processingRemainSize > 0 && !m_pInputProcessor->Process(this, (const void*)processingPoint, processingRemainSize, iBytesProceed))
-		{
-			processingPoint += iBytesProceed;
-			processingTotalSize += iBytesProceed;
-			processingRemainSize -= iBytesProceed;
-			iBytesProceed = 0;
-		}
-
-		processingPoint += iBytesProceed;
-		processingTotalSize += iBytesProceed;
-		processingRemainSize -= iBytesProceed;
-
-		// applying result on input buffer
-		buffer_read_proceed(m_lpInputBuffer, processingTotalSize);
-
-		// registering remaining unprocessed (but decrypted) bytes
-		m_lpInputDecryptedBuffer.reset();
-		if(processingTotalSize < temporary.size()){
-			const auto storingPoint = ((const char*) temporary.read_peek()) + processingTotalSize;
-			m_lpInputDecryptedBuffer.write(storingPoint, temporary.size() - processingTotalSize);
-		}
-	}
-#else
-	else if (!m_bEncrypted)
-	{
-		int iBytesProceed = 0;
-
-		// false가 리턴 되면 다른 phase로 바뀐 것이므로 다시 프로세스로 돌입한다!
-		while (!m_pInputProcessor->Process(this, buffer_read_peek(m_lpInputBuffer), buffer_size(m_lpInputBuffer), iBytesProceed))
-		{
-			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-			iBytesProceed = 0;
-		}
-
-		buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-	}
-	else
-	{
-		int iSizeBuffer = buffer_size(m_lpInputBuffer);
-
-		// 8바이트 단위로만 처리한다. 8바이트 단위에 부족하면 잘못된 암호화 버퍼를 복호화
-		// 할 가능성이 있으므로 짤라서 처리하기로 한다.
-		if (iSizeBuffer & 7) // & 7은 % 8과 같다. 2의 승수에서만 가능
-			iSizeBuffer -= iSizeBuffer & 7;
-
-		if (iSizeBuffer > 0)
-		{
-			TEMP_BUFFER tempbuf;
-			LPBUFFER lpBufferDecrypt = tempbuf.getptr();
-			buffer_adjust_size(lpBufferDecrypt, iSizeBuffer);
-
-			int iSizeAfter = TEA_Decrypt((DWORD*)buffer_write_peek(lpBufferDecrypt),
-				(DWORD*)buffer_read_peek(m_lpInputBuffer),
-				GetDecryptionKey(),
-				iSizeBuffer);
-
-			buffer_write_proceed(lpBufferDecrypt, iSizeAfter);
-
-			int iBytesProceed = 0;
-
-			// false가 리턴 되면 다른 phase로 바뀐 것이므로 다시 프로세스로 돌입한다!
-			while (!m_pInputProcessor->Process(this, buffer_read_peek(lpBufferDecrypt), buffer_size(lpBufferDecrypt), iBytesProceed))
-			{
-				if (iBytesProceed > iSizeBuffer)
-				{
-					buffer_read_proceed(m_lpInputBuffer, iSizeBuffer);
-					iSizeBuffer = 0;
-					iBytesProceed = 0;
-					break;
-				}
-
-				buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-				iSizeBuffer -= iBytesProceed;
-
-				buffer_read_proceed(lpBufferDecrypt, iBytesProceed);
-				iBytesProceed = 0;
-			}
-
-			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-		}
-	}
-#endif
-
-	return (bytes_read);
-}
-
-int DESC::ProcessOutput()
-{
-	if (buffer_size(m_lpOutputBuffer) <= 0)
-		return 0;
-
-	int buffer_left = fdwatch_get_buffer_size(m_lpFdw, m_sock);
-
-	if (buffer_left <= 0)
-		return 0;
-
-	int bytes_to_write = MIN(buffer_left, buffer_size(m_lpOutputBuffer));
-
-	if (bytes_to_write == 0)
-		return 0;
-
-	int result = socket_write(m_sock, (const char*)buffer_read_peek(m_lpOutputBuffer), bytes_to_write);
-
-	if (result == 0)
-	{
-		//sys_log(0, "%d bytes written to %s first %u", bytes_to_write, GetHostName(), *(BYTE *) buffer_read_peek(m_lpOutputBuffer));
-		//Log("%d bytes written", bytes_to_write);
-		max_bytes_written = MAX(bytes_to_write, max_bytes_written);
-
-		total_bytes_written += bytes_to_write;
-		current_bytes_written += bytes_to_write;
-
-		buffer_read_proceed(m_lpOutputBuffer, bytes_to_write);
-
-		if (buffer_size(m_lpOutputBuffer) != 0)
-			fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
-	}
-
-	return (result);
-}
-
-void DESC::BufferedPacket(const void* c_pvData, int iSize)
-{
-	if (m_iPhase == PHASE_CLOSE)
-		return;
-
-	if (!m_lpBufferedOutputBuffer)
-		m_lpBufferedOutputBuffer = buffer_new(MAX(1024, iSize));
-
-	buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
-}
-
-void DESC::Packet(const void* c_pvData, int iSize)
-{
-	assert(iSize > 0);
-
-	if (m_iPhase == PHASE_CLOSE) // 끊는 상태면 보내지 않는다.
-		return;
-
-	if (m_stRelayName.length() != 0)
-	{
-		// Relay 패킷은 암호화하지 않는다.
-		TPacketGGRelay p;
-
-		p.bHeader = HEADER_GG_RELAY;
-		strlcpy(p.szName, m_stRelayName.c_str(), sizeof(p.szName));
-		p.lSize = iSize;
-
-		if (!packet_encode(m_lpOutputBuffer, &p, sizeof(p)))
-		{
-			m_iPhase = PHASE_CLOSE;
-			return;
-		}
-
-		m_stRelayName.clear();
-
-		if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-		{
-			m_iPhase = PHASE_CLOSE;
-			return;
-		}
-	}
-	else
-	{
-		if (m_lpBufferedOutputBuffer)
-		{
-			buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
-
-			c_pvData = buffer_read_peek(m_lpBufferedOutputBuffer);
-			iSize = buffer_size(m_lpBufferedOutputBuffer);
-		}
-
-		// TRAFFIC_PROFILE
-		if (g_bTrafficProfileOn)
-			TrafficProfiler::instance().Report(TrafficProfiler::IODIR_OUTPUT, *(BYTE*)c_pvData, iSize);
-		// END_OF_TRAFFIC_PROFILER
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-		void* buf = buffer_write_peek(m_lpOutputBuffer);
-
-		if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-		{
-			if (cipher_.activated())
-			{
-				cipher_.Encrypt(buf, iSize);
-			}
-		}
-		else
-		{
-			m_iPhase = PHASE_CLOSE;
-		}
-#else
-		if (!m_bEncrypted)
-		{
-			if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-			{
-				m_iPhase = PHASE_CLOSE;
-			}
-		}
-		else
-		{
-			if (buffer_has_space(m_lpOutputBuffer) < iSize + 8)
-			{
-				sys_err("desc buffer mem_size overflow. memsize(%u) write_pos(%u) iSize(%d)",
-					m_lpOutputBuffer->mem_size, m_lpOutputBuffer->write_point_pos, iSize);
-
-				m_iPhase = PHASE_CLOSE;
-			}
-			else
-			{
-				// 암호화에 필요한 충분한 버퍼 크기를 확보한다.
-				/* buffer_adjust_size(m_lpOutputBuffer, iSize + 8); */
-				DWORD* pdwWritePoint = (DWORD*)buffer_write_peek(m_lpOutputBuffer);
-
-				if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-				{
-					int iSize2 = TEA_Encrypt(pdwWritePoint, pdwWritePoint, GetEncryptionKey(), iSize);
-
-					if (iSize2 > iSize)
-						buffer_write_proceed(m_lpOutputBuffer, iSize2 - iSize);
-				}
-			}
-		}
-#endif
-
-		SAFE_BUFFER_DELETE(m_lpBufferedOutputBuffer);
-	}
-
-	//sys_log(0, "%d bytes written (first byte %d)", iSize, *(BYTE *) c_pvData);
-	if (m_iPhase != PHASE_CLOSE)
-		fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
-}
-
-void DESC::LargePacket(const void* c_pvData, int iSize)
-{
-	buffer_adjust_size(m_lpOutputBuffer, iSize);
-	sys_log(0, "LargePacket Size %d", iSize, buffer_size(m_lpOutputBuffer));
-
-	Packet(c_pvData, iSize);
-}
-
-void DESC::SetPhase(int _phase)
-{
-	m_iPhase = _phase;
-
-	TPacketGCPhase pack;
-	pack.header = HEADER_GC_PHASE;
-	pack.phase = _phase;
-	Packet(&pack, sizeof(TPacketGCPhase));
-
-	switch (m_iPhase)
-	{
-	case PHASE_CLOSE:
-		// 메신저가 캐릭터단위가 되면서 삭제
-		// CMessengerManager::instance().Logout(GetAccountTable().login);
-		m_pInputProcessor = &m_inputClose;
-		break;
-
-	case PHASE_HANDSHAKE:
-		m_pInputProcessor = &m_inputHandshake;
-		break;
-
-	case PHASE_SELECT:
-		// 메신저가 캐릭터단위가 되면서 삭제
-		// CMessengerManager::instance().Logout(GetAccountTable().login); // 의도적으로 break 안검
-	case PHASE_LOGIN:
-	case PHASE_LOADING:
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		m_bEncrypted = true;
-#endif
-		m_pInputProcessor = &m_inputLogin;
-		break;
-
-	case PHASE_GAME:
-	case PHASE_DEAD:
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		m_bEncrypted = true;
-#endif
-		m_pInputProcessor = &m_inputMain;
-		break;
-
-	case PHASE_AUTH:
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		m_bEncrypted = true;
-#endif
-		m_pInputProcessor = &m_inputAuth;
-		sys_log(0, "AUTH_PHASE %p", this);
-		break;
-	}
-}
-
-void DESC::BindAccountTable(TAccountTable* pAccountTable)
-{
-	assert(pAccountTable != NULL);
-	thecore_memcpy(&m_accountTable, pAccountTable, sizeof(TAccountTable));
-	DESC_MANAGER::instance().ConnectAccount(m_accountTable.login, this);
-}
-
-void DESC::UDPGrant(const struct sockaddr_in& c_rSockAddr)
-{
-	m_UDPSockAddr = c_rSockAddr;
-
-	TPacketGCBindUDP pack;
-
-	pack.header = HEADER_GC_BINDUDP;
-	pack.addr = m_UDPSockAddr.sin_addr.s_addr;
-	pack.port = m_UDPSockAddr.sin_port;
-
-	Packet(&pack, sizeof(TPacketGCBindUDP));
-}
-
-void DESC::Log(const char* format, ...)
-{
-	if (!m_pLogFile)
-		return;
-
-	va_list args;
-
-	time_t ct = get_global_time();
-	struct tm tm = *localtime(&ct);
-
-	fprintf(m_pLogFile,
-		"%02d %02d %02d:%02d:%02d | ",
-		tm.tm_mon + 1,
-		tm.tm_mday,
-		tm.tm_hour,
-		tm.tm_min,
-		tm.tm_sec);
-
-	va_start(args, format);
-	vfprintf(m_pLogFile, format, args);
-	va_end(args);
-
-	fputs("\n", m_pLogFile);
-
-	fflush(m_pLogFile);
-}
-
-void DESC::StartHandshake(DWORD _handshake)
-{
-	// Handshake
-	m_dwHandshake = _handshake;
-
-	SendHandshake(get_dword_time(), 0);
-
-	m_iHandshakeRetry = 0;
-}
-
-void DESC::SendHandshake(DWORD dwCurTime, long lNewDelta)
-{
-	TPacketGCHandshake pack;
-
-	pack.bHeader = HEADER_GC_HANDSHAKE;
-	pack.dwHandshake = m_dwHandshake;
-	pack.dwTime = dwCurTime;
-	pack.lDelta = lNewDelta;
-
-	Packet(&pack, sizeof(TPacketGCHandshake));
-
-	m_dwHandshakeSentTime = dwCurTime;
-	m_bHandshaking = true;
-}
-
-bool DESC::HandshakeProcess(DWORD dwTime, long lDelta, bool bInfiniteRetry)
-{
-	DWORD dwCurTime = get_dword_time();
-
-	if (lDelta < 0)
-	{
-		sys_err("Desc::HandshakeProcess : value error (lDelta %d, ip %s)", lDelta, m_stHost.c_str());
-		return false;
-	}
-
-	int bias = (int)(dwCurTime - (dwTime + lDelta));
-
-	if (bias >= 0 && bias <= 50)
-	{
-		if (bInfiniteRetry)
-		{
-			BYTE bHeader = HEADER_GC_TIME_SYNC;
-			Packet(&bHeader, sizeof(BYTE));
-		}
-
-		if (GetCharacter())
-			sys_log(0, "Handshake: client_time %u server_time %u name: %s", m_dwClientTime, dwCurTime, GetCharacter()->GetName());
-		else
-			sys_log(0, "Handshake: client_time %u server_time %u", m_dwClientTime, dwCurTime, lDelta);
-
-		m_dwClientTime = dwCurTime;
-		m_bHandshaking = false;
-		return true;
-	}
-
-	long lNewDelta = (long)(dwCurTime - dwTime) / 2;
-
-	if (lNewDelta < 0)
-	{
-		sys_log(0, "Handshake: lower than zero %d", lNewDelta);
-		lNewDelta = (dwCurTime - m_dwHandshakeSentTime) / 2;
-	}
-
-	sys_log(1, "Handshake: ServerTime %u dwTime %u lDelta %d SentTime %u lNewDelta %d", dwCurTime, dwTime, lDelta, m_dwHandshakeSentTime, lNewDelta);
-
-	if (!bInfiniteRetry)
-		if (++m_iHandshakeRetry > HANDSHAKE_RETRY_LIMIT)
-		{
-			sys_err("handshake retry limit reached! (limit %d character %s)",
-				HANDSHAKE_RETRY_LIMIT, GetCharacter() ? GetCharacter()->GetName() : "!NO CHARACTER!");
-			SetPhase(PHASE_CLOSE);
-			return false;
-		}
-
-	SendHandshake(dwCurTime, lNewDelta);
-	return false;
-}
-
-bool DESC::IsHandshaking()
-{
-	return m_bHandshaking;
-}
-
-DWORD DESC::GetClientTime()
-{
-	return m_dwClientTime;
-}
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-void DESC::SendKeyAgreement()
-{
-	TPacketKeyAgreement packet;
-
-	size_t data_length = TPacketKeyAgreement::MAX_DATA_LEN;
-	size_t agreed_length = cipher_.Prepare(packet.data, &data_length);
-	if (agreed_length == 0)
-	{
-		// Initialization failure
-		SetPhase(PHASE_CLOSE);
-		return;
-	}
-	assert(data_length <= TPacketKeyAgreement::MAX_DATA_LEN);
-
-	packet.bHeader = HEADER_GC_KEY_AGREEMENT;
-	packet.wAgreedLength = (WORD)agreed_length;
-	packet.wDataLength = (WORD)data_length;
-
-	Packet(&packet, sizeof(packet));
-}
-
-void DESC::SendKeyAgreementCompleted()
-{
-	TPacketKeyAgreementCompleted packet;
-
-	packet.bHeader = HEADER_GC_KEY_AGREEMENT_COMPLETED;
-
-	Packet(&packet, sizeof(packet));
-}
-
-bool DESC::FinishHandshake(size_t agreed_length, const void* buffer, size_t length)
-{
-	return cipher_.Activate(false, agreed_length, buffer, length);
-}
-
-bool DESC::IsCipherPrepared()
-{
-	return cipher_.IsKeyPrepared();
-}
-#endif
-
-void DESC::SetRelay(const char* c_pszName)
-{
-	m_stRelayName = c_pszName;
-}
-
-void DESC::BindCharacter(LPCHARACTER ch)
-{
-	m_lpCharacter = ch;
-}
-
-void DESC::FlushOutput()
-{
-	if (m_sock == INVALID_SOCKET)
-		return;
-
-	if (buffer_size(m_lpOutputBuffer) <= 0)
-		return;
-
-	struct timeval sleep_tv, now_tv, start_tv;
-	int event_triggered = false;
-
-	gettimeofday(&start_tv, NULL);
-
-	socket_block(m_sock);
-	sys_log(0, "FLUSH START %d", buffer_size(m_lpOutputBuffer));
-
-	while (buffer_size(m_lpOutputBuffer) > 0)
-	{
-		gettimeofday(&now_tv, NULL);
-
-		int iSecondsPassed = now_tv.tv_sec - start_tv.tv_sec;
-
-		if (iSecondsPassed > 10)
-		{
-			if (!event_triggered || iSecondsPassed > 20)
-			{
-				SetPhase(PHASE_CLOSE);
-				break;
-			}
-		}
-
-		sleep_tv.tv_sec = 0;
-		sleep_tv.tv_usec = 10000;
-
-		int num_events = fdwatch(m_lpFdw, &sleep_tv);
-
-		if (num_events < 0)
-		{
-			sys_err("num_events < 0 : %d", num_events);
-			break;
-		}
-
-		int event_idx;
-
-		for (event_idx = 0; event_idx < num_events; ++event_idx)
-		{
-			LPDESC d2 = (LPDESC)fdwatch_get_client_data(m_lpFdw, event_idx);
-
-			if (d2 != this)
-				continue;
-
-			switch (fdwatch_check_event(m_lpFdw, m_sock, event_idx))
-			{
-			case FDW_WRITE:
-				event_triggered = true;
-
-				if (ProcessOutput() < 0)
-				{
-					sys_err("Cannot flush output buffer");
-					SetPhase(PHASE_CLOSE);
-				}
-				break;
-
-			case FDW_EOF:
-				SetPhase(PHASE_CLOSE);
-				break;
-			}
-		}
-
-		if (IsPhase(PHASE_CLOSE))
-			break;
-	}
-
-	if (buffer_size(m_lpOutputBuffer) == 0)
-		sys_log(0, "FLUSH SUCCESS");
-	else
-		sys_log(0, "FLUSH FAIL");
-
-	usleep(250000);
-}
-
-EVENTFUNC(disconnect_event)
-{
-	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("disconnect_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPDESC d = info->desc;
-
-	d->m_pkDisconnectEvent = NULL;
-	d->SetPhase(PHASE_CLOSE);
-	return 0;
-}
-
-bool DESC::DelayedDisconnect(int iSec)
-{
-	if (m_pkDisconnectEvent != NULL)
-		return false;
-
-	desc_event_info* info = AllocEventInfo<desc_event_info>();
-	info->desc = this;
-
-	m_pkDisconnectEvent = event_create(disconnect_event, info, PASSES_PER_SEC(iSec));
-	return true;
-}
-
-void DESC::DisconnectOfSameLogin()
-{
-	if (GetCharacter())
-	{
-		if (m_pkDisconnectEvent)
-			return;
-
-		GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 컴퓨터에서 로그인 하여 접속을 종료 합니다."));
-		DelayedDisconnect(5);
-	}
-	else
-	{
-		SetPhase(PHASE_CLOSE);
-	}
-}
-
-void DESC::SetAdminMode()
-{
-	m_bAdminMode = true;
-}
-
-bool DESC::IsAdminMode()
-{
-	return m_bAdminMode;
-}
-
-#if defined(__SEND_SEQUENCE__)
-BYTE DESC::GetSequence()
-{
-	return gc_abSequence[m_iCurrentSequence];
-}
-
-void DESC::SetNextSequence()
-{
-	if (++m_iCurrentSequence == SEQUENCE_MAX_NUM)
-		m_iCurrentSequence = 0;
-}
-#endif
-
-void DESC::SendLoginSuccessPacket()
-{
-	TAccountTable& rTable = GetAccountTable();
-
-	TPacketGCLoginSuccess p;
-
-	p.bHeader = HEADER_GC_LOGIN_SUCCESS_NEWSLOT;
-
-	p.handle = GetHandle();
-	p.random_key = DESC_MANAGER::instance().MakeRandomKey(GetHandle()); // FOR MARK
-	thecore_memcpy(p.players, rTable.players, sizeof(rTable.players));
-
-	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
-	{
-#if defined(__PROXY_IP__)
-		if (!g_stProxyIP.empty())
-			rTable.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
-#endif
-
-		CGuild* g = CGuildManager::instance().GetLinkedGuild(rTable.players[i].dwID);
-
-		if (g)
-		{
-			p.guild_id[i] = g->GetID();
-			strlcpy(p.guild_name[i], g->GetName(), sizeof(p.guild_name[i]));
-		}
-		else
-		{
-			p.guild_id[i] = 0;
-			p.guild_name[i][0] = '\0';
-		}
-	}
-
-	Packet(&p, sizeof(TPacketGCLoginSuccess));
-}
-
-//void DESC::SendServerStatePacket(int nIndex)
-//{
-//	TPacketGCStateCheck rp;
-//
-//	int iTotal; 
-//	int * paiEmpireUserCount;
-//	int iLocal;
-//
-//	DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-//
-//	rp.header	= 1; 
-//	rp.key		= 0;
-//	rp.index	= nIndex;
-//
-//	if (g_bNoMoreClient) rp.state = 0;
-//	else rp.state = iTotal > g_iFullUserCount ? 3 : iTotal > g_iBusyUserCount ? 2 : 1;
-//	
-//	this->Packet(&rp, sizeof(rp));
-//	//printf("STATE_CHECK PACKET PROCESSED.\n");
-//}
-
-void DESC::SetLoginKey(DWORD dwKey)
-{
-	m_dwLoginKey = dwKey;
-}
-
-void DESC::SetLoginKey(CLoginKey* pkKey)
-{
-	m_pkLoginKey = pkKey;
-	sys_log(0, "SetLoginKey %u", m_pkLoginKey->m_dwKey);
-}
-
-DWORD DESC::GetLoginKey()
-{
-	if (m_pkLoginKey)
-		return m_pkLoginKey->m_dwKey;
-
-	return m_dwLoginKey;
-}
-
-const BYTE* GetKey()
-{
-	static bool bGenerated = false;
-	static DWORD s_adwKey[1938];
-
-	if (!bGenerated)
-	{
-		bGenerated = true;
-		DWORD seed = 1491971513;
-
-		for (UINT i = 0; i < BYTE(seed); ++i)
-		{
-			seed ^= 2148941891ul;
-			seed += 3592385981ul;
-
-			s_adwKey[i] = seed;
-		}
-	}
-
-	return (const BYTE*)s_adwKey;
-}
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-void DESC::SetSecurityKey(const DWORD* c_pdwKey)
-{
-	const BYTE* c_pszKey = GetKey() + 37;
-
-	thecore_memcpy(&m_adwDecryptionKey, c_pdwKey, 16);
-	TEA_Encrypt(&m_adwEncryptionKey[0], &m_adwDecryptionKey[0], (const DWORD*)c_pszKey, 16);
-
-	sys_log(0, "SetSecurityKey decrypt %u %u %u %u encrypt %u %u %u %u",
-		m_adwDecryptionKey[0], m_adwDecryptionKey[1], m_adwDecryptionKey[2], m_adwDecryptionKey[3],
-		m_adwEncryptionKey[0], m_adwEncryptionKey[1], m_adwEncryptionKey[2], m_adwEncryptionKey[3]);
-}
-#endif
-
-void DESC::AssembleCRCMagicCube(BYTE bProcPiece, BYTE bFilePiece)
-{
-	static BYTE abXORTable[32] =
-	{
-		102, 30, 0, 0, 0, 0, 0, 0,
-		188, 44, 0, 0, 0, 0, 0, 0,
-		39, 201, 0, 0, 0, 0, 0, 0,
-		43, 5, 0, 0, 0, 0, 0, 0,
-	};
-
-	bProcPiece = (bProcPiece ^ abXORTable[m_bCRCMagicCubeIdx]);
-	bFilePiece = (bFilePiece ^ abXORTable[m_bCRCMagicCubeIdx + 1]);
-
-	m_dwProcCRC |= bProcPiece << m_bCRCMagicCubeIdx;
-	m_dwFileCRC |= bFilePiece << m_bCRCMagicCubeIdx;
-
-	m_bCRCMagicCubeIdx += 8;
-
-	if (!(m_bCRCMagicCubeIdx & 31))
-	{
-		m_dwProcCRC = 0;
-		m_dwFileCRC = 0;
-		m_bCRCMagicCubeIdx = 0;
-	}
-}
-
-#if defined(__SEND_SEQUENCE__)
-void DESC::push_seq(BYTE hdr, BYTE seq)
-{
-	if (m_seq_vector.size() >= 20)
-	{
-		m_seq_vector.erase(m_seq_vector.begin());
-	}
-
-	seq_t info = { hdr, seq };
-	m_seq_vector.push_back(info);
-}
-#endif
-
-BYTE DESC::GetEmpire()
-{
-	return m_accountTable.bEmpire;
-}
-
-void DESC::ChatPacket(BYTE type, const char* format, ...)
-{
-	char chatbuf[CHAT_MAX_LEN + 1];
-	va_list args;
-
-	va_start(args, format);
-	int len = vsnprintf(chatbuf, sizeof(chatbuf), format, args);
-	va_end(args);
-
-	struct packet_chat pack_chat;
-
-	pack_chat.header = HEADER_GC_CHAT;
-	pack_chat.size = sizeof(struct packet_chat) + len;
-	pack_chat.type = type;
-	pack_chat.id = 0;
-	pack_chat.bEmpire = GetEmpire();
-
-	TEMP_BUFFER buf;
-	buf.write(&pack_chat, sizeof(struct packet_chat));
-	buf.write(chatbuf, len);
-
-	Packet(buf.read_peek(), buf.size());
-}
+#include "stdafx.h"
+#include "config.h"
+#include "utils.h"
+#include "desc.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "protocol.h"
+#include "packet.h"
+#include "messenger_manager.h"
+#include "sectree_manager.h"
+#include "p2p.h"
+#include "buffer_manager.h"
+#if defined(__SEND_SEQUENCE__)
+#	include "sequence.h"
+#endif
+#include "guild.h"
+#include "guild_manager.h"
+#include "TrafficProfiler.h"
+#include "locale_service.h"
+#include "log.h"
+
+extern int max_bytes_written;
+extern int current_bytes_written;
+extern int total_bytes_written;
+
+DESC::DESC()
+{
+	Initialize();
+}
+
+DESC::~DESC()
+{
+}
+
+void DESC::Initialize()
+{
+	m_bDestroyed = false;
+
+	m_pInputProcessor = NULL;
+	m_lpFdw = NULL;
+	m_sock = INVALID_SOCKET;
+	m_iPhase = PHASE_CLOSE;
+	m_dwHandle = 0;
+
+	m_wPort = 0;
+	m_LastTryToConnectTime = 0;
+
+	m_lpInputBuffer = NULL;
+	m_iMinInputBufferLen = 0;
+
+	m_dwHandshake = 0;
+	m_dwHandshakeSentTime = 0;
+	m_iHandshakeRetry = 0;
+	m_dwClientTime = 0;
+	m_bHandshaking = false;
+
+	m_lpBufferedOutputBuffer = NULL;
+	m_lpOutputBuffer = NULL;
+
+	m_pkPingEvent = NULL;
+	m_lpCharacter = NULL;
+	memset(&m_accountTable, 0, sizeof(m_accountTable));
+
+	memset(&m_SockAddr, 0, sizeof(m_SockAddr));
+	memset(&m_UDPSockAddr, 0, sizeof(m_UDPSockAddr));
+
+	m_pLogFile = NULL;
+
+	m_dwInputRateWindowStart = 0;
+	m_iInputRateBytes = 0;
+	m_dwBadHeaderWindowStart = 0;
+	m_iBadHeaderCount = 0;
+	m_dwZeroHeaderWindowStart = 0;
+	m_iZeroHeaderCount = 0;
+
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	m_bEncrypted = false;
+#endif
+
+	m_wP2PPort = 0;
+	m_bP2PChannel = 0;
+
+	m_bAdminMode = false;
+	m_bPong = true;
+	m_bChannelStatusRequested = false;
+
+#if defined(__SEND_SEQUENCE__)
+	m_iCurrentSequence = 0;
+	m_seq_vector.clear();
+#endif
+
+	m_pkLoginKey = NULL;
+	m_dwLoginKey = 0;
+	m_dwPanamaKey = 0;
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	memset(m_adwDecryptionKey, 0, sizeof(m_adwDecryptionKey));
+	memset(m_adwEncryptionKey, 0, sizeof(m_adwEncryptionKey));
+#endif
+
+	m_bCRCMagicCubeIdx = 0;
+	m_dwProcCRC = 0;
+	m_dwFileCRC = 0;
+	m_bHackCRCQuery = 0;
+
+	m_outtime = 0;
+	m_playtime = 0;
+	m_offtime = 0;
+
+	m_pkDisconnectEvent = NULL;
+}
+
+bool DESC::CheckInputRate(size_t bytesRead)
+{
+	const DWORD now = get_dword_time();
+
+	// 1s window
+	if (m_dwInputRateWindowStart == 0 || now - m_dwInputRateWindowStart >= 1000)
+	{
+		m_dwInputRateWindowStart = now;
+		m_iInputRateBytes = 0;
+	}
+
+	m_iInputRateBytes += static_cast<int>(bytesRead);
+
+	// Stricter before entering the game phase to mitigate login floods.
+	const int limit = (m_iPhase < PHASE_GAME) ? (128 * 1024) : (512 * 1024);
+
+	return m_iInputRateBytes <= limit;
+}
+
+bool DESC::RegisterBadHeader(BYTE /*header*/, bool isZeroHeader)
+{
+	const DWORD now = get_dword_time();
+
+	// 10s window
+	if (m_dwBadHeaderWindowStart == 0 || now - m_dwBadHeaderWindowStart >= 10000)
+	{
+		m_dwBadHeaderWindowStart = now;
+		m_iBadHeaderCount = 0;
+	}
+
+	if (m_dwZeroHeaderWindowStart == 0 || now - m_dwZeroHeaderWindowStart >= 10000)
+	{
+		m_dwZeroHeaderWindowStart = now;
+		m_iZeroHeaderCount = 0;
+	}
+
+	if (isZeroHeader)
+		++m_iZeroHeaderCount;
+	else
+		++m_iBadHeaderCount;
+
+	// If we get spammed with invalid headers, close quickly.
+	if (m_iBadHeaderCount > 5 || m_iZeroHeaderCount > 128)
+		return false;
+
+	return true;
+}
+
+bool DESC::ShouldLogBadHeader() const
+{
+	// Log the first occurrence and then every 5th to prevent disk spam.
+	return (m_iBadHeaderCount <= 1) || (m_iBadHeaderCount % 5 == 0);
+}
+
+
+void DESC::Destroy()
+{
+	if (m_bDestroyed)
+		return;
+
+	m_bDestroyed = true;
+
+	if (m_pkLoginKey)
+		m_pkLoginKey->Expire();
+
+	if (GetAccountTable().id)
+		DESC_MANAGER::instance().DisconnectAccount(GetAccountTable().login);
+
+	if (m_pLogFile)
+	{
+		fclose(m_pLogFile);
+		m_pLogFile = NULL;
+	}
+
+	if (m_lpCharacter)
+	{
+		m_lpCharacter->Disconnect("DESC::~DESC");
+		m_lpCharacter = NULL;
+	}
+
+	SAFE_BUFFER_DELETE(m_lpOutputBuffer);
+	SAFE_BUFFER_DELETE(m_lpInputBuffer);
+
+	event_cancel(&m_pkPingEvent);
+	event_cancel(&m_pkDisconnectEvent);
+
+	if (!g_bAuthServer)
+	{
+		if (m_accountTable.login[0] && m_accountTable.passwd[0])
+		{
+			TLogoutPacket pack;
+
+			strlcpy(pack.login, m_accountTable.login, sizeof(pack.login));
+			strlcpy(pack.passwd, m_accountTable.passwd, sizeof(pack.passwd));
+
+			db_clientdesc->DBPacket(HEADER_GD_LOGOUT, m_dwHandle, &pack, sizeof(TLogoutPacket));
+		}
+	}
+
+	if (m_sock != INVALID_SOCKET)
+	{
+		sys_log(0, "SYSTEM: closing socket. DESC #%d", m_sock);
+		Log("SYSTEM: closing socket. DESC #%d", m_sock);
+		fdwatch_del_fd(m_lpFdw, m_sock);
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+		cipher_.CleanUp();
+#endif
+
+		socket_close(m_sock);
+		m_sock = INVALID_SOCKET;
+	}
+
+#if defined(__SEND_SEQUENCE__)
+	m_seq_vector.clear();
+#endif
+}
+
+EVENTFUNC(ping_event)
+{
+	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("ping_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPDESC desc = info->desc;
+
+	if (desc->IsAdminMode())
+		return (ping_event_second_cycle);
+
+	if (!desc->IsPong())
+	{
+		sys_log(0, "PING_EVENT: no pong %s", desc->GetHostName());
+
+		desc->SetPhase(PHASE_CLOSE);
+
+		return (ping_event_second_cycle);
+	}
+	else
+	{
+		TPacketGCPing p;
+		p.header = HEADER_GC_PING;
+		desc->Packet(&p, sizeof(struct packet_ping));
+		desc->SetPong(false);
+	}
+
+	desc->SendHandshake(get_dword_time(), 0);
+
+	return (ping_event_second_cycle);
+}
+
+bool DESC::IsPong()
+{
+	return m_bPong;
+}
+
+void DESC::SetPong(bool b)
+{
+	m_bPong = b;
+}
+
+bool DESC::Setup(LPFDWATCH _fdw, socket_t _fd, const struct sockaddr_in& c_rSockAddr, DWORD _handle, DWORD _handshake)
+{
+	m_lpFdw = _fdw;
+	m_sock = _fd;
+
+	m_stHost = inet_ntoa(c_rSockAddr.sin_addr);
+	m_wPort = c_rSockAddr.sin_port;
+	m_dwHandle = _handle;
+
+	//if (LC_IsEurope() == true || LC_IsNewCIBN())
+	//	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
+	//else
+	// NOTE: 隔 鑿갬 摸 틴  簾?
+	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
+
+	m_iMinInputBufferLen = MAX_INPUT_LEN >> 1;
+	m_lpInputBuffer = buffer_new(MAX_INPUT_LEN);
+
+	m_SockAddr = c_rSockAddr;
+
+	fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_READ, false);
+
+	// Ping Event 
+	desc_event_info* info = AllocEventInfo<desc_event_info>();
+
+	info->desc = this;
+	assert(m_pkPingEvent == NULL);
+
+	m_pkPingEvent = event_create(ping_event, info, ping_event_second_cycle);
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	thecore_memcpy(m_adwEncryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
+	thecore_memcpy(m_adwDecryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
+#endif
+
+	// Set Phase to handshake
+	SetPhase(PHASE_HANDSHAKE);
+	StartHandshake(_handshake);
+
+	sys_log(0, "SYSTEM: new connection from [%s] fd: %d handshake %u output input_len %d, ptr %p",
+		m_stHost.c_str(), m_sock, m_dwHandshake, buffer_size(m_lpInputBuffer), this);
+
+	Log("SYSTEM: new connection from [%s] fd: %d handshake %u ptr %p", m_stHost.c_str(), m_sock, m_dwHandshake, this);
+	return true;
+}
+
+int DESC::ProcessInput()
+{
+	ssize_t bytes_read;
+
+	if (!m_lpInputBuffer)
+	{
+		sys_err("DESC::ProcessInput : nil input buffer");
+		return -1;
+	}
+
+	buffer_adjust_size(m_lpInputBuffer, m_iMinInputBufferLen);
+	bytes_read = socket_read(m_sock, (char*)buffer_write_peek(m_lpInputBuffer), buffer_has_space(m_lpInputBuffer));
+
+	if (bytes_read < 0)
+		return -1;
+	else if (bytes_read == 0)
+		return 0;
+
+	if (!CheckInputRate(static_cast<size_t>(bytes_read)))
+	{
+		sys_log(0, "INPUT_FLOOD: host=%s phase=%d bytes=%zd", GetHostName(), m_iPhase, bytes_read);
+		SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	buffer_write_proceed(m_lpInputBuffer, bytes_read);
+
+	if (!m_pInputProcessor)
+		sys_err("no input processor");
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	else
+	{
+		// making a temporary buffer used to decrypt memory
+		TEMP_BUFFER temporary;
+
+		// checking for non read byes on decrypted buffer
+		// moving the stored buffer to the temporary one
+		if(m_lpInputDecryptedBuffer.size() != 0)
+			temporary.write(m_lpInputDecryptedBuffer.read_peek(), m_lpInputDecryptedBuffer.size());
+
+		// adding the readable memory from the input buffer
+		auto readableInput = buffer_size(m_lpInputBuffer);
+		if(readableInput > temporary.size())
+		{
+			const auto readPoint = (const char*) buffer_read_peek(m_lpInputBuffer);
+			temporary.write(readPoint + temporary.size(), readableInput - temporary.size());
+		}
+
+		if(temporary.size() == 0)
+			return 0;
+
+		// decrypting only non decrypted chunk of memory
+		if (cipher_.activated())
+		{
+			const auto decryptPoint = ((const char*)temporary.read_peek()) + m_lpInputDecryptedBuffer.size();
+			cipher_.Decrypt((void*)(decryptPoint), readableInput - m_lpInputDecryptedBuffer.size());
+		}
+
+		auto processingPoint = (const char*) temporary.read_peek();
+		auto processingRemainSize = temporary.size();
+		auto processingTotalSize = 0;
+
+		int iBytesProceed = 0;
+
+		// false  퓔 摸 phase 侮 譴퓐 母 關 磯!
+		while (processingRemainSize > 0 && !m_pInputProcessor->Process(this, (const void*)processingPoint, processingRemainSize, iBytesProceed))
+		{
+			processingPoint += iBytesProceed;
+			processingTotalSize += iBytesProceed;
+			processingRemainSize -= iBytesProceed;
+			iBytesProceed = 0;
+		}
+
+		processingPoint += iBytesProceed;
+		processingTotalSize += iBytesProceed;
+		processingRemainSize -= iBytesProceed;
+
+		// applying result on input buffer
+		buffer_read_proceed(m_lpInputBuffer, processingTotalSize);
+
+		// registering remaining unprocessed (but decrypted) bytes
+		m_lpInputDecryptedBuffer.reset();
+		if(processingTotalSize < temporary.size()){
+			const auto storingPoint = ((const char*) temporary.read_peek()) + processingTotalSize;
+			m_lpInputDecryptedBuffer.write(storingPoint, temporary.size() - processingTotalSize);
+		}
+	}
+#else
+	else if (!m_bEncrypted)
+	{
+		int iBytesProceed = 0;
+
+		// false  퓔 摸 phase 侮 譴퓐 母 關 磯!
+		while (!m_pInputProcessor->Process(this, buffer_read_peek(m_lpInputBuffer), buffer_size(m_lpInputBuffer), iBytesProceed))
+		{
+			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+			iBytesProceed = 0;
+		}
+
+		buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+	}
+	else
+	{
+		int iSizeBuffer = buffer_size(m_lpInputBuffer);
+
+		// 8트 罐 처磯. 8트  玖 蔘 호화 肪 호화
+		//   퓐 짤 처歐 磯.
+		if (iSizeBuffer & 7) // & 7 % 8 . 2 쩌 
+			iSizeBuffer -= iSizeBuffer & 7;
+
+		if (iSizeBuffer > 0)
+		{
+			TEMP_BUFFER tempbuf;
+			LPBUFFER lpBufferDecrypt = tempbuf.getptr();
+			buffer_adjust_size(lpBufferDecrypt, iSizeBuffer);
+
+			int iSizeAfter = TEA_Decrypt((DWORD*)buffer_write_peek(lpBufferDecrypt),
+				(DWORD*)buffer_read_peek(m_lpInputBuffer),
+				GetDecryptionKey(),
+				iSizeBuffer);
+
+			buffer_write_proceed(lpBufferDecrypt, iSizeAfter);
+
+			int iBytesProceed = 0;
+
+			// false  퓔 摸 phase 侮 譴퓐 母 關 磯!
+			while (!m_pInputProcessor->Process(this, buffer_read_peek(lpBufferDecrypt), buffer_size(lpBufferDecrypt), iBytesProceed))
+			{
+				if (iBytesProceed > iSizeBuffer)
+				{
+					buffer_read_proceed(m_lpInputBuffer, iSizeBuffer);
+					iSizeBuffer = 0;
+					iBytesProceed = 0;
+					break;
+				}
+
+				buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+				iSizeBuffer -= iBytesProceed;
+
+				buffer_read_proceed(lpBufferDecrypt, iBytesProceed);
+				iBytesProceed = 0;
+			}
+
+			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+		}
+	}
+#endif
+
+	return (bytes_read);
+}
+
+int DESC::ProcessOutput()
+{
+	if (buffer_size(m_lpOutputBuffer) <= 0)
+		return 0;
+
+	int buffer_left = fdwatch_get_buffer_size(m_lpFdw, m_sock);
+
+	if (buffer_left <= 0)
+		return 0;
+
+	int bytes_to_write = MIN(buffer_left, buffer_size(m_lpOutputBuffer));
+
+	if (bytes_to_write == 0)
+		return 0;
+
+	int result = socket_write(m_sock, (const char*)buffer_read_peek(m_lpOutputBuffer), bytes_to_write);
+
+	if (result == 0)
+	{
+		//sys_log(0, "%d bytes written to %s first %u", bytes_to_write, GetHostName(), *(BYTE *) buffer_read_peek(m_lpOutputBuffer));
+		//Log("%d bytes written", bytes_to_write);
+		max_bytes_written = MAX(bytes_to_write, max_bytes_written);
+
+		total_bytes_written += bytes_to_write;
+		current_bytes_written += bytes_to_write;
+
+		buffer_read_proceed(m_lpOutputBuffer, bytes_to_write);
+
+		if (buffer_size(m_lpOutputBuffer) != 0)
+			fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
+	}
+
+	return (result);
+}
+
+void DESC::BufferedPacket(const void* c_pvData, int iSize)
+{
+	if (m_iPhase == PHASE_CLOSE)
+		return;
+
+	if (!m_lpBufferedOutputBuffer)
+		m_lpBufferedOutputBuffer = buffer_new(MAX(1024, iSize));
+
+	buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
+}
+
+void DESC::Packet(const void* c_pvData, int iSize)
+{
+	assert(iSize > 0);
+
+	if (m_iPhase == PHASE_CLOSE) //  쨍  苛쨈.
+		return;
+
+	if (m_stRelayName.length() != 0)
+	{
+		// Relay 킷 호화 苛쨈.
+		TPacketGGRelay p;
+
+		p.bHeader = HEADER_GG_RELAY;
+		strlcpy(p.szName, m_stRelayName.c_str(), sizeof(p.szName));
+		p.lSize = iSize;
+
+		if (!packet_encode(m_lpOutputBuffer, &p, sizeof(p)))
+		{
+			m_iPhase = PHASE_CLOSE;
+			return;
+		}
+
+		m_stRelayName.clear();
+
+		if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+		{
+			m_iPhase = PHASE_CLOSE;
+			return;
+		}
+	}
+	else
+	{
+		if (m_lpBufferedOutputBuffer)
+		{
+			buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
+
+			c_pvData = buffer_read_peek(m_lpBufferedOutputBuffer);
+			iSize = buffer_size(m_lpBufferedOutputBuffer);
+		}
+
+		// TRAFFIC_PROFILE
+		if (g_bTrafficProfileOn)
+			TrafficProfiler::instance().Report(TrafficProfiler::IODIR_OUTPUT, *(BYTE*)c_pvData, iSize);
+		// END_OF_TRAFFIC_PROFILER
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+		void* buf = buffer_write_peek(m_lpOutputBuffer);
+
+		if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+		{
+			if (cipher_.activated())
+			{
+				cipher_.Encrypt(buf, iSize);
+			}
+		}
+		else
+		{
+			m_iPhase = PHASE_CLOSE;
+		}
+#else
+		if (!m_bEncrypted)
+		{
+			if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+			{
+				m_iPhase = PHASE_CLOSE;
+			}
+		}
+		else
+		{
+			if (buffer_has_space(m_lpOutputBuffer) < iSize + 8)
+			{
+				sys_err("desc buffer mem_size overflow. memsize(%u) write_pos(%u) iSize(%d)",
+					m_lpOutputBuffer->mem_size, m_lpOutputBuffer->write_point_pos, iSize);
+
+				m_iPhase = PHASE_CLOSE;
+			}
+			else
+			{
+				// 호화 却   크綬 확磯.
+				/* buffer_adjust_size(m_lpOutputBuffer, iSize + 8); */
+				DWORD* pdwWritePoint = (DWORD*)buffer_write_peek(m_lpOutputBuffer);
+
+				if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+				{
+					int iSize2 = TEA_Encrypt(pdwWritePoint, pdwWritePoint, GetEncryptionKey(), iSize);
+
+					if (iSize2 > iSize)
+						buffer_write_proceed(m_lpOutputBuffer, iSize2 - iSize);
+				}
+			}
+		}
+#endif
+
+		SAFE_BUFFER_DELETE(m_lpBufferedOutputBuffer);
+	}
+
+	//sys_log(0, "%d bytes written (first byte %d)", iSize, *(BYTE *) c_pvData);
+	if (m_iPhase != PHASE_CLOSE)
+		fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
+}
+
+void DESC::LargePacket(const void* c_pvData, int iSize)
+{
+	buffer_adjust_size(m_lpOutputBuffer, iSize);
+	sys_log(0, "LargePacket Size %d", iSize, buffer_size(m_lpOutputBuffer));
+
+	Packet(c_pvData, iSize);
+}
+
+void DESC::SetPhase(int _phase)
+{
+	m_iPhase = _phase;
+
+	TPacketGCPhase pack;
+	pack.header = HEADER_GC_PHASE;
+	pack.phase = _phase;
+	Packet(&pack, sizeof(TPacketGCPhase));
+
+	switch (m_iPhase)
+	{
+	case PHASE_CLOSE:
+		// 聘 캐姑 퓔庸 
+		// CMessengerManager::instance().Logout(GetAccountTable().login);
+		m_pInputProcessor = &m_inputClose;
+		break;
+
+	case PHASE_HANDSHAKE:
+		m_pInputProcessor = &m_inputHandshake;
+		break;
+
+	case PHASE_SELECT:
+		// 聘 캐姑 퓔庸 
+		// CMessengerManager::instance().Logout(GetAccountTable().login); // 풩 break 활
+	case PHASE_LOGIN:
+	case PHASE_LOADING:
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		m_bEncrypted = true;
+#endif
+		m_pInputProcessor = &m_inputLogin;
+		break;
+
+	case PHASE_GAME:
+	case PHASE_DEAD:
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		m_bEncrypted = true;
+#endif
+		m_pInputProcessor = &m_inputMain;
+		break;
+
+	case PHASE_AUTH:
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		m_bEncrypted = true;
+#endif
+		m_pInputProcessor = &m_inputAuth;
+		sys_log(0, "AUTH_PHASE %p", this);
+		break;
+	}
+}
+
+void DESC::BindAccountTable(TAccountTable* pAccountTable)
+{
+	assert(pAccountTable != NULL);
+	thecore_memcpy(&m_accountTable, pAccountTable, sizeof(TAccountTable));
+	DESC_MANAGER::instance().ConnectAccount(m_accountTable.login, this);
+}
+
+void DESC::UDPGrant(const struct sockaddr_in& c_rSockAddr)
+{
+	m_UDPSockAddr = c_rSockAddr;
+
+	TPacketGCBindUDP pack;
+
+	pack.header = HEADER_GC_BINDUDP;
+	pack.addr = m_UDPSockAddr.sin_addr.s_addr;
+	pack.port = m_UDPSockAddr.sin_port;
+
+	Packet(&pack, sizeof(TPacketGCBindUDP));
+}
+
+void DESC::Log(const char* format, ...)
+{
+	if (!m_pLogFile)
+		return;
+
+	va_list args;
+
+	time_t ct = get_global_time();
+	struct tm tm = *localtime(&ct);
+
+	fprintf(m_pLogFile,
+		"%02d %02d %02d:%02d:%02d | ",
+		tm.tm_mon + 1,
+		tm.tm_mday,
+		tm.tm_hour,
+		tm.tm_min,
+		tm.tm_sec);
+
+	va_start(args, format);
+	vfprintf(m_pLogFile, format, args);
+	va_end(args);
+
+	fputs("\n", m_pLogFile);
+
+	fflush(m_pLogFile);
+}
+
+void DESC::StartHandshake(DWORD _handshake)
+{
+	// Handshake
+	m_dwHandshake = _handshake;
+
+	SendHandshake(get_dword_time(), 0);
+
+	m_iHandshakeRetry = 0;
+}
+
+void DESC::SendHandshake(DWORD dwCurTime, long lNewDelta)
+{
+	TPacketGCHandshake pack;
+
+	pack.bHeader = HEADER_GC_HANDSHAKE;
+	pack.dwHandshake = m_dwHandshake;
+	pack.dwTime = dwCurTime;
+	pack.lDelta = lNewDelta;
+
+	Packet(&pack, sizeof(TPacketGCHandshake));
+
+	m_dwHandshakeSentTime = dwCurTime;
+	m_bHandshaking = true;
+}
+
+bool DESC::HandshakeProcess(DWORD dwTime, long lDelta, bool bInfiniteRetry)
+{
+	DWORD dwCurTime = get_dword_time();
+
+	if (lDelta < 0)
+	{
+		sys_err("Desc::HandshakeProcess : value error (lDelta %d, ip %s)", lDelta, m_stHost.c_str());
+		return false;
+	}
+
+	int bias = (int)(dwCurTime - (dwTime + lDelta));
+
+	if (bias >= 0 && bias <= 50)
+	{
+		if (bInfiniteRetry)
+		{
+			BYTE bHeader = HEADER_GC_TIME_SYNC;
+			Packet(&bHeader, sizeof(BYTE));
+		}
+
+		if (GetCharacter())
+			sys_log(0, "Handshake: client_time %u server_time %u name: %s", m_dwClientTime, dwCurTime, GetCharacter()->GetName());
+		else
+			sys_log(0, "Handshake: client_time %u server_time %u", m_dwClientTime, dwCurTime, lDelta);
+
+		m_dwClientTime = dwCurTime;
+		m_bHandshaking = false;
+		return true;
+	}
+
+	long lNewDelta = (long)(dwCurTime - dwTime) / 2;
+
+	if (lNewDelta < 0)
+	{
+		sys_log(0, "Handshake: lower than zero %d", lNewDelta);
+		lNewDelta = (dwCurTime - m_dwHandshakeSentTime) / 2;
+	}
+
+	sys_log(1, "Handshake: ServerTime %u dwTime %u lDelta %d SentTime %u lNewDelta %d", dwCurTime, dwTime, lDelta, m_dwHandshakeSentTime, lNewDelta);
+
+	if (!bInfiniteRetry)
+		if (++m_iHandshakeRetry > HANDSHAKE_RETRY_LIMIT)
+		{
+			sys_err("handshake retry limit reached! (limit %d character %s)",
+				HANDSHAKE_RETRY_LIMIT, GetCharacter() ? GetCharacter()->GetName() : "!NO CHARACTER!");
+			SetPhase(PHASE_CLOSE);
+			return false;
+		}
+
+	SendHandshake(dwCurTime, lNewDelta);
+	return false;
+}
+
+bool DESC::IsHandshaking()
+{
+	return m_bHandshaking;
+}
+
+DWORD DESC::GetClientTime()
+{
+	return m_dwClientTime;
+}
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+void DESC::SendKeyAgreement()
+{
+	TPacketKeyAgreement packet;
+
+	size_t data_length = TPacketKeyAgreement::MAX_DATA_LEN;
+	size_t agreed_length = cipher_.Prepare(packet.data, &data_length);
+	if (agreed_length == 0)
+	{
+		// Initialization failure
+		SetPhase(PHASE_CLOSE);
+		return;
+	}
+	assert(data_length <= TPacketKeyAgreement::MAX_DATA_LEN);
+
+	packet.bHeader = HEADER_GC_KEY_AGREEMENT;
+	packet.wAgreedLength = (WORD)agreed_length;
+	packet.wDataLength = (WORD)data_length;
+
+	Packet(&packet, sizeof(packet));
+}
+
+void DESC::SendKeyAgreementCompleted()
+{
+	TPacketKeyAgreementCompleted packet;
+
+	packet.bHeader = HEADER_GC_KEY_AGREEMENT_COMPLETED;
+
+	Packet(&packet, sizeof(packet));
+}
+
+bool DESC::FinishHandshake(size_t agreed_length, const void* buffer, size_t length)
+{
+	return cipher_.Activate(false, agreed_length, buffer, length);
+}
+
+bool DESC::IsCipherPrepared()
+{
+	return cipher_.IsKeyPrepared();
+}
+#endif
+
+void DESC::SetRelay(const char* c_pszName)
+{
+	m_stRelayName = c_pszName;
+}
+
+void DESC::BindCharacter(LPCHARACTER ch)
+{
+	m_lpCharacter = ch;
+}
+
+void DESC::FlushOutput()
+{
+	if (m_sock == INVALID_SOCKET)
+		return;
+
+	if (buffer_size(m_lpOutputBuffer) <= 0)
+		return;
+
+	struct timeval sleep_tv, now_tv, start_tv;
+	int event_triggered = false;
+
+	gettimeofday(&start_tv, NULL);
+
+	socket_block(m_sock);
+	sys_log(0, "FLUSH START %d", buffer_size(m_lpOutputBuffer));
+
+	while (buffer_size(m_lpOutputBuffer) > 0)
+	{
+		gettimeofday(&now_tv, NULL);
+
+		int iSecondsPassed = now_tv.tv_sec - start_tv.tv_sec;
+
+		if (iSecondsPassed > 10)
+		{
+			if (!event_triggered || iSecondsPassed > 20)
+			{
+				SetPhase(PHASE_CLOSE);
+				break;
+			}
+		}
+
+		sleep_tv.tv_sec = 0;
+		sleep_tv.tv_usec = 10000;
+
+		int num_events = fdwatch(m_lpFdw, &sleep_tv);
+
+		if (num_events < 0)
+		{
+			sys_err("num_events < 0 : %d", num_events);
+			break;
+		}
+
+		int event_idx;
+
+		for (event_idx = 0; event_idx < num_events; ++event_idx)
+		{
+			LPDESC d2 = (LPDESC)fdwatch_get_client_data(m_lpFdw, event_idx);
+
+			if (d2 != this)
+				continue;
+
+			switch (fdwatch_check_event(m_lpFdw, m_sock, event_idx))
+			{
+			case FDW_WRITE:
+				event_triggered = true;
+
+				if (ProcessOutput() < 0)
+				{
+					sys_err("Cannot flush output buffer");
+					SetPhase(PHASE_CLOSE);
+				}
+				break;
+
+			case FDW_EOF:
+				SetPhase(PHASE_CLOSE);
+				break;
+			}
+		}
+
+		if (IsPhase(PHASE_CLOSE))
+			break;
+	}
+
+	if (buffer_size(m_lpOutputBuffer) == 0)
+		sys_log(0, "FLUSH SUCCESS");
+	else
+		sys_log(0, "FLUSH FAIL");
+
+	usleep(250000);
+}
+
+EVENTFUNC(disconnect_event)
+{
+	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("disconnect_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPDESC d = info->desc;
+
+	d->m_pkDisconnectEvent = NULL;
+	d->SetPhase(PHASE_CLOSE);
+	return 0;
+}
+
+bool DESC::DelayedDisconnect(int iSec)
+{
+	if (m_pkDisconnectEvent != NULL)
+		return false;
+
+	desc_event_info* info = AllocEventInfo<desc_event_info>();
+	info->desc = this;
+
+	m_pkDisconnectEvent = event_create(disconnect_event, info, PASSES_PER_SEC(iSec));
+	return true;
+}
+
+void DESC::DisconnectOfSameLogin()
+{
+	if (GetCharacter())
+	{
+		if (m_pkDisconnectEvent)
+			return;
+
+		GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 퓨沽 慣 臼   爛求."));
+		DelayedDisconnect(5);
+	}
+	else
+	{
+		SetPhase(PHASE_CLOSE);
+	}
+}
+
+void DESC::SetAdminMode()
+{
+	m_bAdminMode = true;
+}
+
+bool DESC::IsAdminMode()
+{
+	return m_bAdminMode;
+}
+
+#if defined(__SEND_SEQUENCE__)
+BYTE DESC::GetSequence()
+{
+	return gc_abSequence[m_iCurrentSequence];
+}
+
+void DESC::SetNextSequence()
+{
+	if (++m_iCurrentSequence == SEQUENCE_MAX_NUM)
+		m_iCurrentSequence = 0;
+}
+#endif
+
+void DESC::SendLoginSuccessPacket()
+{
+	TAccountTable& rTable = GetAccountTable();
+
+	TPacketGCLoginSuccess p;
+
+	p.bHeader = HEADER_GC_LOGIN_SUCCESS_NEWSLOT;
+
+	p.handle = GetHandle();
+	p.random_key = DESC_MANAGER::instance().MakeRandomKey(GetHandle()); // FOR MARK
+	thecore_memcpy(p.players, rTable.players, sizeof(rTable.players));
+
+	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
+	{
+#if defined(__PROXY_IP__)
+		if (!g_stProxyIP.empty())
+			rTable.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
+#endif
+
+		CGuild* g = CGuildManager::instance().GetLinkedGuild(rTable.players[i].dwID);
+
+		if (g)
+		{
+			p.guild_id[i] = g->GetID();
+			strlcpy(p.guild_name[i], g->GetName(), sizeof(p.guild_name[i]));
+		}
+		else
+		{
+			p.guild_id[i] = 0;
+			p.guild_name[i][0] = '\0';
+		}
+	}
+
+	Packet(&p, sizeof(TPacketGCLoginSuccess));
+}
+
+//void DESC::SendServerStatePacket(int nIndex)
+//{
+//	TPacketGCStateCheck rp;
+//
+//	int iTotal; 
+//	int * paiEmpireUserCount;
+//	int iLocal;
+//
+//	DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+//
+//	rp.header	= 1; 
+//	rp.key		= 0;
+//	rp.index	= nIndex;
+//
+//	if (g_bNoMoreClient) rp.state = 0;
+//	else rp.state = iTotal > g_iFullUserCount ? 3 : iTotal > g_iBusyUserCount ? 2 : 1;
+//	
+//	this->Packet(&rp, sizeof(rp));
+//	//printf("STATE_CHECK PACKET PROCESSED.\n");
+//}
+
+void DESC::SetLoginKey(DWORD dwKey)
+{
+	m_dwLoginKey = dwKey;
+}
+
+void DESC::SetLoginKey(CLoginKey* pkKey)
+{
+	m_pkLoginKey = pkKey;
+	sys_log(0, "SetLoginKey %u", m_pkLoginKey->m_dwKey);
+}
+
+DWORD DESC::GetLoginKey()
+{
+	if (m_pkLoginKey)
+		return m_pkLoginKey->m_dwKey;
+
+	return m_dwLoginKey;
+}
+
+const BYTE* GetKey()
+{
+	static bool bGenerated = false;
+	static DWORD s_adwKey[1938];
+
+	if (!bGenerated)
+	{
+		bGenerated = true;
+		DWORD seed = 1491971513;
+
+		for (UINT i = 0; i < BYTE(seed); ++i)
+		{
+			seed ^= 2148941891ul;
+			seed += 3592385981ul;
+
+			s_adwKey[i] = seed;
+		}
+	}
+
+	return (const BYTE*)s_adwKey;
+}
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+void DESC::SetSecurityKey(const DWORD* c_pdwKey)
+{
+	const BYTE* c_pszKey = GetKey() + 37;
+
+	thecore_memcpy(&m_adwDecryptionKey, c_pdwKey, 16);
+	TEA_Encrypt(&m_adwEncryptionKey[0], &m_adwDecryptionKey[0], (const DWORD*)c_pszKey, 16);
+
+	sys_log(0, "SetSecurityKey decrypt %u %u %u %u encrypt %u %u %u %u",
+		m_adwDecryptionKey[0], m_adwDecryptionKey[1], m_adwDecryptionKey[2], m_adwDecryptionKey[3],
+		m_adwEncryptionKey[0], m_adwEncryptionKey[1], m_adwEncryptionKey[2], m_adwEncryptionKey[3]);
+}
+#endif
+
+void DESC::AssembleCRCMagicCube(BYTE bProcPiece, BYTE bFilePiece)
+{
+	static BYTE abXORTable[32] =
+	{
+		102, 30, 0, 0, 0, 0, 0, 0,
+		188, 44, 0, 0, 0, 0, 0, 0,
+		39, 201, 0, 0, 0, 0, 0, 0,
+		43, 5, 0, 0, 0, 0, 0, 0,
+	};
+
+	bProcPiece = (bProcPiece ^ abXORTable[m_bCRCMagicCubeIdx]);
+	bFilePiece = (bFilePiece ^ abXORTable[m_bCRCMagicCubeIdx + 1]);
+
+	m_dwProcCRC |= bProcPiece << m_bCRCMagicCubeIdx;
+	m_dwFileCRC |= bFilePiece << m_bCRCMagicCubeIdx;
+
+	m_bCRCMagicCubeIdx += 8;
+
+	if (!(m_bCRCMagicCubeIdx & 31))
+	{
+		m_dwProcCRC = 0;
+		m_dwFileCRC = 0;
+		m_bCRCMagicCubeIdx = 0;
+	}
+}
+
+#if defined(__SEND_SEQUENCE__)
+void DESC::push_seq(BYTE hdr, BYTE seq)
+{
+	if (m_seq_vector.size() >= 20)
+	{
+		m_seq_vector.erase(m_seq_vector.begin());
+	}
+
+	seq_t info = { hdr, seq };
+	m_seq_vector.push_back(info);
+}
+#endif
+
+BYTE DESC::GetEmpire()
+{
+	return m_accountTable.bEmpire;
+}
+
+void DESC::ChatPacket(BYTE type, const char* format, ...)
+{
+	char chatbuf[CHAT_MAX_LEN + 1];
+	va_list args;
+
+	va_start(args, format);
+	int len = vsnprintf(chatbuf, sizeof(chatbuf), format, args);
+	va_end(args);
+
+	struct packet_chat pack_chat;
+
+	pack_chat.header = HEADER_GC_CHAT;
+	pack_chat.size = sizeof(struct packet_chat) + len;
+	pack_chat.type = type;
+	pack_chat.id = 0;
+	pack_chat.bEmpire = GetEmpire();
+
+	TEMP_BUFFER buf;
+	buf.write(&pack_chat, sizeof(struct packet_chat));
+	buf.write(chatbuf, len);
+
+	Packet(buf.read_peek(), buf.size());
+}
diff --git a/server/metin2/Source/Server/game/src/desc.h b/server/metin2/Source/Server/game/src/desc.h
index adbd861..55b4d09 100644
--- a/server/metin2/Source/Server/game/src/desc.h
+++ b/server/metin2/Source/Server/game/src/desc.h
@@ -1,286 +1,304 @@
-#ifndef __INC_DESC_H__
-#define __INC_DESC_H__
-
-#include "constants.h"
-#include "input.h"
-#include "buffer_manager.h"
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-#include "cipher.h"
-#endif
-
-#define MAX_ALLOW_USER 4096
-//#define MAX_INPUT_LEN 65536
-#define MAX_INPUT_LEN 262144
-
-#define HANDSHAKE_RETRY_LIMIT 32
-
-class CInputProcessor;
-
-enum EDescType
-{
-	DESC_TYPE_ACCEPTOR,
-	DESC_TYPE_CONNECTOR
-};
-
-class CLoginKey
-{
-public:
-	CLoginKey(DWORD dwKey, LPDESC pkDesc) : m_dwKey(dwKey), m_pkDesc(pkDesc)
-	{
-		m_dwExpireTime = 0;
-	}
-
-	void Expire()
-	{
-		m_dwExpireTime = get_dword_time();
-		m_pkDesc = NULL;
-	}
-
-	operator DWORD() const
-	{
-		return m_dwKey;
-	}
-
-	DWORD m_dwKey;
-	DWORD m_dwExpireTime;
-	LPDESC m_pkDesc;
-};
-
-#if defined(__SEND_SEQUENCE__)
-// sequence 버그 찾기용 데이타
-struct seq_t
-{
-	BYTE hdr;
-	BYTE seq;
-};
-typedef std::vector<seq_t> seq_vector_t;
-// sequence 버그 찾기용 데이타
-#endif
-
-class DESC
-{
-public:
-	EVENTINFO(desc_event_info)
-	{
-		LPDESC desc;
-
-		desc_event_info()
-			: desc(0)
-		{
-		}
-	};
-
-public:
-	DESC();
-	virtual ~DESC();
-
-	virtual BYTE GetType() { return DESC_TYPE_ACCEPTOR; }
-	virtual void Destroy();
-	virtual void SetPhase(int _phase);
-
-	void FlushOutput();
-
-	bool Setup(LPFDWATCH _fdw, socket_t _fd, const struct sockaddr_in& c_rSockAddr, DWORD _handle, DWORD _handshake);
-
-	socket_t GetSocket() const { return m_sock; }
-	const char* GetHostName() { return m_stHost.c_str(); }
-	WORD GetPort() { return m_wPort; }
-
-	void SetP2P(const char* h, WORD w, BYTE b) { m_stP2PHost = h; m_wP2PPort = w; m_bP2PChannel = b; }
-	const char* GetP2PHost() { return m_stP2PHost.c_str(); }
-	WORD GetP2PPort() const { return m_wP2PPort; }
-	BYTE GetP2PChannel() const { return m_bP2PChannel; }
-
-	void BufferedPacket(const void* c_pvData, int iSize);
-	void Packet(const void* c_pvData, int iSize);
-	void LargePacket(const void* c_pvData, int iSize);
-
-	int ProcessInput(); // returns -1 if error
-	int ProcessOutput(); // returns -1 if error
-
-	CInputProcessor* GetInputProcessor() { return m_pInputProcessor; }
-
-	DWORD GetHandle() const { return m_dwHandle; }
-	LPBUFFER GetOutputBuffer() { return m_lpOutputBuffer; }
-
-	void BindAccountTable(TAccountTable* pTable);
-	TAccountTable& GetAccountTable() { return m_accountTable; }
-
-	void BindCharacter(LPCHARACTER ch);
-	LPCHARACTER GetCharacter() { return m_lpCharacter; }
-
-	bool IsPhase(int phase) const { return m_iPhase == phase ? true : false; }
-
-	const struct sockaddr_in& GetAddr() { return m_SockAddr; }
-
-	void UDPGrant(const struct sockaddr_in& c_rSockAddr);
-	const struct sockaddr_in& GetUDPAddr() { return m_UDPSockAddr; }
-
-	void Log(const char* format, ...);
-
-	// 핸드쉐이크 (시간 동기화)
-	void StartHandshake(DWORD _dw);
-	void SendHandshake(DWORD dwCurTime, long lNewDelta);
-	bool HandshakeProcess(DWORD dwTime, long lDelta, bool bInfiniteRetry = false);
-	bool IsHandshaking();
-
-	DWORD GetHandshake() const { return m_dwHandshake; }
-	DWORD GetClientTime();
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	void SendKeyAgreement();
-	void SendKeyAgreementCompleted();
-	bool FinishHandshake(size_t agreed_length, const void* buffer, size_t length);
-	bool IsCipherPrepared();
-#else
-	// Obsolete encryption stuff here
-	void SetSecurityKey(const DWORD* c_pdwKey);
-	const DWORD* GetEncryptionKey() const { return &m_adwEncryptionKey[0]; }
-	const DWORD* GetDecryptionKey() const { return &m_adwDecryptionKey[0]; }
-#endif
-
-	// 제국
-	BYTE GetEmpire();
-
-	// for p2p
-	void SetRelay(const char* c_pszName);
-	bool DelayedDisconnect(int iSec);
-	void DisconnectOfSameLogin();
-
-	void SetAdminMode();
-	bool IsAdminMode(); // Handshake 에서 어드민 명령을 쓸수있나?
-
-	void SetPong(bool b);
-	bool IsPong();
-
-#if defined(__SEND_SEQUENCE__)
-	BYTE GetSequence();
-	void SetNextSequence();
-#endif
-
-	void SendLoginSuccessPacket();
-	//void SendServerStatePacket(int nIndex);
-
-	void SetPanamaKey(DWORD dwKey) { m_dwPanamaKey = dwKey; }
-	DWORD GetPanamaKey() const { return m_dwPanamaKey; }
-
-	void SetLoginKey(DWORD dwKey);
-	void SetLoginKey(CLoginKey* pkKey);
-	DWORD GetLoginKey();
-
-	void AssembleCRCMagicCube(BYTE bProcPiece, BYTE bFilePiece);
-
-	void SetClientVersion(const char* c_pszTimestamp) { m_stClientVersion = c_pszTimestamp; }
-	const char* GetClientVersion() { return m_stClientVersion.c_str(); }
-
-	bool isChannelStatusRequested() const { return m_bChannelStatusRequested; }
-	void SetChannelStatusRequested(bool bChannelStatusRequested) { m_bChannelStatusRequested = bChannelStatusRequested; }
-
-protected:
-	void Initialize();
-
-protected:
-	CInputProcessor* m_pInputProcessor;
-	CInputClose m_inputClose;
-	CInputHandshake m_inputHandshake;
-	CInputLogin m_inputLogin;
-	CInputMain m_inputMain;
-	CInputDead m_inputDead;
-	CInputAuth m_inputAuth;
-
-	LPFDWATCH m_lpFdw;
-	socket_t m_sock;
-	int m_iPhase;
-	DWORD m_dwHandle;
-
-	std::string m_stHost;
-	WORD m_wPort;
-	time_t m_LastTryToConnectTime;
-
-	LPBUFFER m_lpInputBuffer;
-	TEMP_BUFFER m_lpInputDecryptedBuffer;
-	int m_iMinInputBufferLen;
-
-	DWORD m_dwHandshake;
-	DWORD m_dwHandshakeSentTime;
-	int m_iHandshakeRetry;
-	DWORD m_dwClientTime;
-	bool m_bHandshaking;
-
-	LPBUFFER m_lpBufferedOutputBuffer;
-	LPBUFFER m_lpOutputBuffer;
-
-	LPEVENT m_pkPingEvent;
-	LPCHARACTER m_lpCharacter;
-	TAccountTable m_accountTable;
-
-	struct sockaddr_in m_SockAddr;
-	struct sockaddr_in m_UDPSockAddr;
-
-	FILE* m_pLogFile;
-	std::string m_stRelayName;
-
-	std::string m_stP2PHost;
-	WORD m_wP2PPort;
-	BYTE m_bP2PChannel;
-
-	bool m_bAdminMode; // Handshake 에서 어드민 명령을 쓸수있나?
-	bool m_bPong;
-
-#if defined(__SEND_SEQUENCE__)
-	int m_iCurrentSequence;
-#endif
-
-	CLoginKey* m_pkLoginKey;
-	DWORD m_dwLoginKey;
-	DWORD m_dwPanamaKey;
-
-	BYTE m_bCRCMagicCubeIdx;
-	DWORD m_dwProcCRC;
-	DWORD m_dwFileCRC;
-	bool m_bHackCRCQuery;
-
-	std::string m_stClientVersion;
-
-	std::string m_Login;
-	int m_outtime;
-	int m_playtime;
-	int m_offtime;
-
-	bool m_bDestroyed;
-	bool m_bChannelStatusRequested;
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	Cipher cipher_;
-#else
-	// Obsolete encryption stuff here
-	bool m_bEncrypted;
-	DWORD m_adwDecryptionKey[4];
-	DWORD m_adwEncryptionKey[4];
-#endif
-
-public:
-	LPEVENT m_pkDisconnectEvent;
-
-public:
-	void SetLogin(const std::string& login) { m_Login = login; }
-	void SetLogin(const char* login) { m_Login = login; }
-	const std::string& GetLogin() { return m_Login; }
-
-	void SetOutTime(int outtime) { m_outtime = outtime; }
-	void SetOffTime(int offtime) { m_offtime = offtime; }
-	void SetPlayTime(int playtime) { m_playtime = playtime; }
-
-	void RawPacket(const void* c_pvData, int iSize);
-	void ChatPacket(BYTE type, const char* format, ...);
-
-#if defined(__SEND_SEQUENCE__)
-	/* 시퀀스 버그 찾기용 코드 */
-public:
-	seq_vector_t m_seq_vector;
-	void push_seq(BYTE hdr, BYTE seq);
-#endif
-
-};
-
-#endif // __INC_DESC_H__
+#ifndef __INC_DESC_H__
+#define __INC_DESC_H__
+
+#include "constants.h"
+#include "input.h"
+#include "buffer_manager.h"
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+#include "cipher.h"
+#endif
+
+#define MAX_ALLOW_USER 4096
+//#define MAX_INPUT_LEN 65536
+#define MAX_INPUT_LEN 262144
+
+#define HANDSHAKE_RETRY_LIMIT 32
+
+class CInputProcessor;
+
+enum EDescType
+{
+	DESC_TYPE_ACCEPTOR,
+	DESC_TYPE_CONNECTOR
+};
+
+class CLoginKey
+{
+public:
+	CLoginKey(DWORD dwKey, LPDESC pkDesc) : m_dwKey(dwKey), m_pkDesc(pkDesc)
+	{
+		m_dwExpireTime = 0;
+	}
+
+	void Expire()
+	{
+		m_dwExpireTime = get_dword_time();
+		m_pkDesc = NULL;
+	}
+
+	operator DWORD() const
+	{
+		return m_dwKey;
+	}
+
+	DWORD m_dwKey;
+	DWORD m_dwExpireTime;
+	LPDESC m_pkDesc;
+};
+
+#if defined(__SEND_SEQUENCE__)
+// sequence  찾 타
+struct seq_t
+{
+	BYTE hdr;
+	BYTE seq;
+};
+typedef std::vector<seq_t> seq_vector_t;
+// sequence  찾 타
+#endif
+
+class DESC
+{
+public:
+	EVENTINFO(desc_event_info)
+	{
+		LPDESC desc;
+
+		desc_event_info()
+			: desc(0)
+		{
+		}
+	};
+
+public:
+	DESC();
+	virtual ~DESC();
+
+	virtual BYTE GetType() { return DESC_TYPE_ACCEPTOR; }
+	virtual void Destroy();
+	virtual void SetPhase(int _phase);
+
+	void FlushOutput();
+
+	bool Setup(LPFDWATCH _fdw, socket_t _fd, const struct sockaddr_in& c_rSockAddr, DWORD _handle, DWORD _handshake);
+
+	socket_t GetSocket() const { return m_sock; }
+	const char* GetHostName() { return m_stHost.c_str(); }
+	WORD GetPort() { return m_wPort; }
+
+	void SetP2P(const char* h, WORD w, BYTE b) { m_stP2PHost = h; m_wP2PPort = w; m_bP2PChannel = b; }
+	const char* GetP2PHost() { return m_stP2PHost.c_str(); }
+	WORD GetP2PPort() const { return m_wP2PPort; }
+	BYTE GetP2PChannel() const { return m_bP2PChannel; }
+
+	void BufferedPacket(const void* c_pvData, int iSize);
+	void Packet(const void* c_pvData, int iSize);
+	void LargePacket(const void* c_pvData, int iSize);
+
+	int ProcessInput(); // returns -1 if error
+	int ProcessOutput(); // returns -1 if error
+
+	CInputProcessor* GetInputProcessor() { return m_pInputProcessor; }
+
+	DWORD GetHandle() const { return m_dwHandle; }
+	LPBUFFER GetOutputBuffer() { return m_lpOutputBuffer; }
+
+	void BindAccountTable(TAccountTable* pTable);
+	TAccountTable& GetAccountTable() { return m_accountTable; }
+
+	void BindCharacter(LPCHARACTER ch);
+	LPCHARACTER GetCharacter() { return m_lpCharacter; }
+
+	bool IsPhase(int phase) const { return m_iPhase == phase ? true : false; }
+
+	const struct sockaddr_in& GetAddr() { return m_SockAddr; }
+
+	void UDPGrant(const struct sockaddr_in& c_rSockAddr);
+	const struct sockaddr_in& GetUDPAddr() { return m_UDPSockAddr; }
+
+	void Log(const char* format, ...);
+
+	// 湄壤┖ (챨 화)
+	void StartHandshake(DWORD _dw);
+	void SendHandshake(DWORD dwCurTime, long lNewDelta);
+	bool HandshakeProcess(DWORD dwTime, long lDelta, bool bInfiniteRetry = false);
+	bool IsHandshaking();
+
+	DWORD GetHandshake() const { return m_dwHandshake; }
+	DWORD GetClientTime();
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	void SendKeyAgreement();
+	void SendKeyAgreementCompleted();
+	bool FinishHandshake(size_t agreed_length, const void* buffer, size_t length);
+	bool IsCipherPrepared();
+#else
+	// Obsolete encryption stuff here
+	void SetSecurityKey(const DWORD* c_pdwKey);
+	const DWORD* GetEncryptionKey() const { return &m_adwEncryptionKey[0]; }
+	const DWORD* GetDecryptionKey() const { return &m_adwDecryptionKey[0]; }
+#endif
+
+	// 
+	BYTE GetEmpire();
+
+	// for p2p
+	void SetRelay(const char* c_pszName);
+	bool DelayedDisconnect(int iSec);
+	void DisconnectOfSameLogin();
+
+	void SetAdminMode();
+	bool IsAdminMode(); // Handshake    簾?
+
+	void SetPong(bool b);
+	bool IsPong();
+
+#if defined(__SEND_SEQUENCE__)
+	BYTE GetSequence();
+	void SetNextSequence();
+#endif
+
+	void SendLoginSuccessPacket();
+	//void SendServerStatePacket(int nIndex);
+
+	void SetPanamaKey(DWORD dwKey) { m_dwPanamaKey = dwKey; }
+	DWORD GetPanamaKey() const { return m_dwPanamaKey; }
+
+	void SetLoginKey(DWORD dwKey);
+	void SetLoginKey(CLoginKey* pkKey);
+	DWORD GetLoginKey();
+
+	void AssembleCRCMagicCube(BYTE bProcPiece, BYTE bFilePiece);
+
+	void SetClientVersion(const char* c_pszTimestamp) { m_stClientVersion = c_pszTimestamp; }
+	const char* GetClientVersion() { return m_stClientVersion.c_str(); }
+
+	bool isChannelStatusRequested() const { return m_bChannelStatusRequested; }
+	void SetChannelStatusRequested(bool bChannelStatusRequested) { m_bChannelStatusRequested = bChannelStatusRequested; }
+
+protected:
+	void Initialize();
+
+protected:
+	CInputProcessor* m_pInputProcessor;
+	CInputClose m_inputClose;
+	CInputHandshake m_inputHandshake;
+	CInputLogin m_inputLogin;
+	CInputMain m_inputMain;
+	CInputDead m_inputDead;
+	CInputAuth m_inputAuth;
+
+	LPFDWATCH m_lpFdw;
+	socket_t m_sock;
+	int m_iPhase;
+	DWORD m_dwHandle;
+
+	std::string m_stHost;
+	WORD m_wPort;
+	time_t m_LastTryToConnectTime;
+
+	LPBUFFER m_lpInputBuffer;
+	TEMP_BUFFER m_lpInputDecryptedBuffer;
+	int m_iMinInputBufferLen;
+
+	DWORD m_dwHandshake;
+	DWORD m_dwHandshakeSentTime;
+	int m_iHandshakeRetry;
+	DWORD m_dwClientTime;
+	bool m_bHandshaking;
+
+	LPBUFFER m_lpBufferedOutputBuffer;
+	LPBUFFER m_lpOutputBuffer;
+
+	LPEVENT m_pkPingEvent;
+	LPCHARACTER m_lpCharacter;
+	TAccountTable m_accountTable;
+
+	struct sockaddr_in m_SockAddr;
+	struct sockaddr_in m_UDPSockAddr;
+
+	FILE* m_pLogFile;
+	std::string m_stRelayName;
+
+	std::string m_stP2PHost;
+	WORD m_wP2PPort;
+	BYTE m_bP2PChannel;
+
+	bool m_bAdminMode; // Handshake    簾?
+	bool m_bPong;
+
+#if defined(__SEND_SEQUENCE__)
+	int m_iCurrentSequence;
+#endif
+
+	CLoginKey* m_pkLoginKey;
+	DWORD m_dwLoginKey;
+	DWORD m_dwPanamaKey;
+
+	BYTE m_bCRCMagicCubeIdx;
+	DWORD m_dwProcCRC;
+	DWORD m_dwFileCRC;
+	bool m_bHackCRCQuery;
+
+	std::string m_stClientVersion;
+
+	std::string m_Login;
+	int m_outtime;
+	int m_playtime;
+	int m_offtime;
+
+	bool m_bDestroyed;
+	bool m_bChannelStatusRequested;
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	Cipher cipher_;
+#else
+	// Obsolete encryption stuff here
+	bool m_bEncrypted;
+	DWORD m_adwDecryptionKey[4];
+	DWORD m_adwEncryptionKey[4];
+#endif
+
+public:
+	LPEVENT m_pkDisconnectEvent;
+
+public:
+	void SetLogin(const std::string& login) { m_Login = login; }
+	void SetLogin(const char* login) { m_Login = login; }
+	const std::string& GetLogin() { return m_Login; }
+
+	void SetOutTime(int outtime) { m_outtime = outtime; }
+	void SetOffTime(int offtime) { m_offtime = offtime; }
+	void SetPlayTime(int playtime) { m_playtime = playtime; }
+
+	
+	// -----------------------------------------------------------------------
+	// Production hardening: basic packet/byte rate limiting per connection.
+	// This mitigates connect+packet floods without relying only on firewall.
+	// -----------------------------------------------------------------------
+	bool CheckInputRate(size_t bytesRead);
+	bool RegisterBadHeader(BYTE header, bool isZeroHeader);
+	bool ShouldLogBadHeader() const;
+
+private:
+	DWORD m_dwInputRateWindowStart;
+	int   m_iInputRateBytes;
+	DWORD m_dwBadHeaderWindowStart;
+	int   m_iBadHeaderCount;
+	DWORD m_dwZeroHeaderWindowStart;
+	int   m_iZeroHeaderCount;
+
+public:
+void RawPacket(const void* c_pvData, int iSize);
+	void ChatPacket(BYTE type, const char* format, ...);
+
+#if defined(__SEND_SEQUENCE__)
+	/*   찾 湄 */
+public:
+	seq_vector_t m_seq_vector;
+	void push_seq(BYTE hdr, BYTE seq);
+#endif
+
+};
+
+#endif // __INC_DESC_H__
diff --git a/server/metin2/Source/Server/game/src/desc_manager.cpp b/server/metin2/Source/Server/game/src/desc_manager.cpp
index 0d93926..1c5a713 100644
--- a/server/metin2/Source/Server/game/src/desc_manager.cpp
+++ b/server/metin2/Source/Server/game/src/desc_manager.cpp
@@ -1,559 +1,619 @@
-#include "stdafx.h"
-#include "config.h"
-#include "utils.h"
-#include "crc32.h"
-#include "desc.h"
-#include "desc_p2p.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "protocol.h"
-#include "messenger_manager.h"
-#include "p2p.h"
-#include "ip_ban.h"
-#include "dev_log.h"
-#include "ClientPackageCryptInfo.h"
-
-struct valid_ip
-{
-	const char* ip;
-	BYTE network;
-	BYTE mask;
-};
-
-static struct valid_ip admin_ip[] =
-{
-	{ "210.123.10", 128, 128 },
-	{ "\n", 0, 0 }
-};
-
-int IsValidIP(struct valid_ip* ip_table, const char* host)
-{
-	int i, j;
-	char ip_addr[256];
-
-	for (i = 0; *(ip_table + i)->ip != '\n'; ++i)
-	{
-		j = 255 - (ip_table + i)->mask;
-
-		do
-		{
-			snprintf(ip_addr, sizeof(ip_addr), "%s.%d", (ip_table + i)->ip, (ip_table + i)->network + j);
-
-			if (!strcmp(ip_addr, host))
-				return TRUE;
-
-			if (!j)
-				break;
-		} while (j--);
-	}
-
-	return FALSE;
-}
-
-DESC_MANAGER::DESC_MANAGER() : m_bDestroyed(false)
-{
-	Initialize();
-	//NOTE : Destroy 끝에서 Initialize 를 부르는건 또 무슨 짓이냐..-_-; 정말 
-
-	m_pPackageCrypt = new CClientPackageCryptInfo;
-}
-
-DESC_MANAGER::~DESC_MANAGER()
-{
-	Destroy();
-	delete m_pPackageCrypt;
-}
-
-void DESC_MANAGER::Initialize()
-{
-	m_iSocketsConnected = 0;
-	m_iHandleCount = 0;
-	m_iLocalUserCount = 0;
-	memset(m_aiEmpireUserCount, 0, sizeof(m_aiEmpireUserCount));
-	m_bDisconnectInvalidCRC = false;
-}
-
-void DESC_MANAGER::Destroy()
-{
-	if (m_bDestroyed)
-		return;
-
-	m_bDestroyed = true;
-
-	DESC_SET::iterator i = m_set_pkDesc.begin();
-
-	while (i != m_set_pkDesc.end())
-	{
-		LPDESC d = *i;
-		DESC_SET::iterator ci = i;
-		++i;
-
-		if (d->GetType() == DESC_TYPE_CONNECTOR)
-			continue;
-
-		if (d->IsPhase(PHASE_P2P))
-			continue;
-
-		DestroyDesc(d, false);
-		m_set_pkDesc.erase(ci);
-	}
-
-	i = m_set_pkDesc.begin();
-
-	while (i != m_set_pkDesc.end())
-	{
-		LPDESC d = *i;
-		DESC_SET::iterator ci = i;
-		++i;
-
-		DestroyDesc(d, false);
-		m_set_pkDesc.erase(ci);
-	}
-
-	m_set_pkClientDesc.clear();
-
-	//m_AccountIDMap.clear();
-	m_map_loginName.clear();
-	m_map_handle.clear();
-
-	Initialize();
-}
-
-DWORD DESC_MANAGER::CreateHandshake()
-{
-	char crc_buf[8];
-	crc_t crc;
-	DESC_HANDSHAKE_MAP::iterator it;
-
-RETRY:
-	do
-	{
-		DWORD val = thecore_random() % (1024 * 1024);
-
-		*(DWORD*)(crc_buf) = val;
-		*((DWORD*)crc_buf + 1) = get_global_time();
-
-		crc = GetCRC32(crc_buf, 8);
-		it = m_map_handshake.find(crc);
-	} while (it != m_map_handshake.end());
-
-	if (crc == 0)
-		goto RETRY;
-
-	return (crc);
-}
-
-LPDESC DESC_MANAGER::AcceptDesc(LPFDWATCH fdw, socket_t s)
-{
-	socket_t desc;
-	LPDESC newd;
-	static struct sockaddr_in peer;
-	static char host[MAX_HOST_LENGTH + 1];
-
-	if ((desc = socket_accept(s, &peer)) == -1)
-		return NULL;
-
-	strlcpy(host, inet_ntoa(peer.sin_addr), sizeof(host));
-
-	if (g_bAuthServer)
-	{
-		if (IsBanIP(peer.sin_addr))
-		{
-			sys_log(0, "connection from %s was banned.", host);
-			socket_close(desc);
-			return NULL;
-		}
-	}
-
-	if (!IsValidIP(admin_ip, host)) // admin_ip 에 등록된 IP 는 최대 사용자 수에 구애받지 않는다.
-	{
-		if (m_iSocketsConnected >= MAX_ALLOW_USER)
-		{
-			sys_err("max connection reached. MAX_ALLOW_USER = %d", MAX_ALLOW_USER);
-			socket_close(desc);
-			return NULL;
-		}
-	}
-
-	newd = M2_NEW DESC;
-	crc_t handshake = CreateHandshake();
-
-	if (!newd->Setup(fdw, desc, peer, ++m_iHandleCount, handshake))
-	{
-		socket_close(desc);
-		M2_DELETE(newd);
-		return NULL;
-	}
-
-	m_map_handshake.insert(DESC_HANDSHAKE_MAP::value_type(handshake, newd));
-	m_map_handle.insert(DESC_HANDLE_MAP::value_type(newd->GetHandle(), newd));
-
-	m_set_pkDesc.insert(newd);
-	++m_iSocketsConnected;
-	return (newd);
-}
-
-LPDESC DESC_MANAGER::AcceptP2PDesc(LPFDWATCH fdw, socket_t bind_fd)
-{
-	socket_t fd;
-	struct sockaddr_in peer;
-	char host[MAX_HOST_LENGTH + 1];
-
-	if ((fd = socket_accept(bind_fd, &peer)) == -1)
-		return NULL;
-
-	strlcpy(host, inet_ntoa(peer.sin_addr), sizeof(host));
-
-	LPDESC_P2P pkDesc = M2_NEW DESC_P2P;
-
-	if (!pkDesc->Setup(fdw, fd, host, peer.sin_port))
-	{
-		sys_err("DESC_MANAGER::AcceptP2PDesc : Setup failed");
-		socket_close(fd);
-		M2_DELETE(pkDesc);
-		return NULL;
-	}
-
-	m_set_pkDesc.insert(pkDesc);
-	++m_iSocketsConnected;
-
-	sys_log(0, "DESC_MANAGER::AcceptP2PDesc %s:%u", host, peer.sin_port);
-	P2P_MANAGER::instance().RegisterAcceptor(pkDesc);
-	return (pkDesc);
-}
-
-void DESC_MANAGER::ConnectAccount(const std::string& login, LPDESC d)
-{
-	dev_log(LOG_DEB0, "BBBB ConnectAccount(%s)", login.c_str());
-	m_map_loginName.insert(DESC_LOGINNAME_MAP::value_type(login, d));
-}
-
-void DESC_MANAGER::DisconnectAccount(const std::string& login)
-{
-	dev_log(LOG_DEB0, "BBBB DisConnectAccount(%s)", login.c_str());
-	m_map_loginName.erase(login);
-}
-
-void DESC_MANAGER::DestroyDesc(LPDESC d, bool bEraseFromSet)
-{
-	if (bEraseFromSet)
-		m_set_pkDesc.erase(d);
-
-	if (d->GetHandshake())
-		m_map_handshake.erase(d->GetHandshake());
-
-	if (d->GetHandle() != 0)
-		m_map_handle.erase(d->GetHandle());
-	else
-		m_set_pkClientDesc.erase((LPCLIENT_DESC)d);
-
-	// Explicit call to the virtual function Destroy()
-	d->Destroy();
-
-	M2_DELETE(d);
-	--m_iSocketsConnected;
-}
-
-void DESC_MANAGER::DestroyClosed()
-{
-	DESC_SET::iterator i = m_set_pkDesc.begin();
-
-	while (i != m_set_pkDesc.end())
-	{
-		LPDESC d = *i;
-		DESC_SET::iterator ci = i;
-		++i;
-
-		if (d->IsPhase(PHASE_CLOSE))
-		{
-			if (d->GetType() == DESC_TYPE_CONNECTOR)
-			{
-				LPCLIENT_DESC client_desc = (LPCLIENT_DESC)d;
-
-				if (client_desc->IsRetryWhenClosed())
-				{
-					client_desc->Reset();
-					continue;
-				}
-			}
-
-			DestroyDesc(d, false);
-			m_set_pkDesc.erase(ci);
-		}
-	}
-}
-
-LPDESC DESC_MANAGER::FindByLoginName(const std::string& login)
-{
-	DESC_LOGINNAME_MAP::iterator it = m_map_loginName.find(login);
-
-	if (m_map_loginName.end() == it)
-		return NULL;
-
-	return (it->second);
-}
-
-LPDESC DESC_MANAGER::FindByHandle(DWORD handle)
-{
-	DESC_HANDLE_MAP::iterator it = m_map_handle.find(handle);
-
-	if (m_map_handle.end() == it)
-		return NULL;
-
-	return (it->second);
-}
-
-const DESC_MANAGER::DESC_SET& DESC_MANAGER::GetClientSet()
-{
-	return m_set_pkDesc;
-}
-
-struct name_with_desc_func
-{
-	const char* m_name;
-
-	name_with_desc_func(const char* name) : m_name(name)
-	{
-	}
-
-	bool operator () (LPDESC d)
-	{
-		if (d->GetCharacter() && !strcmp(d->GetCharacter()->GetName(), m_name))
-			return true;
-
-		return false;
-	}
-};
-
-LPDESC DESC_MANAGER::FindByCharacterName(const char* name)
-{
-	DESC_SET::iterator it = std::find_if(m_set_pkDesc.begin(), m_set_pkDesc.end(), name_with_desc_func(name));
-	return (it == m_set_pkDesc.end()) ? nullptr : (*it);
-}
-
-LPCLIENT_DESC DESC_MANAGER::CreateConnectionDesc(LPFDWATCH fdw, const char* host, WORD port, int iPhaseWhenSucceed, bool bRetryWhenClosed)
-{
-	LPCLIENT_DESC newd;
-
-	newd = M2_NEW CLIENT_DESC;
-
-	newd->Setup(fdw, host, port);
-	newd->Connect(iPhaseWhenSucceed);
-	newd->SetRetryWhenClosed(bRetryWhenClosed);
-
-	m_set_pkDesc.insert(newd);
-	m_set_pkClientDesc.insert(newd);
-
-	++m_iSocketsConnected;
-	return (newd);
-}
-
-struct FuncTryConnect
-{
-	void operator () (LPDESC d)
-	{
-		((LPCLIENT_DESC)d)->Connect();
-	}
-};
-
-void DESC_MANAGER::TryConnect()
-{
-	FuncTryConnect f;
-	std::for_each(m_set_pkClientDesc.begin(), m_set_pkClientDesc.end(), f);
-}
-
-bool DESC_MANAGER::IsP2PDescExist(const char* szHost, WORD wPort)
-{
-	CLIENT_DESC_SET::iterator it = m_set_pkClientDesc.begin();
-
-	while (it != m_set_pkClientDesc.end())
-	{
-		LPCLIENT_DESC d = *(it++);
-
-		if (!strcmp(d->GetP2PHost(), szHost) && d->GetP2PPort() == wPort)
-			return true;
-	}
-
-	return false;
-}
-
-LPDESC DESC_MANAGER::FindByHandshake(DWORD dwHandshake)
-{
-	DESC_HANDSHAKE_MAP::iterator it = m_map_handshake.find(dwHandshake);
-
-	if (it == m_map_handshake.end())
-		return NULL;
-
-	return (it->second);
-}
-
-class FuncWho
-{
-public:
-	int iTotalCount;
-	int aiEmpireUserCount[EMPIRE_MAX_NUM];
-
-	FuncWho()
-	{
-		iTotalCount = 0;
-		memset(aiEmpireUserCount, 0, sizeof(aiEmpireUserCount));
-	}
-
-	void operator() (LPDESC d)
-	{
-		if (d->GetCharacter())
-		{
-			++iTotalCount;
-			++aiEmpireUserCount[d->GetEmpire()];
-		}
-	}
-};
-
-void DESC_MANAGER::UpdateLocalUserCount()
-{
-	const DESC_SET& c_ref_set = GetClientSet();
-	FuncWho f;
-	f = std::for_each(c_ref_set.begin(), c_ref_set.end(), f);
-
-	m_iLocalUserCount = f.iTotalCount;
-	thecore_memcpy(m_aiEmpireUserCount, f.aiEmpireUserCount, sizeof(m_aiEmpireUserCount));
-
-	m_aiEmpireUserCount[1] += P2P_MANAGER::instance().GetEmpireUserCount(1);
-	m_aiEmpireUserCount[2] += P2P_MANAGER::instance().GetEmpireUserCount(2);
-	m_aiEmpireUserCount[3] += P2P_MANAGER::instance().GetEmpireUserCount(3);
-}
-
-void DESC_MANAGER::GetUserCount(int& iTotal, int** paiEmpireUserCount, int& iLocalCount)
-{
-	*paiEmpireUserCount = &m_aiEmpireUserCount[0];
-
-	int iCount = P2P_MANAGER::instance().GetCount();
-	if (iCount < 0)
-	{
-		sys_err("P2P_MANAGER::instance().GetCount() == -1");
-	}
-	iTotal = m_iLocalUserCount + iCount;
-	iLocalCount = m_iLocalUserCount;
-}
-
-DWORD DESC_MANAGER::MakeRandomKey(DWORD dwHandle)
-{
-	DWORD random_key = thecore_random();
-	m_map_handle_random_key.insert(std::make_pair(dwHandle, random_key));
-	return random_key;
-}
-
-bool DESC_MANAGER::GetRandomKey(DWORD dwHandle, DWORD* prandom_key)
-{
-	DESC_HANDLE_RANDOM_KEY_MAP::iterator it = m_map_handle_random_key.find(dwHandle);
-
-	if (it == m_map_handle_random_key.end())
-		return false;
-
-	*prandom_key = it->second;
-	return true;
-}
-
-LPDESC DESC_MANAGER::FindByLoginKey(DWORD dwKey)
-{
-	std::map<DWORD, CLoginKey*>::iterator it = m_map_pkLoginKey.find(dwKey);
-
-	if (it == m_map_pkLoginKey.end())
-		return NULL;
-
-	return it->second->m_pkDesc;
-}
-
-DWORD DESC_MANAGER::CreateLoginKey(LPDESC d)
-{
-	DWORD dwKey = 0;
-
-	do
-	{
-		dwKey = number(1, INT_MAX);
-
-		if (m_map_pkLoginKey.find(dwKey) != m_map_pkLoginKey.end())
-			continue;
-
-		CLoginKey* pkKey = M2_NEW CLoginKey(dwKey, d);
-		d->SetLoginKey(pkKey);
-		m_map_pkLoginKey.insert(std::make_pair(dwKey, pkKey));
-		break;
-	} while (1);
-
-	return dwKey;
-}
-
-void DESC_MANAGER::ProcessExpiredLoginKey()
-{
-	DWORD dwCurrentTime = get_dword_time();
-
-	std::map<DWORD, CLoginKey*>::iterator it, it2;
-
-	it = m_map_pkLoginKey.begin();
-
-	while (it != m_map_pkLoginKey.end())
-	{
-		it2 = it++;
-
-		if (it2->second->m_dwExpireTime == 0)
-			continue;
-
-		if (dwCurrentTime - it2->second->m_dwExpireTime > 60000)
-		{
-			M2_DELETE(it2->second);
-			m_map_pkLoginKey.erase(it2);
-		}
-	}
-}
-
-bool DESC_MANAGER::LoadClientPackageCryptInfo(const char* pDirName)
-{
-	return m_pPackageCrypt->LoadPackageCryptInfo(pDirName);
-}
-#ifdef __FreeBSD__
-void DESC_MANAGER::NotifyClientPackageFileChanged(const std::string& dirName, eFileUpdatedOptions eUpdateOption)
-{
-	Instance().LoadClientPackageCryptInfo(dirName.c_str());
-}
-#endif 
-
-void DESC_MANAGER::SendClientPackageCryptKey(LPDESC desc)
-{
-	if (!desc)
-	{
-		return;
-	}
-
-	TPacketGCHybridCryptKeys packet;
-	{
-		packet.bHeader = HEADER_GC_HYBRIDCRYPT_KEYS;
-		m_pPackageCrypt->GetPackageCryptKeys(&(packet.pDataKeyStream), packet.KeyStreamLen);
-	}
-
-	if (packet.KeyStreamLen > 0)
-	{
-		desc->Packet(packet.GetStreamData(), packet.GetStreamSize());
-	}
-}
-
-void DESC_MANAGER::SendClientPackageSDBToLoadMap(LPDESC desc, const char* pMapName)
-{
-	if (!desc)
-	{
-		return;
-	}
-
-	TPacketGCPackageSDB packet;
-	{
-		packet.bHeader = HEADER_GC_HYBRIDCRYPT_SDB;
-		if (!m_pPackageCrypt->GetRelatedMapSDBStreams(pMapName, &(packet.m_pDataSDBStream), packet.iStreamLen))
-			return;
-	}
-
-	if (packet.iStreamLen > 0)
-	{
-		desc->Packet(packet.GetStreamData(), packet.GetStreamSize());
-	}
-}
+#include "stdafx.h"
+#include "config.h"
+#include "utils.h"
+#include "crc32.h"
+#include "desc.h"
+#include "desc_p2p.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "protocol.h"
+#include "messenger_manager.h"
+#include "p2p.h"
+#include "ip_ban.h"
+#include "dev_log.h"
+#include "ClientPackageCryptInfo.h"
+
+struct valid_ip
+{
+	const char* ip;
+	BYTE network;
+	BYTE mask;
+};
+
+static struct valid_ip admin_ip[] =
+{
+	{ "210.123.10", 128, 128 },
+	{ "\n", 0, 0 }
+};
+
+int IsValidIP(struct valid_ip* ip_table, const char* host)
+{
+	int i, j;
+	char ip_addr[256];
+
+	for (i = 0; *(ip_table + i)->ip != '\n'; ++i)
+	{
+		j = 255 - (ip_table + i)->mask;
+
+		do
+		{
+			snprintf(ip_addr, sizeof(ip_addr), "%s.%d", (ip_table + i)->ip, (ip_table + i)->network + j);
+
+			if (!strcmp(ip_addr, host))
+				return TRUE;
+
+			if (!j)
+				break;
+		} while (j--);
+	}
+
+	return FALSE;
+}
+
+DESC_MANAGER::DESC_MANAGER() : m_bDestroyed(false)
+{
+	m_iMaxConnPerIP = 3;
+	m_iMaxConnPerIPWindow = 20;
+	m_iConnWindowSec = 10;
+	Initialize();
+	//NOTE : Destroy  Initialize  罐째   犬..-_-;  
+
+	m_pPackageCrypt = new CClientPackageCryptInfo;
+}
+
+DESC_MANAGER::~DESC_MANAGER()
+{
+	Destroy();
+	delete m_pPackageCrypt;
+}
+
+void DESC_MANAGER::Initialize()
+{
+	m_iSocketsConnected = 0;
+	m_iHandleCount = 0;
+	m_iLocalUserCount = 0;
+	memset(m_aiEmpireUserCount, 0, sizeof(m_aiEmpireUserCount));
+	m_bDisconnectInvalidCRC = false;
+}
+
+void DESC_MANAGER::Destroy()
+{
+	if (m_bDestroyed)
+		return;
+
+	m_bDestroyed = true;
+
+	DESC_SET::iterator i = m_set_pkDesc.begin();
+
+	while (i != m_set_pkDesc.end())
+	{
+		LPDESC d = *i;
+		DESC_SET::iterator ci = i;
+		++i;
+
+		if (d->GetType() == DESC_TYPE_CONNECTOR)
+			continue;
+
+		if (d->IsPhase(PHASE_P2P))
+			continue;
+
+		DestroyDesc(d, false);
+		m_set_pkDesc.erase(ci);
+	}
+
+	i = m_set_pkDesc.begin();
+
+	while (i != m_set_pkDesc.end())
+	{
+		LPDESC d = *i;
+		DESC_SET::iterator ci = i;
+		++i;
+
+		DestroyDesc(d, false);
+		m_set_pkDesc.erase(ci);
+	}
+
+	m_set_pkClientDesc.clear();
+
+	//m_AccountIDMap.clear();
+	m_map_loginName.clear();
+	m_map_handle.clear();
+
+	Initialize();
+}
+
+DWORD DESC_MANAGER::CreateHandshake()
+{
+	char crc_buf[8];
+	crc_t crc;
+	DESC_HANDSHAKE_MAP::iterator it;
+
+RETRY:
+	do
+	{
+		DWORD val = thecore_random() % (1024 * 1024);
+
+		*(DWORD*)(crc_buf) = val;
+		*((DWORD*)crc_buf + 1) = get_global_time();
+
+		crc = GetCRC32(crc_buf, 8);
+		it = m_map_handshake.find(crc);
+	} while (it != m_map_handshake.end());
+
+	if (crc == 0)
+		goto RETRY;
+
+	return (crc);
+}
+
+bool DESC_MANAGER::CheckAndUpdateIPConnection(const char* host)
+{
+	if (!host || !*host)
+		return false;
+
+	const DWORD now = get_global_time();
+	SIpConnStat& st = m_map_ip_conn[host];
+
+	if (st.dwWindowStart == 0 || (now - st.dwWindowStart) >= (DWORD)m_iConnWindowSec)
+	{
+		st.dwWindowStart = now;
+		st.iWindowCount = 0;
+	}
+
+	if (st.iWindowCount >= m_iMaxConnPerIPWindow)
+	{
+		sys_log(0, "IP rate limit: %s (%d connects/%ds)", host, st.iWindowCount, m_iConnWindowSec);
+		return false;
+	}
+
+	if (st.iActive >= m_iMaxConnPerIP)
+	{
+		sys_log(0, "IP active limit: %s (%d active)", host, st.iActive);
+		return false;
+	}
+
+	++st.iWindowCount;
+	++st.iActive;
+	return true;
+}
+
+void DESC_MANAGER::DecreaseIPActive(const char* host)
+{
+	if (!host || !*host)
+		return;
+
+	IP_CONN_MAP::iterator it = m_map_ip_conn.find(host);
+	if (it == m_map_ip_conn.end())
+		return;
+
+	if (it->second.iActive > 0)
+		--it->second.iActive;
+
+	// prune idle entries after 60s to keep the map bounded
+	const DWORD now = get_global_time();
+	if (it->second.iActive <= 0 && it->second.dwWindowStart != 0 && (now - it->second.dwWindowStart) > 60)
+		m_map_ip_conn.erase(it);
+}
+
+
+LPDESC DESC_MANAGER::AcceptDesc(LPFDWATCH fdw, socket_t s)
+{
+	socket_t desc;
+	LPDESC newd;
+	static struct sockaddr_in peer;
+	static char host[MAX_HOST_LENGTH + 1];
+
+	if ((desc = socket_accept(s, &peer)) == -1)
+		return NULL;
+
+	strlcpy(host, inet_ntoa(peer.sin_addr), sizeof(host));
+
+	if (g_bAuthServer)
+	{
+		if (IsBanIP(peer.sin_addr))
+		{
+			sys_log(0, "connection from %s was banned.", host);
+			socket_close(desc);
+			return NULL;
+		}
+	}
+
+	if (!IsValidIP(admin_ip, host)) // admin_ip  溝 IP  獵   岺 苛쨈.
+	{
+		if (!CheckAndUpdateIPConnection(host))
+		{
+			socket_close(desc);
+			return NULL;
+		}
+		if (m_iSocketsConnected >= MAX_ALLOW_USER)
+		{
+			sys_err("max connection reached. MAX_ALLOW_USER = %d", MAX_ALLOW_USER);
+			socket_close(desc);
+			return NULL;
+		}
+	}
+
+	newd = M2_NEW DESC;
+	crc_t handshake = CreateHandshake();
+
+	if (!newd->Setup(fdw, desc, peer, ++m_iHandleCount, handshake))
+	{
+		socket_close(desc);
+		M2_DELETE(newd);
+		return NULL;
+	}
+
+	m_map_handshake.insert(DESC_HANDSHAKE_MAP::value_type(handshake, newd));
+	m_map_handle.insert(DESC_HANDLE_MAP::value_type(newd->GetHandle(), newd));
+
+	m_set_pkDesc.insert(newd);
+	++m_iSocketsConnected;
+	return (newd);
+}
+
+LPDESC DESC_MANAGER::AcceptP2PDesc(LPFDWATCH fdw, socket_t bind_fd)
+{
+	socket_t fd;
+	struct sockaddr_in peer;
+	char host[MAX_HOST_LENGTH + 1];
+
+	if ((fd = socket_accept(bind_fd, &peer)) == -1)
+		return NULL;
+
+	strlcpy(host, inet_ntoa(peer.sin_addr), sizeof(host));
+
+	LPDESC_P2P pkDesc = M2_NEW DESC_P2P;
+
+	if (!pkDesc->Setup(fdw, fd, host, peer.sin_port))
+	{
+		sys_err("DESC_MANAGER::AcceptP2PDesc : Setup failed");
+		socket_close(fd);
+		M2_DELETE(pkDesc);
+		return NULL;
+	}
+
+	m_set_pkDesc.insert(pkDesc);
+	++m_iSocketsConnected;
+
+	sys_log(0, "DESC_MANAGER::AcceptP2PDesc %s:%u", host, peer.sin_port);
+	P2P_MANAGER::instance().RegisterAcceptor(pkDesc);
+	return (pkDesc);
+}
+
+void DESC_MANAGER::ConnectAccount(const std::string& login, LPDESC d)
+{
+	dev_log(LOG_DEB0, "BBBB ConnectAccount(%s)", login.c_str());
+	m_map_loginName.insert(DESC_LOGINNAME_MAP::value_type(login, d));
+}
+
+void DESC_MANAGER::DisconnectAccount(const std::string& login)
+{
+	dev_log(LOG_DEB0, "BBBB DisConnectAccount(%s)", login.c_str());
+	m_map_loginName.erase(login);
+}
+
+void DESC_MANAGER::DestroyDesc(LPDESC d, bool bEraseFromSet)
+{
+	if (bEraseFromSet)
+		m_set_pkDesc.erase(d);
+
+	if (d->GetHandshake())
+		m_map_handshake.erase(d->GetHandshake());
+
+	if (d->GetHandle() != 0)
+		m_map_handle.erase(d->GetHandle());
+	else
+		m_set_pkClientDesc.erase((LPCLIENT_DESC)d);
+
+	// Explicit call to the virtual function Destroy()
+	d->Destroy();
+
+	DecreaseIPActive(d->GetHostName());
+
+	M2_DELETE(d);
+	--m_iSocketsConnected;
+}
+
+void DESC_MANAGER::DestroyClosed()
+{
+	DESC_SET::iterator i = m_set_pkDesc.begin();
+
+	while (i != m_set_pkDesc.end())
+	{
+		LPDESC d = *i;
+		DESC_SET::iterator ci = i;
+		++i;
+
+		if (d->IsPhase(PHASE_CLOSE))
+		{
+			if (d->GetType() == DESC_TYPE_CONNECTOR)
+			{
+				LPCLIENT_DESC client_desc = (LPCLIENT_DESC)d;
+
+				if (client_desc->IsRetryWhenClosed())
+				{
+					client_desc->Reset();
+					continue;
+				}
+			}
+
+			DestroyDesc(d, false);
+			m_set_pkDesc.erase(ci);
+		}
+	}
+}
+
+LPDESC DESC_MANAGER::FindByLoginName(const std::string& login)
+{
+	DESC_LOGINNAME_MAP::iterator it = m_map_loginName.find(login);
+
+	if (m_map_loginName.end() == it)
+		return NULL;
+
+	return (it->second);
+}
+
+LPDESC DESC_MANAGER::FindByHandle(DWORD handle)
+{
+	DESC_HANDLE_MAP::iterator it = m_map_handle.find(handle);
+
+	if (m_map_handle.end() == it)
+		return NULL;
+
+	return (it->second);
+}
+
+const DESC_MANAGER::DESC_SET& DESC_MANAGER::GetClientSet()
+{
+	return m_set_pkDesc;
+}
+
+struct name_with_desc_func
+{
+	const char* m_name;
+
+	name_with_desc_func(const char* name) : m_name(name)
+	{
+	}
+
+	bool operator () (LPDESC d)
+	{
+		if (d->GetCharacter() && !strcmp(d->GetCharacter()->GetName(), m_name))
+			return true;
+
+		return false;
+	}
+};
+
+LPDESC DESC_MANAGER::FindByCharacterName(const char* name)
+{
+	DESC_SET::iterator it = std::find_if(m_set_pkDesc.begin(), m_set_pkDesc.end(), name_with_desc_func(name));
+	return (it == m_set_pkDesc.end()) ? nullptr : (*it);
+}
+
+LPCLIENT_DESC DESC_MANAGER::CreateConnectionDesc(LPFDWATCH fdw, const char* host, WORD port, int iPhaseWhenSucceed, bool bRetryWhenClosed)
+{
+	LPCLIENT_DESC newd;
+
+	newd = M2_NEW CLIENT_DESC;
+
+	newd->Setup(fdw, host, port);
+	newd->Connect(iPhaseWhenSucceed);
+	newd->SetRetryWhenClosed(bRetryWhenClosed);
+
+	m_set_pkDesc.insert(newd);
+	m_set_pkClientDesc.insert(newd);
+
+	++m_iSocketsConnected;
+	return (newd);
+}
+
+struct FuncTryConnect
+{
+	void operator () (LPDESC d)
+	{
+		((LPCLIENT_DESC)d)->Connect();
+	}
+};
+
+void DESC_MANAGER::TryConnect()
+{
+	FuncTryConnect f;
+	std::for_each(m_set_pkClientDesc.begin(), m_set_pkClientDesc.end(), f);
+}
+
+bool DESC_MANAGER::IsP2PDescExist(const char* szHost, WORD wPort)
+{
+	CLIENT_DESC_SET::iterator it = m_set_pkClientDesc.begin();
+
+	while (it != m_set_pkClientDesc.end())
+	{
+		LPCLIENT_DESC d = *(it++);
+
+		if (!strcmp(d->GetP2PHost(), szHost) && d->GetP2PPort() == wPort)
+			return true;
+	}
+
+	return false;
+}
+
+LPDESC DESC_MANAGER::FindByHandshake(DWORD dwHandshake)
+{
+	DESC_HANDSHAKE_MAP::iterator it = m_map_handshake.find(dwHandshake);
+
+	if (it == m_map_handshake.end())
+		return NULL;
+
+	return (it->second);
+}
+
+class FuncWho
+{
+public:
+	int iTotalCount;
+	int aiEmpireUserCount[EMPIRE_MAX_NUM];
+
+	FuncWho()
+	{
+		iTotalCount = 0;
+		memset(aiEmpireUserCount, 0, sizeof(aiEmpireUserCount));
+	}
+
+	void operator() (LPDESC d)
+	{
+		if (d->GetCharacter())
+		{
+			++iTotalCount;
+			++aiEmpireUserCount[d->GetEmpire()];
+		}
+	}
+};
+
+void DESC_MANAGER::UpdateLocalUserCount()
+{
+	const DESC_SET& c_ref_set = GetClientSet();
+	FuncWho f;
+	f = std::for_each(c_ref_set.begin(), c_ref_set.end(), f);
+
+	m_iLocalUserCount = f.iTotalCount;
+	thecore_memcpy(m_aiEmpireUserCount, f.aiEmpireUserCount, sizeof(m_aiEmpireUserCount));
+
+	m_aiEmpireUserCount[1] += P2P_MANAGER::instance().GetEmpireUserCount(1);
+	m_aiEmpireUserCount[2] += P2P_MANAGER::instance().GetEmpireUserCount(2);
+	m_aiEmpireUserCount[3] += P2P_MANAGER::instance().GetEmpireUserCount(3);
+}
+
+void DESC_MANAGER::GetUserCount(int& iTotal, int** paiEmpireUserCount, int& iLocalCount)
+{
+	*paiEmpireUserCount = &m_aiEmpireUserCount[0];
+
+	int iCount = P2P_MANAGER::instance().GetCount();
+	if (iCount < 0)
+	{
+		sys_err("P2P_MANAGER::instance().GetCount() == -1");
+	}
+	iTotal = m_iLocalUserCount + iCount;
+	iLocalCount = m_iLocalUserCount;
+}
+
+DWORD DESC_MANAGER::MakeRandomKey(DWORD dwHandle)
+{
+	DWORD random_key = thecore_random();
+	m_map_handle_random_key.insert(std::make_pair(dwHandle, random_key));
+	return random_key;
+}
+
+bool DESC_MANAGER::GetRandomKey(DWORD dwHandle, DWORD* prandom_key)
+{
+	DESC_HANDLE_RANDOM_KEY_MAP::iterator it = m_map_handle_random_key.find(dwHandle);
+
+	if (it == m_map_handle_random_key.end())
+		return false;
+
+	*prandom_key = it->second;
+	return true;
+}
+
+LPDESC DESC_MANAGER::FindByLoginKey(DWORD dwKey)
+{
+	std::map<DWORD, CLoginKey*>::iterator it = m_map_pkLoginKey.find(dwKey);
+
+	if (it == m_map_pkLoginKey.end())
+		return NULL;
+
+	return it->second->m_pkDesc;
+}
+
+DWORD DESC_MANAGER::CreateLoginKey(LPDESC d)
+{
+	DWORD dwKey = 0;
+
+	do
+	{
+		dwKey = number(1, INT_MAX);
+
+		if (m_map_pkLoginKey.find(dwKey) != m_map_pkLoginKey.end())
+			continue;
+
+		CLoginKey* pkKey = M2_NEW CLoginKey(dwKey, d);
+		d->SetLoginKey(pkKey);
+		m_map_pkLoginKey.insert(std::make_pair(dwKey, pkKey));
+		break;
+	} while (1);
+
+	return dwKey;
+}
+
+void DESC_MANAGER::ProcessExpiredLoginKey()
+{
+	DWORD dwCurrentTime = get_dword_time();
+
+	std::map<DWORD, CLoginKey*>::iterator it, it2;
+
+	it = m_map_pkLoginKey.begin();
+
+	while (it != m_map_pkLoginKey.end())
+	{
+		it2 = it++;
+
+		if (it2->second->m_dwExpireTime == 0)
+			continue;
+
+		if (dwCurrentTime - it2->second->m_dwExpireTime > 60000)
+		{
+			M2_DELETE(it2->second);
+			m_map_pkLoginKey.erase(it2);
+		}
+	}
+}
+
+bool DESC_MANAGER::LoadClientPackageCryptInfo(const char* pDirName)
+{
+	return m_pPackageCrypt->LoadPackageCryptInfo(pDirName);
+}
+#ifdef __FreeBSD__
+void DESC_MANAGER::NotifyClientPackageFileChanged(const std::string& dirName, eFileUpdatedOptions eUpdateOption)
+{
+	Instance().LoadClientPackageCryptInfo(dirName.c_str());
+}
+#endif 
+
+void DESC_MANAGER::SendClientPackageCryptKey(LPDESC desc)
+{
+	if (!desc)
+	{
+		return;
+	}
+
+	TPacketGCHybridCryptKeys packet;
+	{
+		packet.bHeader = HEADER_GC_HYBRIDCRYPT_KEYS;
+		m_pPackageCrypt->GetPackageCryptKeys(&(packet.pDataKeyStream), packet.KeyStreamLen);
+	}
+
+	if (packet.KeyStreamLen > 0)
+	{
+		desc->Packet(packet.GetStreamData(), packet.GetStreamSize());
+	}
+}
+
+void DESC_MANAGER::SendClientPackageSDBToLoadMap(LPDESC desc, const char* pMapName)
+{
+	if (!desc)
+	{
+		return;
+	}
+
+	TPacketGCPackageSDB packet;
+	{
+		packet.bHeader = HEADER_GC_HYBRIDCRYPT_SDB;
+		if (!m_pPackageCrypt->GetRelatedMapSDBStreams(pMapName, &(packet.m_pDataSDBStream), packet.iStreamLen))
+			return;
+	}
+
+	if (packet.iStreamLen > 0)
+	{
+		desc->Packet(packet.GetStreamData(), packet.GetStreamSize());
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/desc_manager.h b/server/metin2/Source/Server/game/src/desc_manager.h
index 689ea94..3cd608c 100644
--- a/server/metin2/Source/Server/game/src/desc_manager.h
+++ b/server/metin2/Source/Server/game/src/desc_manager.h
@@ -1,100 +1,117 @@
-#ifndef __INC_DESC_MANAGER_H__
-#define __INC_DESC_MANAGER_H__
-
-#include "../../common/stl.h"
-#include "../../common/length.h"
-#include "IFileMonitor.h"
-
-class CLoginKey;
-class CClientPackageCryptInfo;
-
-class DESC_MANAGER : public singleton<DESC_MANAGER>
-{
-public:
-	typedef std::unordered_set<LPDESC> DESC_SET;
-	typedef std::unordered_set<LPCLIENT_DESC> CLIENT_DESC_SET;
-	typedef std::map<int, LPDESC> DESC_HANDLE_MAP;
-	typedef std::map<DWORD, LPDESC> DESC_HANDSHAKE_MAP;
-	typedef std::map<DWORD, LPDESC> DESC_ACCOUNTID_MAP;
-	typedef std::unordered_map<std::string, LPDESC> DESC_LOGINNAME_MAP;
-	typedef std::map<DWORD, DWORD> DESC_HANDLE_RANDOM_KEY_MAP;
-
-public:
-	DESC_MANAGER();
-	virtual ~DESC_MANAGER();
-
-	void Initialize();
-	void Destroy();
-
-	LPDESC AcceptDesc(LPFDWATCH fdw, socket_t s);
-	LPDESC AcceptP2PDesc(LPFDWATCH fdw, socket_t s);
-	void DestroyDesc(LPDESC d, bool erase_from_set = true);
-
-	DWORD CreateHandshake();
-
-	LPCLIENT_DESC CreateConnectionDesc(LPFDWATCH fdw, const char* host, WORD port, int iPhaseWhenSucceed, bool bRetryWhenClosed);
-	void TryConnect();
-
-	LPDESC FindByHandle(DWORD handle);
-	LPDESC FindByHandshake(DWORD dwHandshake);
-
-	LPDESC FindByCharacterName(const char* name);
-	LPDESC FindByLoginName(const std::string& login);
-	void ConnectAccount(const std::string& login, LPDESC d);
-	void DisconnectAccount(const std::string& login);
-
-	void DestroyClosed();
-
-	void UpdateLocalUserCount();
-	DWORD GetLocalUserCount() { return m_iLocalUserCount; }
-	void GetUserCount(int& iTotal, int** paiEmpireUserCount, int& iLocalCount);
-
-	const DESC_SET& GetClientSet();
-
-	DWORD MakeRandomKey(DWORD dwHandle);
-	bool GetRandomKey(DWORD dwHandle, DWORD* prandom_key);
-
-	DWORD CreateLoginKey(LPDESC d);
-	LPDESC FindByLoginKey(DWORD dwKey);
-	void ProcessExpiredLoginKey();
-
-	bool IsDisconnectInvalidCRC() { return m_bDisconnectInvalidCRC; }
-	void SetDisconnectInvalidCRCMode(bool bMode) { m_bDisconnectInvalidCRC = bMode; }
-
-	bool IsP2PDescExist(const char* szHost, WORD wPort);
-
-	// for C/S hybrid crypt
-	bool LoadClientPackageCryptInfo(const char* pDirName);
-	void SendClientPackageCryptKey(LPDESC desc);
-	void SendClientPackageSDBToLoadMap(LPDESC desc, const char* pMapName);
-#ifdef __FreeBSD__
-	static void NotifyClientPackageFileChanged(const std::string& fileName, eFileUpdatedOptions eUpdateOption);
-#endif 
-
-private:
-	bool m_bDisconnectInvalidCRC;
-
-	DESC_HANDLE_RANDOM_KEY_MAP m_map_handle_random_key;
-
-	CLIENT_DESC_SET m_set_pkClientDesc;
-	DESC_SET m_set_pkDesc;
-
-	DESC_HANDLE_MAP m_map_handle;
-	DESC_HANDSHAKE_MAP m_map_handshake;
-	//DESC_ACCOUNTID_MAP m_AccountIDMap;
-	DESC_LOGINNAME_MAP m_map_loginName;
-	std::map<DWORD, CLoginKey*> m_map_pkLoginKey;
-
-	int m_iSocketsConnected;
-
-	int m_iHandleCount;
-
-	int m_iLocalUserCount;
-	int m_aiEmpireUserCount[EMPIRE_MAX_NUM];
-
-	bool m_bDestroyed;
-
-	CClientPackageCryptInfo* m_pPackageCrypt;
-};
-
-#endif // __INC_DESC_MANAGER_H__
+#ifndef __INC_DESC_MANAGER_H__
+#define __INC_DESC_MANAGER_H__
+
+#include "../../common/stl.h"
+#include "../../common/length.h"
+#include "IFileMonitor.h"
+
+class CLoginKey;
+class CClientPackageCryptInfo;
+
+class DESC_MANAGER : public singleton<DESC_MANAGER>
+{
+public:
+	typedef std::unordered_set<LPDESC> DESC_SET;
+	typedef std::unordered_set<LPCLIENT_DESC> CLIENT_DESC_SET;
+	typedef std::map<int, LPDESC> DESC_HANDLE_MAP;
+	typedef std::map<DWORD, LPDESC> DESC_HANDSHAKE_MAP;
+	typedef std::map<DWORD, LPDESC> DESC_ACCOUNTID_MAP;
+	typedef std::unordered_map<std::string, LPDESC> DESC_LOGINNAME_MAP;
+	typedef std::map<DWORD, DWORD> DESC_HANDLE_RANDOM_KEY_MAP;
+
+	struct SIpConnStat
+	{
+		DWORD dwWindowStart;
+		int iWindowCount;
+		int iActive;
+		SIpConnStat() : dwWindowStart(0), iWindowCount(0), iActive(0) {}
+	};
+	typedef std::unordered_map<std::string, SIpConnStat> IP_CONN_MAP;
+
+public:
+	DESC_MANAGER();
+	virtual ~DESC_MANAGER();
+
+	void Initialize();
+	void Destroy();
+
+	LPDESC AcceptDesc(LPFDWATCH fdw, socket_t s);
+	LPDESC AcceptP2PDesc(LPFDWATCH fdw, socket_t s);
+	void DestroyDesc(LPDESC d, bool erase_from_set = true);
+
+	DWORD CreateHandshake();
+
+	LPCLIENT_DESC CreateConnectionDesc(LPFDWATCH fdw, const char* host, WORD port, int iPhaseWhenSucceed, bool bRetryWhenClosed);
+	void TryConnect();
+
+	LPDESC FindByHandle(DWORD handle);
+	LPDESC FindByHandshake(DWORD dwHandshake);
+
+	LPDESC FindByCharacterName(const char* name);
+	LPDESC FindByLoginName(const std::string& login);
+	void ConnectAccount(const std::string& login, LPDESC d);
+	void DisconnectAccount(const std::string& login);
+
+	void DestroyClosed();
+
+	void UpdateLocalUserCount();
+	DWORD GetLocalUserCount() { return m_iLocalUserCount; }
+	void GetUserCount(int& iTotal, int** paiEmpireUserCount, int& iLocalCount);
+
+	const DESC_SET& GetClientSet();
+
+	DWORD MakeRandomKey(DWORD dwHandle);
+	bool GetRandomKey(DWORD dwHandle, DWORD* prandom_key);
+
+	DWORD CreateLoginKey(LPDESC d);
+	LPDESC FindByLoginKey(DWORD dwKey);
+	void ProcessExpiredLoginKey();
+
+	bool IsDisconnectInvalidCRC() { return m_bDisconnectInvalidCRC; }
+	void SetDisconnectInvalidCRCMode(bool bMode) { m_bDisconnectInvalidCRC = bMode; }
+
+	bool IsP2PDescExist(const char* szHost, WORD wPort);
+
+	// for C/S hybrid crypt
+	bool LoadClientPackageCryptInfo(const char* pDirName);
+	void SendClientPackageCryptKey(LPDESC desc);
+	void SendClientPackageSDBToLoadMap(LPDESC desc, const char* pMapName);
+#ifdef __FreeBSD__
+	static void NotifyClientPackageFileChanged(const std::string& fileName, eFileUpdatedOptions eUpdateOption);
+#endif 
+
+private:
+	bool CheckAndUpdateIPConnection(const char* host);
+	void DecreaseIPActive(const char* host);
+
+	bool m_bDisconnectInvalidCRC;
+
+	DESC_HANDLE_RANDOM_KEY_MAP m_map_handle_random_key;
+
+	IP_CONN_MAP m_map_ip_conn;
+	int m_iMaxConnPerIP;
+	int m_iMaxConnPerIPWindow;
+	int m_iConnWindowSec;
+
+	CLIENT_DESC_SET m_set_pkClientDesc;
+	DESC_SET m_set_pkDesc;
+
+	DESC_HANDLE_MAP m_map_handle;
+	DESC_HANDSHAKE_MAP m_map_handshake;
+	//DESC_ACCOUNTID_MAP m_AccountIDMap;
+	DESC_LOGINNAME_MAP m_map_loginName;
+	std::map<DWORD, CLoginKey*> m_map_pkLoginKey;
+
+	int m_iSocketsConnected;
+
+	int m_iHandleCount;
+
+	int m_iLocalUserCount;
+	int m_aiEmpireUserCount[EMPIRE_MAX_NUM];
+
+	bool m_bDestroyed;
+
+	CClientPackageCryptInfo* m_pPackageCrypt;
+};
+
+#endif // __INC_DESC_MANAGER_H__
diff --git a/server/metin2/Source/Server/game/src/desc_p2p.cpp b/server/metin2/Source/Server/game/src/desc_p2p.cpp
index f6ed11c..11e73ba 100644
--- a/server/metin2/Source/Server/game/src/desc_p2p.cpp
+++ b/server/metin2/Source/Server/game/src/desc_p2p.cpp
@@ -1,92 +1,116 @@
-#include "stdafx.h"
-#include "desc_p2p.h"
-#include "protocol.h"
-#include "p2p.h"
-#include "../../common/service.h"
-#if !defined(__ALLOW_EXTERNAL_PEER__)
-#include "config.h"
-#endif
-
-DESC_P2P::~DESC_P2P()
-{
-}
-
-void DESC_P2P::Destroy()
-{
-	if (m_sock == INVALID_SOCKET)
-		return;
-
-	P2P_MANAGER::instance().UnregisterAcceptor(this);
-
-	fdwatch_del_fd(m_lpFdw, m_sock);
-
-	sys_log(0, "SYSTEM: closing p2p socket. DESC #%d", m_sock);
-
-	socket_close(m_sock);
-	m_sock = INVALID_SOCKET;
-
-	// Chain up to base class Destroy()
-	DESC::Destroy();
-}
-
-bool DESC_P2P::Setup(LPFDWATCH fdw, socket_t fd, const char* host, WORD wPort)
-{
-	m_lpFdw = fdw;
-	m_stHost = host;
-	m_wPort = wPort;
-	m_sock = fd;
-
-	if (!(m_lpOutputBuffer = buffer_new(1024 * 1024)))
-		return false;
-
-	if (!(m_lpInputBuffer = buffer_new(1024 * 1024)))
-		return false;
-
-	fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_READ, false);
-
-	m_iMinInputBufferLen = 1024 * 1024;
-
-#if !defined(__ALLOW_EXTERNAL_PEER__)
-	if (strcmp(host, g_szPublicIP))
-	{
-		sys_log(0, "SYSTEM: new p2p connection from [%s] to [%s] fd: %d BLOCKED", host, g_szPublicIP, m_sock);
-		SetPhase(PHASE_CLOSE);
-		return true;
-	}
-#endif
-
-	SetPhase(PHASE_P2P);
-
-	sys_log(0, "SYSTEM: new p2p connection from [%s] fd: %d", host, m_sock);
-	return true;
-}
-
-void DESC_P2P::SetPhase(int iPhase)
-{
-	static CInputP2P s_inputP2P;
-
-	switch (iPhase)
-	{
-	case PHASE_P2P:
-		sys_log(1, "PHASE_P2P");
-
-		if (m_lpInputBuffer)
-			buffer_reset(m_lpInputBuffer);
-
-		if (m_lpOutputBuffer)
-			buffer_reset(m_lpOutputBuffer);
-
-		m_pInputProcessor = &s_inputP2P;
-		break;
-
-	case PHASE_CLOSE:
-		m_pInputProcessor = NULL;
-		break;
-
-	default:
-		sys_err("DESC_P2P::SetPhase : Unknown phase");
-		break;
-	}
-
-	m_iPhase = iPhase;
-}
+#include "stdafx.h"
+#include <arpa/inet.h>
+#include "desc_p2p.h"
+#include "protocol.h"
+#include "p2p.h"
+#include "../../common/service.h"
+#if !defined(__ALLOW_EXTERNAL_PEER__)
+#include "config.h"
+#endif
+
+DESC_P2P::~DESC_P2P()
+{
+}
+
+void DESC_P2P::Destroy()
+{
+	if (m_sock == INVALID_SOCKET)
+		return;
+
+	P2P_MANAGER::instance().UnregisterAcceptor(this);
+
+	fdwatch_del_fd(m_lpFdw, m_sock);
+
+	sys_log(0, "SYSTEM: closing p2p socket. DESC #%d", m_sock);
+
+	socket_close(m_sock);
+	m_sock = INVALID_SOCKET;
+
+	// Chain up to base class Destroy()
+	DESC::Destroy();
+}
+
+bool DESC_P2P::Setup(LPFDWATCH fdw, socket_t fd, const char* host, WORD wPort)
+{
+	m_lpFdw = fdw;
+	m_stHost = host;
+	m_wPort = wPort;
+	m_sock = fd;
+
+	if (!(m_lpOutputBuffer = buffer_new(1024 * 1024)))
+		return false;
+
+	if (!(m_lpInputBuffer = buffer_new(1024 * 1024)))
+		return false;
+
+	fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_READ, false);
+
+	m_iMinInputBufferLen = 1024 * 1024;
+
+#if !defined(__ALLOW_EXTERNAL_PEER__)
+	// Hardening: do not rely on firewall. Only allow loopback or RFC1918 peers.
+	// If you run multi-host cores over public WAN, define __ALLOW_EXTERNAL_PEER__ and protect via firewall/VPN.
+	{
+		const in_addr_t dwAddr = inet_addr(host);
+		bool bAllowed = false;
+		if (dwAddr != INADDR_NONE)
+		{
+			const uint32_t ip = ntohl(dwAddr);
+			// 127.0.0.0/8
+			if ((ip >> 24) == 127)
+				bAllowed = true;
+			// 10.0.0.0/8
+			else if ((ip >> 24) == 10)
+				bAllowed = true;
+			// 172.16.0.0/12
+			else if ((ip >> 20) == 0xAC1)
+				bAllowed = true;
+			// 192.168.0.0/16
+			else if ((ip >> 16) == 0xC0A8)
+				bAllowed = true;
+		}
+
+		if (!bAllowed)
+		{
+			sys_log(0, "SYSTEM: new p2p connection from [%s] fd: %d BLOCKED (non-local peer)", host, m_sock);
+			SetPhase(PHASE_CLOSE);
+			return true;
+		}
+	}
+#endif
+
+	SetPhase(PHASE_P2P);
+
+	sys_log(0, "SYSTEM: new p2p connection from [%s] fd: %d", host, m_sock);
+	return true;
+}
+
+void DESC_P2P::SetPhase(int iPhase)
+{
+	static CInputP2P s_inputP2P;
+
+	switch (iPhase)
+	{
+	case PHASE_P2P:
+		sys_log(1, "PHASE_P2P");
+
+		if (m_lpInputBuffer)
+			buffer_reset(m_lpInputBuffer);
+
+		if (m_lpOutputBuffer)
+			buffer_reset(m_lpOutputBuffer);
+
+		m_pInputProcessor = &s_inputP2P;
+		break;
+
+	case PHASE_CLOSE:
+		m_pInputProcessor = NULL;
+		break;
+
+	default:
+		sys_err("DESC_P2P::SetPhase : Unknown phase");
+		break;
+	}
+
+	m_iPhase = iPhase;
+}
diff --git a/server/metin2/Source/Server/game/src/growth_pet.cpp b/server/metin2/Source/Server/game/src/growth_pet.cpp
index 6cdd5f8..5d122e7 100644
--- a/server/metin2/Source/Server/game/src/growth_pet.cpp
+++ b/server/metin2/Source/Server/game/src/growth_pet.cpp
@@ -2613,15 +2613,7 @@ bool CGrowthPetManager::InitializeSkill(TGrowthPetSkillTable* pTab, int iSize)
 			continue;
 		}
 
-		if (!pProto->kActivatePctPoly.Analyze(pTab->szActivatePctPoly))
-		{
-			sys_err("syntax error skill: %s szActivatePctPoly: %s", pTab->szName, pTab->szActivatePctPoly);
-			bError = true;
-			M2_DELETE(pProto);
-			continue;
-		}
-
-		if (!pProto->kDurationPoly.Analyze(pTab->szDurationPoly))
+				if (!pProto->kDurationPoly.Analyze(pTab->szDurationPoly))
 		{
 			sys_err("syntax error skill: %s szDurationPoly: %s", pTab->szName, pTab->szDurationPoly);
 			bError = true;
@@ -2648,9 +2640,14 @@ bool CGrowthPetManager::InitializeSkill(TGrowthPetSkillTable* pTab, int iSize)
 		// Insert loaded skills
 		for (const auto& pSkill : skillVec)
 			m_growthPetSkillMap[pSkill->dwPetVnum][pSkill->dwSkillVnum] = pSkill;
+
+		return true;
 	}
 
-	return !bError;
+	// On error, prevent leaking partially built protos.
+	for (auto* p : skillVec)
+		M2_DELETE(p);
+	return false;
 }
 
 CPetSkillProto* CGrowthPetManager::GetGrowthPetSkill(DWORD dwPetVnum, DWORD dwSkillVnum)
@@ -2665,4 +2662,4 @@ CPetSkillProto* CGrowthPetManager::GetGrowthPetSkill(DWORD dwPetVnum, DWORD dwSk
 		return nullptr;
 
 	return skillIterator->second;
-}
\ No newline at end of file
+}
diff --git a/server/metin2/Source/Server/game/src/guild.cpp b/server/metin2/Source/Server/game/src/guild.cpp
index 3c32221..c59bd10 100644
--- a/server/metin2/Source/Server/game/src/guild.cpp
+++ b/server/metin2/Source/Server/game/src/guild.cpp
@@ -1,2241 +1,2253 @@
-#include "stdafx.h"
-#include "utils.h"
-#include "config.h"
-#include "char.h"
-#include "packet.h"
-#include "desc_client.h"
-#include "buffer_manager.h"
-#include "char_manager.h"
-#include "db.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "affect.h"
-#include "p2p.h"
-#include "questmanager.h"
-#include "building.h"
-#include "locale_service.h"
-#include "log.h"
-#include "questmanager.h"
-
-SGuildMember::SGuildMember(LPCHARACTER ch, BYTE grade, DWORD offer_exp)
-	: pid(ch->GetPlayerID()), grade(grade), is_general(0), job(ch->GetJob()), level(ch->GetLevel()), offer_exp(offer_exp), name(ch->GetName())
-{}
-SGuildMember::SGuildMember(DWORD pid, BYTE grade, BYTE is_general, BYTE job, BYTE level, DWORD offer_exp, char* name)
-	: pid(pid), grade(grade), is_general(is_general), job(job), level(level), offer_exp(offer_exp), name(name)
-{}
-
-namespace
-{
-	struct FGuildNameSender
-	{
-		FGuildNameSender(DWORD id, const char* guild_name) : id(id), name(guild_name)
-		{
-			p.header = HEADER_GC_GUILD;
-			p.subheader = GUILD_SUBHEADER_GC_GUILD_NAME;
-			p.size = sizeof(p) + sizeof(DWORD) + GUILD_NAME_MAX_LEN;
-		}
-
-		void operator() (LPCHARACTER ch)
-		{
-			LPDESC d = ch->GetDesc();
-
-			if (d)
-			{
-				d->BufferedPacket(&p, sizeof(p));
-				d->BufferedPacket(&id, sizeof(id));
-				d->Packet(name, GUILD_NAME_MAX_LEN);
-			}
-		}
-
-		DWORD id;
-		const char* name;
-		TPacketGCGuild p;
-	};
-}
-
-CGuild::CGuild(TGuildCreateParameter& cp)
-{
-	Initialize();
-
-	m_general_count = 0;
-
-	m_iMemberCountBonus = 0;
-
-	strlcpy(m_data.name, cp.name, sizeof(m_data.name));
-	m_data.master_pid = cp.master->GetPlayerID();
-	strlcpy(m_data.grade_array[0].grade_name, LC_STRING("길드장"), sizeof(m_data.grade_array[0].grade_name));
-	m_data.grade_array[0].auth_flag = GUILD_AUTH_ADD_MEMBER | GUILD_AUTH_REMOVE_MEMBER | GUILD_AUTH_NOTICE | GUILD_AUTH_USE_SKILL;
-
-	for (int i = 1; i < GUILD_GRADE_COUNT; ++i)
-	{
-		strlcpy(m_data.grade_array[i].grade_name, LC_STRING("길드원"), sizeof(m_data.grade_array[i].grade_name));
-		m_data.grade_array[i].auth_flag = 0;
-	}
-
-	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery(
-		"INSERT INTO `guild%s` (`name`, `master`, `sp`, `level`, `exp`, `skill_point`, `skill`) "
-		"VALUES('%s', %u, 1000, 1, 0, 0, '\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0')",
-		get_table_postfix(), m_data.name, m_data.master_pid));
-
-	// TODO if error occur?
-	m_data.guild_id = pmsg->Get()->uiInsertID;
-
-	char grade_name[GUILD_GRADE_NAME_MAX_LEN * 2 + 1];
-
-	for (int i = 0; i < GUILD_GRADE_COUNT; ++i)
-	{
-		DBManager::instance().EscapeString(grade_name, sizeof(grade_name),
-			m_data.grade_array[i].grade_name, strlen(m_data.grade_array[i].grade_name));
-
-		DBManager::instance().Query("INSERT INTO `guild_grade%s` VALUES(%u, %d, '%s', %d)",
-			get_table_postfix(),
-			m_data.guild_id,
-			i + 1,
-			grade_name,
-			m_data.grade_array[i].auth_flag);
-	}
-
-	ComputeGuildPoints();
-	m_data.power = m_data.max_power;
-	m_data.ladder_point = 0;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_CREATE, 0, &m_data.guild_id, sizeof(DWORD));
-
-	TPacketGuildSkillUpdate guild_skill;
-	guild_skill.guild_id = m_data.guild_id;
-	guild_skill.amount = 0;
-	guild_skill.skill_point = 0;
-	memset(guild_skill.skill_levels, 0, GUILD_SKILL_COUNT);
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_SKILL_UPDATE, 0, &guild_skill, sizeof(guild_skill));
-
-	// TODO GUILD_NAME
-	CHARACTER_MANAGER::instance().for_each_pc(FGuildNameSender(GetID(), GetName()));
-	/*
-	TPacketDGGuildMember p;
-	memset(&p, 0, sizeof(p));
-	p.dwPID = cp.master->GetPlayerID();
-	p.bGrade = 15;
-	AddMember(&p);
-	*/
-	RequestAddMember(cp.master, GUILD_LEADER_GRADE);
-}
-
-void CGuild::Initialize()
-{
-	memset(&m_data, 0, sizeof(m_data));
-	m_data.level = 1;
-
-	for (int i = 0; i < GUILD_SKILL_COUNT; ++i)
-		abSkillUsable[i] = true;
-
-	m_iMemberCountBonus = 0;
-}
-
-CGuild::~CGuild()
-{
-}
-
-void CGuild::RequestAddMember(LPCHARACTER ch, int grade)
-{
-	if (ch->GetGuild())
-		return;
-
-	TPacketGDGuildAddMember gd;
-
-	if (m_member.find(ch->GetPlayerID()) != m_member.end())
-	{
-		sys_err("Already a member in guild %s[%d]", ch->GetName(), ch->GetPlayerID());
-		return;
-	}
-
-	gd.dwPID = ch->GetPlayerID();
-	gd.dwGuild = GetID();
-	gd.bGrade = grade;
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_ADD_MEMBER, 0, &gd, sizeof(TPacketGDGuildAddMember));
-}
-
-void CGuild::AddMember(TPacketDGGuildMember* p)
-{
-	TGuildMemberContainer::iterator it;
-
-	if ((it = m_member.find(p->dwPID)) == m_member.end())
-		m_member.insert(std::make_pair(p->dwPID, TGuildMember(p->dwPID, p->bGrade, p->isGeneral, p->bJob, p->bLevel, p->dwOffer, p->szName)));
-	else
-	{
-		TGuildMember& r_gm = it->second;
-		r_gm.pid = p->dwPID;
-		r_gm.grade = p->bGrade;
-		r_gm.job = p->bJob;
-		r_gm.offer_exp = p->dwOffer;
-		r_gm.is_general = p->isGeneral;
-	}
-
-	CGuildManager::instance().Link(p->dwPID, this);
-
-	SendListOneToAll(p->dwPID);
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(p->dwPID);
-
-	sys_log(0, "GUILD: AddMember PID %u, grade %u, job %u, level %u, offer %u, name %s ptr %p",
-		p->dwPID, p->bGrade, p->bJob, p->bLevel, p->dwOffer, p->szName, get_pointer(ch));
-
-	if (ch)
-		LoginMember(ch);
-	else
-		P2PLoginMember(p->dwPID);
-}
-
-bool CGuild::RequestRemoveMember(DWORD pid)
-{
-	TGuildMemberContainer::iterator it;
-
-	if ((it = m_member.find(pid)) == m_member.end())
-		return false;
-
-	if (it->second.grade == GUILD_LEADER_GRADE)
-		return false;
-
-	TPacketGuild gd_guild;
-
-	gd_guild.dwGuild = GetID();
-	gd_guild.dwInfo = pid;
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_REMOVE_MEMBER, 0, &gd_guild, sizeof(TPacketGuild));
-	return true;
-}
-
-bool CGuild::RemoveMember(DWORD pid)
-{
-	sys_log(0, "Receive Guild P2P RemoveMember");
-	TGuildMemberContainer::iterator it;
-
-	if ((it = m_member.find(pid)) == m_member.end())
-		return false;
-
-	if (it->second.grade == GUILD_LEADER_GRADE)
-		return false;
-
-	if (it->second.is_general)
-		m_general_count--;
-
-	m_member.erase(it);
-	SendOnlineRemoveOnePacket(pid);
-
-	CGuildManager::instance().Unlink(pid);
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-	if (ch)
-	{
-		//GuildRemoveAffect(ch);
-		m_memberOnline.erase(ch);
-		ch->SetGuild(NULL);
-	}
-
-	if (LC_IsBrazil() == true)
-	{
-		DBManager::instance().Query("REPLACE INTO guild_invite_limit VALUES(%d, %d)", GetID(), get_global_time());
-	}
-
-	return true;
-}
-
-void CGuild::P2PLoginMember(DWORD pid)
-{
-	if (m_member.find(pid) == m_member.end())
-	{
-		sys_err("GUILD [%d] is not a memeber of guild.", pid);
-		return;
-	}
-
-	m_memberP2POnline.insert(pid);
-
-	// Login event occur + Send List
-	TGuildMemberOnlineContainer::iterator it;
-
-	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-		SendLoginPacket(*it, pid);
-}
-
-void CGuild::LoginMember(LPCHARACTER ch)
-{
-	if (m_member.find(ch->GetPlayerID()) == m_member.end())
-	{
-		sys_err("GUILD %s[%d] is not a memeber of guild.", ch->GetName(), ch->GetPlayerID());
-		return;
-	}
-
-	ch->SetGuild(this);
-
-	// Login event occur + Send List
-	TGuildMemberOnlineContainer::iterator it;
-
-	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-		SendLoginPacket(*it, ch);
-
-	m_memberOnline.insert(ch);
-
-	SendAllGradePacket(ch);
-	SendGuildInfoPacket(ch);
-	SendListPacket(ch);
-	SendSkillInfoPacket(ch);
-	SendEnemyGuild(ch);
-
-	//GuildUpdateAffect(ch);
-}
-
-void CGuild::P2PLogoutMember(DWORD pid)
-{
-	if (m_member.find(pid) == m_member.end())
-	{
-		sys_err("GUILD [%d] is not a memeber of guild.", pid);
-		return;
-	}
-
-	m_memberP2POnline.erase(pid);
-
-	// Logout event occur
-	TGuildMemberOnlineContainer::iterator it;
-	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		SendLogoutPacket(*it, pid);
-	}
-}
-
-void CGuild::LogoutMember(LPCHARACTER ch)
-{
-	if (m_member.find(ch->GetPlayerID()) == m_member.end())
-	{
-		sys_err("GUILD %s[%d] is not a memeber of guild.", ch->GetName(), ch->GetPlayerID());
-		return;
-	}
-
-	//GuildRemoveAffect(ch);
-
-	//ch->SetGuild(NULL);
-	m_memberOnline.erase(ch);
-
-	// Logout event occur
-	TGuildMemberOnlineContainer::iterator it;
-	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		SendLogoutPacket(*it, ch);
-	}
-}
-
-void CGuild::SendOnlineRemoveOnePacket(DWORD pid)
-{
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 4;
-	pack.subheader = GUILD_SUBHEADER_GC_REMOVE;
-
-	TEMP_BUFFER buf;
-	buf.write(&pack, sizeof(pack));
-	buf.write(&pid, sizeof(pid));
-
-	TGuildMemberOnlineContainer::iterator it;
-
-	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-
-		if (d)
-			d->Packet(buf.read_peek(), buf.size());
-	}
-}
-
-void CGuild::SendAllGradePacket(LPCHARACTER ch)
-{
-	LPDESC d = ch->GetDesc();
-	if (!d)
-		return;
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 1 + GUILD_GRADE_COUNT * (sizeof(TGuildGrade) + 1);
-	pack.subheader = GUILD_SUBHEADER_GC_GRADE;
-
-	TEMP_BUFFER buf;
-
-	buf.write(&pack, sizeof(pack));
-	BYTE n = 15;
-	buf.write(&n, 1);
-
-	for (int i = 0; i < GUILD_GRADE_COUNT; i++)
-	{
-		BYTE j = i + 1;
-		buf.write(&j, 1);
-		buf.write(&m_data.grade_array[i], sizeof(TGuildGrade));
-	}
-
-	d->Packet(buf.read_peek(), buf.size());
-}
-
-void CGuild::SendListOneToAll(LPCHARACTER ch)
-{
-	SendListOneToAll(ch->GetPlayerID());
-}
-
-void CGuild::SendListOneToAll(DWORD pid)
-{
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(TPacketGCGuild);
-	pack.subheader = GUILD_SUBHEADER_GC_LIST;
-
-	pack.size += sizeof(TGuildMemberPacketData);
-
-	char c[CHARACTER_NAME_MAX_LEN + 1];
-	memset(c, 0, sizeof(c));
-
-	TGuildMemberContainer::iterator cit = m_member.find(pid);
-	if (cit == m_member.end())
-		return;
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-		if (!d)
-			continue;
-
-		TEMP_BUFFER buf;
-
-		buf.write(&pack, sizeof(pack));
-
-		cit->second._dummy = 1;
-
-		buf.write(&(cit->second), sizeof(DWORD) * 3 + 1);
-		buf.write(cit->second.name.c_str(), cit->second.name.length());
-		buf.write(c, CHARACTER_NAME_MAX_LEN + 1 - cit->second.name.length());
-		d->Packet(buf.read_peek(), buf.size());
-	}
-}
-
-void CGuild::SendListPacket(LPCHARACTER ch)
-{
-	/*
-	List Packet
-
-	Header
-	Count (byte)
-	[
-		...
-		name_flag 1 - 이름을 보내느냐 안보내느냐
-		name CHARACTER_NAME_MAX_LEN+1
-	] * Count
-	*/
-
-	LPDESC d;
-	if (!(d = ch->GetDesc()))
-		return;
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(TPacketGCGuild);
-	pack.subheader = GUILD_SUBHEADER_GC_LIST;
-
-	pack.size += sizeof(TGuildMemberPacketData) * m_member.size();
-
-	TEMP_BUFFER buf;
-
-	buf.write(&pack, sizeof(pack));
-
-	char c[CHARACTER_NAME_MAX_LEN + 1];
-
-	for (TGuildMemberContainer::iterator it = m_member.begin(); it != m_member.end(); ++it)
-	{
-		it->second._dummy = 1;
-
-		buf.write(&(it->second), sizeof(DWORD) * 3 + 1);
-
-		strlcpy(c, it->second.name.c_str(), MIN(sizeof(c), it->second.name.length() + 1));
-
-		buf.write(c, CHARACTER_NAME_MAX_LEN + 1);
-
-		if (test_server)
-			sys_log(0, "name %s job %d", it->second.name.c_str(), it->second.job);
-	}
-
-	d->Packet(buf.read_peek(), buf.size());
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		SendLoginPacket(ch, *it);
-	}
-
-	for (TGuildMemberP2POnlineContainer::iterator it = m_memberP2POnline.begin(); it != m_memberP2POnline.end(); ++it)
-	{
-		SendLoginPacket(ch, *it);
-	}
-
-}
-
-void CGuild::SendLoginPacket(LPCHARACTER ch, LPCHARACTER chLogin)
-{
-	SendLoginPacket(ch, chLogin->GetPlayerID());
-}
-
-void CGuild::SendLoginPacket(LPCHARACTER ch, DWORD pid)
-{
-	/*
-	Login Packet
-	header 4
-	pid 4
-	*/
-	if (!ch->GetDesc())
-		return;
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 4;
-	pack.subheader = GUILD_SUBHEADER_GC_LOGIN;
-
-	TEMP_BUFFER buf;
-
-	buf.write(&pack, sizeof(pack));
-
-	buf.write(&pid, 4);
-
-	ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-}
-
-void CGuild::SendLogoutPacket(LPCHARACTER ch, LPCHARACTER chLogout)
-{
-	SendLogoutPacket(ch, chLogout->GetPlayerID());
-}
-
-void CGuild::SendLogoutPacket(LPCHARACTER ch, DWORD pid)
-{
-	/*
-	Logout Packet
-	header 4
-	pid 4
-	*/
-	if (!ch->GetDesc())
-		return;
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 4;
-	pack.subheader = GUILD_SUBHEADER_GC_LOGOUT;
-
-	TEMP_BUFFER buf;
-
-	buf.write(&pack, sizeof(pack));
-	buf.write(&pid, 4);
-
-	ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-}
-
-void CGuild::LoadGuildMemberData(SQLMsg* pmsg)
-{
-	if (pmsg->Get()->uiNumRows == 0)
-		return;
-
-	m_general_count = 0;
-
-	m_member.clear();
-
-	for (uint i = 0; i < pmsg->Get()->uiNumRows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-
-		DWORD pid = strtoul(row[0], (char**)NULL, 10);
-		BYTE grade = (BYTE)strtoul(row[1], (char**)NULL, 10);
-		BYTE is_general = 0;
-
-		if (row[2] && *row[2] == '1')
-			is_general = 1;
-
-		DWORD offer = strtoul(row[3], (char**)NULL, 10);
-		BYTE level = (BYTE)strtoul(row[4], (char**)NULL, 10);
-		BYTE job = (BYTE)strtoul(row[5], (char**)NULL, 10);
-		char* name = row[6];
-
-		if (is_general)
-			m_general_count++;
-
-		m_member.insert(std::make_pair(pid, TGuildMember(pid, grade, is_general, job, level, offer, name)));
-		CGuildManager::instance().Link(pid, this);
-	}
-}
-
-void CGuild::LoadGuildGradeData(SQLMsg* pmsg)
-{
-	/*
-	// 15개 아닐 가능성 존재
-	if (pmsg->Get()->iNumRows != 15)
-	{
-		sys_err("Query failed: getting guild grade data. GuildID(%d)", GetID());
-		return;
-	}
-	*/
-	for (uint i = 0; i < pmsg->Get()->uiNumRows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-		BYTE grade = 0;
-		str_to_number(grade, row[0]);
-		char* name = row[1];
-		DWORD auth = strtoul(row[2], NULL, 10);
-
-		if (grade >= 1 && grade <= 15)
-		{
-			//sys_log(0, "GuildGradeLoad %s", name);
-			strlcpy(m_data.grade_array[grade - 1].grade_name, name, sizeof(m_data.grade_array[grade - 1].grade_name));
-			m_data.grade_array[grade - 1].auth_flag = auth;
-		}
-	}
-}
-void CGuild::LoadGuildData(SQLMsg* pmsg)
-{
-	if (pmsg->Get()->uiNumRows == 0)
-	{
-		sys_err("Query failed: getting guild data %s", pmsg->stQuery.c_str());
-		return;
-	}
-
-	MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-	m_data.master_pid = strtoul(row[0], (char**)NULL, 10);
-	m_data.level = (BYTE)strtoul(row[1], (char**)NULL, 10);
-	m_data.exp = strtoul(row[2], (char**)NULL, 10);
-	strlcpy(m_data.name, row[3], sizeof(m_data.name));
-
-	m_data.skill_point = (BYTE)strtoul(row[4], (char**)NULL, 10);
-	if (row[5])
-		thecore_memcpy(m_data.abySkill, row[5], sizeof(BYTE) * GUILD_SKILL_COUNT);
-	else
-		memset(m_data.abySkill, 0, sizeof(BYTE) * GUILD_SKILL_COUNT);
-
-	m_data.power = MAX(0, strtoul(row[6], (char**)NULL, 10));
-
-	str_to_number(m_data.ladder_point, row[7]);
-
-	if (m_data.ladder_point < 0)
-		m_data.ladder_point = 0;
-
-	str_to_number(m_data.win, row[8]);
-	str_to_number(m_data.draw, row[9]);
-	str_to_number(m_data.loss, row[10]);
-	str_to_number(m_data.gold, row[11]);
-
-	ComputeGuildPoints();
-}
-
-void CGuild::Load(DWORD guild_id)
-{
-	Initialize();
-
-	m_data.guild_id = guild_id;
-
-	DBManager::instance().FuncQuery(std::bind(&CGuild::LoadGuildData, this, std::placeholders::_1),
-		"SELECT master, level, exp, name, skill_point, skill, sp, ladder_point, win, draw, loss, gold"
-		" FROM guild%s WHERE id = %u", get_table_postfix(), m_data.guild_id);
-
-	sys_log(0, "GUILD: loading guild id %12s %u", m_data.name, guild_id);
-
-	DBManager::instance().FuncQuery(std::bind(&CGuild::LoadGuildGradeData, this, std::placeholders::_1),
-		"SELECT grade, name, auth+0 FROM guild_grade%s WHERE guild_id = %u", get_table_postfix(), m_data.guild_id);
-
-	DBManager::instance().FuncQuery(std::bind(&CGuild::LoadGuildMemberData, this, std::placeholders::_1),
-		"SELECT pid, grade, is_general, offer, level, job, name FROM guild_member%s, player%s WHERE guild_id = %u and pid = id", get_table_postfix(), get_table_postfix(), guild_id);
-}
-
-void CGuild::SaveLevel()
-{
-	DBManager::instance().Query("UPDATE guild%s SET level=%d, exp=%u, skill_point=%d WHERE id = %u", get_table_postfix(), m_data.level, m_data.exp, m_data.skill_point, m_data.guild_id);
-}
-
-void CGuild::SendDBSkillUpdate(int amount)
-{
-	TPacketGuildSkillUpdate guild_skill;
-	guild_skill.guild_id = m_data.guild_id;
-	guild_skill.amount = amount;
-	guild_skill.skill_point = m_data.skill_point;
-	thecore_memcpy(guild_skill.skill_levels, m_data.abySkill, sizeof(BYTE) * GUILD_SKILL_COUNT);
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_SKILL_UPDATE, 0, &guild_skill, sizeof(guild_skill));
-}
-
-void CGuild::SaveSkill()
-{
-	char text[GUILD_SKILL_COUNT * 2 + 1];
-
-	DBManager::instance().EscapeString(text, sizeof(text), (const char*)m_data.abySkill, sizeof(m_data.abySkill));
-	DBManager::instance().Query("UPDATE guild%s SET sp = %d, skill_point=%d, skill='%s' WHERE id = %u",
-		get_table_postfix(), m_data.power, m_data.skill_point, text, m_data.guild_id);
-}
-
-TGuildMember* CGuild::GetMember(DWORD pid)
-{
-	TGuildMemberContainer::iterator it = m_member.find(pid);
-	if (it == m_member.end())
-		return NULL;
-
-	return &it->second;
-}
-
-DWORD CGuild::GetMemberPID(const std::string& strName)
-{
-	for (TGuildMemberContainer::iterator iter = m_member.begin(); iter != m_member.end(); iter++)
-	{
-		if (iter->second.name == strName) return iter->first;
-	}
-
-	return 0;
-}
-
-#if defined(__GUILD_LEADER_GRADE_NAME__)
-BYTE CGuild::GetGeneralPID(DWORD pid)
-{
-	for (TGuildMemberContainer::iterator iter = m_member.begin(); iter != m_member.end(); iter++)
-	{
-		if (iter->first == pid)
-			return iter->second.is_general;
-	}
-
-	return 0;
-}
-#endif
-
-void CGuild::__P2PUpdateGrade(SQLMsg* pmsg)
-{
-	if (pmsg->Get()->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-
-		int grade = 0;
-		const char* name = row[1];
-		int auth = 0;
-
-		str_to_number(grade, row[0]);
-		str_to_number(auth, row[2]);
-
-		if (grade <= 0)
-			return;
-
-		grade--;
-
-		// 등급 명칭이 현재와 다르다면 업데이트
-		if (0 != strcmp(m_data.grade_array[grade].grade_name, name))
-		{
-			strlcpy(m_data.grade_array[grade].grade_name, name, sizeof(m_data.grade_array[grade].grade_name));
-
-			TPacketGCGuild pack;
-
-			pack.header = HEADER_GC_GUILD;
-			pack.size = sizeof(pack);
-			pack.subheader = GUILD_SUBHEADER_GC_GRADE_NAME;
-
-			TOneGradeNamePacket pack2;
-
-			pack.size += sizeof(pack2);
-			pack2.grade = grade + 1;
-			strlcpy(pack2.grade_name, name, sizeof(pack2.grade_name));
-
-			TEMP_BUFFER buf;
-
-			buf.write(&pack, sizeof(pack));
-			buf.write(&pack2, sizeof(pack2));
-
-			for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-			{
-				LPDESC d = (*it)->GetDesc();
-
-				if (d)
-					d->Packet(buf.read_peek(), buf.size());
-			}
-		}
-
-		if (m_data.grade_array[grade].auth_flag != auth)
-		{
-			m_data.grade_array[grade].auth_flag = auth;
-
-			TPacketGCGuild pack;
-			pack.header = HEADER_GC_GUILD;
-			pack.size = sizeof(pack);
-			pack.subheader = GUILD_SUBHEADER_GC_GRADE_AUTH;
-
-			TOneGradeAuthPacket pack2;
-			pack.size += sizeof(pack2);
-			pack2.grade = grade + 1;
-			pack2.auth = auth;
-
-			TEMP_BUFFER buf;
-			buf.write(&pack, sizeof(pack));
-			buf.write(&pack2, sizeof(pack2));
-
-			for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-			{
-				LPDESC d = (*it)->GetDesc();
-				if (d)
-				{
-					d->Packet(buf.read_peek(), buf.size());
-				}
-			}
-		}
-	}
-}
-
-void CGuild::P2PChangeGrade(BYTE grade)
-{
-	DBManager::instance().FuncQuery(std::bind(&CGuild::__P2PUpdateGrade, this, std::placeholders::_1),
-		"SELECT grade, name, auth+0 FROM guild_grade%s WHERE guild_id = %u and grade = %d", get_table_postfix(), m_data.guild_id, grade);
-}
-
-namespace
-{
-	struct FSendChangeGrade
-	{
-		BYTE grade;
-		TPacketGuild p;
-
-		FSendChangeGrade(DWORD guild_id, BYTE grade) : grade(grade)
-		{
-			p.dwGuild = guild_id;
-			p.dwInfo = grade;
-		}
-
-		void operator()()
-		{
-			db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_GRADE, 0, &p, sizeof(p));
-		}
-	};
-}
-
-void SendChangeGrade(DWORD guild_id, BYTE grade)
-{
-	TPacketGuild p;
-	p.dwGuild = guild_id;
-	p.dwInfo = grade;
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_GRADE, 0, &p, sizeof(p));
-}
-
-void CGuild::ChangeGradeName(BYTE grade, const char* grade_name)
-{
-	if (grade == 1)
-		return;
-
-	if (grade < 1 || grade > 15)
-	{
-		sys_err("Wrong guild grade value %d", grade);
-		return;
-	}
-
-	if (strlen(grade_name) > GUILD_NAME_MAX_LEN)
-		return;
-
-	if (!*grade_name)
-		return;
-
-	char text[GUILD_NAME_MAX_LEN * 2 + 1];
-
-	DBManager::instance().EscapeString(text, sizeof(text), grade_name, strlen(grade_name));
-	DBManager::instance().FuncAfterQuery(std::bind(&SendChangeGrade, GetID(), grade), "UPDATE guild_grade%s SET name = '%s' where guild_id = %u and grade = %d", get_table_postfix(), text, m_data.guild_id, grade);
-
-	grade--;
-	strlcpy(m_data.grade_array[grade].grade_name, grade_name, sizeof(m_data.grade_array[grade].grade_name));
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack);
-	pack.subheader = GUILD_SUBHEADER_GC_GRADE_NAME;
-
-	TOneGradeNamePacket pack2;
-	pack.size += sizeof(pack2);
-	pack2.grade = grade + 1;
-	strlcpy(pack2.grade_name, grade_name, sizeof(pack2.grade_name));
-
-	TEMP_BUFFER buf;
-	buf.write(&pack, sizeof(pack));
-	buf.write(&pack2, sizeof(pack2));
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-
-		if (d)
-			d->Packet(buf.read_peek(), buf.size());
-	}
-}
-
-void CGuild::ChangeGradeAuth(BYTE grade, BYTE auth)
-{
-	if (grade == 1)
-		return;
-
-	if (grade < 1 || grade > 15)
-	{
-		sys_err("Wrong guild grade value %d", grade);
-		return;
-	}
-
-	DBManager::instance().FuncAfterQuery(std::bind(&SendChangeGrade, GetID(), grade), "UPDATE guild_grade%s SET auth = %d where guild_id = %u and grade = %d", get_table_postfix(), auth, m_data.guild_id, grade);
-
-	grade--;
-
-	m_data.grade_array[grade].auth_flag = auth;
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack);
-	pack.subheader = GUILD_SUBHEADER_GC_GRADE_AUTH;
-
-	TOneGradeAuthPacket pack2;
-	pack.size += sizeof(pack2);
-	pack2.grade = grade + 1;
-	pack2.auth = auth;
-
-	TEMP_BUFFER buf;
-	buf.write(&pack, sizeof(pack));
-	buf.write(&pack2, sizeof(pack2));
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-
-		if (d)
-			d->Packet(buf.read_peek(), buf.size());
-	}
-}
-
-void CGuild::SendGuildInfoPacket(LPCHARACTER ch)
-{
-	LPDESC d = ch->GetDesc();
-
-	if (!d)
-		return;
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(TPacketGCGuild) + sizeof(TPacketGCGuildInfo);
-	pack.subheader = GUILD_SUBHEADER_GC_INFO;
-
-	TPacketGCGuildInfo pack_sub;
-
-	memset(&pack_sub, 0, sizeof(TPacketGCGuildInfo));
-	pack_sub.member_count = GetMemberCount();
-	pack_sub.max_member_count = GetMaxMemberCount();
-	pack_sub.guild_id = m_data.guild_id;
-	pack_sub.master_pid = m_data.master_pid;
-	pack_sub.exp = m_data.exp;
-	pack_sub.level = m_data.level;
-	strlcpy(pack_sub.name, m_data.name, sizeof(pack_sub.name));
-	pack_sub.gold = m_data.gold;
-	pack_sub.has_land = HasLand();
-
-	sys_log(0, "GMC guild_name %s", m_data.name);
-	sys_log(0, "GMC master %d", m_data.master_pid);
-
-	d->BufferedPacket(&pack, sizeof(TPacketGCGuild));
-	d->Packet(&pack_sub, sizeof(TPacketGCGuildInfo));
-}
-
-bool CGuild::OfferExp(LPCHARACTER ch, int amount)
-{
-	TGuildMemberContainer::iterator cit = m_member.find(ch->GetPlayerID());
-
-	if (cit == m_member.end())
-		return false;
-
-	if (m_data.exp + amount < m_data.exp)
-		return false;
-
-	if (amount < 0)
-		return false;
-
-	if (ch->GetExp() < (DWORD)amount)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 제공하고자 하는 경험치가 남은 경험치보다 많습니다."));
-		return false;
-	}
-
-	if (ch->GetExp() - (DWORD)amount > ch->GetExp())
-	{
-		sys_err("Wrong guild offer amount %d by %s[%u]", amount, ch->GetName(), ch->GetPlayerID());
-		return false;
-	}
-
-	ch->PointChange(POINT_EXP, -amount);
-
-	TPacketGuildExpUpdate guild_exp;
-	guild_exp.guild_id = GetID();
-	guild_exp.amount = amount / 100;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_EXP_UPDATE, 0, &guild_exp, sizeof(guild_exp));
-	GuildPointChange(POINT_EXP, amount / 100, true);
-
-	cit->second.offer_exp += amount / 100;
-	cit->second._dummy = 0;
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-		if (d)
-		{
-			pack.subheader = GUILD_SUBHEADER_GC_LIST;
-			pack.size = sizeof(pack) + 13;
-			d->BufferedPacket(&pack, sizeof(pack));
-			d->Packet(&(cit->second), sizeof(DWORD) * 3 + 1);
-		}
-	}
-
-	SaveMember(ch->GetPlayerID());
-
-	TPacketGuildChangeMemberData gd_guild;
-
-	gd_guild.guild_id = GetID();
-	gd_guild.pid = ch->GetPlayerID();
-	gd_guild.offer = cit->second.offer_exp;
-	gd_guild.level = ch->GetLevel();
-	gd_guild.grade = cit->second.grade;
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_MEMBER_DATA, 0, &gd_guild, sizeof(gd_guild));
-	return true;
-}
-
-void CGuild::Disband()
-{
-	sys_log(0, "GUILD: Disband %s:%u", GetName(), GetID());
-
-	// building::CLand* pLand = building::CManager::instance().FindLandByGuild(GetID());
-	// if (pLand)
-		// pLand->SetOwner(0);
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPCHARACTER ch = *it;
-		ch->SetGuild(NULL);
-		SendOnlineRemoveOnePacket(ch->GetPlayerID());
-		ch->SetQuestFlag("guild_manage.new_disband_time", get_global_time());
-	}
-
-	for (TGuildMemberContainer::iterator it = m_member.begin(); it != m_member.end(); ++it)
-	{
-		CGuildManager::instance().Unlink(it->first);
-	}
-
-}
-
-void CGuild::RequestDisband(DWORD pid)
-{
-	if (m_data.master_pid != pid)
-		return;
-
-	TPacketGuild gd_guild;
-	gd_guild.dwGuild = GetID();
-	gd_guild.dwInfo = 0;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_DISBAND, 0, &gd_guild, sizeof(TPacketGuild));
-
-	// LAND_CLEAR
-	building::CManager::instance().ClearLandByGuildID(GetID());
-	// END_LAND_CLEAR
-}
-
-void CGuild::AddComment(LPCHARACTER ch, const std::string& str)
-{
-	if (str.length() == 0)
-		return;
-
-	if (str.length() > GUILD_COMMENT_MAX_LEN)
-	{
-		sys_err("POST_COMMENT: %s comment too long (length: %u)", ch->GetName(), str.length());
-		return;
-	}
-
-	if (m_guildPostCommentPulse > thecore_pulse() && !ch->IsGM())
-	{
-		int iDeltaSecs = ((m_guildPostCommentPulse / PASSES_PER_SEC(1)) - (thecore_pulse() / PASSES_PER_SEC(1)));
-		int iMin = iDeltaSecs / 60;
-		int iSec = (iDeltaSecs - (iMin * 60));
-
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can post a new comment in %02d minutes and %02d seconds!", iMin, iSec));
-		return;
-	}
-
-	char text[GUILD_COMMENT_MAX_LEN * 2 + 1];
-	DBManager::instance().EscapeString(text, sizeof(text), str.c_str(), str.length());
-
-	DBManager::instance().FuncAfterQuery(std::bind(&CGuild::RefreshCommentForce, this, ch->GetPlayerID()),
-		"INSERT INTO guild_comment%s(guild_id, name, notice, content, time) VALUES(%u, '%s', %d, '%s', NOW())",
-		get_table_postfix(), m_data.guild_id, ch->GetName(), (str[0] == '!') ? 1 : 0, text);
-
-	m_guildPostCommentPulse = thecore_pulse() + PASSES_PER_SEC(10 * 60);
-}
-
-void CGuild::DeleteComment(LPCHARACTER ch, DWORD comment_id)
-{
-	SQLMsg* pmsg;
-
-	if (GetMember(ch->GetPlayerID())->grade == GUILD_LEADER_GRADE)
-		pmsg = DBManager::instance().DirectQuery("DELETE FROM guild_comment%s WHERE id = %u AND guild_id = %u", get_table_postfix(), comment_id, m_data.guild_id);
-	else
-		pmsg = DBManager::instance().DirectQuery("DELETE FROM guild_comment%s WHERE id = %u AND guild_id = %u AND name = '%s'", get_table_postfix(), comment_id, m_data.guild_id, ch->GetName());
-
-	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 삭제할 수 없는 글입니다."));
-	else
-		RefreshCommentForce(ch->GetPlayerID());
-
-	M2_DELETE(pmsg);
-}
-
-void CGuild::RefreshComment(LPCHARACTER ch)
-{
-	RefreshCommentForce(ch->GetPlayerID());
-}
-
-void CGuild::RefreshCommentForce(DWORD player_id)
-{
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(player_id);
-	if (ch == NULL)
-		return;
-
-	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery("SELECT id, name, content FROM guild_comment%s WHERE guild_id = %u ORDER BY notice DESC, id DESC LIMIT %d", get_table_postfix(), m_data.guild_id, GUILD_COMMENT_MAX_COUNT));
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 1;
-	pack.subheader = GUILD_SUBHEADER_GC_COMMENTS;
-
-	BYTE count = pmsg->Get()->uiNumRows;
-
-	LPDESC d = ch->GetDesc();
-
-	if (!d)
-		return;
-
-	pack.size += (sizeof(DWORD) + CHARACTER_NAME_MAX_LEN + 1 + GUILD_COMMENT_MAX_LEN + 1) * (WORD)count;
-	d->BufferedPacket(&pack, sizeof(pack));
-	d->BufferedPacket(&count, 1);
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	char szContent[GUILD_COMMENT_MAX_LEN + 1];
-	memset(szName, 0, sizeof(szName));
-	memset(szContent, 0, sizeof(szContent));
-
-	for (uint i = 0; i < pmsg->Get()->uiNumRows; i++)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-		DWORD id = strtoul(row[0], NULL, 10);
-
-		strlcpy(szName, row[1], sizeof(szName));
-		strlcpy(szContent, row[2], sizeof(szContent));
-
-		d->BufferedPacket(&id, sizeof(id));
-		d->BufferedPacket(szName, sizeof(szName));
-
-		if (i == pmsg->Get()->uiNumRows - 1)
-			d->Packet(szContent, sizeof(szContent)); // 마지막 줄이면 보내기
-		else
-			d->BufferedPacket(szContent, sizeof(szContent));
-	}
-}
-
-bool CGuild::ChangeMemberGeneral(DWORD pid, BYTE is_general)
-{
-#if !defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (is_general && GetGeneralCount() >= GetMaxGeneralCount())
-		return false;
-#endif
-
-	TGuildMemberContainer::iterator it = m_member.find(pid);
-	if (it == m_member.end())
-		return true;
-
-	is_general = is_general ? 1 : 0;
-
-	if (it->second.is_general == is_general)
-		return true;
-
-	if (is_general)
-		++m_general_count;
-	else
-		--m_general_count;
-
-	it->second.is_general = is_general;
-
-	TGuildMemberOnlineContainer::iterator itOnline = m_memberOnline.begin();
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 5;
-	pack.subheader = GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL;
-
-	while (itOnline != m_memberOnline.end())
-	{
-		LPDESC d = (*(itOnline++))->GetDesc();
-
-		if (!d)
-			continue;
-
-		d->BufferedPacket(&pack, sizeof(pack));
-		d->BufferedPacket(&pid, sizeof(pid));
-		d->Packet(&is_general, sizeof(is_general));
-	}
-
-	SaveMember(pid);
-	return true;
-}
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-BYTE CGuild::IsGeneralMember(DWORD pid)
-{
-	TGuildMemberContainer::iterator it = m_member.begin();
-	for (; it != m_member.end(); ++it)
-	{
-		if (it->first == pid)
-			return it->second.is_general;
-	}
-	return 0;
-}
-#endif
-
-void CGuild::ChangeMemberGrade(DWORD pid, BYTE grade)
-{
-	if (grade == 1)
-		return;
-
-	TGuildMemberContainer::iterator it = m_member.find(pid);
-
-	if (it == m_member.end())
-		return;
-
-	it->second.grade = grade;
-
-	TGuildMemberOnlineContainer::iterator itOnline = m_memberOnline.begin();
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 5;
-	pack.subheader = GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE;
-
-	while (itOnline != m_memberOnline.end())
-	{
-		LPDESC d = (*(itOnline++))->GetDesc();
-
-		if (!d)
-			continue;
-
-		d->BufferedPacket(&pack, sizeof(pack));
-		d->BufferedPacket(&pid, sizeof(pid));
-		d->Packet(&grade, sizeof(grade));
-	}
-
-	SaveMember(pid);
-
-	TPacketGuildChangeMemberData gd_guild;
-
-	gd_guild.guild_id = GetID();
-	gd_guild.pid = pid;
-	gd_guild.offer = it->second.offer_exp;
-	gd_guild.level = it->second.level;
-	gd_guild.grade = grade;
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_MEMBER_DATA, 0, &gd_guild, sizeof(gd_guild));
-}
-
-void CGuild::SkillLevelUp(DWORD dwVnum)
-{
-	DWORD dwRealVnum = dwVnum - GUILD_SKILL_START;
-
-	if (dwRealVnum >= GUILD_SKILL_COUNT)
-		return;
-
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-
-	if (!pkSk)
-	{
-		sys_err("There is no such guild skill by number %u", dwVnum);
-		return;
-	}
-
-	if (m_data.abySkill[dwRealVnum] >= pkSk->bMaxLevel)
-		return;
-
-	if (m_data.skill_point <= 0)
-		return;
-	m_data.skill_point--;
-
-	m_data.abySkill[dwRealVnum] ++;
-
-	ComputeGuildPoints();
-	SaveSkill();
-	SendDBSkillUpdate();
-
-	/*
-	switch (dwVnum)
-	{
-	case GUILD_SKILL_GAHO:
-	{
-		TGuildMemberOnlineContainer::iterator it;
-
-		for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-			(*it)->PointChange(POINT_DEF_GRADE, 1);
-	}
-	break;
-	case GUILD_SKILL_HIM:
-	{
-		TGuildMemberOnlineContainer::iterator it;
-
-		for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-			(*it)->PointChange(POINT_ATT_GRADE, 1);
-	}
-	break;
-	}
-	*/
-
-	std::for_each(m_memberOnline.begin(), m_memberOnline.end(), std::bind(&CGuild::SendSkillInfoPacket, this, std::placeholders::_1));
-
-	sys_log(0, "Guild SkillUp: %s %d level %d type %u", GetName(), pkSk->dwVnum, m_data.abySkill[dwRealVnum], pkSk->dwType);
-}
-
-void CGuild::UseSkill(DWORD dwVnum, LPCHARACTER ch, DWORD pid)
-{
-	LPCHARACTER victim = NULL;
-
-	if (!GetMember(ch->GetPlayerID()) || !HasGradeAuth(GetMember(ch->GetPlayerID())->grade, GUILD_AUTH_USE_SKILL))
-		return;
-
-	sys_log(0, "GUILD_USE_SKILL : cname(%s), skill(%d)", ch ? ch->GetName() : "", dwVnum);
-
-	DWORD dwRealVnum = dwVnum - GUILD_SKILL_START;
-
-	if (ch && !ch->CanMove())
-		return;
-
-	if (dwRealVnum >= GUILD_SKILL_COUNT)
-		return;
-
-	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
-
-	if (!pkSk)
-	{
-		sys_err("There is no such guild skill by number %u", dwVnum);
-		return;
-	}
-
-	if (m_data.abySkill[dwRealVnum] == 0)
-		return;
-
-	if ((pkSk->dwFlag & SKILL_FLAG_SELFONLY))
-	{
-		// 이미 걸려 있으므로 사용하지 않음.
-		if (ch && ch->FindAffect(pkSk->dwVnum))
-			return;
-
-		victim = ch;
-	}
-
-	if ((pkSk->dwFlag & SKILL_FLAG_PARTY))
-	{
-		if (ch && ch->FindAffect(pkSk->dwVnum))
-			return;
-
-		victim = ch;
-	}
-
-	if (ch && ch->IsAffectFlag(AFF_REVIVE_INVISIBLE))
-		ch->RemoveAffect(AFFECT_REVIVE_INVISIBLE);
-
-	if (ch && ch->IsAffectFlag(AFF_EUNHYUNG))
-		ch->RemoveAffect(SKILL_EUNHYUNG);
-
-	double k = 1.0 * m_data.abySkill[dwRealVnum] / pkSk->bMaxLevel;
-	pkSk->kSPCostPoly.SetVar("k", k);
-	int iNeededSP = (int)pkSk->kSPCostPoly.Eval();
-
-	if (GetSP() < iNeededSP)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 용신력이 부족합니다. (%d, %d)", GetSP(), iNeededSP));
-		return;
-	}
-
-	pkSk->kCooldownPoly.SetVar("k", k);
-	int iCooltime = (int)pkSk->kCooldownPoly.Eval();
-
-	if (!abSkillUsable[dwRealVnum])
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 쿨타임이 끝나지 않아 길드 스킬을 사용할 수 없습니다."));
-		return;
-	}
-
-	{
-		TPacketGuildUseSkill p;
-		p.dwGuild = GetID();
-		p.dwSkillVnum = pkSk->dwVnum;
-		p.dwCooltime = iCooltime;
-		db_clientdesc->DBPacket(HEADER_GD_GUILD_USE_SKILL, 0, &p, sizeof(p));
-	}
-	abSkillUsable[dwRealVnum] = false;
-	//abSkillUsed[dwRealVnum] = true;
-	//adwSkillNextUseTime[dwRealVnum] = get_dword_time() + iCooltime * 1000;
-
-	//PointChange(POINT_SP, -iNeededSP);
-	//GuildPointChange(POINT_SP, -iNeededSP);
-
-	if (test_server)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> %d 스킬을 사용함 (%d, %d) to %lu", dwVnum, GetSP(), iNeededSP, pid));
-
-	switch (dwVnum)
-	{
-	case GUILD_SKILL_TELEPORT:
-		// 현재 서버에 있는 사람을 먼저 시도.
-		SendDBSkillUpdate(-iNeededSP);
-		if ((victim = (CHARACTER_MANAGER::instance().FindByPID(pid))))
-			ch->WarpSet(victim->GetX(), victim->GetY());
-		else
-		{
-			if (m_memberP2POnline.find(pid) != m_memberP2POnline.end())
-			{
-				// 다른 서버에 로그인된 사람이 있음 -> 메시지 보내 좌표를 받아오자
-				// 1. A.pid, B.pid 를 뿌림
-				// 2. B.pid를 가진 서버가 뿌린서버에게 A.pid, 좌표 를 보냄
-				// 3. 워프
-				CCI* pcci = P2P_MANAGER::instance().FindByPID(pid);
-
-				if (pcci->bChannel != g_bChannel)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 상대가 %d 채널에 있습니다. (현재 채널 %d)", pcci->bChannel, g_bChannel));
-				}
-				else
-				{
-					TPacketGGFindPosition p;
-					p.header = HEADER_GG_FIND_POSITION;
-					p.dwFromPID = ch ? ch->GetPlayerID() : 0;
-					p.dwTargetPID = pid;
-					pcci->pkDesc->Packet(&p, sizeof(TPacketGGFindPosition));
-					if (test_server) ch->ChatPacket(CHAT_TYPE_PARTY, "sent find position packet for guild teleport");
-				}
-			}
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 상대가 온라인 상태가 아닙니다."));
-		}
-		break;
-
-	/*
-	case GUILD_SKILL_ACCEL:
-		ch->RemoveAffect(dwVnum);
-		ch->AddAffect(dwVnum, POINT_MOV_SPEED, m_data.abySkill[dwRealVnum] * 3, pkSk->dwAffectFlag, (int)pkSk->kDurationPoly.Eval(), 0, false);
-		ch->AddAffect(dwVnum, POINT_ATT_SPEED, m_data.abySkill[dwRealVnum] * 3, pkSk->dwAffectFlag, (int)pkSk->kDurationPoly.Eval(), 0, false);
-		break;
-	*/
-
-	default:
-	{
-		/*
-		if (ch->GetPlayerID() != GetMasterPID())
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드장만 길드 스킬을 사용할 수 있습니다."));
-			return;
-		}
-		*/
-
-		if (!UnderAnyWar())
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드 스킬은 길드전 중에만 사용할 수 있습니다."));
-			return;
-		}
-
-		SendDBSkillUpdate(-iNeededSP);
-
-		for (auto it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-		{
-			LPCHARACTER victim = *it;
-			victim->RemoveAffect(dwVnum);
-			ch->ComputeSkill(dwVnum, victim, m_data.abySkill[dwRealVnum]);
-		}
-	}
-	break;
-
-	/*
-	if (!victim)
-		return;
-
-	ch->ComputeSkill(dwVnum, victim, m_data.abySkill[dwRealVnum]);
-	*/
-
-	}
-}
-
-void CGuild::SendSkillInfoPacket(LPCHARACTER ch) const
-{
-	LPDESC d = ch->GetDesc();
-
-	if (!d)
-		return;
-
-	TPacketGCGuild pack;
-
-	pack.header = HEADER_GC_GUILD;
-	pack.size = sizeof(pack) + 6 + GUILD_SKILL_COUNT;
-	pack.subheader = GUILD_SUBHEADER_GC_SKILL_INFO;
-
-	d->BufferedPacket(&pack, sizeof(pack));
-	d->BufferedPacket(&m_data.skill_point, 1);
-	d->BufferedPacket(&m_data.abySkill, GUILD_SKILL_COUNT);
-	d->BufferedPacket(&m_data.power, 2);
-	d->Packet(&m_data.max_power, 2);
-}
-
-void CGuild::ComputeGuildPoints()
-{
-	m_data.max_power = GUILD_BASE_POWER + (m_data.level - 1) * GUILD_POWER_PER_LEVEL;
-
-	m_data.power = MINMAX(0, m_data.power, m_data.max_power);
-}
-
-int CGuild::GetSkillLevel(DWORD vnum)
-{
-	DWORD dwRealVnum = vnum - GUILD_SKILL_START;
-
-	if (dwRealVnum >= GUILD_SKILL_COUNT)
-		return 0;
-
-	return m_data.abySkill[dwRealVnum];
-}
-
-/*
-void CGuild::GuildUpdateAffect(LPCHARACTER ch)
-{
-	if (GetSkillLevel(GUILD_SKILL_GAHO))
-		ch->PointChange(POINT_DEF_GRADE, GetSkillLevel(GUILD_SKILL_GAHO));
-
-	if (GetSkillLevel(GUILD_SKILL_HIM))
-		ch->PointChange(POINT_ATT_GRADE, GetSkillLevel(GUILD_SKILL_HIM));
-}
-*/
-
-/*
-void CGuild::GuildRemoveAffect(LPCHARACTER ch)
-{
-	if (GetSkillLevel(GUILD_SKILL_GAHO))
-		ch->PointChange(POINT_DEF_GRADE, -(int)GetSkillLevel(GUILD_SKILL_GAHO));
-
-	if (GetSkillLevel(GUILD_SKILL_HIM))
-		ch->PointChange(POINT_ATT_GRADE, -(int)GetSkillLevel(GUILD_SKILL_HIM));
-}
-*/
-
-void CGuild::UpdateSkill(BYTE skill_point, BYTE* skill_levels)
-{
-	//int iDefMoreBonus = 0;
-	//int iAttMoreBonus = 0;
-
-	m_data.skill_point = skill_point;
-	/*
-	if (skill_levels[GUILD_SKILL_GAHO - GUILD_SKILL_START] != GetSkillLevel(GUILD_SKILL_GAHO))
-	{
-		iDefMoreBonus = skill_levels[GUILD_SKILL_GAHO - GUILD_SKILL_START] - GetSkillLevel(GUILD_SKILL_GAHO);
-	}
-	if (skill_levels[GUILD_SKILL_HIM - GUILD_SKILL_START] != GetSkillLevel(GUILD_SKILL_HIM))
-	{
-		iAttMoreBonus = skill_levels[GUILD_SKILL_HIM - GUILD_SKILL_START] - GetSkillLevel(GUILD_SKILL_HIM);
-	}
-
-	if (iDefMoreBonus || iAttMoreBonus)
-	{
-		for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-		{
-			(*it)->PointChange(POINT_ATT_GRADE, iAttMoreBonus);
-			(*it)->PointChange(POINT_DEF_GRADE, iDefMoreBonus);
-		}
-	}
-	*/
-
-	thecore_memcpy(m_data.abySkill, skill_levels, sizeof(BYTE) * GUILD_SKILL_COUNT);
-	ComputeGuildPoints();
-}
-
-static DWORD __guild_levelup_exp(int level)
-{
-	if (LC_IsYMIR())
-	{
-		return guild_exp_table[level];
-	}
-	else
-	{
-		return guild_exp_table2[level];
-	}
-}
-
-void CGuild::GuildPointChange(BYTE type, int amount, bool save)
-{
-	switch (type)
-	{
-	case POINT_SP:
-		m_data.power += amount;
-
-		m_data.power = MINMAX(0, m_data.power, m_data.max_power);
-
-		if (save)
-		{
-			SaveSkill();
-		}
-
-		for_each(m_memberOnline.begin(), m_memberOnline.end(), std::bind(&CGuild::SendSkillInfoPacket, this, std::placeholders::_1));
-		break;
-
-	case POINT_EXP:
-		if (amount < 0 && m_data.exp < (DWORD)-amount)
-		{
-			m_data.exp = 0;
-		}
-		else
-		{
-			m_data.exp += amount;
-
-			while (m_data.exp >= __guild_levelup_exp(m_data.level))
-			{
-				if (m_data.level < GUILD_MAX_LEVEL)
-				{
-					m_data.exp -= __guild_levelup_exp(m_data.level);
-					++m_data.level;
-					++m_data.skill_point;
-
-					if (m_data.level > GUILD_MAX_LEVEL)
-						m_data.level = GUILD_MAX_LEVEL;
-
-					ComputeGuildPoints();
-					GuildPointChange(POINT_SP, m_data.max_power - m_data.power);
-
-					if (save)
-						ChangeLadderPoint(GUILD_LADDER_POINT_PER_LEVEL);
-
-					// NOTIFY_GUILD_EXP_CHANGE
-					for_each(m_memberOnline.begin(), m_memberOnline.end(), std::bind(&CGuild::SendGuildInfoPacket, this, std::placeholders::_1));
-					// END_OF_NOTIFY_GUILD_EXP_CHANGE
-				}
-
-				if (m_data.level == GUILD_MAX_LEVEL)
-				{
-					m_data.exp = 0;
-				}
-			}
-		}
-
-		TPacketGCGuild pack;
-		pack.header = HEADER_GC_GUILD;
-		pack.size = sizeof(pack) + 5;
-		pack.subheader = GUILD_SUBHEADER_GC_CHANGE_EXP;
-
-		TEMP_BUFFER buf;
-		buf.write(&pack, sizeof(pack));
-		buf.write(&m_data.level, 1);
-		buf.write(&m_data.exp, 4);
-
-		for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-		{
-			LPDESC d = (*it)->GetDesc();
-
-			if (d)
-				d->Packet(buf.read_peek(), buf.size());
-		}
-
-		if (save)
-			SaveLevel();
-
-		break;
-	}
-}
-
-void CGuild::SkillRecharge()
-{
-	//GuildPointChange(POINT_SP, m_data.max_power / 2);
-	//GuildPointChange(POINT_SP, 10);
-}
-
-void CGuild::SaveMember(DWORD pid)
-{
-	TGuildMemberContainer::iterator it = m_member.find(pid);
-
-	if (it == m_member.end())
-		return;
-
-	DBManager::instance().Query(
-		"UPDATE guild_member%s SET grade = %d, offer = %u, is_general = %d WHERE pid = %u and guild_id = %u",
-		get_table_postfix(), it->second.grade, it->second.offer_exp, it->second.is_general, pid, m_data.guild_id);
-}
-
-void CGuild::LevelChange(DWORD pid, BYTE level)
-{
-	TGuildMemberContainer::iterator cit = m_member.find(pid);
-
-	if (cit == m_member.end())
-		return;
-
-	cit->second.level = level;
-
-	TPacketGuildChangeMemberData gd_guild;
-
-	gd_guild.guild_id = GetID();
-	gd_guild.pid = pid;
-	gd_guild.offer = cit->second.offer_exp;
-	gd_guild.grade = cit->second.grade;
-	gd_guild.level = level;
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_MEMBER_DATA, 0, &gd_guild, sizeof(gd_guild));
-
-	TPacketGCGuild pack;
-	pack.header = HEADER_GC_GUILD;
-	cit->second._dummy = 0;
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-
-		if (d)
-		{
-			pack.subheader = GUILD_SUBHEADER_GC_LIST;
-			pack.size = sizeof(pack) + 13;
-			d->BufferedPacket(&pack, sizeof(pack));
-			d->Packet(&(cit->second), sizeof(DWORD) * 3 + 1);
-		}
-	}
-}
-
-void CGuild::ChangeMemberData(DWORD pid, DWORD offer, BYTE level, BYTE grade)
-{
-	TGuildMemberContainer::iterator cit = m_member.find(pid);
-
-	if (cit == m_member.end())
-		return;
-
-	cit->second.offer_exp = offer;
-	cit->second.level = level;
-	cit->second.grade = grade;
-	cit->second._dummy = 0;
-
-	TPacketGCGuild pack;
-	memset(&pack, 0, sizeof(pack));
-	pack.header = HEADER_GC_GUILD;
-
-	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-		if (d)
-		{
-			pack.subheader = GUILD_SUBHEADER_GC_LIST;
-			pack.size = sizeof(pack) + 13;
-			d->BufferedPacket(&pack, sizeof(pack));
-			d->Packet(&(cit->second), sizeof(DWORD) * 3 + 1);
-		}
-	}
-}
-
-namespace
-{
-	struct FGuildChat
-	{
-		const char* c_pszText;
-
-		FGuildChat(const char* c_pszText)
-			: c_pszText(c_pszText)
-		{}
-
-		void operator()(LPCHARACTER ch)
-		{
-			ch->ChatPacket(CHAT_TYPE_GUILD, "%s", c_pszText);
-		}
-	};
-}
-
-void CGuild::P2PChat(const char* c_pszText)
-{
-	std::for_each(m_memberOnline.begin(), m_memberOnline.end(), FGuildChat(c_pszText));
-}
-
-void CGuild::Chat(const char* c_pszText)
-{
-	std::for_each(m_memberOnline.begin(), m_memberOnline.end(), FGuildChat(c_pszText));
-
-	TPacketGGGuild p1;
-	TPacketGGGuildChat p2;
-
-	p1.bHeader = HEADER_GG_GUILD;
-	p1.bSubHeader = GUILD_SUBHEADER_GG_CHAT;
-	p1.dwGuild = GetID();
-	strlcpy(p2.szText, c_pszText, sizeof(p2.szText));
-
-	P2P_MANAGER::instance().Send(&p1, sizeof(TPacketGGGuild));
-	P2P_MANAGER::instance().Send(&p2, sizeof(TPacketGGGuildChat));
-}
-
-LPCHARACTER CGuild::GetMasterCharacter()
-{
-	return CHARACTER_MANAGER::instance().FindByPID(GetMasterPID());
-}
-
-void CGuild::Packet(const void* buf, int size)
-{
-	for (auto it = m_memberOnline.begin(); it!=m_memberOnline.end();++it)
-	{
-		LPDESC d = (*it)->GetDesc();
-
-		if (d)
-			d->Packet(buf, size);
-	}
-}
-
-int CGuild::GetTotalLevel() const
-{
-	int total = 0;
-
-	for (auto it = m_member.begin(); it != m_member.end(); ++it)
-	{
-		total += it->second.level;
-	}
-
-	return total;
-}
-
-bool CGuild::ChargeSP(LPCHARACTER ch, int iSP)
-{
-	int gold = iSP * 100;
-
-	if (gold < iSP || ch->GetGold() < gold)
-		return false;
-
-	int iRemainSP = m_data.max_power - m_data.power;
-
-	if (iSP > iRemainSP)
-	{
-		iSP = iRemainSP;
-		gold = iSP * 100;
-	}
-
-	ch->PointChange(POINT_GOLD, -gold);
-	DBManager::instance().SendMoneyLog(MONEY_LOG_GUILD, 1, -gold);
-
-	SendDBSkillUpdate(iSP);
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> %lu의 용신력을 회복하였습니다.", iSP));
-	}
-	return true;
-}
-
-void CGuild::SkillUsableChange(DWORD dwSkillVnum, bool bUsable)
-{
-	DWORD dwRealVnum = dwSkillVnum - GUILD_SKILL_START;
-
-	if (dwRealVnum >= GUILD_SKILL_COUNT)
-		return;
-
-	abSkillUsable[dwRealVnum] = bUsable;
-
-	// GUILD_SKILL_COOLTIME_BUG_FIX
-	sys_log(0, "CGuild::SkillUsableChange(guild=%s, skill=%d, usable=%d)", GetName(), dwSkillVnum, bUsable);
-	// END_OF_GUILD_SKILL_COOLTIME_BUG_FIX
-}
-
-// GUILD_MEMBER_COUNT_BONUS
-void CGuild::SetMemberCountBonus(int iBonus)
-{
-	m_iMemberCountBonus = iBonus;
-	sys_log(0, "GUILD_IS_FULL_BUG : Bonus set to %d(val:%d)", iBonus, m_iMemberCountBonus);
-}
-
-void CGuild::BroadcastMemberCountBonus()
-{
-	TPacketGGGuild p1;
-
-	p1.bHeader = HEADER_GG_GUILD;
-	p1.bSubHeader = GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS;
-	p1.dwGuild = GetID();
-
-	P2P_MANAGER::instance().Send(&p1, sizeof(TPacketGGGuild));
-	P2P_MANAGER::instance().Send(&m_iMemberCountBonus, sizeof(int));
-}
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-int CGuild::GetNearMemberCount(LPCHARACTER ch)
-{
-	int count = 0;
-
-	TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin();;
-	for (; it != m_memberOnline.end(); ++it)
-	{
-		LPCHARACTER member = *it;
-		if (member == NULL)
-			continue;
-
-		if (ch->GetMapIndex() != member->GetMapIndex())
-			continue;
-
-		if (DISTANCE_APPROX(ch->GetX() - member->GetX(), ch->GetY() - member->GetY()) < 1000)
-			++count;
-	}
-
-	return count;
-}
-#endif
-
-int CGuild::GetMaxMemberCount()
-{
-	// GUILD_IS_FULL_BUG_FIX
-	if (m_iMemberCountBonus < 0 || m_iMemberCountBonus > 18)
-		m_iMemberCountBonus = 0;
-	// END_GUILD_IS_FULL_BUG_FIX
-
-	if (LC_IsHongKong() == true)
-	{
-		quest::PC* pPC = quest::CQuestManager::instance().GetPC(GetMasterPID());
-
-		if (pPC != NULL)
-		{
-			if (pPC->GetFlag("guild.is_unlimit_member") == 1)
-			{
-				return INT_MAX;
-			}
-		}
-	}
-
-	return 32 + 2 * (m_data.level - 1) + m_iMemberCountBonus;
-}
-// END_OF_GUILD_MEMBER_COUNT_BONUS
-
-void CGuild::AdvanceLevel(int iLevel)
-{
-	if (m_data.level == iLevel)
-		return;
-
-	m_data.level = MIN(GUILD_MAX_LEVEL, iLevel);
-}
-
-void CGuild::RequestDepositMoney(LPCHARACTER ch, int iGold)
-{
-	if (false == ch->CanDeposit())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 잠시후에 이용해주십시오"));
-		return;
-	}
-
-	if (ch->GetGold() < iGold)
-		return;
-
-	ch->PointChange(POINT_GOLD, -iGold);
-
-	TPacketGDGuildMoney p;
-	p.dwGuild = GetID();
-	p.iGold = iGold;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_DEPOSIT_MONEY, 0, &p, sizeof(p));
-
-	char buf[64 + 1];
-	snprintf(buf, sizeof(buf), "%u %s", GetID(), GetName());
-	LogManager::instance().CharLog(ch, iGold, "GUILD_DEPOSIT", buf);
-
-	ch->UpdateDepositPulse();
-	sys_log(0, "GUILD: DEPOSIT %s:%u player %s[%u] gold %d", GetName(), GetID(), ch->GetName(), ch->GetPlayerID(), iGold);
-}
-
-void CGuild::RequestWithdrawMoney(LPCHARACTER ch, int iGold)
-{
-	if (false == ch->CanDeposit())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 잠시후에 이용해주십시오"));
-		return;
-	}
-
-	if (ch->GetPlayerID() != GetMasterPID())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드 금고에선 길드장만 출금할 수 있습니다."));
-		return;
-	}
-
-	if (m_data.gold < iGold)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 가지고 있는 돈이 부족합니다."));
-		return;
-	}
-
-	TPacketGDGuildMoney p;
-	p.dwGuild = GetID();
-	p.iGold = iGold;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_WITHDRAW_MONEY, 0, &p, sizeof(p));
-
-	ch->UpdateDepositPulse();
-}
-
-void CGuild::RecvMoneyChange(int iGold)
-{
-	m_data.gold = iGold;
-
-	TPacketGCGuild p;
-	p.header = HEADER_GC_GUILD;
-	p.size = sizeof(p) + sizeof(int);
-	p.subheader = GUILD_SUBHEADER_GC_MONEY_CHANGE;
-
-	for (auto it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
-	{
-		LPCHARACTER ch = *it;
-		LPDESC d = ch->GetDesc();
-		d->BufferedPacket(&p, sizeof(p));
-		d->Packet(&iGold, sizeof(int));
-	}
-}
-
-void CGuild::RecvWithdrawMoneyGive(int iChangeGold)
-{
-	LPCHARACTER ch = GetMasterCharacter();
-
-	if (ch)
-	{
-		ch->PointChange(POINT_GOLD, iChangeGold);
-		sys_log(0, "GUILD: WITHDRAW %s:%u player %s[%u] gold %d", GetName(), GetID(), ch->GetName(), ch->GetPlayerID(), iChangeGold);
-	}
-
-	TPacketGDGuildMoneyWithdrawGiveReply p;
-	p.dwGuild = GetID();
-	p.iChangeGold = iChangeGold;
-	p.bGiveSuccess = ch ? 1 : 0;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY, 0, &p, sizeof(p));
-}
-
-bool CGuild::HasLand()
-{
-	return building::CManager::instance().FindLandByGuild(GetID()) != NULL;
-}
-
-// GUILD_JOIN_BUG_FIX
-/// 길드 초대 event 정보
-EVENTINFO(TInviteGuildEventInfo)
-{
-	DWORD dwInviteePID; ///< 초대받은 character 의 PID
-	DWORD dwGuildID; ///< 초대한 Guild 의 ID
-
-	TInviteGuildEventInfo()
-		: dwInviteePID(0)
-		, dwGuildID(0)
-	{
-	}
-};
-
-/**
- * 길드 초대 event callback 함수.
- * event 가 발동하면 초대 거절로 처리한다.
- */
-EVENTFUNC(GuildInviteEvent)
-{
-	TInviteGuildEventInfo* pInfo = dynamic_cast<TInviteGuildEventInfo*>(event->info);
-
-	if (pInfo == NULL)
-	{
-		sys_err("GuildInviteEvent> <Factor> Null pointer");
-		return 0;
-	}
-
-	CGuild* pGuild = CGuildManager::instance().FindGuild(pInfo->dwGuildID);
-
-	if (pGuild)
-	{
-		sys_log(0, "GuildInviteEvent %s", pGuild->GetName());
-		pGuild->InviteDeny(pInfo->dwInviteePID);
-	}
-
-	return 0;
-}
-
-void CGuild::Invite(LPCHARACTER pchInviter, LPCHARACTER pchInvitee)
-{
-	if (quest::CQuestManager::instance().GetPCForce(pchInviter->GetPlayerID())->IsRunning() == true)
-	{
-		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 상대방이 초대 신청을 받을 수 없는 상태입니다."));
-		return;
-	}
-
-	if (quest::CQuestManager::instance().GetPCForce(pchInvitee->GetPlayerID())->IsRunning() == true)
-		return;
-
-	if (pchInvitee->IsBlockMode(BLOCK_GUILD_INVITE))
-	{
-		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 상대방이 길드 초대 거부 상태입니다."));
-		return;
-	}
-	else if (!HasGradeAuth(GetMember(pchInviter->GetPlayerID())->grade, GUILD_AUTH_ADD_MEMBER))
-	{
-		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드원을 초대할 권한이 없습니다."));
-		return;
-	}
-	else if (pchInvitee->GetEmpire() != pchInviter->GetEmpire())
-	{
-		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 다른 제국 사람을 길드에 초대할 수 없습니다."));
-		return;
-	}
-
-	GuildJoinErrCode errcode = VerifyGuildJoinableCondition(pchInvitee);
-	switch (errcode)
-	{
-	case GERR_NONE: break;
-	case GERR_WITHDRAWPENALTY:
-		pchInviter->ChatPacket(CHAT_TYPE_INFO,
-			LC_STRING("<길드> 탈퇴한 후 %d일이 지나지 않은 사람은 길드에 초대할 수 없습니다.",
-			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
-		return;
-	case GERR_COMMISSIONPENALTY:
-		pchInviter->ChatPacket(CHAT_TYPE_INFO,
-			LC_STRING("<길드> 길드를 해산한 지 %d일이 지나지 않은 사람은 길드에 초대할 수 없습니다.",
-			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
-		return;
-	case GERR_ALREADYJOIN:	pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 상대방이 이미 다른 길드에 속해있습니다.")); return;
-	case GERR_GUILDISFULL:	pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 최대 길드원 수를 초과했습니다.")); return;
-	case GERR_GUILD_IS_IN_WAR: pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 현재 길드가 전쟁 중 입니다.")); return;
-	case GERR_INVITE_LIMIT: pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 현재 신규 가입 제한 상태 입니다.")); return;
-
-	default: sys_err("ignore guild join error(%d)", errcode); return;
-	}
-
-	if (m_GuildInviteEventMap.end() != m_GuildInviteEventMap.find(pchInvitee->GetPlayerID()))
-		return;
-
-	//
-	// 이벤트 생성
-	// 
-	TInviteGuildEventInfo* pInfo = AllocEventInfo<TInviteGuildEventInfo>();
-	pInfo->dwInviteePID = pchInvitee->GetPlayerID();
-	pInfo->dwGuildID = GetID();
-
-	m_GuildInviteEventMap.insert(EventMap::value_type(pchInvitee->GetPlayerID(), event_create(GuildInviteEvent, pInfo, PASSES_PER_SEC(10))));
-
-	//
-	// 초대 받는 character 에게 초대 패킷 전송
-	// 
-
-	DWORD gid = GetID();
-
-	TPacketGCGuild p;
-	p.header = HEADER_GC_GUILD;
-	p.size = sizeof(p) + sizeof(DWORD) + GUILD_NAME_MAX_LEN + 1;
-	p.subheader = GUILD_SUBHEADER_GC_GUILD_INVITE;
-
-	TEMP_BUFFER buf;
-	buf.write(&p, sizeof(p));
-	buf.write(&gid, sizeof(DWORD));
-	buf.write(GetName(), GUILD_NAME_MAX_LEN + 1);
-
-	pchInvitee->GetDesc()->Packet(buf.read_peek(), buf.size());
-}
-
-void CGuild::InviteAccept(LPCHARACTER pchInvitee)
-{
-	EventMap::iterator itFind = m_GuildInviteEventMap.find(pchInvitee->GetPlayerID());
-	if (itFind == m_GuildInviteEventMap.end())
-	{
-		sys_log(0, "GuildInviteAccept from not invited character(invite guild: %s, invitee: %s)", GetName(), pchInvitee->GetName());
-		return;
-	}
-
-	event_cancel(&itFind->second);
-	m_GuildInviteEventMap.erase(itFind);
-
-	GuildJoinErrCode errcode = VerifyGuildJoinableCondition(pchInvitee);
-	switch (errcode)
-	{
-	case GERR_NONE: break;
-	case GERR_WITHDRAWPENALTY:
-		pchInvitee->ChatPacket(CHAT_TYPE_INFO,
-			LC_STRING("<길드> 탈퇴한 후 %d일이 지나지 않은 사람은 길드에 초대할 수 없습니다.",
-			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
-		return;
-	case GERR_COMMISSIONPENALTY:
-		pchInvitee->ChatPacket(CHAT_TYPE_INFO,
-			LC_STRING("<길드> 길드를 해산한 지 %d일이 지나지 않은 사람은 길드에 초대할 수 없습니다.",
-			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
-		return;
-	case GERR_ALREADYJOIN:	pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 상대방이 이미 다른 길드에 속해있습니다.")); return;
-	case GERR_GUILDISFULL:	pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 최대 길드원 수를 초과했습니다.")); return;
-	case GERR_GUILD_IS_IN_WAR: pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 현재 길드가 전쟁 중 입니다.")); return;
-	case GERR_INVITE_LIMIT: pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 현재 신규 가입 제한 상태 입니다.")); return;
-
-	default: sys_err("ignore guild join error(%d)", errcode); return;
-	}
-
-	RequestAddMember(pchInvitee, 15);
-}
-
-void CGuild::InviteDeny(DWORD dwPID)
-{
-	EventMap::iterator itFind = m_GuildInviteEventMap.find(dwPID);
-	if (itFind == m_GuildInviteEventMap.end())
-	{
-		sys_log(0, "GuildInviteDeny from not invited character(invite guild: %s, invitee PID: %d)", GetName(), dwPID);
-		return;
-	}
-
-	event_cancel(&itFind->second);
-	m_GuildInviteEventMap.erase(itFind);
-}
-
-CGuild::GuildJoinErrCode CGuild::VerifyGuildJoinableCondition(const LPCHARACTER pchInvitee)
-{
-	if (get_global_time() - pchInvitee->GetQuestFlag("guild_manage.new_withdraw_time")
-		< CGuildManager::instance().GetWithdrawDelay())
-		return GERR_WITHDRAWPENALTY;
-	else if (get_global_time() - pchInvitee->GetQuestFlag("guild_manage.new_disband_time")
-		< CGuildManager::instance().GetDisbandDelay())
-		return GERR_COMMISSIONPENALTY;
-	else if (pchInvitee->GetGuild())
-		return GERR_ALREADYJOIN;
-	else if (GetMemberCount() >= GetMaxMemberCount())
-	{
-		sys_log(1, "GuildName = %s, GetMemberCount() = %d, GetMaxMemberCount() = %d (32 + MAX(level(%d)-10, 0) * 2 + bonus(%d)",
-			GetName(), GetMemberCount(), GetMaxMemberCount(), m_data.level, m_iMemberCountBonus);
-		return GERR_GUILDISFULL;
-	}
-	else if (UnderAnyWar() != 0)
-	{
-		return GERR_GUILD_IS_IN_WAR;
-	}
-	else if (LC_IsBrazil() == true)
-	{
-		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT value FROM guild_invite_limit WHERE id=%d", GetID()));
-
-		if (pMsg->Get()->uiNumRows > 0)
-		{
-			MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-			time_t limit_time = 0;
-			str_to_number(limit_time, row[0]);
-
-			if (test_server == true)
-			{
-				limit_time += quest::CQuestManager::instance().GetEventFlag("guild_invite_limit") * 60;
-			}
-			else
-			{
-				limit_time += quest::CQuestManager::instance().GetEventFlag("guild_invite_limit") * 24 * 60 * 60;
-			}
-
-			if (get_global_time() < limit_time) return GERR_INVITE_LIMIT;
-		}
-	}
-
-	return GERR_NONE;
-}
-// END_OF_GUILD_JOIN_BUG_FIX
-
-bool CGuild::ChangeMasterTo(DWORD dwPID)
-{
-	if (GetMember(dwPID) == NULL) return false;
-
-	TPacketChangeGuildMaster p;
-	p.dwGuildID = GetID();
-	p.idFrom = GetMasterPID();
-	p.idTo = dwPID;
-
-	db_clientdesc->DBPacket(HEADER_GD_REQ_CHANGE_GUILD_MASTER, 0, &p, sizeof(p));
-
-	return true;
-}
-
-void CGuild::SendGuildDataUpdateToAllMember(SQLMsg* pmsg)
-{
-	TGuildMemberOnlineContainer::iterator iter = m_memberOnline.begin();
-
-	for (; iter != m_memberOnline.end(); iter++)
-	{
-		SendGuildInfoPacket(*iter);
-		SendAllGradePacket(*iter);
-	}
-}
+#include "stdafx.h"
+#include "utils.h"
+#include "config.h"
+#include "char.h"
+#include "packet.h"
+#include "desc_client.h"
+#include "buffer_manager.h"
+#include "char_manager.h"
+#include "db.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "affect.h"
+#include "p2p.h"
+#include "questmanager.h"
+#include "building.h"
+#include "locale_service.h"
+#include "log.h"
+#include "questmanager.h"
+
+SGuildMember::SGuildMember(LPCHARACTER ch, BYTE grade, DWORD offer_exp)
+	: pid(ch->GetPlayerID()), grade(grade), is_general(0), job(ch->GetJob()), level(ch->GetLevel()), offer_exp(offer_exp), name(ch->GetName())
+{}
+SGuildMember::SGuildMember(DWORD pid, BYTE grade, BYTE is_general, BYTE job, BYTE level, DWORD offer_exp, char* name)
+	: pid(pid), grade(grade), is_general(is_general), job(job), level(level), offer_exp(offer_exp), name(name)
+{}
+
+namespace
+{
+	struct FGuildNameSender
+	{
+		FGuildNameSender(DWORD id, const char* guild_name) : id(id), name(guild_name)
+		{
+			p.header = HEADER_GC_GUILD;
+			p.subheader = GUILD_SUBHEADER_GC_GUILD_NAME;
+			p.size = sizeof(p) + sizeof(DWORD) + GUILD_NAME_MAX_LEN;
+		}
+
+		void operator() (LPCHARACTER ch)
+		{
+			LPDESC d = ch->GetDesc();
+
+			if (d)
+			{
+				d->BufferedPacket(&p, sizeof(p));
+				d->BufferedPacket(&id, sizeof(id));
+				d->Packet(name, GUILD_NAME_MAX_LEN);
+			}
+		}
+
+		DWORD id;
+		const char* name;
+		TPacketGCGuild p{};
+	};
+}
+
+CGuild::CGuild(TGuildCreateParameter& cp)
+{
+	Initialize();
+
+	m_general_count = 0;
+
+	m_iMemberCountBonus = 0;
+
+	strlcpy(m_data.name, cp.name, sizeof(m_data.name));
+	m_data.master_pid = cp.master->GetPlayerID();
+	strlcpy(m_data.grade_array[0].grade_name, LC_STRING(""), sizeof(m_data.grade_array[0].grade_name));
+	m_data.grade_array[0].auth_flag = GUILD_AUTH_ADD_MEMBER | GUILD_AUTH_REMOVE_MEMBER | GUILD_AUTH_NOTICE | GUILD_AUTH_USE_SKILL;
+
+	for (int i = 1; i < GUILD_GRADE_COUNT; ++i)
+	{
+		strlcpy(m_data.grade_array[i].grade_name, LC_STRING(""), sizeof(m_data.grade_array[i].grade_name));
+		m_data.grade_array[i].auth_flag = 0;
+	}
+
+	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery(
+		"INSERT INTO `guild%s` (`name`, `master`, `sp`, `level`, `exp`, `skill_point`, `skill`) "
+		"VALUES('%s', %u, 1000, 1, 0, 0, '\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0')",
+		get_table_postfix(), m_data.name, m_data.master_pid));
+
+	// TODO if error occur?
+	m_data.guild_id = pmsg->Get()->uiInsertID;
+
+	char grade_name[GUILD_GRADE_NAME_MAX_LEN * 2 + 1];
+
+	for (int i = 0; i < GUILD_GRADE_COUNT; ++i)
+	{
+		DBManager::instance().EscapeString(grade_name, sizeof(grade_name),
+			m_data.grade_array[i].grade_name, strlen(m_data.grade_array[i].grade_name));
+
+		DBManager::instance().Query("INSERT INTO `guild_grade%s` VALUES(%u, %d, '%s', %d)",
+			get_table_postfix(),
+			m_data.guild_id,
+			i + 1,
+			grade_name,
+			m_data.grade_array[i].auth_flag);
+	}
+
+	ComputeGuildPoints();
+	m_data.power = m_data.max_power;
+	m_data.ladder_point = 0;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_CREATE, 0, &m_data.guild_id, sizeof(DWORD));
+
+	TPacketGuildSkillUpdate guild_skill;
+	guild_skill.guild_id = m_data.guild_id;
+	guild_skill.amount = 0;
+	guild_skill.skill_point = 0;
+	memset(guild_skill.skill_levels, 0, GUILD_SKILL_COUNT);
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_SKILL_UPDATE, 0, &guild_skill, sizeof(guild_skill));
+
+	// TODO GUILD_NAME
+	CHARACTER_MANAGER::instance().for_each_pc(FGuildNameSender(GetID(), GetName()));
+	/*
+	TPacketDGGuildMember p;
+	memset(&p, 0, sizeof(p));
+	p.dwPID = cp.master->GetPlayerID();
+	p.bGrade = 15;
+	AddMember(&p);
+	*/
+	RequestAddMember(cp.master, GUILD_LEADER_GRADE);
+}
+
+void CGuild::Initialize()
+{
+	memset(&m_data, 0, sizeof(m_data));
+	m_data.level = 1;
+
+	for (int i = 0; i < GUILD_SKILL_COUNT; ++i)
+		abSkillUsable[i] = true;
+
+	m_iMemberCountBonus = 0;
+}
+
+CGuild::~CGuild()
+{
+}
+
+void CGuild::RequestAddMember(LPCHARACTER ch, int grade)
+{
+	if (ch->GetGuild())
+		return;
+
+	TPacketGDGuildAddMember gd;
+
+	if (m_member.find(ch->GetPlayerID()) != m_member.end())
+	{
+		sys_err("Already a member in guild %s[%d]", ch->GetName(), ch->GetPlayerID());
+		return;
+	}
+
+	gd.dwPID = ch->GetPlayerID();
+	gd.dwGuild = GetID();
+	gd.bGrade = grade;
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_ADD_MEMBER, 0, &gd, sizeof(TPacketGDGuildAddMember));
+}
+
+void CGuild::AddMember(TPacketDGGuildMember* p)
+{
+	TGuildMemberContainer::iterator it;
+
+	if ((it = m_member.find(p->dwPID)) == m_member.end())
+		m_member.insert(std::make_pair(p->dwPID, TGuildMember(p->dwPID, p->bGrade, p->isGeneral, p->bJob, p->bLevel, p->dwOffer, p->szName)));
+	else
+	{
+		TGuildMember& r_gm = it->second;
+		r_gm.pid = p->dwPID;
+		r_gm.grade = p->bGrade;
+		r_gm.job = p->bJob;
+		r_gm.offer_exp = p->dwOffer;
+		r_gm.is_general = p->isGeneral;
+	}
+
+	CGuildManager::instance().Link(p->dwPID, this);
+
+	SendListOneToAll(p->dwPID);
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(p->dwPID);
+
+	sys_log(0, "GUILD: AddMember PID %u, grade %u, job %u, level %u, offer %u, name %s ptr %p",
+		p->dwPID, p->bGrade, p->bJob, p->bLevel, p->dwOffer, p->szName, get_pointer(ch));
+
+	if (ch)
+		LoginMember(ch);
+	else
+		P2PLoginMember(p->dwPID);
+}
+
+bool CGuild::RequestRemoveMember(DWORD pid)
+{
+	TGuildMemberContainer::iterator it;
+
+	if ((it = m_member.find(pid)) == m_member.end())
+		return false;
+
+	if (it->second.grade == GUILD_LEADER_GRADE)
+		return false;
+
+	if (UnderAnyWar() != 0)
+		return false;
+
+	TPacketGuild gd_guild;
+
+	gd_guild.dwGuild = GetID();
+	gd_guild.dwInfo = pid;
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_REMOVE_MEMBER, 0, &gd_guild, sizeof(TPacketGuild));
+	return true;
+}
+
+bool CGuild::RemoveMember(DWORD pid)
+{
+	sys_log(0, "Receive Guild P2P RemoveMember");
+	TGuildMemberContainer::iterator it;
+
+	if ((it = m_member.find(pid)) == m_member.end())
+		return false;
+
+	if (it->second.grade == GUILD_LEADER_GRADE)
+		return false;
+
+	if (it->second.is_general)
+		m_general_count--;
+
+	m_member.erase(it);
+	SendOnlineRemoveOnePacket(pid);
+
+	CGuildManager::instance().Unlink(pid);
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+	if (ch)
+	{
+		//GuildRemoveAffect(ch);
+		m_memberOnline.erase(ch);
+		ch->SetGuild(NULL);
+	}
+
+	if (LC_IsBrazil() == true)
+	{
+		DBManager::instance().Query("REPLACE INTO guild_invite_limit VALUES(%d, %d)", GetID(), get_global_time());
+	}
+
+	return true;
+}
+
+void CGuild::P2PLoginMember(DWORD pid)
+{
+	if (m_member.find(pid) == m_member.end())
+	{
+		sys_err("GUILD [%d] is not a memeber of guild.", pid);
+		return;
+	}
+
+	m_memberP2POnline.insert(pid);
+
+	// Login event occur + Send List
+	TGuildMemberOnlineContainer::iterator it;
+
+	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+		SendLoginPacket(*it, pid);
+}
+
+void CGuild::LoginMember(LPCHARACTER ch)
+{
+	if (m_member.find(ch->GetPlayerID()) == m_member.end())
+	{
+		sys_err("GUILD %s[%d] is not a memeber of guild.", ch->GetName(), ch->GetPlayerID());
+		return;
+	}
+
+	ch->SetGuild(this);
+
+	// Login event occur + Send List
+	TGuildMemberOnlineContainer::iterator it;
+
+	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+		SendLoginPacket(*it, ch);
+
+	m_memberOnline.insert(ch);
+
+	SendAllGradePacket(ch);
+	SendGuildInfoPacket(ch);
+	SendListPacket(ch);
+	SendSkillInfoPacket(ch);
+	SendEnemyGuild(ch);
+
+	//GuildUpdateAffect(ch);
+}
+
+void CGuild::P2PLogoutMember(DWORD pid)
+{
+	if (m_member.find(pid) == m_member.end())
+	{
+		sys_err("GUILD [%d] is not a memeber of guild.", pid);
+		return;
+	}
+
+	m_memberP2POnline.erase(pid);
+
+	// Logout event occur
+	TGuildMemberOnlineContainer::iterator it;
+	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		SendLogoutPacket(*it, pid);
+	}
+}
+
+void CGuild::LogoutMember(LPCHARACTER ch)
+{
+	if (m_member.find(ch->GetPlayerID()) == m_member.end())
+	{
+		sys_err("GUILD %s[%d] is not a memeber of guild.", ch->GetName(), ch->GetPlayerID());
+		return;
+	}
+
+	//GuildRemoveAffect(ch);
+
+	//ch->SetGuild(NULL);
+	m_memberOnline.erase(ch);
+
+	// Logout event occur
+	TGuildMemberOnlineContainer::iterator it;
+	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		SendLogoutPacket(*it, ch);
+	}
+}
+
+void CGuild::SendOnlineRemoveOnePacket(DWORD pid)
+{
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 4;
+	pack.subheader = GUILD_SUBHEADER_GC_REMOVE;
+
+	TEMP_BUFFER buf;
+	buf.write(&pack, sizeof(pack));
+	buf.write(&pid, sizeof(pid));
+
+	TGuildMemberOnlineContainer::iterator it;
+
+	for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+
+		if (d)
+			d->Packet(buf.read_peek(), buf.size());
+	}
+}
+
+void CGuild::SendAllGradePacket(LPCHARACTER ch)
+{
+	LPDESC d = ch->GetDesc();
+	if (!d)
+		return;
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 1 + GUILD_GRADE_COUNT * (sizeof(TGuildGrade) + 1);
+	pack.subheader = GUILD_SUBHEADER_GC_GRADE;
+
+	TEMP_BUFFER buf;
+
+	buf.write(&pack, sizeof(pack));
+	BYTE n = 15;
+	buf.write(&n, 1);
+
+	for (int i = 0; i < GUILD_GRADE_COUNT; i++)
+	{
+		BYTE j = i + 1;
+		buf.write(&j, 1);
+		buf.write(&m_data.grade_array[i], sizeof(TGuildGrade));
+	}
+
+	d->Packet(buf.read_peek(), buf.size());
+}
+
+void CGuild::SendListOneToAll(LPCHARACTER ch)
+{
+	SendListOneToAll(ch->GetPlayerID());
+}
+
+void CGuild::SendListOneToAll(DWORD pid)
+{
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(TPacketGCGuild);
+	pack.subheader = GUILD_SUBHEADER_GC_LIST;
+
+	pack.size += sizeof(TGuildMemberPacketData);
+
+	char c[CHARACTER_NAME_MAX_LEN + 1];
+	memset(c, 0, sizeof(c));
+
+	TGuildMemberContainer::iterator cit = m_member.find(pid);
+	if (cit == m_member.end())
+		return;
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+		if (!d)
+			continue;
+
+		TEMP_BUFFER buf;
+
+		buf.write(&pack, sizeof(pack));
+
+		cit->second._dummy = 1;
+
+		buf.write(&(cit->second), sizeof(DWORD) * 3 + 1);
+		buf.write(cit->second.name.c_str(), cit->second.name.length());
+		buf.write(c, CHARACTER_NAME_MAX_LEN + 1 - cit->second.name.length());
+		d->Packet(buf.read_peek(), buf.size());
+	}
+}
+
+void CGuild::SendListPacket(LPCHARACTER ch)
+{
+	/*
+	List Packet
+
+	Header
+	Count (byte)
+	[
+		...
+		name_flag 1 - 見  횐
+		name CHARACTER_NAME_MAX_LEN+1
+	] * Count
+	*/
+
+	LPDESC d;
+	if (!(d = ch->GetDesc()))
+		return;
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(TPacketGCGuild);
+	pack.subheader = GUILD_SUBHEADER_GC_LIST;
+
+	pack.size += sizeof(TGuildMemberPacketData) * m_member.size();
+
+	TEMP_BUFFER buf;
+
+	buf.write(&pack, sizeof(pack));
+
+	char c[CHARACTER_NAME_MAX_LEN + 1];
+
+	for (TGuildMemberContainer::iterator it = m_member.begin(); it != m_member.end(); ++it)
+	{
+		it->second._dummy = 1;
+
+		buf.write(&(it->second), sizeof(DWORD) * 3 + 1);
+
+		strlcpy(c, it->second.name.c_str(), MIN(sizeof(c), it->second.name.length() + 1));
+
+		buf.write(c, CHARACTER_NAME_MAX_LEN + 1);
+
+		if (test_server)
+			sys_log(0, "name %s job %d", it->second.name.c_str(), it->second.job);
+	}
+
+	d->Packet(buf.read_peek(), buf.size());
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		SendLoginPacket(ch, *it);
+	}
+
+	for (TGuildMemberP2POnlineContainer::iterator it = m_memberP2POnline.begin(); it != m_memberP2POnline.end(); ++it)
+	{
+		SendLoginPacket(ch, *it);
+	}
+
+}
+
+void CGuild::SendLoginPacket(LPCHARACTER ch, LPCHARACTER chLogin)
+{
+	SendLoginPacket(ch, chLogin->GetPlayerID());
+}
+
+void CGuild::SendLoginPacket(LPCHARACTER ch, DWORD pid)
+{
+	/*
+	Login Packet
+	header 4
+	pid 4
+	*/
+	if (!ch->GetDesc())
+		return;
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 4;
+	pack.subheader = GUILD_SUBHEADER_GC_LOGIN;
+
+	TEMP_BUFFER buf;
+
+	buf.write(&pack, sizeof(pack));
+
+	buf.write(&pid, 4);
+
+	ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+}
+
+void CGuild::SendLogoutPacket(LPCHARACTER ch, LPCHARACTER chLogout)
+{
+	SendLogoutPacket(ch, chLogout->GetPlayerID());
+}
+
+void CGuild::SendLogoutPacket(LPCHARACTER ch, DWORD pid)
+{
+	/*
+	Logout Packet
+	header 4
+	pid 4
+	*/
+	if (!ch->GetDesc())
+		return;
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 4;
+	pack.subheader = GUILD_SUBHEADER_GC_LOGOUT;
+
+	TEMP_BUFFER buf;
+
+	buf.write(&pack, sizeof(pack));
+	buf.write(&pid, 4);
+
+	ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+}
+
+void CGuild::LoadGuildMemberData(SQLMsg* pmsg)
+{
+	if (pmsg->Get()->uiNumRows == 0)
+		return;
+
+	m_general_count = 0;
+
+	m_member.clear();
+
+	for (uint i = 0; i < pmsg->Get()->uiNumRows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+
+		DWORD pid = strtoul(row[0], (char**)NULL, 10);
+		BYTE grade = (BYTE)strtoul(row[1], (char**)NULL, 10);
+		BYTE is_general = 0;
+
+		if (row[2] && *row[2] == '1')
+			is_general = 1;
+
+		DWORD offer = strtoul(row[3], (char**)NULL, 10);
+		BYTE level = (BYTE)strtoul(row[4], (char**)NULL, 10);
+		BYTE job = (BYTE)strtoul(row[5], (char**)NULL, 10);
+		char* name = row[6];
+
+		if (is_general)
+			m_general_count++;
+
+		m_member.insert(std::make_pair(pid, TGuildMember(pid, grade, is_general, job, level, offer, name)));
+		CGuildManager::instance().Link(pid, this);
+	}
+}
+
+void CGuild::LoadGuildGradeData(SQLMsg* pmsg)
+{
+	/*
+	// 15 틈  
+	if (pmsg->Get()->iNumRows != 15)
+	{
+		sys_err("Query failed: getting guild grade data. GuildID(%d)", GetID());
+		return;
+	}
+	*/
+	for (uint i = 0; i < pmsg->Get()->uiNumRows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+		BYTE grade = 0;
+		str_to_number(grade, row[0]);
+		char* name = row[1];
+		DWORD auth = strtoul(row[2], NULL, 10);
+
+		if (grade >= 1 && grade <= 15)
+		{
+			//sys_log(0, "GuildGradeLoad %s", name);
+			strlcpy(m_data.grade_array[grade - 1].grade_name, name, sizeof(m_data.grade_array[grade - 1].grade_name));
+			m_data.grade_array[grade - 1].auth_flag = auth;
+		}
+	}
+}
+void CGuild::LoadGuildData(SQLMsg* pmsg)
+{
+	if (pmsg->Get()->uiNumRows == 0)
+	{
+		sys_err("Query failed: getting guild data %s", pmsg->stQuery.c_str());
+		return;
+	}
+
+	MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+	m_data.master_pid = strtoul(row[0], (char**)NULL, 10);
+	m_data.level = (BYTE)strtoul(row[1], (char**)NULL, 10);
+	m_data.exp = strtoul(row[2], (char**)NULL, 10);
+	strlcpy(m_data.name, row[3], sizeof(m_data.name));
+
+	m_data.skill_point = (BYTE)strtoul(row[4], (char**)NULL, 10);
+	if (row[5])
+		thecore_memcpy(m_data.abySkill, row[5], sizeof(BYTE) * GUILD_SKILL_COUNT);
+	else
+		memset(m_data.abySkill, 0, sizeof(BYTE) * GUILD_SKILL_COUNT);
+
+	m_data.power = MAX(0, strtoul(row[6], (char**)NULL, 10));
+
+	str_to_number(m_data.ladder_point, row[7]);
+
+	if (m_data.ladder_point < 0)
+		m_data.ladder_point = 0;
+
+	str_to_number(m_data.win, row[8]);
+	str_to_number(m_data.draw, row[9]);
+	str_to_number(m_data.loss, row[10]);
+	str_to_number(m_data.gold, row[11]);
+
+	ComputeGuildPoints();
+}
+
+void CGuild::Load(DWORD guild_id)
+{
+	Initialize();
+
+	m_data.guild_id = guild_id;
+
+	DBManager::instance().FuncQuery(std::bind(&CGuild::LoadGuildData, this, std::placeholders::_1),
+		"SELECT master, level, exp, name, skill_point, skill, sp, ladder_point, win, draw, loss, gold"
+		" FROM guild%s WHERE id = %u", get_table_postfix(), m_data.guild_id);
+
+	sys_log(0, "GUILD: loading guild id %12s %u", m_data.name, guild_id);
+
+	DBManager::instance().FuncQuery(std::bind(&CGuild::LoadGuildGradeData, this, std::placeholders::_1),
+		"SELECT grade, name, auth+0 FROM guild_grade%s WHERE guild_id = %u", get_table_postfix(), m_data.guild_id);
+
+	DBManager::instance().FuncQuery(std::bind(&CGuild::LoadGuildMemberData, this, std::placeholders::_1),
+		"SELECT pid, grade, is_general, offer, level, job, name FROM guild_member%s, player%s WHERE guild_id = %u and pid = id", get_table_postfix(), get_table_postfix(), guild_id);
+}
+
+void CGuild::SaveLevel()
+{
+	DBManager::instance().Query("UPDATE guild%s SET level=%d, exp=%u, skill_point=%d WHERE id = %u", get_table_postfix(), m_data.level, m_data.exp, m_data.skill_point, m_data.guild_id);
+}
+
+void CGuild::SendDBSkillUpdate(int amount)
+{
+	TPacketGuildSkillUpdate guild_skill;
+	guild_skill.guild_id = m_data.guild_id;
+	guild_skill.amount = amount;
+	guild_skill.skill_point = m_data.skill_point;
+	thecore_memcpy(guild_skill.skill_levels, m_data.abySkill, sizeof(BYTE) * GUILD_SKILL_COUNT);
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_SKILL_UPDATE, 0, &guild_skill, sizeof(guild_skill));
+}
+
+void CGuild::SaveSkill()
+{
+	char text[GUILD_SKILL_COUNT * 2 + 1];
+
+	DBManager::instance().EscapeString(text, sizeof(text), (const char*)m_data.abySkill, sizeof(m_data.abySkill));
+	DBManager::instance().Query("UPDATE guild%s SET sp = %d, skill_point=%d, skill='%s' WHERE id = %u",
+		get_table_postfix(), m_data.power, m_data.skill_point, text, m_data.guild_id);
+}
+
+TGuildMember* CGuild::GetMember(DWORD pid)
+{
+	TGuildMemberContainer::iterator it = m_member.find(pid);
+	if (it == m_member.end())
+		return NULL;
+
+	return &it->second;
+}
+
+DWORD CGuild::GetMemberPID(const std::string& strName)
+{
+	for (TGuildMemberContainer::iterator iter = m_member.begin(); iter != m_member.end(); iter++)
+	{
+		if (iter->second.name == strName) return iter->first;
+	}
+
+	return 0;
+}
+
+#if defined(__GUILD_LEADER_GRADE_NAME__)
+BYTE CGuild::GetGeneralPID(DWORD pid)
+{
+	for (TGuildMemberContainer::iterator iter = m_member.begin(); iter != m_member.end(); iter++)
+	{
+		if (iter->first == pid)
+			return iter->second.is_general;
+	}
+
+	return 0;
+}
+#endif
+
+void CGuild::__P2PUpdateGrade(SQLMsg* pmsg)
+{
+	if (pmsg->Get()->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+
+		int grade = 0;
+		const char* name = row[1];
+		int auth = 0;
+
+		str_to_number(grade, row[0]);
+		str_to_number(auth, row[2]);
+
+		if (grade <= 0)
+			return;
+
+		grade--;
+
+		//  칭  摸摸 트
+		if (0 != strcmp(m_data.grade_array[grade].grade_name, name))
+		{
+			strlcpy(m_data.grade_array[grade].grade_name, name, sizeof(m_data.grade_array[grade].grade_name));
+
+			TPacketGCGuild pack{};
+
+			pack.header = HEADER_GC_GUILD;
+			pack.size = sizeof(pack);
+			pack.subheader = GUILD_SUBHEADER_GC_GRADE_NAME;
+
+			TOneGradeNamePacket pack2;
+
+			pack.size += sizeof(pack2);
+			pack2.grade = grade + 1;
+			strlcpy(pack2.grade_name, name, sizeof(pack2.grade_name));
+
+			TEMP_BUFFER buf;
+
+			buf.write(&pack, sizeof(pack));
+			buf.write(&pack2, sizeof(pack2));
+
+			for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+			{
+				LPDESC d = (*it)->GetDesc();
+
+				if (d)
+					d->Packet(buf.read_peek(), buf.size());
+			}
+		}
+
+		if (m_data.grade_array[grade].auth_flag != auth)
+		{
+			m_data.grade_array[grade].auth_flag = auth;
+
+			TPacketGCGuild pack{};
+			pack.header = HEADER_GC_GUILD;
+			pack.size = sizeof(pack);
+			pack.subheader = GUILD_SUBHEADER_GC_GRADE_AUTH;
+
+			TOneGradeAuthPacket pack2;
+			pack.size += sizeof(pack2);
+			pack2.grade = grade + 1;
+			pack2.auth = auth;
+
+			TEMP_BUFFER buf;
+			buf.write(&pack, sizeof(pack));
+			buf.write(&pack2, sizeof(pack2));
+
+			for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+			{
+				LPDESC d = (*it)->GetDesc();
+				if (d)
+				{
+					d->Packet(buf.read_peek(), buf.size());
+				}
+			}
+		}
+	}
+}
+
+void CGuild::P2PChangeGrade(BYTE grade)
+{
+	DBManager::instance().FuncQuery(std::bind(&CGuild::__P2PUpdateGrade, this, std::placeholders::_1),
+		"SELECT grade, name, auth+0 FROM guild_grade%s WHERE guild_id = %u and grade = %d", get_table_postfix(), m_data.guild_id, grade);
+}
+
+namespace
+{
+	struct FSendChangeGrade
+	{
+		BYTE grade;
+		TPacketGuild p;
+
+		FSendChangeGrade(DWORD guild_id, BYTE grade) : grade(grade)
+		{
+			p.dwGuild = guild_id;
+			p.dwInfo = grade;
+		}
+
+		void operator()()
+		{
+			db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_GRADE, 0, &p, sizeof(p));
+		}
+	};
+}
+
+void SendChangeGrade(DWORD guild_id, BYTE grade)
+{
+	TPacketGuild p;
+	p.dwGuild = guild_id;
+	p.dwInfo = grade;
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_GRADE, 0, &p, sizeof(p));
+}
+
+void CGuild::ChangeGradeName(BYTE grade, const char* grade_name)
+{
+	if (grade == 1)
+		return;
+
+	if (grade < 1 || grade > 15)
+	{
+		sys_err("Wrong guild grade value %d", grade);
+		return;
+	}
+
+	if (strlen(grade_name) > GUILD_NAME_MAX_LEN)
+		return;
+
+	if (!*grade_name)
+		return;
+
+	char text[GUILD_NAME_MAX_LEN * 2 + 1];
+
+	DBManager::instance().EscapeString(text, sizeof(text), grade_name, strlen(grade_name));
+	DBManager::instance().FuncAfterQuery(std::bind(&SendChangeGrade, GetID(), grade), "UPDATE guild_grade%s SET name = '%s' where guild_id = %u and grade = %d", get_table_postfix(), text, m_data.guild_id, grade);
+
+	grade--;
+	strlcpy(m_data.grade_array[grade].grade_name, grade_name, sizeof(m_data.grade_array[grade].grade_name));
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack);
+	pack.subheader = GUILD_SUBHEADER_GC_GRADE_NAME;
+
+	TOneGradeNamePacket pack2;
+	pack.size += sizeof(pack2);
+	pack2.grade = grade + 1;
+	strlcpy(pack2.grade_name, grade_name, sizeof(pack2.grade_name));
+
+	TEMP_BUFFER buf;
+	buf.write(&pack, sizeof(pack));
+	buf.write(&pack2, sizeof(pack2));
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+
+		if (d)
+			d->Packet(buf.read_peek(), buf.size());
+	}
+}
+
+void CGuild::ChangeGradeAuth(BYTE grade, BYTE auth)
+{
+	if (grade == 1)
+		return;
+
+	if (grade < 1 || grade > 15)
+	{
+		sys_err("Wrong guild grade value %d", grade);
+		return;
+	}
+
+	DBManager::instance().FuncAfterQuery(std::bind(&SendChangeGrade, GetID(), grade), "UPDATE guild_grade%s SET auth = %d where guild_id = %u and grade = %d", get_table_postfix(), auth, m_data.guild_id, grade);
+
+	grade--;
+
+	m_data.grade_array[grade].auth_flag = auth;
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack);
+	pack.subheader = GUILD_SUBHEADER_GC_GRADE_AUTH;
+
+	TOneGradeAuthPacket pack2;
+	pack.size += sizeof(pack2);
+	pack2.grade = grade + 1;
+	pack2.auth = auth;
+
+	TEMP_BUFFER buf;
+	buf.write(&pack, sizeof(pack));
+	buf.write(&pack2, sizeof(pack2));
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+
+		if (d)
+			d->Packet(buf.read_peek(), buf.size());
+	}
+}
+
+void CGuild::SendGuildInfoPacket(LPCHARACTER ch)
+{
+	LPDESC d = ch->GetDesc();
+
+	if (!d)
+		return;
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(TPacketGCGuild) + sizeof(TPacketGCGuildInfo);
+	pack.subheader = GUILD_SUBHEADER_GC_INFO;
+
+	TPacketGCGuildInfo pack_sub;
+
+	memset(&pack_sub, 0, sizeof(TPacketGCGuildInfo));
+	pack_sub.member_count = GetMemberCount();
+	pack_sub.max_member_count = GetMaxMemberCount();
+	pack_sub.guild_id = m_data.guild_id;
+	pack_sub.master_pid = m_data.master_pid;
+	pack_sub.exp = m_data.exp;
+	pack_sub.level = m_data.level;
+	strlcpy(pack_sub.name, m_data.name, sizeof(pack_sub.name));
+	pack_sub.gold = m_data.gold;
+	pack_sub.has_land = HasLand();
+
+	sys_log(0, "GMC guild_name %s", m_data.name);
+	sys_log(0, "GMC master %d", m_data.master_pid);
+
+	d->BufferedPacket(&pack, sizeof(TPacketGCGuild));
+	d->Packet(&pack_sub, sizeof(TPacketGCGuildInfo));
+}
+
+bool CGuild::OfferExp(LPCHARACTER ch, int amount)
+{
+	TGuildMemberContainer::iterator cit = m_member.find(ch->GetPlayerID());
+
+	if (cit == m_member.end())
+		return false;
+
+	if (m_data.exp + amount < m_data.exp)
+		return false;
+
+	if (amount < 0)
+		return false;
+
+	if (ch->GetExp() < (DWORD)amount)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 構 求 치  치 求."));
+		return false;
+	}
+
+	if (ch->GetExp() - (DWORD)amount > ch->GetExp())
+	{
+		sys_err("Wrong guild offer amount %d by %s[%u]", amount, ch->GetName(), ch->GetPlayerID());
+		return false;
+	}
+
+	ch->PointChange(POINT_EXP, -amount);
+
+	TPacketGuildExpUpdate guild_exp;
+	guild_exp.guild_id = GetID();
+	guild_exp.amount = amount / 100;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_EXP_UPDATE, 0, &guild_exp, sizeof(guild_exp));
+	GuildPointChange(POINT_EXP, amount / 100, true);
+
+	cit->second.offer_exp += amount / 100;
+	cit->second._dummy = 0;
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+		if (d)
+		{
+			pack.subheader = GUILD_SUBHEADER_GC_LIST;
+			pack.size = sizeof(pack) + 13;
+			d->BufferedPacket(&pack, sizeof(pack));
+			d->Packet(&(cit->second), sizeof(DWORD) * 3 + 1);
+		}
+	}
+
+	SaveMember(ch->GetPlayerID());
+
+	TPacketGuildChangeMemberData gd_guild;
+
+	gd_guild.guild_id = GetID();
+	gd_guild.pid = ch->GetPlayerID();
+	gd_guild.offer = cit->second.offer_exp;
+	gd_guild.level = ch->GetLevel();
+	gd_guild.grade = cit->second.grade;
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_MEMBER_DATA, 0, &gd_guild, sizeof(gd_guild));
+	return true;
+}
+
+void CGuild::Disband()
+{
+	sys_log(0, "GUILD: Disband %s:%u", GetName(), GetID());
+
+	// building::CLand* pLand = building::CManager::instance().FindLandByGuild(GetID());
+	// if (pLand)
+		// pLand->SetOwner(0);
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPCHARACTER ch = *it;
+		ch->SetGuild(NULL);
+		SendOnlineRemoveOnePacket(ch->GetPlayerID());
+		ch->SetQuestFlag("guild_manage.new_disband_time", get_global_time());
+	}
+
+	for (TGuildMemberContainer::iterator it = m_member.begin(); it != m_member.end(); ++it)
+	{
+		CGuildManager::instance().Unlink(it->first);
+	}
+
+}
+
+void CGuild::RequestDisband(DWORD pid)
+{
+	if (m_data.master_pid != pid)
+		return;
+
+	TPacketGuild gd_guild;
+	gd_guild.dwGuild = GetID();
+	gd_guild.dwInfo = 0;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_DISBAND, 0, &gd_guild, sizeof(TPacketGuild));
+
+	// LAND_CLEAR
+	building::CManager::instance().ClearLandByGuildID(GetID());
+	// END_LAND_CLEAR
+}
+
+void CGuild::AddComment(LPCHARACTER ch, const std::string& str)
+{
+	if (str.length() == 0)
+		return;
+
+	if (str.length() > GUILD_COMMENT_MAX_LEN)
+	{
+		sys_err("POST_COMMENT: %s comment too long (length: %u)", ch->GetName(), str.length());
+		return;
+	}
+
+	if (m_guildPostCommentPulse > thecore_pulse() && !ch->IsGM())
+	{
+		int iDeltaSecs = ((m_guildPostCommentPulse / PASSES_PER_SEC(1)) - (thecore_pulse() / PASSES_PER_SEC(1)));
+		int iMin = iDeltaSecs / 60;
+		int iSec = (iDeltaSecs - (iMin * 60));
+
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can post a new comment in %02d minutes and %02d seconds!", iMin, iSec));
+		return;
+	}
+
+	char text[GUILD_COMMENT_MAX_LEN * 2 + 1];
+	DBManager::instance().EscapeString(text, sizeof(text), str.c_str(), str.length());
+
+	DBManager::instance().FuncAfterQuery(std::bind(&CGuild::RefreshCommentForce, this, ch->GetPlayerID()),
+		"INSERT INTO guild_comment%s(guild_id, name, notice, content, time) VALUES(%u, '%s', %d, '%s', NOW())",
+		get_table_postfix(), m_data.guild_id, ch->GetName(), (str[0] == '!') ? 1 : 0, text);
+
+	m_guildPostCommentPulse = thecore_pulse() + PASSES_PER_SEC(10 * 60);
+}
+
+void CGuild::DeleteComment(LPCHARACTER ch, DWORD comment_id)
+{
+	SQLMsg* pmsg;
+
+	if (pMember->grade == GUILD_LEADER_GRADE)
+		pmsg = DBManager::instance().DirectQuery("DELETE FROM guild_comment%s WHERE id = %u AND guild_id = %u", get_table_postfix(), comment_id, m_data.guild_id);
+	else
+		pmsg = DBManager::instance().DirectQuery("DELETE FROM guild_comment%s WHERE id = %u AND guild_id = %u AND name = '%s'", get_table_postfix(), comment_id, m_data.guild_id, szNameEsc);
+
+	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>    都求."));
+	else
+		RefreshCommentForce(ch->GetPlayerID());
+
+	M2_DELETE(pmsg);
+}
+
+void CGuild::RefreshComment(LPCHARACTER ch)
+{
+	RefreshCommentForce(ch->GetPlayerID());
+}
+
+void CGuild::RefreshCommentForce(DWORD player_id)
+{
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(player_id);
+	if (ch == NULL)
+		return;
+
+	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery("SELECT id, name, content FROM guild_comment%s WHERE guild_id = %u ORDER BY notice DESC, id DESC LIMIT %d", get_table_postfix(), m_data.guild_id, GUILD_COMMENT_MAX_COUNT));
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 1;
+	pack.subheader = GUILD_SUBHEADER_GC_COMMENTS;
+
+	BYTE count = pmsg->Get()->uiNumRows;
+
+	LPDESC d = ch->GetDesc();
+
+	if (!d)
+		return;
+
+	pack.size += (sizeof(DWORD) + CHARACTER_NAME_MAX_LEN + 1 + GUILD_COMMENT_MAX_LEN + 1) * (WORD)count;
+	d->BufferedPacket(&pack, sizeof(pack));
+	d->BufferedPacket(&count, 1);
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	char szContent[GUILD_COMMENT_MAX_LEN + 1];
+	memset(szName, 0, sizeof(szName));
+	memset(szContent, 0, sizeof(szContent));
+
+	for (uint i = 0; i < pmsg->Get()->uiNumRows; i++)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+		DWORD id = strtoul(row[0], NULL, 10);
+
+		strlcpy(szName, row[1], sizeof(szName));
+		strlcpy(szContent, row[2], sizeof(szContent));
+
+		d->BufferedPacket(&id, sizeof(id));
+		d->BufferedPacket(szName, sizeof(szName));
+
+		if (i == pmsg->Get()->uiNumRows - 1)
+			d->Packet(szContent, sizeof(szContent)); //  見 
+		else
+			d->BufferedPacket(szContent, sizeof(szContent));
+	}
+}
+
+bool CGuild::ChangeMemberGeneral(DWORD pid, BYTE is_general)
+{
+#if !defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (is_general && GetGeneralCount() >= GetMaxGeneralCount())
+		return false;
+#endif
+
+	TGuildMemberContainer::iterator it = m_member.find(pid);
+	if (it == m_member.end())
+		return true;
+
+	is_general = is_general ? 1 : 0;
+
+	if (it->second.is_general == is_general)
+		return true;
+
+	if (is_general)
+		++m_general_count;
+	else
+		--m_general_count;
+
+	it->second.is_general = is_general;
+
+	TGuildMemberOnlineContainer::iterator itOnline = m_memberOnline.begin();
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 5;
+	pack.subheader = GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL;
+
+	while (itOnline != m_memberOnline.end())
+	{
+		LPDESC d = (*(itOnline++))->GetDesc();
+
+		if (!d)
+			continue;
+
+		d->BufferedPacket(&pack, sizeof(pack));
+		d->BufferedPacket(&pid, sizeof(pid));
+		d->Packet(&is_general, sizeof(is_general));
+	}
+
+	SaveMember(pid);
+	return true;
+}
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+BYTE CGuild::IsGeneralMember(DWORD pid)
+{
+	TGuildMemberContainer::iterator it = m_member.begin();
+	for (; it != m_member.end(); ++it)
+	{
+		if (it->first == pid)
+			return it->second.is_general;
+	}
+	return 0;
+}
+#endif
+
+void CGuild::ChangeMemberGrade(DWORD pid, BYTE grade)
+{
+	if (grade == 1)
+		return;
+
+	TGuildMemberContainer::iterator it = m_member.find(pid);
+
+	if (it == m_member.end())
+		return;
+
+	it->second.grade = grade;
+
+	TGuildMemberOnlineContainer::iterator itOnline = m_memberOnline.begin();
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 5;
+	pack.subheader = GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE;
+
+	while (itOnline != m_memberOnline.end())
+	{
+		LPDESC d = (*(itOnline++))->GetDesc();
+
+		if (!d)
+			continue;
+
+		d->BufferedPacket(&pack, sizeof(pack));
+		d->BufferedPacket(&pid, sizeof(pid));
+		d->Packet(&grade, sizeof(grade));
+	}
+
+	SaveMember(pid);
+
+	TPacketGuildChangeMemberData gd_guild;
+
+	gd_guild.guild_id = GetID();
+	gd_guild.pid = pid;
+	gd_guild.offer = it->second.offer_exp;
+	gd_guild.level = it->second.level;
+	gd_guild.grade = grade;
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_MEMBER_DATA, 0, &gd_guild, sizeof(gd_guild));
+}
+
+void CGuild::SkillLevelUp(DWORD dwVnum)
+{
+	DWORD dwRealVnum = dwVnum - GUILD_SKILL_START;
+
+	if (dwRealVnum >= GUILD_SKILL_COUNT)
+		return;
+
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+
+	if (!pkSk)
+	{
+		sys_err("There is no such guild skill by number %u", dwVnum);
+		return;
+	}
+
+	if (m_data.abySkill[dwRealVnum] >= pkSk->bMaxLevel)
+		return;
+
+	if (m_data.skill_point <= 0)
+		return;
+	m_data.skill_point--;
+
+	m_data.abySkill[dwRealVnum] ++;
+
+	ComputeGuildPoints();
+	SaveSkill();
+	SendDBSkillUpdate();
+
+	/*
+	switch (dwVnum)
+	{
+	case GUILD_SKILL_GAHO:
+	{
+		TGuildMemberOnlineContainer::iterator it;
+
+		for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+			(*it)->PointChange(POINT_DEF_GRADE, 1);
+	}
+	break;
+	case GUILD_SKILL_HIM:
+	{
+		TGuildMemberOnlineContainer::iterator it;
+
+		for (it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+			(*it)->PointChange(POINT_ATT_GRADE, 1);
+	}
+	break;
+	}
+	*/
+
+	std::for_each(m_memberOnline.begin(), m_memberOnline.end(), std::bind(&CGuild::SendSkillInfoPacket, this, std::placeholders::_1));
+
+	sys_log(0, "Guild SkillUp: %s %d level %d type %u", GetName(), pkSk->dwVnum, m_data.abySkill[dwRealVnum], pkSk->dwType);
+}
+
+void CGuild::UseSkill(DWORD dwVnum, LPCHARACTER ch, DWORD pid)
+{
+	LPCHARACTER victim = NULL;
+
+	if (!GetMember(ch->GetPlayerID()) || !HasGradeAuth(pMember->grade, GUILD_AUTH_USE_SKILL))
+		return;
+
+	sys_log(0, "GUILD_USE_SKILL : cname(%s), skill(%d)", ch ? ch->GetName() : "", dwVnum);
+
+	DWORD dwRealVnum = dwVnum - GUILD_SKILL_START;
+
+	if (ch && !ch->CanMove())
+		return;
+
+	if (dwRealVnum >= GUILD_SKILL_COUNT)
+		return;
+
+	CSkillProto* pkSk = CSkillManager::instance().Get(dwVnum);
+
+	if (!pkSk)
+	{
+		sys_err("There is no such guild skill by number %u", dwVnum);
+		return;
+	}
+
+	if (m_data.abySkill[dwRealVnum] == 0)
+		return;
+
+	if ((pkSk->dwFlag & SKILL_FLAG_SELFONLY))
+	{
+		// 譴  퓐  .
+		if (ch && ch->FindAffect(pkSk->dwVnum))
+			return;
+
+		victim = ch;
+	}
+
+	if ((pkSk->dwFlag & SKILL_FLAG_PARTY))
+	{
+		if (ch && ch->FindAffect(pkSk->dwVnum))
+			return;
+
+		victim = ch;
+	}
+
+	if (ch && ch->IsAffectFlag(AFF_REVIVE_INVISIBLE))
+		ch->RemoveAffect(AFFECT_REVIVE_INVISIBLE);
+
+	if (ch && ch->IsAffectFlag(AFF_EUNHYUNG))
+		ch->RemoveAffect(SKILL_EUNHYUNG);
+
+	double k = 1.0 * m_data.abySkill[dwRealVnum] / pkSk->bMaxLevel;
+	pkSk->kSPCostPoly.SetVar("k", k);
+	int iNeededSP = (int)pkSk->kSPCostPoly.Eval();
+
+	if (GetSP() < iNeededSP)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 킹 爛求. (%d, %d)", GetSP(), iNeededSP));
+		return;
+	}
+
+	pkSk->kCooldownPoly.SetVar("k", k);
+	int iCooltime = (int)pkSk->kCooldownPoly.Eval();
+
+	if (!abSkillUsable[dwRealVnum])
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 타  刻  킬   求."));
+		return;
+	}
+
+	{
+		TPacketGuildUseSkill p;
+		p.dwGuild = GetID();
+		p.dwSkillVnum = pkSk->dwVnum;
+		p.dwCooltime = iCooltime;
+		db_clientdesc->DBPacket(HEADER_GD_GUILD_USE_SKILL, 0, &p, sizeof(p));
+	}
+	abSkillUsable[dwRealVnum] = false;
+	//abSkillUsed[dwRealVnum] = true;
+	//adwSkillNextUseTime[dwRealVnum] = get_dword_time() + iCooltime * 1000;
+
+	//PointChange(POINT_SP, -iNeededSP);
+	//GuildPointChange(POINT_SP, -iNeededSP);
+
+	if (test_server)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> %d 킬  (%d, %d) to %lu", dwVnum, GetSP(), iNeededSP, pid));
+
+	switch (dwVnum)
+	{
+	case GUILD_SKILL_TELEPORT:
+		//   獵   천.
+		SendDBSkillUpdate(-iNeededSP);
+		if ((victim = (CHARACTER_MANAGER::instance().FindByPID(pid))))
+			ch->WarpSet(victim->GetX(), victim->GetY());
+		else
+		{
+			if (m_memberP2POnline.find(pid) != m_memberP2POnline.end())
+			{
+				// 摸  慣琯   -> 聘  표 騁틸
+				// 1. A.pid, B.pid  祺
+				// 2. B.pid   祺 A.pid, 표  
+				// 3. 
+				CCI* pcci = P2P_MANAGER::instance().FindByPID(pid);
+
+				if (pcci->bChannel != g_bChannel)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 諛 %d 채恝 笭求. ( 채 %d)", pcci->bChannel, g_bChannel));
+				}
+				else
+				{
+					TPacketGGFindPosition p;
+					p.header = HEADER_GG_FIND_POSITION;
+					p.dwFromPID = ch ? ch->GetPlayerID() : 0;
+					p.dwTargetPID = pid;
+					pcci->pkDesc->Packet(&p, sizeof(TPacketGGFindPosition));
+					if (test_server) ch->ChatPacket(CHAT_TYPE_PARTY, "sent find position packet for guild teleport");
+				}
+			}
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 諛 쨋 째 틈爛求."));
+		}
+		break;
+
+	/*
+	case GUILD_SKILL_ACCEL:
+		ch->RemoveAffect(dwVnum);
+		ch->AddAffect(dwVnum, POINT_MOV_SPEED, m_data.abySkill[dwRealVnum] * 3, pkSk->dwAffectFlag, (int)pkSk->kDurationPoly.Eval(), 0, false);
+		ch->AddAffect(dwVnum, POINT_ATT_SPEED, m_data.abySkill[dwRealVnum] * 3, pkSk->dwAffectFlag, (int)pkSk->kDurationPoly.Eval(), 0, false);
+		break;
+	*/
+
+	default:
+	{
+		/*
+		if (ch->GetPlayerID() != GetMasterPID())
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 躍  킬   笭求."));
+			return;
+		}
+		*/
+
+		if (!UnderAnyWar())
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  킬  傷   笭求."));
+			return;
+		}
+
+		SendDBSkillUpdate(-iNeededSP);
+
+		for (auto it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+		{
+			LPCHARACTER victim = *it;
+			victim->RemoveAffect(dwVnum);
+			ch->ComputeSkill(dwVnum, victim, m_data.abySkill[dwRealVnum]);
+		}
+	}
+	break;
+
+	/*
+	if (!victim)
+		return;
+
+	ch->ComputeSkill(dwVnum, victim, m_data.abySkill[dwRealVnum]);
+	*/
+
+	}
+}
+
+void CGuild::SendSkillInfoPacket(LPCHARACTER ch) const
+{
+	LPDESC d = ch->GetDesc();
+
+	if (!d)
+		return;
+
+	TPacketGCGuild pack{};
+
+	pack.header = HEADER_GC_GUILD;
+	pack.size = sizeof(pack) + 6 + GUILD_SKILL_COUNT;
+	pack.subheader = GUILD_SUBHEADER_GC_SKILL_INFO;
+
+	d->BufferedPacket(&pack, sizeof(pack));
+	d->BufferedPacket(&m_data.skill_point, 1);
+	d->BufferedPacket(&m_data.abySkill, GUILD_SKILL_COUNT);
+	d->BufferedPacket(&m_data.power, 2);
+	d->Packet(&m_data.max_power, 2);
+}
+
+void CGuild::ComputeGuildPoints()
+{
+	m_data.max_power = GUILD_BASE_POWER + (m_data.level - 1) * GUILD_POWER_PER_LEVEL;
+
+	m_data.power = MINMAX(0, m_data.power, m_data.max_power);
+}
+
+int CGuild::GetSkillLevel(DWORD vnum)
+{
+	DWORD dwRealVnum = vnum - GUILD_SKILL_START;
+
+	if (dwRealVnum >= GUILD_SKILL_COUNT)
+		return 0;
+
+	return m_data.abySkill[dwRealVnum];
+}
+
+/*
+void CGuild::GuildUpdateAffect(LPCHARACTER ch)
+{
+	if (GetSkillLevel(GUILD_SKILL_GAHO))
+		ch->PointChange(POINT_DEF_GRADE, GetSkillLevel(GUILD_SKILL_GAHO));
+
+	if (GetSkillLevel(GUILD_SKILL_HIM))
+		ch->PointChange(POINT_ATT_GRADE, GetSkillLevel(GUILD_SKILL_HIM));
+}
+*/
+
+/*
+void CGuild::GuildRemoveAffect(LPCHARACTER ch)
+{
+	if (GetSkillLevel(GUILD_SKILL_GAHO))
+		ch->PointChange(POINT_DEF_GRADE, -(int)GetSkillLevel(GUILD_SKILL_GAHO));
+
+	if (GetSkillLevel(GUILD_SKILL_HIM))
+		ch->PointChange(POINT_ATT_GRADE, -(int)GetSkillLevel(GUILD_SKILL_HIM));
+}
+*/
+
+void CGuild::UpdateSkill(BYTE skill_point, BYTE* skill_levels)
+{
+	//int iDefMoreBonus = 0;
+	//int iAttMoreBonus = 0;
+
+	m_data.skill_point = skill_point;
+	/*
+	if (skill_levels[GUILD_SKILL_GAHO - GUILD_SKILL_START] != GetSkillLevel(GUILD_SKILL_GAHO))
+	{
+		iDefMoreBonus = skill_levels[GUILD_SKILL_GAHO - GUILD_SKILL_START] - GetSkillLevel(GUILD_SKILL_GAHO);
+	}
+	if (skill_levels[GUILD_SKILL_HIM - GUILD_SKILL_START] != GetSkillLevel(GUILD_SKILL_HIM))
+	{
+		iAttMoreBonus = skill_levels[GUILD_SKILL_HIM - GUILD_SKILL_START] - GetSkillLevel(GUILD_SKILL_HIM);
+	}
+
+	if (iDefMoreBonus || iAttMoreBonus)
+	{
+		for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+		{
+			(*it)->PointChange(POINT_ATT_GRADE, iAttMoreBonus);
+			(*it)->PointChange(POINT_DEF_GRADE, iDefMoreBonus);
+		}
+	}
+	*/
+
+	thecore_memcpy(m_data.abySkill, skill_levels, sizeof(BYTE) * GUILD_SKILL_COUNT);
+	ComputeGuildPoints();
+}
+
+static DWORD __guild_levelup_exp(int level)
+{
+	if (LC_IsYMIR())
+	{
+		return guild_exp_table[level];
+	}
+	else
+	{
+		return guild_exp_table2[level];
+	}
+}
+
+void CGuild::GuildPointChange(BYTE type, int amount, bool save)
+{
+	switch (type)
+	{
+	case POINT_SP:
+		m_data.power += amount;
+
+		m_data.power = MINMAX(0, m_data.power, m_data.max_power);
+
+		if (save)
+		{
+			SaveSkill();
+		}
+
+		for_each(m_memberOnline.begin(), m_memberOnline.end(), std::bind(&CGuild::SendSkillInfoPacket, this, std::placeholders::_1));
+		break;
+
+	case POINT_EXP:
+		if (amount < 0 && m_data.exp < (DWORD)-amount)
+		{
+			m_data.exp = 0;
+		}
+		else
+		{
+			m_data.exp += amount;
+
+			while (m_data.exp >= __guild_levelup_exp(m_data.level))
+			{
+				if (m_data.level < GUILD_MAX_LEVEL)
+				{
+					m_data.exp -= __guild_levelup_exp(m_data.level);
+					++m_data.level;
+					++m_data.skill_point;
+
+					if (m_data.level > GUILD_MAX_LEVEL)
+						m_data.level = GUILD_MAX_LEVEL;
+
+					ComputeGuildPoints();
+					GuildPointChange(POINT_SP, m_data.max_power - m_data.power);
+
+					if (save)
+						ChangeLadderPoint(GUILD_LADDER_POINT_PER_LEVEL);
+
+					// NOTIFY_GUILD_EXP_CHANGE
+					for_each(m_memberOnline.begin(), m_memberOnline.end(), std::bind(&CGuild::SendGuildInfoPacket, this, std::placeholders::_1));
+					// END_OF_NOTIFY_GUILD_EXP_CHANGE
+				}
+
+				if (m_data.level == GUILD_MAX_LEVEL)
+				{
+					m_data.exp = 0;
+				}
+			}
+		}
+
+		TPacketGCGuild pack{};
+		pack.header = HEADER_GC_GUILD;
+		pack.size = sizeof(pack) + 5;
+		pack.subheader = GUILD_SUBHEADER_GC_CHANGE_EXP;
+
+		TEMP_BUFFER buf;
+		buf.write(&pack, sizeof(pack));
+		buf.write(&m_data.level, 1);
+		buf.write(&m_data.exp, 4);
+
+		for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+		{
+			LPDESC d = (*it)->GetDesc();
+
+			if (d)
+				d->Packet(buf.read_peek(), buf.size());
+		}
+
+		if (save)
+			SaveLevel();
+
+		break;
+	}
+}
+
+void CGuild::SkillRecharge()
+{
+	//GuildPointChange(POINT_SP, m_data.max_power / 2);
+	//GuildPointChange(POINT_SP, 10);
+}
+
+void CGuild::SaveMember(DWORD pid)
+{
+	TGuildMemberContainer::iterator it = m_member.find(pid);
+
+	if (it == m_member.end())
+		return;
+
+	DBManager::instance().Query(
+		"UPDATE guild_member%s SET grade = %d, offer = %u, is_general = %d WHERE pid = %u and guild_id = %u",
+		get_table_postfix(), it->second.grade, it->second.offer_exp, it->second.is_general, pid, m_data.guild_id);
+}
+
+void CGuild::LevelChange(DWORD pid, BYTE level)
+{
+	TGuildMemberContainer::iterator cit = m_member.find(pid);
+
+	if (cit == m_member.end())
+		return;
+
+	cit->second.level = level;
+
+	TPacketGuildChangeMemberData gd_guild;
+
+	gd_guild.guild_id = GetID();
+	gd_guild.pid = pid;
+	gd_guild.offer = cit->second.offer_exp;
+	gd_guild.grade = cit->second.grade;
+	gd_guild.level = level;
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_CHANGE_MEMBER_DATA, 0, &gd_guild, sizeof(gd_guild));
+
+	TPacketGCGuild pack{};
+	pack.header = HEADER_GC_GUILD;
+	cit->second._dummy = 0;
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+
+		if (d)
+		{
+			pack.subheader = GUILD_SUBHEADER_GC_LIST;
+			pack.size = sizeof(pack) + 13;
+			d->BufferedPacket(&pack, sizeof(pack));
+			d->Packet(&(cit->second), sizeof(DWORD) * 3 + 1);
+		}
+	}
+}
+
+void CGuild::ChangeMemberData(DWORD pid, DWORD offer, BYTE level, BYTE grade)
+{
+	TGuildMemberContainer::iterator cit = m_member.find(pid);
+
+	if (cit == m_member.end())
+		return;
+
+	cit->second.offer_exp = offer;
+	cit->second.level = level;
+	cit->second.grade = grade;
+	cit->second._dummy = 0;
+
+	TPacketGCGuild pack{};
+	memset(&pack, 0, sizeof(pack));
+	pack.header = HEADER_GC_GUILD;
+
+	for (TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+		if (d)
+		{
+			pack.subheader = GUILD_SUBHEADER_GC_LIST;
+			pack.size = sizeof(pack) + 13;
+			d->BufferedPacket(&pack, sizeof(pack));
+			d->Packet(&(cit->second), sizeof(DWORD) * 3 + 1);
+		}
+	}
+}
+
+namespace
+{
+	struct FGuildChat
+	{
+		const char* c_pszText;
+
+		FGuildChat(const char* c_pszText)
+			: c_pszText(c_pszText)
+		{}
+
+		void operator()(LPCHARACTER ch)
+		{
+			ch->ChatPacket(CHAT_TYPE_GUILD, "%s", c_pszText);
+		}
+	};
+}
+
+void CGuild::P2PChat(const char* c_pszText)
+{
+	std::for_each(m_memberOnline.begin(), m_memberOnline.end(), FGuildChat(c_pszText));
+}
+
+void CGuild::Chat(const char* c_pszText)
+{
+	std::for_each(m_memberOnline.begin(), m_memberOnline.end(), FGuildChat(c_pszText));
+
+	TPacketGGGuild p1;
+	TPacketGGGuildChat p2;
+
+	p1.bHeader = HEADER_GG_GUILD;
+	p1.bSubHeader = GUILD_SUBHEADER_GG_CHAT;
+	p1.dwGuild = GetID();
+	strlcpy(p2.szText, c_pszText, sizeof(p2.szText));
+
+	P2P_MANAGER::instance().Send(&p1, sizeof(TPacketGGGuild));
+	P2P_MANAGER::instance().Send(&p2, sizeof(TPacketGGGuildChat));
+}
+
+LPCHARACTER CGuild::GetMasterCharacter()
+{
+	return CHARACTER_MANAGER::instance().FindByPID(GetMasterPID());
+}
+
+void CGuild::Packet(const void* buf, int size)
+{
+	for (auto it = m_memberOnline.begin(); it!=m_memberOnline.end();++it)
+	{
+		LPDESC d = (*it)->GetDesc();
+
+		if (d)
+			d->Packet(buf, size);
+	}
+}
+
+int CGuild::GetTotalLevel() const
+{
+	int total = 0;
+
+	for (auto it = m_member.begin(); it != m_member.end(); ++it)
+	{
+		total += it->second.level;
+	}
+
+	return total;
+}
+
+bool CGuild::ChargeSP(LPCHARACTER ch, int iSP)
+{
+	int gold = iSP * 100;
+
+	if (gold < iSP || ch->GetGold() < gold)
+		return false;
+
+	int iRemainSP = m_data.max_power - m_data.power;
+
+	if (iSP > iRemainSP)
+	{
+		iSP = iRemainSP;
+		gold = iSP * 100;
+	}
+
+	ch->PointChange(POINT_GOLD, -gold);
+	DBManager::instance().SendMoneyLog(MONEY_LOG_GUILD, 1, -gold);
+
+	SendDBSkillUpdate(iSP);
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> %lu 킹 회臼求.", iSP));
+	}
+	return true;
+}
+
+void CGuild::SkillUsableChange(DWORD dwSkillVnum, bool bUsable)
+{
+	DWORD dwRealVnum = dwSkillVnum - GUILD_SKILL_START;
+
+	if (dwRealVnum >= GUILD_SKILL_COUNT)
+		return;
+
+	abSkillUsable[dwRealVnum] = bUsable;
+
+	// GUILD_SKILL_COOLTIME_BUG_FIX
+	sys_log(0, "CGuild::SkillUsableChange(guild=%s, skill=%d, usable=%d)", GetName(), dwSkillVnum, bUsable);
+	// END_OF_GUILD_SKILL_COOLTIME_BUG_FIX
+}
+
+// GUILD_MEMBER_COUNT_BONUS
+void CGuild::SetMemberCountBonus(int iBonus)
+{
+	m_iMemberCountBonus = iBonus;
+	sys_log(0, "GUILD_IS_FULL_BUG : Bonus set to %d(val:%d)", iBonus, m_iMemberCountBonus);
+}
+
+void CGuild::BroadcastMemberCountBonus()
+{
+	TPacketGGGuild p1;
+
+	p1.bHeader = HEADER_GG_GUILD;
+	p1.bSubHeader = GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS;
+	p1.dwGuild = GetID();
+
+	P2P_MANAGER::instance().Send(&p1, sizeof(TPacketGGGuild));
+	P2P_MANAGER::instance().Send(&m_iMemberCountBonus, sizeof(int));
+}
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+int CGuild::GetNearMemberCount(LPCHARACTER ch)
+{
+	int count = 0;
+
+	TGuildMemberOnlineContainer::iterator it = m_memberOnline.begin();;
+	for (; it != m_memberOnline.end(); ++it)
+	{
+		LPCHARACTER member = *it;
+		if (member == NULL)
+			continue;
+
+		if (ch->GetMapIndex() != member->GetMapIndex())
+			continue;
+
+		if (DISTANCE_APPROX(ch->GetX() - member->GetX(), ch->GetY() - member->GetY()) < 1000)
+			++count;
+	}
+
+	return count;
+}
+#endif
+
+int CGuild::GetMaxMemberCount()
+{
+	// GUILD_IS_FULL_BUG_FIX
+	if (m_iMemberCountBonus < 0 || m_iMemberCountBonus > 18)
+		m_iMemberCountBonus = 0;
+	// END_GUILD_IS_FULL_BUG_FIX
+
+	if (LC_IsHongKong() == true)
+	{
+		quest::PC* pPC = quest::CQuestManager::instance().GetPC(GetMasterPID());
+
+		if (pPC != NULL)
+		{
+			if (pPC->GetFlag("guild.is_unlimit_member") == 1)
+			{
+				return INT_MAX;
+			}
+		}
+	}
+
+	return 32 + 2 * (m_data.level - 1) + m_iMemberCountBonus;
+}
+// END_OF_GUILD_MEMBER_COUNT_BONUS
+
+void CGuild::AdvanceLevel(int iLevel)
+{
+	if (m_data.level == iLevel)
+		return;
+
+	m_data.level = MIN(GUILD_MAX_LEVEL, iLevel);
+}
+
+void CGuild::RequestDepositMoney(LPCHARACTER ch, int iGold)
+{
+	if (false == ch->CanDeposit())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 커 結笭駕첼"));
+		return;
+	}
+	if (iGold <= 0)
+		return;
+
+
+	if (ch->GetGold() < iGold)
+		return;
+
+	ch->PointChange(POINT_GOLD, -iGold);
+
+	TPacketGDGuildMoney p;
+	p.dwGuild = GetID();
+	p.iGold = iGold;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_DEPOSIT_MONEY, 0, &p, sizeof(p));
+
+	char buf[64 + 1];
+	snprintf(buf, sizeof(buf), "%u %s", GetID(), GetName());
+	LogManager::instance().CharLog(ch, iGold, "GUILD_DEPOSIT", buf);
+
+	ch->UpdateDepositPulse();
+	sys_log(0, "GUILD: DEPOSIT %s:%u player %s[%u] gold %d", GetName(), GetID(), ch->GetName(), ch->GetPlayerID(), iGold);
+}
+
+void CGuild::RequestWithdrawMoney(LPCHARACTER ch, int iGold)
+{
+	if (false == ch->CanDeposit())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 커 結笭駕첼"));
+		return;
+	}
+	if (iGold <= 0)
+		return;
+
+
+	if (ch->GetPlayerID() != GetMasterPID())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  腑 躍   笭求."));
+		return;
+	}
+
+	if (m_data.gold < iGold)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  獵  爛求."));
+		return;
+	}
+
+	TPacketGDGuildMoney p;
+	p.dwGuild = GetID();
+	p.iGold = iGold;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_WITHDRAW_MONEY, 0, &p, sizeof(p));
+
+	ch->UpdateDepositPulse();
+}
+
+void CGuild::RecvMoneyChange(int iGold)
+{
+	if (iGold < 0)
+		iGold = 0;
+
+	m_data.gold = iGold;
+
+	TPacketGCGuild p;
+	p.header = HEADER_GC_GUILD;
+	p.size = sizeof(p) + sizeof(int);
+	p.subheader = GUILD_SUBHEADER_GC_MONEY_CHANGE;
+
+	for (auto it = m_memberOnline.begin(); it != m_memberOnline.end(); ++it)
+	{
+		LPCHARACTER ch = *it;
+		LPDESC d = ch->GetDesc();
+		d->BufferedPacket(&p, sizeof(p));
+		d->Packet(&iGold, sizeof(int));
+	}
+}
+
+void CGuild::RecvWithdrawMoneyGive(int iChangeGold)
+{
+	LPCHARACTER ch = GetMasterCharacter();
+
+	if (ch)
+	{
+		ch->PointChange(POINT_GOLD, iChangeGold);
+		sys_log(0, "GUILD: WITHDRAW %s:%u player %s[%u] gold %d", GetName(), GetID(), ch->GetName(), ch->GetPlayerID(), iChangeGold);
+	}
+
+	TPacketGDGuildMoneyWithdrawGiveReply p;
+	p.dwGuild = GetID();
+	p.iChangeGold = iChangeGold;
+	p.bGiveSuccess = ch ? 1 : 0;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY, 0, &p, sizeof(p));
+}
+
+bool CGuild::HasLand()
+{
+	return building::CManager::instance().FindLandByGuild(GetID()) != NULL;
+}
+
+// GUILD_JOIN_BUG_FIX
+///  苛 event 
+EVENTINFO(TInviteGuildEventInfo)
+{
+	DWORD dwInviteePID; ///< 苛 character  PID
+	DWORD dwGuildID; ///< 苛 Guild  ID
+
+	TInviteGuildEventInfo()
+		: dwInviteePID(0)
+		, dwGuildID(0)
+	{
+	}
+};
+
+/**
+ *  苛 event callback 獨.
+ * event  森玖 苛  처磯.
+ */
+EVENTFUNC(GuildInviteEvent)
+{
+	TInviteGuildEventInfo* pInfo = dynamic_cast<TInviteGuildEventInfo*>(event->info);
+
+	if (pInfo == NULL)
+	{
+		sys_err("GuildInviteEvent> <Factor> Null pointer");
+		return 0;
+	}
+
+	CGuild* pGuild = CGuildManager::instance().FindGuild(pInfo->dwGuildID);
+
+	if (pGuild)
+	{
+		sys_log(0, "GuildInviteEvent %s", pGuild->GetName());
+		pGuild->InviteDeny(pInfo->dwInviteePID);
+	}
+
+	return 0;
+}
+
+void CGuild::Invite(LPCHARACTER pchInviter, LPCHARACTER pchInvitee)
+{
+	if (quest::CQuestManager::instance().GetPCForce(pchInviter->GetPlayerID())->IsRunning() == true)
+	{
+		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  苛 청    都求."));
+		return;
+	}
+
+	if (quest::CQuestManager::instance().GetPCForce(pchInvitee->GetPlayerID())->IsRunning() == true)
+		return;
+
+	if (pchInvitee->IsBlockMode(BLOCK_GUILD_INVITE))
+	{
+		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   苛 탄 都求."));
+		return;
+	}
+	else if (!HasGradeAuth(GetMember(pchInviter->GetPlayerID())->grade, GUILD_AUTH_ADD_MEMBER))
+	{
+		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  苛  求."));
+		return;
+	}
+	else if (pchInvitee->GetEmpire() != pchInviter->GetEmpire())
+	{
+		pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 摸   恙 苛  求."));
+		return;
+	}
+
+	GuildJoinErrCode errcode = VerifyGuildJoinableCondition(pchInvitee);
+	switch (errcode)
+	{
+	case GERR_NONE: break;
+	case GERR_WITHDRAWPENALTY:
+		pchInviter->ChatPacket(CHAT_TYPE_INFO,
+			LC_STRING("<> 탈  %d    恙 苛  求.",
+			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
+		return;
+	case GERR_COMMISSIONPENALTY:
+		pchInviter->ChatPacket(CHAT_TYPE_INFO,
+			LC_STRING("<> 躍 滿  %d    恙 苛  求.",
+			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
+		return;
+	case GERR_ALREADYJOIN:	pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  譴 摸 恙 笭求.")); return;
+	case GERR_GUILDISFULL:	pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 獵   歌颯求.")); return;
+	case GERR_GUILD_IS_IN_WAR: pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  弱   都求.")); return;
+	case GERR_INVITE_LIMIT: pchInviter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  킥    都求.")); return;
+
+	default: sys_err("ignore guild join error(%d)", errcode); return;
+	}
+
+	if (m_GuildInviteEventMap.end() != m_GuildInviteEventMap.find(pchInvitee->GetPlayerID()))
+		return;
+
+	//
+	// 遣트 
+	// 
+	TInviteGuildEventInfo* pInfo = AllocEventInfo<TInviteGuildEventInfo>();
+	pInfo->dwInviteePID = pchInvitee->GetPlayerID();
+	pInfo->dwGuildID = GetID();
+
+	m_GuildInviteEventMap.insert(EventMap::value_type(pchInvitee->GetPlayerID(), event_create(GuildInviteEvent, pInfo, PASSES_PER_SEC(10))));
+
+	//
+	// 苛 濱 character  苛 킷 
+	// 
+
+	DWORD gid = GetID();
+
+	TPacketGCGuild p{};
+	p.header = HEADER_GC_GUILD;
+	p.size = sizeof(p) + sizeof(DWORD) + GUILD_NAME_MAX_LEN + 1;
+	p.subheader = GUILD_SUBHEADER_GC_GUILD_INVITE;
+
+	TEMP_BUFFER buf;
+	buf.write(&p, sizeof(p));
+	buf.write(&gid, sizeof(DWORD));
+	buf.write(GetName(), GUILD_NAME_MAX_LEN + 1);
+
+	pchInvitee->GetDesc()->Packet(buf.read_peek(), buf.size());
+}
+
+void CGuild::InviteAccept(LPCHARACTER pchInvitee)
+{
+	EventMap::iterator itFind = m_GuildInviteEventMap.find(pchInvitee->GetPlayerID());
+	if (itFind == m_GuildInviteEventMap.end())
+	{
+		sys_log(0, "GuildInviteAccept from not invited character(invite guild: %s, invitee: %s)", GetName(), pchInvitee->GetName());
+		return;
+	}
+
+	event_cancel(&itFind->second);
+	m_GuildInviteEventMap.erase(itFind);
+
+	GuildJoinErrCode errcode = VerifyGuildJoinableCondition(pchInvitee);
+	switch (errcode)
+	{
+	case GERR_NONE: break;
+	case GERR_WITHDRAWPENALTY:
+		pchInvitee->ChatPacket(CHAT_TYPE_INFO,
+			LC_STRING("<> 탈  %d    恙 苛  求.",
+			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
+		return;
+	case GERR_COMMISSIONPENALTY:
+		pchInvitee->ChatPacket(CHAT_TYPE_INFO,
+			LC_STRING("<> 躍 滿  %d    恙 苛  求.",
+			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
+		return;
+	case GERR_ALREADYJOIN:	pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  譴 摸 恙 笭求.")); return;
+	case GERR_GUILDISFULL:	pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 獵   歌颯求.")); return;
+	case GERR_GUILD_IS_IN_WAR: pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  弱   都求.")); return;
+	case GERR_INVITE_LIMIT: pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  킥    都求.")); return;
+
+	default: sys_err("ignore guild join error(%d)", errcode); return;
+	}
+
+	RequestAddMember(pchInvitee, 15);
+}
+
+void CGuild::InviteDeny(DWORD dwPID)
+{
+	EventMap::iterator itFind = m_GuildInviteEventMap.find(dwPID);
+	if (itFind == m_GuildInviteEventMap.end())
+	{
+		sys_log(0, "GuildInviteDeny from not invited character(invite guild: %s, invitee PID: %d)", GetName(), dwPID);
+		return;
+	}
+
+	event_cancel(&itFind->second);
+	m_GuildInviteEventMap.erase(itFind);
+}
+
+CGuild::GuildJoinErrCode CGuild::VerifyGuildJoinableCondition(const LPCHARACTER pchInvitee)
+{
+	if (get_global_time() - pchInvitee->GetQuestFlag("guild_manage.new_withdraw_time")
+		< CGuildManager::instance().GetWithdrawDelay())
+		return GERR_WITHDRAWPENALTY;
+	else if (get_global_time() - pchInvitee->GetQuestFlag("guild_manage.new_disband_time")
+		< CGuildManager::instance().GetDisbandDelay())
+		return GERR_COMMISSIONPENALTY;
+	else if (pchInvitee->GetGuild())
+		return GERR_ALREADYJOIN;
+	else if (GetMemberCount() >= GetMaxMemberCount())
+	{
+		sys_log(1, "GuildName = %s, GetMemberCount() = %d, GetMaxMemberCount() = %d (32 + MAX(level(%d)-10, 0) * 2 + bonus(%d)",
+			GetName(), GetMemberCount(), GetMaxMemberCount(), m_data.level, m_iMemberCountBonus);
+		return GERR_GUILDISFULL;
+	}
+	else if (UnderAnyWar() != 0)
+	{
+		return GERR_GUILD_IS_IN_WAR;
+	}
+	else if (LC_IsBrazil() == true)
+	{
+		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT value FROM guild_invite_limit WHERE id=%d", GetID()));
+
+		if (pMsg->Get()->uiNumRows > 0)
+		{
+			MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+			time_t limit_time = 0;
+			str_to_number(limit_time, row[0]);
+
+			if (test_server == true)
+			{
+				limit_time += quest::CQuestManager::instance().GetEventFlag("guild_invite_limit") * 60;
+			}
+			else
+			{
+				limit_time += quest::CQuestManager::instance().GetEventFlag("guild_invite_limit") * 24 * 60 * 60;
+			}
+
+			if (get_global_time() < limit_time) return GERR_INVITE_LIMIT;
+		}
+	}
+
+	return GERR_NONE;
+}
+// END_OF_GUILD_JOIN_BUG_FIX
+
+bool CGuild::ChangeMasterTo(DWORD dwPID)
+{
+	if (GetMember(dwPID) == NULL) return false;
+
+	TPacketChangeGuildMaster p;
+	p.dwGuildID = GetID();
+	p.idFrom = GetMasterPID();
+	p.idTo = dwPID;
+
+	db_clientdesc->DBPacket(HEADER_GD_REQ_CHANGE_GUILD_MASTER, 0, &p, sizeof(p));
+
+	return true;
+}
+
+void CGuild::SendGuildDataUpdateToAllMember(SQLMsg* pmsg)
+{
+	TGuildMemberOnlineContainer::iterator iter = m_memberOnline.begin();
+
+	for (; iter != m_memberOnline.end(); iter++)
+	{
+		SendGuildInfoPacket(*iter);
+		SendAllGradePacket(*iter);
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/guild_manager.cpp b/server/metin2/Source/Server/game/src/guild_manager.cpp
index 4756364..1ac06b4 100644
--- a/server/metin2/Source/Server/game/src/guild_manager.cpp
+++ b/server/metin2/Source/Server/game/src/guild_manager.cpp
@@ -1,1025 +1,1065 @@
-#include "stdafx.h"
-#include "constants.h"
-#include "utils.h"
-#include "config.h"
-#include "log.h"
-#include "char.h"
-#include "db.h"
-#include "lzo_manager.h"
-#include "desc_client.h"
-#include "buffer_manager.h"
-#include "char_manager.h"
-#include "packet.h"
-#include "war_map.h"
-#include "questmanager.h"
-#include "locale_service.h"
-#include "guild_manager.h"
-#include "MarkManager.h"
-
-namespace
-{
-	struct FGuildNameSender
-	{
-		FGuildNameSender(DWORD id, const char* guild_name) : id(id), name(guild_name)
-		{
-			p.header = HEADER_GC_GUILD;
-			p.subheader = GUILD_SUBHEADER_GC_GUILD_NAME;
-			p.size = sizeof(p) + GUILD_NAME_MAX_LEN + sizeof(DWORD);
-		}
-
-		void operator()(LPCHARACTER ch)
-		{
-			LPDESC d = ch->GetDesc();
-
-			if (d)
-			{
-				d->BufferedPacket(&p, sizeof(p));
-				d->BufferedPacket(&id, sizeof(id));
-				d->Packet(name, GUILD_NAME_MAX_LEN);
-			}
-		}
-
-		DWORD id;
-		const char* name;
-		TPacketGCGuild p;
-	};
-}
-
-CGuildManager::CGuildManager()
-{
-}
-
-CGuildManager::~CGuildManager()
-{
-	for( TGuildMap::const_iterator iter = m_mapGuild.begin() ; iter != m_mapGuild.end() ; ++iter )
-	{
-		M2_DELETE(iter->second);
-	}
-
-	m_mapGuild.clear();
-}
-
-int CGuildManager::GetDisbandDelay()
-{
-	return quest::CQuestManager::instance().GetEventFlag("guild_disband_delay") * (test_server ? 60 : 86400);
-}
-
-int CGuildManager::GetWithdrawDelay()
-{
-	return quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay") * (test_server ? 60 : 86400);
-}
-
-DWORD CGuildManager::CreateGuild(TGuildCreateParameter& gcp)
-{
-	if (!gcp.master)
-		return 0;
-
-	if (!check_name(gcp.name))
-	{
-		gcp.master->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드 이름이 적합하지 않습니다."));
-		return 0;
-	}
-
-	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM guild%s WHERE name = '%s'",
-		get_table_postfix(), gcp.name));
-
-	if (pmsg->Get()->uiNumRows > 0)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-
-		if (!(row[0] && row[0][0] == '0'))
-		{
-			gcp.master->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 이미 같은 이름의 길드가 있습니다."));
-			return 0;
-		}
-	}
-	else
-	{
-		gcp.master->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드를 생성할 수 없습니다."));
-		return 0;
-	}
-
-	// new CGuild(gcp) queries guild tables and tell dbcache to notice other game servers.
-	// other game server calls CGuildManager::LoadGuild to load guild.
-	CGuild* pg = M2_NEW CGuild(gcp);
-	m_mapGuild.insert(std::make_pair(pg->GetID(), pg));
-	return pg->GetID();
-}
-
-void CGuildManager::Unlink(DWORD pid)
-{
-	m_map_pkGuildByPID.erase(pid);
-}
-
-CGuild* CGuildManager::GetLinkedGuild(DWORD pid)
-{
-	TGuildMap::iterator it = m_map_pkGuildByPID.find(pid);
-
-	if (it == m_map_pkGuildByPID.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CGuildManager::Link(DWORD pid, CGuild* guild)
-{
-	if (m_map_pkGuildByPID.find(pid) == m_map_pkGuildByPID.end())
-		m_map_pkGuildByPID.insert(std::make_pair(pid, guild));
-}
-
-void CGuildManager::P2PLogoutMember(DWORD pid)
-{
-	TGuildMap::iterator it = m_map_pkGuildByPID.find(pid);
-
-	if (it != m_map_pkGuildByPID.end())
-	{
-		it->second->P2PLogoutMember(pid);
-	}
-}
-
-void CGuildManager::P2PLoginMember(DWORD pid)
-{
-	TGuildMap::iterator it = m_map_pkGuildByPID.find(pid);
-
-	if (it != m_map_pkGuildByPID.end())
-	{
-		it->second->P2PLoginMember(pid);
-	}
-}
-
-void CGuildManager::LoginMember(LPCHARACTER ch)
-{
-	TGuildMap::iterator it = m_map_pkGuildByPID.find(ch->GetPlayerID());
-
-	if (it != m_map_pkGuildByPID.end())
-	{
-		it->second->LoginMember(ch);
-	}
-}
-
-CGuild* CGuildManager::TouchGuild(DWORD guild_id)
-{
-	TGuildMap::iterator it = m_mapGuild.find(guild_id);
-
-	if (it == m_mapGuild.end())
-	{
-		m_mapGuild.insert(std::make_pair(guild_id, M2_NEW CGuild(guild_id)));
-		it = m_mapGuild.find(guild_id);
-
-		CHARACTER_MANAGER::instance().for_each_pc(FGuildNameSender(guild_id, it->second->GetName()));
-	}
-
-	return it->second;
-}
-
-CGuild* CGuildManager::FindGuild(DWORD guild_id)
-{
-	TGuildMap::iterator it = m_mapGuild.find(guild_id);
-	if (it == m_mapGuild.end())
-	{
-		return NULL;
-	}
-	return it->second;
-}
-
-CGuild* CGuildManager::FindGuildByName(const std::string guild_name)
-{
-	auto it = m_mapGuild.begin();
-	for (; it!=m_mapGuild.end(); ++it)
-	{
-		if (it->second->GetName() == guild_name)
-			return it->second;
-	}
-	return NULL;
-}
-
-void CGuildManager::Initialize()
-{
-	sys_log(0, "Initializing Guild");
-
-	if (g_bAuthServer)
-	{
-		sys_log(0, "	No need for auth server");
-		return;
-	}
-
-	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery("SELECT id FROM guild%s", get_table_postfix()));
-
-	std::vector<DWORD> vecGuildID;
-	vecGuildID.reserve(pmsg->Get()->uiNumRows);
-
-	for (uint i = 0; i < pmsg->Get()->uiNumRows; i++)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-		DWORD guild_id = strtoul(row[0], (char**)NULL, 10);
-		LoadGuild(guild_id);
-
-		vecGuildID.push_back(guild_id);
-	}
-
-	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
-
-	rkMarkMgr.SetMarkPathPrefix("mark");
-
-	extern bool GuildMarkConvert(const std::vector<DWORD> & vecGuildID);
-	GuildMarkConvert(vecGuildID);
-
-	rkMarkMgr.LoadMarkIndex();
-	rkMarkMgr.LoadMarkImages();
-	rkMarkMgr.LoadSymbol(GUILD_SYMBOL_FILENAME);
-}
-
-void CGuildManager::LoadGuild(DWORD guild_id)
-{
-	TGuildMap::iterator it = m_mapGuild.find(guild_id);
-
-	if (it == m_mapGuild.end())
-	{
-		m_mapGuild.insert(std::make_pair(guild_id, M2_NEW CGuild(guild_id)));
-	}
-	else
-	{
-		//it->second->Load(guild_id);
-	}
-}
-
-void CGuildManager::DisbandGuild(DWORD guild_id)
-{
-	TGuildMap::iterator it = m_mapGuild.find(guild_id);
-
-	if (it == m_mapGuild.end())
-		return;
-
-	it->second->Disband();
-
-	M2_DELETE(it->second);
-	m_mapGuild.erase(it);
-
-	CGuildMarkManager::instance().DeleteMark(guild_id);
-}
-
-void CGuildManager::SkillRecharge()
-{
-	for (TGuildMap::iterator it = m_mapGuild.begin(); it != m_mapGuild.end(); ++it)
-	{
-		it->second->SkillRecharge();
-	}
-}
-
-int CGuildManager::GetRank(CGuild* g)
-{
-	int point = g->GetLadderPoint();
-	int rank = 1;
-
-	for (auto it = m_mapGuild.begin(); it != m_mapGuild.end();++it)
-	{
-		CGuild* pg = it->second;
-
-		if (pg->GetLadderPoint() > point)
-			rank++;
-	}
-
-	return rank;
-}
-
-static auto SortGuild(std::vector<CGuild*>& v)
-{
-	std::sort(v.begin(), v.end(), [](const CGuild* g1, const CGuild* g2)
-	{
-		if (g1->GetLadderPoint() < g2->GetLadderPoint())
-			return 1;
-		if (g1->GetLadderPoint() > g2->GetLadderPoint())
-			return 0;
-		if (g1->GetGuildWarWinCount() < g2->GetGuildWarWinCount())
-			return 1;
-		if (g1->GetGuildWarWinCount() > g2->GetGuildWarWinCount())
-			return 0;
-		if (g1->GetGuildWarLossCount() < g2->GetGuildWarLossCount())
-			return 1;
-		if (g1->GetGuildWarLossCount() > g2->GetGuildWarLossCount())
-			return 0;
-		const int c = strcmp(g1->GetName(), g2->GetName());
-		if (c > 0)
-			return 1;
-		return 0;
-		});
-}
-
-void CGuildManager::GetHighRankString(DWORD dwMyGuild, char* buffer, size_t buflen)
-{
-	using namespace std;
-	vector<CGuild*> v;
-
-	for (auto it = m_mapGuild.begin(); it != m_mapGuild.end(); ++it)
-	{
-		if (it->second)
-			v.push_back(it->second);
-	}
-
-	SortGuild(v);
-	int n = v.size();
-	int len = 0, len2;
-	*buffer = '\0';
-
-	for (int i = 0; i < 8; ++i)
-	{
-		if (n - i - 1 < 0)
-			break;
-
-		CGuild* g = v[n - i - 1];
-
-		if (!g)
-			continue;
-
-		if (g->GetLadderPoint() <= 0)
-			break;
-
-		if (dwMyGuild == g->GetID())
-		{
-			len2 = snprintf(buffer + len, buflen - len, "[COLOR r;255|g;255|b;0]");
-
-			if (len2 < 0 || len2 >= (int)buflen - len)
-				len += (buflen - len) - 1;
-			else
-				len += len2;
-		}
-
-		if (i)
-		{
-			len2 = snprintf(buffer + len, buflen - len, "[ENTER]");
-
-			if (len2 < 0 || len2 >= (int)buflen - len)
-				len += (buflen - len) - 1;
-			else
-				len += len2;
-		}
-
-		len2 = snprintf(buffer + len, buflen - len, "%3d | %-12s | %-8d | %4d | %4d | %4d",
-			GetRank(g),
-			g->GetName(),
-			g->GetLadderPoint(),
-			g->GetGuildWarWinCount(),
-			g->GetGuildWarDrawCount(),
-			g->GetGuildWarLossCount());
-
-		if (len2 < 0 || len2 >= (int)buflen - len)
-			len += (buflen - len) - 1;
-		else
-			len += len2;
-
-		if (g->GetID() == dwMyGuild)
-		{
-			len2 = snprintf(buffer + len, buflen - len, "[/COLOR]");
-
-			if (len2 < 0 || len2 >= (int)buflen - len)
-				len += (buflen - len) - 1;
-			else
-				len += len2;
-		}
-	}
-}
-
-void CGuildManager::GetAroundRankString(DWORD dwMyGuild, char* buffer, size_t buflen)
-{
-	using namespace std;
-	vector<CGuild*> v;
-
-	for (auto it = m_mapGuild.begin(); it != m_mapGuild.end(); ++it)
-	{
-		if (it->second)
-			v.push_back(it->second);
-	}
-
-	SortGuild(v);
-	int n = v.size();
-	int idx;
-
-	for (idx = 0; idx < (int)v.size(); ++idx)
-		if (v[idx]->GetID() == dwMyGuild)
-			break;
-
-	int len = 0, len2;
-	int count = 0;
-	*buffer = '\0';
-
-	for (int i = -3; i <= 3; ++i)
-	{
-		if (idx - i < 0)
-			continue;
-
-		if (idx - i >= n)
-			continue;
-
-		CGuild* g = v[idx - i];
-
-		if (!g)
-			continue;
-
-		if (dwMyGuild == g->GetID())
-		{
-			len2 = snprintf(buffer + len, buflen - len, "[COLOR r;255|g;255|b;0]");
-
-			if (len2 < 0 || len2 >= (int)buflen - len)
-				len += (buflen - len) - 1;
-			else
-				len += len2;
-		}
-
-		if (count)
-		{
-			len2 = snprintf(buffer + len, buflen - len, "[ENTER]");
-
-			if (len2 < 0 || len2 >= (int)buflen - len)
-				len += (buflen - len) - 1;
-			else
-				len += len2;
-		}
-
-		len2 = snprintf(buffer + len, buflen - len, "%3d | %-12s | %-8d | %4d | %4d | %4d",
-			GetRank(g),
-			g->GetName(),
-			g->GetLadderPoint(),
-			g->GetGuildWarWinCount(),
-			g->GetGuildWarDrawCount(),
-			g->GetGuildWarLossCount());
-
-		if (len2 < 0 || len2 >= (int)buflen - len)
-			len += (buflen - len) - 1;
-		else
-			len += len2;
-
-		++count;
-
-		if (g->GetID() == dwMyGuild)
-		{
-			len2 = snprintf(buffer + len, buflen - len, "[/COLOR]");
-
-			if (len2 < 0 || len2 >= (int)buflen - len)
-				len += (buflen - len) - 1;
-			else
-				len += len2;
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// Guild War
-/////////////////////////////////////////////////////////////////////
-void CGuildManager::RequestCancelWar(DWORD guild_id1, DWORD guild_id2)
-{
-	sys_log(0, "RequestCancelWar %d %d", guild_id1, guild_id2);
-
-	TPacketGuildWar p;
-	p.bWar = GUILD_WAR_CANCEL;
-	p.dwGuildFrom = guild_id1;
-	p.dwGuildTo = guild_id2;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR, 0, &p, sizeof(p));
-}
-
-void CGuildManager::RequestEndWar(DWORD guild_id1, DWORD guild_id2)
-{
-	sys_log(0, "RequestEndWar %d %d", guild_id1, guild_id2);
-
-	TPacketGuildWar p;
-	p.bWar = GUILD_WAR_END;
-	p.dwGuildFrom = guild_id1;
-	p.dwGuildTo = guild_id2;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR, 0, &p, sizeof(p));
-}
-
-void CGuildManager::RequestWarOver(DWORD dwGuild1, DWORD dwGuild2, DWORD dwGuildWinner, long lReward)
-{
-	CGuild* g1 = TouchGuild(dwGuild1);
-	CGuild* g2 = TouchGuild(dwGuild2);
-
-	if (g1->GetGuildWarState(g2->GetID()) != GUILD_WAR_ON_WAR)
-	{
-		sys_log(0, "RequestWarOver : both guild was not in war %u %u", dwGuild1, dwGuild2);
-		RequestEndWar(dwGuild1, dwGuild2);
-		return;
-	}
-
-	TPacketGuildWar p;
-
-	p.bWar = GUILD_WAR_OVER;
-	// 길드전이 끝나도 보상은 없다.
-	//p.lWarPrice = lReward;
-	p.lWarPrice = 0;
-	p.bType = dwGuildWinner == 0 ? 1 : 0; // bType == 1 means draw for this packet.
-
-	if (dwGuildWinner == 0)
-	{
-		p.dwGuildFrom = dwGuild1;
-		p.dwGuildTo = dwGuild2;
-	}
-	else
-	{
-		p.dwGuildFrom = dwGuildWinner;
-		p.dwGuildTo = dwGuildWinner == dwGuild1 ? dwGuild2 : dwGuild1;
-	}
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR, 0, &p, sizeof(p));
-	sys_log(0, "RequestWarOver : winner %u loser %u draw %u betprice %d", p.dwGuildFrom, p.dwGuildTo, p.bType, p.lWarPrice);
-}
-
-void CGuildManager::DeclareWar(DWORD guild_id1, DWORD guild_id2, BYTE bType)
-{
-	if (guild_id1 == guild_id2)
-		return;
-
-	CGuild* g1 = FindGuild(guild_id1);
-	CGuild* g2 = FindGuild(guild_id2);
-
-	if (!g1 || !g2)
-		return;
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (CGuildDragonLairManager::Instance().FindGuild(guild_id1)
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-		|| GetEventFlag(guild_id1, "dragonlair_channel")
-#endif
-		)
-	{
-		if (g1->GetMasterCharacter())
-			g1->GetMasterCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Guild] You cannot declare a guild war whilst fighting in the dragon cave."));
-		return;
-	}
-
-	if (CGuildDragonLairManager::Instance().FindGuild(guild_id2)
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-		|| GetEventFlag(guild_id2, "dragonlair_channel")
-#endif
-		)
-	{
-		if (g1->GetMasterCharacter())
-			g1->GetMasterCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Guild] The enemy guild is currently fighting in the dragon cave."));
-		return;
-	}
-#endif
-
-	if (g1->DeclareWar(guild_id2, bType, GUILD_WAR_SEND_DECLARE) &&
-		g2->DeclareWar(guild_id1, bType, GUILD_WAR_RECV_DECLARE))
-	{
-		if (false == LC_IsGermany())
-		{
-			char buf[256];
-			snprintf(buf, sizeof(buf), LC_STRING("%s 길드가 %s 길드에 선전포고를 하였습니다!", TouchGuild(guild_id1)->GetName(), TouchGuild(guild_id2)->GetName()));
-			SendNotice(buf);
-		}
-	}
-}
-
-void CGuildManager::RefuseWar(DWORD guild_id1, DWORD guild_id2)
-{
-	CGuild* g1 = FindGuild(guild_id1);
-	CGuild* g2 = FindGuild(guild_id2);
-
-	if (g1 && g2)
-	{
-		if (g2->GetMasterCharacter())
-			g2->GetMasterCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> %s 길드가 길드전을 거부하였습니다.", g1->GetName()));
-	}
-
-	if (g1 != NULL)
-		g1->RefuseWar(guild_id2);
-
-	if (g2 != NULL && g1 != NULL)
-		g2->RefuseWar(g1->GetID());
-}
-
-void CGuildManager::WaitStartWar(DWORD guild_id1, DWORD guild_id2)
-{
-	CGuild* g1 = FindGuild(guild_id1);
-	CGuild* g2 = FindGuild(guild_id2);
-
-	if (!g1 || !g2)
-	{
-		sys_log(0, "GuildWar: CGuildManager::WaitStartWar(%d,%d) - something wrong in arg. there is no guild like that.", guild_id1, guild_id2);
-		return;
-	}
-
-	if (g1->WaitStartWar(guild_id2) || g2->WaitStartWar(guild_id1))
-	{
-		char buf[256];
-		snprintf(buf, sizeof(buf), LC_STRING("%s 길드와 %s 길드가 잠시 후 전쟁을 시작합니다!", g1->GetName(), g2->GetName()));
-		SendNotice(buf);
-	}
-}
-
-struct FSendWarList
-{
-	FSendWarList(BYTE subheader, DWORD guild_id1, DWORD guild_id2)
-	{
-		gid1 = guild_id1;
-		gid2 = guild_id2;
-
-		p.header = HEADER_GC_GUILD;
-		p.size = sizeof(p) + sizeof(DWORD) * 2;
-		p.subheader = subheader;
-	}
-
-	void operator() (LPCHARACTER ch)
-	{
-		LPDESC d = ch->GetDesc();
-
-		if (d)
-		{
-			d->BufferedPacket(&p, sizeof(p));
-			d->BufferedPacket(&gid1, sizeof(DWORD));
-			d->Packet(&gid2, sizeof(DWORD));
-		}
-	}
-
-	DWORD gid1, gid2;
-	TPacketGCGuild p;
-};
-
-void CGuildManager::StartWar(DWORD guild_id1, DWORD guild_id2)
-{
-	CGuild* g1 = FindGuild(guild_id1);
-	CGuild* g2 = FindGuild(guild_id2);
-
-	if (!g1 || !g2)
-		return;
-
-	if (!g1->CheckStartWar(guild_id2) || !g2->CheckStartWar(guild_id1))
-		return;
-
-	g1->StartWar(guild_id2);
-	g2->StartWar(guild_id1);
-
-	char buf[256];
-	snprintf(buf, sizeof(buf), LC_STRING("%s 길드와 %s 길드가 전쟁을 시작하였습니다!", g1->GetName(), g2->GetName()));
-	SendNotice(buf);
-
-	if (guild_id1 > guild_id2)
-		std::swap(guild_id1, guild_id2);
-
-	CHARACTER_MANAGER::instance().for_each_pc(FSendWarList(GUILD_SUBHEADER_GC_GUILD_WAR_LIST, guild_id1, guild_id2));
-	m_GuildWar.insert(std::make_pair(guild_id1, guild_id2));
-}
-
-void SendGuildWarOverNotice(CGuild* g1, CGuild* g2, bool bDraw)
-{
-	if (g1 && g2)
-	{
-		char buf[256];
-
-		if (bDraw)
-		{
-			snprintf(buf, sizeof(buf), LC_STRING("%s 길드와 %s 길드 사이의 전쟁이 무승부로 끝났습니다.", g1->GetName(), g2->GetName()));
-		}
-		else
-		{
-			if (g1->GetWarScoreAgainstTo(g2->GetID()) > g2->GetWarScoreAgainstTo(g1->GetID()))
-			{
-				snprintf(buf, sizeof(buf), LC_STRING("%s 길드가 %s 길드와의 전쟁에서 승리 했습니다.", g1->GetName(), g2->GetName()));
-			}
-			else
-			{
-				snprintf(buf, sizeof(buf), LC_STRING("%s 길드가 %s 길드와의 전쟁에서 승리 했습니다.", g2->GetName(), g1->GetName()));
-			}
-		}
-
-		SendNotice(buf);
-	}
-}
-
-bool CGuildManager::EndWar(DWORD guild_id1, DWORD guild_id2)
-{
-	if (guild_id1 > guild_id2)
-		std::swap(guild_id1, guild_id2);
-
-	CGuild* g1 = FindGuild(guild_id1);
-	CGuild* g2 = FindGuild(guild_id2);
-
-	std::pair<DWORD, DWORD> k = std::make_pair(guild_id1, guild_id2);
-
-	TGuildWarContainer::iterator it = m_GuildWar.find(k);
-
-	if (m_GuildWar.end() == it)
-	{
-		sys_log(0, "EndWar(%d,%d) - EndWar request but guild is not in list", guild_id1, guild_id2);
-		return false;
-	}
-
-	if (g1 && g2)
-	{
-		if (g1->GetGuildWarType(guild_id2) == GUILD_WAR_TYPE_FIELD)
-		{
-			SendGuildWarOverNotice(g1, g2, g1->GetWarScoreAgainstTo(guild_id2) == g2->GetWarScoreAgainstTo(guild_id1));
-		}
-	}
-	else
-	{
-		return false;
-	}
-
-	if (g1)
-		g1->EndWar(guild_id2);
-
-	if (g2)
-		g2->EndWar(guild_id1);
-
-	m_GuildWarEndTime[k] = get_global_time();
-	CHARACTER_MANAGER::instance().for_each_pc(FSendWarList(GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST, guild_id1, guild_id2));
-	m_GuildWar.erase(it);
-
-	return true;
-}
-
-void CGuildManager::WarOver(DWORD guild_id1, DWORD guild_id2, bool bDraw)
-{
-	CGuild* g1 = FindGuild(guild_id1);
-	CGuild* g2 = FindGuild(guild_id2);
-
-	if (guild_id1 > guild_id2)
-		std::swap(guild_id1, guild_id2);
-
-	std::pair<DWORD, DWORD> k = std::make_pair(guild_id1, guild_id2);
-
-	TGuildWarContainer::iterator it = m_GuildWar.find(k);
-
-	if (m_GuildWar.end() == it)
-		return;
-
-	SendGuildWarOverNotice(g1, g2, bDraw);
-
-	EndWar(guild_id1, guild_id2);
-}
-
-void CGuildManager::CancelWar(DWORD guild_id1, DWORD guild_id2)
-{
-	if (!EndWar(guild_id1, guild_id2))
-		return;
-
-	CGuild* g1 = FindGuild(guild_id1);
-	CGuild* g2 = FindGuild(guild_id2);
-
-	if (g1)
-	{
-		LPCHARACTER master1 = g1->GetMasterCharacter();
-
-		if (master1)
-			master1->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드전이 취소 되었습니다."));
-	}
-
-	if (g2)
-	{
-		LPCHARACTER master2 = g2->GetMasterCharacter();
-
-		if (master2)
-			master2->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드전이 취소 되었습니다."));
-	}
-
-	if (g1 && g2)
-	{
-		char buf[256 + 1];
-		snprintf(buf, sizeof(buf), LC_STRING("%s 길드와 %s 길드 사이의 전쟁이 취소되었습니다.", g1->GetName(), g2->GetName()));
-		SendNotice(buf);
-	}
-}
-
-void CGuildManager::ReserveWar(DWORD dwGuild1, DWORD dwGuild2, BYTE bType) // from DB
-{
-	sys_log(0, "GuildManager::ReserveWar %u %u", dwGuild1, dwGuild2);
-
-	CGuild* g1 = FindGuild(dwGuild1);
-	CGuild* g2 = FindGuild(dwGuild2);
-
-	if (!g1 || !g2)
-		return;
-
-	g1->ReserveWar(dwGuild2, bType);
-	g2->ReserveWar(dwGuild1, bType);
-}
-
-void CGuildManager::ShowGuildWarList(LPCHARACTER ch)
-{
-	for (auto it = m_GuildWar.begin(); it != m_GuildWar.end(); ++it)
-	{
-		CGuild* A = TouchGuild(it->first);
-		CGuild* B = TouchGuild(it->second);
-
-		if (A && B)
-		{
-			ch->ChatPacket(CHAT_TYPE_NOTICE, "%s[%d] vs %s[%d] time %u sec.",
-				A->GetName(), A->GetID(),
-				B->GetName(), B->GetID(),
-				get_global_time() - A->GetWarStartTime(B->GetID()));
-		}
-	}
-}
-
-void CGuildManager::SendGuildWar(LPCHARACTER ch)
-{
-	if (!ch->GetDesc())
-		return;
-
-	TEMP_BUFFER buf;
-	TPacketGCGuild p;
-	p.header = HEADER_GC_GUILD;
-	p.subheader = GUILD_SUBHEADER_GC_GUILD_WAR_LIST;
-	p.size = sizeof(p) + (sizeof(DWORD) * 2) * m_GuildWar.size();
-	buf.write(&p, sizeof(p));
-
-	auto it = m_GuildWar.begin();
-	for (; it != m_GuildWar.end(); ++it)
-	{
-		buf.write(&it->first, sizeof(DWORD));
-		buf.write(&it->second, sizeof(DWORD));
-	}
-
-	ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-}
-
-void SendGuildWarScore(DWORD dwGuild, DWORD dwGuildOpp, int iDelta, int iBetScoreDelta)
-{
-	TPacketGuildWarScore p;
-
-	p.dwGuildGainPoint = dwGuild;
-	p.dwGuildOpponent = dwGuildOpp;
-	p.lScore = iDelta;
-	p.lBetScore = iBetScoreDelta;
-
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR_SCORE, 0, &p, sizeof(TPacketGuildWarScore));
-	sys_log(0, "SendGuildWarScore %u %u %d", dwGuild, dwGuildOpp, iDelta);
-}
-
-void CGuildManager::Kill(LPCHARACTER killer, LPCHARACTER victim)
-{
-	// 20200814.Owsap : Prevent same host accumulate points.
-	if ((strcmp(killer->GetDesc()->GetHostName(), victim->GetDesc()->GetHostName()) == 0) && !test_server)
-		return;
-
-	if (!killer->IsPC())
-		return;
-
-	if (!victim->IsPC())
-		return;
-
-	if (killer->GetWarMap())
-	{
-		killer->GetWarMap()->OnKill(killer, victim);
-		return;
-	}
-
-	CGuild* gAttack = killer->GetGuild();
-	CGuild* gDefend = victim->GetGuild();
-
-	if (!gAttack || !gDefend)
-		return;
-
-	if (gAttack->GetGuildWarType(gDefend->GetID()) != GUILD_WAR_TYPE_FIELD)
-		return;
-
-	if (!gAttack->UnderWar(gDefend->GetID()))
-		return;
-
-	SendGuildWarScore(gAttack->GetID(), gDefend->GetID(), victim->GetLevel());
-}
-
-void CGuildManager::StopAllGuildWar()
-{
-	for (auto it = m_GuildWar.begin(); it != m_GuildWar.end(); ++it)
-	{
-		CGuild* g = CGuildManager::instance().TouchGuild(it->first);
-		CGuild* pg = CGuildManager::instance().TouchGuild(it->second);
-		g->EndWar(it->second);
-		pg->EndWar(it->first);
-	}
-
-	m_GuildWar.clear();
-}
-
-void CGuildManager::ReserveWarAdd(TGuildWarReserve* p)
-{
-	CGuildWarReserveForGame* pkReserve = NULL;
-
-	auto it = m_map_kReserveWar.find(p->dwID);
-	if (it != m_map_kReserveWar.end())
-		pkReserve = it->second;
-	else
-	{
-		pkReserve = M2_NEW CGuildWarReserveForGame;
-
-		m_map_kReserveWar.insert(std::make_pair(p->dwID, pkReserve));
-		m_vec_kReserveWar.push_back(pkReserve);
-	}
-
-	thecore_memcpy(&pkReserve->data, p, sizeof(TGuildWarReserve));
-
-	sys_log(0, "ReserveWarAdd %u gid1 %u power %d gid2 %u power %d handicap %d",
-		pkReserve->data.dwID, p->dwGuildFrom, p->lPowerFrom, p->dwGuildTo, p->lPowerTo, p->lHandicap);
-}
-
-void CGuildManager::ReserveWarBet(TPacketGDGuildWarBet* p)
-{
-	auto it = m_map_kReserveWar.find(p->dwWarID);
-	if (it == m_map_kReserveWar.end())
-		return;
-
-	it->second->mapBet.insert(std::make_pair(p->szLogin, std::make_pair(p->dwGuild, p->dwGold)));
-}
-
-bool CGuildManager::IsBet(DWORD dwID, const char* c_pszLogin)
-{
-	auto it = m_map_kReserveWar.find(dwID);
-	if (it == m_map_kReserveWar.end())
-		return true;
-
-	return it->second->mapBet.end() != it->second->mapBet.find(c_pszLogin);
-}
-
-void CGuildManager::ReserveWarDelete(DWORD dwID)
-{
-	sys_log(0, "ReserveWarDelete %u", dwID);
-	auto it = m_map_kReserveWar.find(dwID);
-	if (it == m_map_kReserveWar.end())
-		return;
-
-	auto it_vec = m_vec_kReserveWar.begin();
-	while (it_vec != m_vec_kReserveWar.end())
-	{
-		if (*it_vec == it->second)
-		{
-			it_vec = m_vec_kReserveWar.erase(it_vec);
-			break;
-		}
-		else
-			++it_vec;
-	}
-
-	M2_DELETE(it->second);
-	m_map_kReserveWar.erase(it);
-}
-
-std::vector<CGuildWarReserveForGame*>& CGuildManager::GetReserveWarRef()
-{
-	return m_vec_kReserveWar;
-}
-
-//
-// End of Guild War
-//
-
-void CGuildManager::ChangeMaster(DWORD dwGID)
-{
-	TGuildMap::iterator iter = m_mapGuild.find(dwGID);
-
-	if (iter != m_mapGuild.end())
-	{
-		iter->second->Load(dwGID);
-	}
-
-	// 업데이트된 정보 보내주기
-	DBManager::instance().FuncQuery(std::bind(&CGuild::SendGuildDataUpdateToAllMember, iter->second, std::placeholders::_1), "SELECT 1");
-}
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-void CGuildManager::SendGuildEventFlagList(LPCHARACTER pChar)
-{
-	LPGUILD pGuild = pChar->GetGuild();
-	if (pGuild == nullptr)
-		return;
-
-	TGuildEventFlagMap::iterator itGuild = m_mapGuildEventFlag.find(pGuild->GetID());
-	if (itGuild != m_mapGuildEventFlag.end())
-	{
-		TEventFlagMap::iterator itEventFlag = itGuild->second.begin();
-		for (; itEventFlag != itGuild->second.end(); ++itEventFlag)
-		{
-			pChar->ChatPacket(CHAT_TYPE_INFO, "%s %ld", itEventFlag->first.c_str(), itEventFlag->second);
-		}
-	}
-}
-
-void CGuildManager::RequestSetEventFlag(DWORD dwGuildID, const std::string& strFlagName, long lValue)
-{
-	TPacketSetGuildEventFlag t;
-	t.dwGuildID = dwGuildID;
-	strlcpy(t.szFlagName, strFlagName.c_str(), sizeof(t.szFlagName));
-	t.lValue = lValue;
-	db_clientdesc->DBPacket(HEADER_GD_GUILD_EVENT_FLAG, 0, &t, sizeof(TPacketSetGuildEventFlag));
-}
-
-void CGuildManager::SetEventFlag(DWORD dwGuildID, const std::string& strFlagName, long lValue)
-{
-	long lPrevValue = m_mapGuildEventFlag[dwGuildID][strFlagName];
-
-	sys_log(0, "GUILD %u EventFlag %s prev_value %ld value %ld ", dwGuildID, strFlagName.c_str(), lPrevValue, lValue);
-	m_mapGuildEventFlag[dwGuildID][strFlagName] = lValue;
-}
-
-long CGuildManager::GetEventFlag(DWORD dwGuildID, const std::string& strFlagName)
-{
-	TGuildEventFlagMap::iterator itGuild = m_mapGuildEventFlag.find(dwGuildID);
-	if (itGuild != m_mapGuildEventFlag.end())
-	{
-		TEventFlagMap::iterator itEventFlag = itGuild->second.find(strFlagName);
-		if (itEventFlag != itGuild->second.end())
-			return itEventFlag->second;
-	}
-	return 0;
-}
-#endif
+#include "stdafx.h"
+#include "constants.h"
+#include "utils.h"
+#include "config.h"
+#include "log.h"
+#include "char.h"
+#include "db.h"
+#include "lzo_manager.h"
+#include "desc_client.h"
+#include "buffer_manager.h"
+#include "char_manager.h"
+#include "packet.h"
+#include "war_map.h"
+#include "questmanager.h"
+#include "locale_service.h"
+#include "guild_manager.h"
+#include "MarkManager.h"
+
+namespace
+{
+	struct FGuildNameSender
+	{
+		FGuildNameSender(DWORD id, const char* guild_name) : id(id), name(guild_name)
+		{
+			p.header = HEADER_GC_GUILD;
+			p.subheader = GUILD_SUBHEADER_GC_GUILD_NAME;
+			p.size = sizeof(p) + GUILD_NAME_MAX_LEN + sizeof(DWORD);
+		}
+
+		void operator()(LPCHARACTER ch)
+		{
+			LPDESC d = ch->GetDesc();
+
+			if (d)
+			{
+				d->BufferedPacket(&p, sizeof(p));
+				d->BufferedPacket(&id, sizeof(id));
+				d->Packet(name, GUILD_NAME_MAX_LEN);
+			}
+		}
+
+		DWORD id;
+		const char* name;
+		TPacketGCGuild p;
+	};
+}
+
+CGuildManager::CGuildManager()
+{
+}
+
+CGuildManager::~CGuildManager()
+{
+	for( TGuildMap::const_iterator iter = m_mapGuild.begin() ; iter != m_mapGuild.end() ; ++iter )
+	{
+		M2_DELETE(iter->second);
+	}
+
+	m_mapGuild.clear();
+}
+
+int CGuildManager::GetDisbandDelay()
+{
+	return quest::CQuestManager::instance().GetEventFlag("guild_disband_delay") * (test_server ? 60 : 86400);
+}
+
+int CGuildManager::GetWithdrawDelay()
+{
+	return quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay") * (test_server ? 60 : 86400);
+}
+
+DWORD CGuildManager::CreateGuild(TGuildCreateParameter& gcp)
+{
+	if (!gcp.master)
+		return 0;
+
+	if (!check_name(gcp.name))
+	{
+		gcp.master->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  見  駕求."));
+		return 0;
+	}
+
+	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM guild%s WHERE name = '%s'",
+		get_table_postfix(), gcp.name));
+
+	if (pmsg->Get()->uiNumRows > 0)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+
+		if (!(row[0] && row[0][0] == '0'))
+		{
+			gcp.master->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 譴  見 弱 笭求."));
+			return 0;
+		}
+	}
+	else
+	{
+		gcp.master->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 躍   求."));
+		return 0;
+	}
+
+	// new CGuild(gcp) queries guild tables and tell dbcache to notice other game servers.
+	// other game server calls CGuildManager::LoadGuild to load guild.
+	CGuild* pg = M2_NEW CGuild(gcp);
+	m_mapGuild.insert(std::make_pair(pg->GetID(), pg));
+	return pg->GetID();
+}
+
+void CGuildManager::Unlink(DWORD pid)
+{
+	m_map_pkGuildByPID.erase(pid);
+}
+
+CGuild* CGuildManager::GetLinkedGuild(DWORD pid)
+{
+	TGuildMap::iterator it = m_map_pkGuildByPID.find(pid);
+
+	if (it == m_map_pkGuildByPID.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CGuildManager::Link(DWORD pid, CGuild* guild)
+{
+	if (m_map_pkGuildByPID.find(pid) == m_map_pkGuildByPID.end())
+		m_map_pkGuildByPID.insert(std::make_pair(pid, guild));
+}
+
+void CGuildManager::P2PLogoutMember(DWORD pid)
+{
+	TGuildMap::iterator it = m_map_pkGuildByPID.find(pid);
+
+	if (it != m_map_pkGuildByPID.end())
+	{
+		it->second->P2PLogoutMember(pid);
+	}
+}
+
+void CGuildManager::P2PLoginMember(DWORD pid)
+{
+	TGuildMap::iterator it = m_map_pkGuildByPID.find(pid);
+
+	if (it != m_map_pkGuildByPID.end())
+	{
+		it->second->P2PLoginMember(pid);
+	}
+}
+
+void CGuildManager::LoginMember(LPCHARACTER ch)
+{
+	TGuildMap::iterator it = m_map_pkGuildByPID.find(ch->GetPlayerID());
+
+	if (it != m_map_pkGuildByPID.end())
+	{
+		it->second->LoginMember(ch);
+	}
+}
+
+CGuild* CGuildManager::TouchGuild(DWORD guild_id)
+{
+	TGuildMap::iterator it = m_mapGuild.find(guild_id);
+
+	if (it == m_mapGuild.end())
+	{
+		m_mapGuild.insert(std::make_pair(guild_id, M2_NEW CGuild(guild_id)));
+		it = m_mapGuild.find(guild_id);
+
+		CHARACTER_MANAGER::instance().for_each_pc(FGuildNameSender(guild_id, it->second->GetName()));
+	}
+
+	return it->second;
+}
+
+CGuild* CGuildManager::FindGuild(DWORD guild_id)
+{
+	TGuildMap::iterator it = m_mapGuild.find(guild_id);
+	if (it == m_mapGuild.end())
+	{
+		return NULL;
+	}
+	return it->second;
+}
+
+CGuild* CGuildManager::FindGuildByName(const std::string guild_name)
+{
+	auto it = m_mapGuild.begin();
+	for (; it!=m_mapGuild.end(); ++it)
+	{
+		if (it->second->GetName() == guild_name)
+			return it->second;
+	}
+	return NULL;
+}
+
+void CGuildManager::Initialize()
+{
+	sys_log(0, "Initializing Guild");
+
+	if (g_bAuthServer)
+	{
+		sys_log(0, "	No need for auth server");
+		return;
+
+	char szGuildNameEsc[(GUILD_NAME_MAX_LEN + 1) * 2 + 1];
+	DBManager::instance().EscapeString(szGuildNameEsc, sizeof(szGuildNameEsc), gcp.name, strlen(gcp.name));
+
+	}
+
+	std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery("SELECT id FROM guild%s", get_table_postfix()));
+
+	std::vector<DWORD> vecGuildID;
+	vecGuildID.reserve(pmsg->Get()->uiNumRows);
+
+	for (uint i = 0; i < pmsg->Get()->uiNumRows; i++)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+		DWORD guild_id = strtoul(row[0], (char**)NULL, 10);
+		LoadGuild(guild_id);
+
+		vecGuildID.push_back(guild_id);
+	}
+
+	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
+
+	rkMarkMgr.SetMarkPathPrefix("mark");
+
+	extern bool GuildMarkConvert(const std::vector<DWORD> & vecGuildID);
+	GuildMarkConvert(vecGuildID);
+
+	rkMarkMgr.LoadMarkIndex();
+	rkMarkMgr.LoadMarkImages();
+	rkMarkMgr.LoadSymbol(GUILD_SYMBOL_FILENAME);
+}
+
+void CGuildManager::LoadGuild(DWORD guild_id)
+{
+	TGuildMap::iterator it = m_mapGuild.find(guild_id);
+
+	if (it == m_mapGuild.end())
+	{
+		m_mapGuild.insert(std::make_pair(guild_id, M2_NEW CGuild(guild_id)));
+	}
+	else
+	{
+		//it->second->Load(guild_id);
+	}
+}
+
+void CGuildManager::DisbandGuild(DWORD guild_id)
+{
+	TGuildMap::iterator it = m_mapGuild.find(guild_id);
+
+	if (it == m_mapGuild.end())
+		return;
+
+	// [Safety] Ensure no online character keeps a stale guild pointer while disband is processed
+	struct FNullGuildPtr
+	{
+		DWORD guild_id;
+		FNullGuildPtr(DWORD id) : guild_id(id) {}
+		void operator()(LPCHARACTER ch)
+		{
+			if (!ch) return;
+			CGuild* g = ch->GetGuild();
+			if (g && g->GetID() == guild_id)
+				ch->SetGuild(NULL);
+		}
+	};
+	CHARACTER_MANAGER::instance().for_each_pc(FNullGuildPtr(guild_id));
+
+	it->second->Disband();
+
+	M2_DELETE(it->second);
+	m_mapGuild.erase(it);
+
+	CGuildMarkManager::instance().DeleteMark(guild_id);
+}
+
+void CGuildManager::SkillRecharge()
+{
+	for (TGuildMap::iterator it = m_mapGuild.begin(); it != m_mapGuild.end(); ++it)
+	{
+		it->second->SkillRecharge();
+	}
+}
+
+int CGuildManager::GetRank(CGuild* g)
+{
+	int point = g->GetLadderPoint();
+	int rank = 1;
+
+	for (auto it = m_mapGuild.begin(); it != m_mapGuild.end();++it)
+	{
+		CGuild* pg = it->second;
+
+		if (pg->GetLadderPoint() > point)
+			rank++;
+	}
+
+	return rank;
+}
+
+static auto SortGuild(std::vector<CGuild*>& v)
+{
+	std::sort(v.begin(), v.end(), [](const CGuild* g1, const CGuild* g2)
+	{
+		if (g1->GetLadderPoint() < g2->GetLadderPoint())
+			return 1;
+		if (g1->GetLadderPoint() > g2->GetLadderPoint())
+			return 0;
+		if (g1->GetGuildWarWinCount() < g2->GetGuildWarWinCount())
+			return 1;
+		if (g1->GetGuildWarWinCount() > g2->GetGuildWarWinCount())
+			return 0;
+		if (g1->GetGuildWarLossCount() < g2->GetGuildWarLossCount())
+			return 1;
+		if (g1->GetGuildWarLossCount() > g2->GetGuildWarLossCount())
+			return 0;
+		const int c = strcmp(g1->GetName(), g2->GetName());
+		if (c > 0)
+			return 1;
+		return 0;
+		});
+}
+
+void CGuildManager::GetHighRankString(DWORD dwMyGuild, char* buffer, size_t buflen)
+{
+	using namespace std;
+	vector<CGuild*> v;
+
+	for (auto it = m_mapGuild.begin(); it != m_mapGuild.end(); ++it)
+	{
+		if (it->second)
+			v.push_back(it->second);
+	}
+
+	SortGuild(v);
+	int n = v.size();
+	int len = 0, len2;
+	*buffer = '\0';
+
+	for (int i = 0; i < 8; ++i)
+	{
+		if (n - i - 1 < 0)
+			break;
+
+		CGuild* g = v[n - i - 1];
+
+		if (!g)
+			continue;
+
+		if (g->GetLadderPoint() <= 0)
+			break;
+
+		if (dwMyGuild == g->GetID())
+		{
+			len2 = snprintf(buffer + len, buflen - len, "[COLOR r;255|g;255|b;0]");
+
+			if (len2 < 0 || len2 >= (int)buflen - len)
+				len += (buflen - len) - 1;
+			else
+				len += len2;
+		}
+
+		if (i)
+		{
+			len2 = snprintf(buffer + len, buflen - len, "[ENTER]");
+
+			if (len2 < 0 || len2 >= (int)buflen - len)
+				len += (buflen - len) - 1;
+			else
+				len += len2;
+		}
+
+		len2 = snprintf(buffer + len, buflen - len, "%3d | %-12s | %-8d | %4d | %4d | %4d",
+			GetRank(g),
+			g->GetName(),
+			g->GetLadderPoint(),
+			g->GetGuildWarWinCount(),
+			g->GetGuildWarDrawCount(),
+			g->GetGuildWarLossCount());
+
+		if (len2 < 0 || len2 >= (int)buflen - len)
+			len += (buflen - len) - 1;
+		else
+			len += len2;
+
+		if (g->GetID() == dwMyGuild)
+		{
+			len2 = snprintf(buffer + len, buflen - len, "[/COLOR]");
+
+			if (len2 < 0 || len2 >= (int)buflen - len)
+				len += (buflen - len) - 1;
+			else
+				len += len2;
+		}
+	}
+}
+
+void CGuildManager::GetAroundRankString(DWORD dwMyGuild, char* buffer, size_t buflen)
+{
+	using namespace std;
+	vector<CGuild*> v;
+
+	for (auto it = m_mapGuild.begin(); it != m_mapGuild.end(); ++it)
+	{
+		if (it->second)
+			v.push_back(it->second);
+	}
+
+	SortGuild(v);
+	int n = v.size();
+	int idx;
+
+	for (idx = 0; idx < (int)v.size(); ++idx)
+		if (v[idx]->GetID() == dwMyGuild)
+			break;
+
+	int len = 0, len2;
+	int count = 0;
+	*buffer = '\0';
+
+	for (int i = -3; i <= 3; ++i)
+	{
+		if (idx - i < 0)
+			continue;
+
+		if (idx - i >= n)
+			continue;
+
+		CGuild* g = v[idx - i];
+
+		if (!g)
+			continue;
+
+		if (dwMyGuild == g->GetID())
+		{
+			len2 = snprintf(buffer + len, buflen - len, "[COLOR r;255|g;255|b;0]");
+
+			if (len2 < 0 || len2 >= (int)buflen - len)
+				len += (buflen - len) - 1;
+			else
+				len += len2;
+		}
+
+		if (count)
+		{
+			len2 = snprintf(buffer + len, buflen - len, "[ENTER]");
+
+			if (len2 < 0 || len2 >= (int)buflen - len)
+				len += (buflen - len) - 1;
+			else
+				len += len2;
+		}
+
+		len2 = snprintf(buffer + len, buflen - len, "%3d | %-12s | %-8d | %4d | %4d | %4d",
+			GetRank(g),
+			g->GetName(),
+			g->GetLadderPoint(),
+			g->GetGuildWarWinCount(),
+			g->GetGuildWarDrawCount(),
+			g->GetGuildWarLossCount());
+
+		if (len2 < 0 || len2 >= (int)buflen - len)
+			len += (buflen - len) - 1;
+		else
+			len += len2;
+
+		++count;
+
+		if (g->GetID() == dwMyGuild)
+		{
+			len2 = snprintf(buffer + len, buflen - len, "[/COLOR]");
+
+			if (len2 < 0 || len2 >= (int)buflen - len)
+				len += (buflen - len) - 1;
+			else
+				len += len2;
+		}
+	}
+}
+
+/////////////////////////////////////////////////////////////////////
+// Guild War
+/////////////////////////////////////////////////////////////////////
+void CGuildManager::RequestCancelWar(DWORD guild_id1, DWORD guild_id2)
+{
+	sys_log(0, "RequestCancelWar %d %d", guild_id1, guild_id2);
+
+	TPacketGuildWar p;
+	p.bWar = GUILD_WAR_CANCEL;
+	p.dwGuildFrom = guild_id1;
+	p.dwGuildTo = guild_id2;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR, 0, &p, sizeof(p));
+}
+
+void CGuildManager::RequestEndWar(DWORD guild_id1, DWORD guild_id2)
+{
+	sys_log(0, "RequestEndWar %d %d", guild_id1, guild_id2);
+
+	TPacketGuildWar p;
+	p.bWar = GUILD_WAR_END;
+	p.dwGuildFrom = guild_id1;
+	p.dwGuildTo = guild_id2;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR, 0, &p, sizeof(p));
+}
+
+void CGuildManager::RequestWarOver(DWORD dwGuild1, DWORD dwGuild2, DWORD dwGuildWinner, long lReward)
+{
+	CGuild* g1 = TouchGuild(dwGuild1);
+	CGuild* g2 = TouchGuild(dwGuild2);
+
+	if (g1->GetGuildWarState(g2->GetID()) != GUILD_WAR_ON_WAR)
+	{
+		sys_log(0, "RequestWarOver : both guild was not in war %u %u", dwGuild1, dwGuild2);
+		RequestEndWar(dwGuild1, dwGuild2);
+		return;
+	}
+
+	TPacketGuildWar p;
+
+	p.bWar = GUILD_WAR_OVER;
+	//    .
+	//p.lWarPrice = lReward;
+	p.lWarPrice = 0;
+	p.bType = dwGuildWinner == 0 ? 1 : 0; // bType == 1 means draw for this packet.
+
+	if (dwGuildWinner == 0)
+	{
+		p.dwGuildFrom = dwGuild1;
+		p.dwGuildTo = dwGuild2;
+	}
+	else
+	{
+		p.dwGuildFrom = dwGuildWinner;
+		p.dwGuildTo = dwGuildWinner == dwGuild1 ? dwGuild2 : dwGuild1;
+	}
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR, 0, &p, sizeof(p));
+	sys_log(0, "RequestWarOver : winner %u loser %u draw %u betprice %d", p.dwGuildFrom, p.dwGuildTo, p.bType, p.lWarPrice);
+}
+
+void CGuildManager::DeclareWar(DWORD guild_id1, DWORD guild_id2, BYTE bType)
+{
+	if (guild_id1 == guild_id2)
+		return;
+
+	CGuild* g1 = FindGuild(guild_id1);
+	CGuild* g2 = FindGuild(guild_id2);
+
+	if (!g1 || !g2)
+		return;
+
+	// Anti-spam: throttle repeated declare requests for the same pair
+	// (prevents scripts from spamming DB/P2P and stalling guild_manager)
+	static std::map<unsigned long long, DWORD> s_WarDeclareSpamTime;
+	DWORD dwNow = get_dword_time();
+	DWORD a = guild_id1, b = guild_id2;
+	if (a > b) std::swap(a, b);
+	unsigned long long ullKey = (static_cast<unsigned long long>(a) << 32) | b;
+	auto itSpam = s_WarDeclareSpamTime.find(ullKey);
+	if (itSpam != s_WarDeclareSpamTime.end() && dwNow - itSpam->second < 3000)
+		return;
+	s_WarDeclareSpamTime[ullKey] = dwNow;
+
+	// Cooldown after war end (avoid spam loops / deleted guild edge-cases)
+	std::pair<DWORD, DWORD> k = std::make_pair(a, b);
+	auto itEnd = m_GuildWarEndTime.find(k);
+	if (itEnd != m_GuildWarEndTime.end())
+	{
+		if (get_global_time() - itEnd->second < 60)
+			return;
+	}
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (CGuildDragonLairManager::Instance().FindGuild(guild_id1)
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+		|| GetEventFlag(guild_id1, "dragonlair_channel")
+#endif
+		)
+	{
+		if (g1->GetMasterCharacter())
+			g1->GetMasterCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Guild] You cannot declare a guild war whilst fighting in the dragon cave."));
+		return;
+	}
+
+	if (CGuildDragonLairManager::Instance().FindGuild(guild_id2)
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+		|| GetEventFlag(guild_id2, "dragonlair_channel")
+#endif
+		)
+	{
+		if (g1->GetMasterCharacter())
+			g1->GetMasterCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Guild] The enemy guild is currently fighting in the dragon cave."));
+		return;
+	}
+#endif
+
+	if (g1->DeclareWar(guild_id2, bType, GUILD_WAR_SEND_DECLARE) &&
+		g2->DeclareWar(guild_id1, bType, GUILD_WAR_RECV_DECLARE))
+	{
+		if (false == LC_IsGermany())
+		{
+			char buf[256];
+			snprintf(buf, sizeof(buf), LC_STRING("%s 弱 %s 恙  臼求!", g1->GetName(), g2->GetName()));
+			SendNotice(buf);
+		}
+	}
+}
+
+void CGuildManager::RefuseWar(DWORD guild_id1, DWORD guild_id2)
+{
+	CGuild* g1 = FindGuild(guild_id1);
+	CGuild* g2 = FindGuild(guild_id2);
+
+	if (g1 && g2)
+	{
+		if (g2->GetMasterCharacter())
+			g2->GetMasterCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> %s 弱  탄臼求.", g1->GetName()));
+	}
+
+	if (g1 != NULL)
+		g1->RefuseWar(guild_id2);
+
+	if (g2 != NULL && g1 != NULL)
+		g2->RefuseWar(g1->GetID());
+}
+
+void CGuildManager::WaitStartWar(DWORD guild_id1, DWORD guild_id2)
+{
+	CGuild* g1 = FindGuild(guild_id1);
+	CGuild* g2 = FindGuild(guild_id2);
+
+	if (!g1 || !g2)
+	{
+		sys_log(0, "GuildWar: CGuildManager::WaitStartWar(%d,%d) - something wrong in arg. there is no guild like that.", guild_id1, guild_id2);
+		return;
+	}
+
+	if (g1->WaitStartWar(guild_id2) || g2->WaitStartWar(guild_id1))
+	{
+		char buf[256];
+		snprintf(buf, sizeof(buf), LC_STRING("%s  %s 弱    爛求!", g1->GetName(), g2->GetName()));
+		SendNotice(buf);
+	}
+}
+
+struct FSendWarList
+{
+	FSendWarList(BYTE subheader, DWORD guild_id1, DWORD guild_id2)
+	{
+		gid1 = guild_id1;
+		gid2 = guild_id2;
+
+		p.header = HEADER_GC_GUILD;
+		p.size = sizeof(p) + sizeof(DWORD) * 2;
+		p.subheader = subheader;
+	}
+
+	void operator() (LPCHARACTER ch)
+	{
+		LPDESC d = ch->GetDesc();
+
+		if (d)
+		{
+			d->BufferedPacket(&p, sizeof(p));
+			d->BufferedPacket(&gid1, sizeof(DWORD));
+			d->Packet(&gid2, sizeof(DWORD));
+		}
+	}
+
+	DWORD gid1, gid2;
+	TPacketGCGuild p;
+};
+
+void CGuildManager::StartWar(DWORD guild_id1, DWORD guild_id2)
+{
+	CGuild* g1 = FindGuild(guild_id1);
+	CGuild* g2 = FindGuild(guild_id2);
+
+	if (!g1 || !g2)
+		return;
+
+	if (!g1->CheckStartWar(guild_id2) || !g2->CheckStartWar(guild_id1))
+		return;
+
+	g1->StartWar(guild_id2);
+	g2->StartWar(guild_id1);
+
+	char buf[256];
+	snprintf(buf, sizeof(buf), LC_STRING("%s  %s 弱  臼求!", g1->GetName(), g2->GetName()));
+	SendNotice(buf);
+
+	if (guild_id1 > guild_id2)
+		std::swap(guild_id1, guild_id2);
+
+	CHARACTER_MANAGER::instance().for_each_pc(FSendWarList(GUILD_SUBHEADER_GC_GUILD_WAR_LIST, guild_id1, guild_id2));
+	m_GuildWar.insert(std::make_pair(guild_id1, guild_id2));
+}
+
+void SendGuildWarOverNotice(CGuild* g1, CGuild* g2, bool bDraw)
+{
+	if (g1 && g2)
+	{
+		char buf[256];
+
+		if (bDraw)
+		{
+			snprintf(buf, sizeof(buf), LC_STRING("%s  %s    쨘管 求.", g1->GetName(), g2->GetName()));
+		}
+		else
+		{
+			if (g1->GetWarScoreAgainstTo(g2->GetID()) > g2->GetWarScoreAgainstTo(g1->GetID()))
+			{
+				snprintf(buf, sizeof(buf), LC_STRING("%s 弱 %s  占 쨍 颯求.", g1->GetName(), g2->GetName()));
+			}
+			else
+			{
+				snprintf(buf, sizeof(buf), LC_STRING("%s 弱 %s  占 쨍 颯求.", g2->GetName(), g1->GetName()));
+			}
+		}
+
+		SendNotice(buf);
+	}
+}
+
+bool CGuildManager::EndWar(DWORD guild_id1, DWORD guild_id2)
+{
+	if (guild_id1 > guild_id2)
+		std::swap(guild_id1, guild_id2);
+
+	CGuild* g1 = FindGuild(guild_id1);
+	CGuild* g2 = FindGuild(guild_id2);
+
+	std::pair<DWORD, DWORD> k = std::make_pair(guild_id1, guild_id2);
+
+	TGuildWarContainer::iterator it = m_GuildWar.find(k);
+
+	if (m_GuildWar.end() == it)
+	{
+		sys_log(0, "EndWar(%d,%d) - EndWar request but guild is not in list", guild_id1, guild_id2);
+		return false;
+	}
+
+	if (g1 && g2)
+	{
+		if (g1->GetGuildWarType(guild_id2) == GUILD_WAR_TYPE_FIELD)
+		{
+			SendGuildWarOverNotice(g1, g2, g1->GetWarScoreAgainstTo(guild_id2) == g2->GetWarScoreAgainstTo(guild_id1));
+		}
+	}
+	else
+	{
+		return false;
+	}
+
+	if (g1)
+		g1->EndWar(guild_id2);
+
+	if (g2)
+		g2->EndWar(guild_id1);
+
+	m_GuildWarEndTime[k] = get_global_time();
+	CHARACTER_MANAGER::instance().for_each_pc(FSendWarList(GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST, guild_id1, guild_id2));
+	m_GuildWar.erase(it);
+
+	return true;
+}
+
+void CGuildManager::WarOver(DWORD guild_id1, DWORD guild_id2, bool bDraw)
+{
+	CGuild* g1 = FindGuild(guild_id1);
+	CGuild* g2 = FindGuild(guild_id2);
+
+	if (guild_id1 > guild_id2)
+		std::swap(guild_id1, guild_id2);
+
+	std::pair<DWORD, DWORD> k = std::make_pair(guild_id1, guild_id2);
+
+	TGuildWarContainer::iterator it = m_GuildWar.find(k);
+
+	if (m_GuildWar.end() == it)
+		return;
+
+	SendGuildWarOverNotice(g1, g2, bDraw);
+
+	EndWar(guild_id1, guild_id2);
+}
+
+void CGuildManager::CancelWar(DWORD guild_id1, DWORD guild_id2)
+{
+	if (!EndWar(guild_id1, guild_id2))
+		return;
+
+	CGuild* g1 = FindGuild(guild_id1);
+	CGuild* g2 = FindGuild(guild_id2);
+
+	if (g1)
+	{
+		LPCHARACTER master1 = g1->GetMasterCharacter();
+
+		if (master1)
+			master1->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   퓸求."));
+	}
+
+	if (g2)
+	{
+		LPCHARACTER master2 = g2->GetMasterCharacter();
+
+		if (master2)
+			master2->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   퓸求."));
+	}
+
+	if (g1 && g2)
+	{
+		char buf[256 + 1];
+		snprintf(buf, sizeof(buf), LC_STRING("%s  %s    撚퓸求.", g1->GetName(), g2->GetName()));
+		SendNotice(buf);
+	}
+}
+
+void CGuildManager::ReserveWar(DWORD dwGuild1, DWORD dwGuild2, BYTE bType) // from DB
+{
+	sys_log(0, "GuildManager::ReserveWar %u %u", dwGuild1, dwGuild2);
+
+	CGuild* g1 = FindGuild(dwGuild1);
+	CGuild* g2 = FindGuild(dwGuild2);
+
+	if (!g1 || !g2)
+		return;
+
+	g1->ReserveWar(dwGuild2, bType);
+	g2->ReserveWar(dwGuild1, bType);
+}
+
+void CGuildManager::ShowGuildWarList(LPCHARACTER ch)
+{
+	for (auto it = m_GuildWar.begin(); it != m_GuildWar.end(); ++it)
+	{
+		CGuild* A = TouchGuild(it->first);
+		CGuild* B = TouchGuild(it->second);
+
+		if (A && B)
+		{
+			ch->ChatPacket(CHAT_TYPE_NOTICE, "%s[%d] vs %s[%d] time %u sec.",
+				A->GetName(), A->GetID(),
+				B->GetName(), B->GetID(),
+				get_global_time() - A->GetWarStartTime(B->GetID()));
+		}
+	}
+}
+
+void CGuildManager::SendGuildWar(LPCHARACTER ch)
+{
+	if (!ch->GetDesc())
+		return;
+
+	TEMP_BUFFER buf;
+	TPacketGCGuild p;
+	p.header = HEADER_GC_GUILD;
+	p.subheader = GUILD_SUBHEADER_GC_GUILD_WAR_LIST;
+	p.size = sizeof(p) + (sizeof(DWORD) * 2) * m_GuildWar.size();
+	buf.write(&p, sizeof(p));
+
+	auto it = m_GuildWar.begin();
+	for (; it != m_GuildWar.end(); ++it)
+	{
+		buf.write(&it->first, sizeof(DWORD));
+		buf.write(&it->second, sizeof(DWORD));
+	}
+
+	ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+}
+
+void SendGuildWarScore(DWORD dwGuild, DWORD dwGuildOpp, int iDelta, int iBetScoreDelta)
+{
+	TPacketGuildWarScore p;
+
+	p.dwGuildGainPoint = dwGuild;
+	p.dwGuildOpponent = dwGuildOpp;
+	p.lScore = iDelta;
+	p.lBetScore = iBetScoreDelta;
+
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_WAR_SCORE, 0, &p, sizeof(TPacketGuildWarScore));
+	sys_log(0, "SendGuildWarScore %u %u %d", dwGuild, dwGuildOpp, iDelta);
+}
+
+void CGuildManager::Kill(LPCHARACTER killer, LPCHARACTER victim)
+{
+	// 20200814.Owsap : Prevent same host accumulate points.
+	if ((strcmp(killer->GetDesc()->GetHostName(), victim->GetDesc()->GetHostName()) == 0) && !test_server)
+		return;
+
+	if (!killer->IsPC())
+		return;
+
+	if (!victim->IsPC())
+		return;
+
+	if (killer->GetWarMap())
+	{
+		killer->GetWarMap()->OnKill(killer, victim);
+		return;
+	}
+
+	CGuild* gAttack = killer->GetGuild();
+	CGuild* gDefend = victim->GetGuild();
+
+	if (!gAttack || !gDefend)
+		return;
+
+	if (gAttack->GetGuildWarType(gDefend->GetID()) != GUILD_WAR_TYPE_FIELD)
+		return;
+
+	if (!gAttack->UnderWar(gDefend->GetID()))
+		return;
+
+	SendGuildWarScore(gAttack->GetID(), gDefend->GetID(), victim->GetLevel());
+}
+
+void CGuildManager::StopAllGuildWar()
+{
+	for (auto it = m_GuildWar.begin(); it != m_GuildWar.end(); ++it)
+	{
+		CGuild* g = CGuildManager::instance().TouchGuild(it->first);
+		CGuild* pg = CGuildManager::instance().TouchGuild(it->second);
+		g->EndWar(it->second);
+		pg->EndWar(it->first);
+	}
+
+	m_GuildWar.clear();
+}
+
+void CGuildManager::ReserveWarAdd(TGuildWarReserve* p)
+{
+	CGuildWarReserveForGame* pkReserve = NULL;
+
+	auto it = m_map_kReserveWar.find(p->dwID);
+	if (it != m_map_kReserveWar.end())
+		pkReserve = it->second;
+	else
+	{
+		pkReserve = M2_NEW CGuildWarReserveForGame;
+
+		m_map_kReserveWar.insert(std::make_pair(p->dwID, pkReserve));
+		m_vec_kReserveWar.push_back(pkReserve);
+	}
+
+	thecore_memcpy(&pkReserve->data, p, sizeof(TGuildWarReserve));
+
+	sys_log(0, "ReserveWarAdd %u gid1 %u power %d gid2 %u power %d handicap %d",
+		pkReserve->data.dwID, p->dwGuildFrom, p->lPowerFrom, p->dwGuildTo, p->lPowerTo, p->lHandicap);
+}
+
+void CGuildManager::ReserveWarBet(TPacketGDGuildWarBet* p)
+{
+	auto it = m_map_kReserveWar.find(p->dwWarID);
+	if (it == m_map_kReserveWar.end())
+		return;
+
+	it->second->mapBet.insert(std::make_pair(p->szLogin, std::make_pair(p->dwGuild, p->dwGold)));
+}
+
+bool CGuildManager::IsBet(DWORD dwID, const char* c_pszLogin)
+{
+	auto it = m_map_kReserveWar.find(dwID);
+	if (it == m_map_kReserveWar.end())
+		return true;
+
+	return it->second->mapBet.end() != it->second->mapBet.find(c_pszLogin);
+}
+
+void CGuildManager::ReserveWarDelete(DWORD dwID)
+{
+	sys_log(0, "ReserveWarDelete %u", dwID);
+	auto it = m_map_kReserveWar.find(dwID);
+	if (it == m_map_kReserveWar.end())
+		return;
+
+	auto it_vec = m_vec_kReserveWar.begin();
+	while (it_vec != m_vec_kReserveWar.end())
+	{
+		if (*it_vec == it->second)
+		{
+			it_vec = m_vec_kReserveWar.erase(it_vec);
+			break;
+		}
+		else
+			++it_vec;
+	}
+
+	M2_DELETE(it->second);
+	m_map_kReserveWar.erase(it);
+}
+
+std::vector<CGuildWarReserveForGame*>& CGuildManager::GetReserveWarRef()
+{
+	return m_vec_kReserveWar;
+}
+
+//
+// End of Guild War
+//
+
+void CGuildManager::ChangeMaster(DWORD dwGID)
+{
+	TGuildMap::iterator iter = m_mapGuild.find(dwGID);
+
+	if (iter != m_mapGuild.end())
+	{
+		iter->second->Load(dwGID);
+	}
+
+	// 트  殮
+	DBManager::instance().FuncQuery(std::bind(&CGuild::SendGuildDataUpdateToAllMember, iter->second, std::placeholders::_1), "SELECT 1");
+}
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+void CGuildManager::SendGuildEventFlagList(LPCHARACTER pChar)
+{
+	LPGUILD pGuild = pChar->GetGuild();
+	if (pGuild == nullptr)
+		return;
+
+	TGuildEventFlagMap::iterator itGuild = m_mapGuildEventFlag.find(pGuild->GetID());
+	if (itGuild != m_mapGuildEventFlag.end())
+	{
+		TEventFlagMap::iterator itEventFlag = itGuild->second.begin();
+		for (; itEventFlag != itGuild->second.end(); ++itEventFlag)
+		{
+			pChar->ChatPacket(CHAT_TYPE_INFO, "%s %ld", itEventFlag->first.c_str(), itEventFlag->second);
+		}
+	}
+}
+
+void CGuildManager::RequestSetEventFlag(DWORD dwGuildID, const std::string& strFlagName, long lValue)
+{
+	TPacketSetGuildEventFlag t;
+	t.dwGuildID = dwGuildID;
+	strlcpy(t.szFlagName, strFlagName.c_str(), sizeof(t.szFlagName));
+	t.lValue = lValue;
+	db_clientdesc->DBPacket(HEADER_GD_GUILD_EVENT_FLAG, 0, &t, sizeof(TPacketSetGuildEventFlag));
+}
+
+void CGuildManager::SetEventFlag(DWORD dwGuildID, const std::string& strFlagName, long lValue)
+{
+	long lPrevValue = m_mapGuildEventFlag[dwGuildID][strFlagName];
+
+	sys_log(0, "GUILD %u EventFlag %s prev_value %ld value %ld ", dwGuildID, strFlagName.c_str(), lPrevValue, lValue);
+	m_mapGuildEventFlag[dwGuildID][strFlagName] = lValue;
+}
+
+long CGuildManager::GetEventFlag(DWORD dwGuildID, const std::string& strFlagName)
+{
+	TGuildEventFlagMap::iterator itGuild = m_mapGuildEventFlag.find(dwGuildID);
+	if (itGuild != m_mapGuildEventFlag.end())
+	{
+		TEventFlagMap::iterator itEventFlag = itGuild->second.find(strFlagName);
+		if (itEventFlag != itGuild->second.end())
+			return itEventFlag->second;
+	}
+	return 0;
+}
+#endif
diff --git a/server/metin2/Source/Server/game/src/horsename_manager.cpp b/server/metin2/Source/Server/game/src/horsename_manager.cpp
index db8b27e..9c3fe84 100644
--- a/server/metin2/Source/Server/game/src/horsename_manager.cpp
+++ b/server/metin2/Source/Server/game/src/horsename_manager.cpp
@@ -1,75 +1,83 @@
-#include "stdafx.h"
-#include "horsename_manager.h"
-#include "desc_client.h"
-#include "char_manager.h"
-#include "char.h"
-#include "affect.h"
-#include "utils.h"
-
-CHorseNameManager::CHorseNameManager()
-{
-	m_mapHorseNames.clear();
-}
-
-const char* CHorseNameManager::GetHorseName(DWORD dwPlayerID)
-{
-	std::map<DWORD, std::string>::iterator iter;
-
-	iter = m_mapHorseNames.find(dwPlayerID);
-
-	if (iter != m_mapHorseNames.end())
-	{
-		return iter->second.c_str();
-	}
-	else
-	{
-		return NULL;
-	}
-}
-
-void CHorseNameManager::UpdateHorseName(DWORD dwPlayerID, const char* szHorseName, bool broadcast)
-{
-	if (szHorseName == NULL)
-	{
-		sys_err("HORSE_NAME: NULL NAME (%u)", dwPlayerID);
-		szHorseName = "";
-	}
-
-	sys_log(0, "HORSENAME: update %u %s", dwPlayerID, szHorseName);
-
-	m_mapHorseNames[dwPlayerID] = szHorseName;
-
-	if (broadcast == true)
-	{
-		BroadcastHorseName(dwPlayerID, szHorseName);
-	}
-}
-
-void CHorseNameManager::BroadcastHorseName(DWORD dwPlayerID, const char* szHorseName)
-{
-	TPacketUpdateHorseName packet;
-	packet.dwPlayerID = dwPlayerID;
-	strlcpy(packet.szHorseName, szHorseName, sizeof(packet.szHorseName));
-
-	db_clientdesc->DBPacket(HEADER_GD_UPDATE_HORSE_NAME, 0, &packet, sizeof(TPacketUpdateHorseName));
-}
-
-void CHorseNameManager::Validate(LPCHARACTER pChar)
-{
-	CAffect* pkAff = pChar->FindAffect(AFFECT_HORSE_NAME);
-
-	if (pkAff != NULL)
-	{
-		if (pChar->GetQuestFlag("horse_name.valid_till") < get_global_time())
-		{
-			pChar->HorseSummon(false, true);
-			pChar->RemoveAffect(pkAff);
-			UpdateHorseName(pChar->GetPlayerID(), "", true);
-			pChar->HorseSummon(true, true);
-		}
-		else
-		{
-			++(pkAff->lDuration);
-		}
-	}
-}
+#include "stdafx.h"
+#include "horsename_manager.h"
+#include "desc_client.h"
+#include "char_manager.h"
+#include "char.h"
+#include "affect.h"
+#include "utils.h"
+
+CHorseNameManager::CHorseNameManager()
+{
+	m_mapHorseNames.clear();
+}
+
+const char* CHorseNameManager::GetHorseName(DWORD dwPlayerID)
+{
+	std::map<DWORD, std::string>::iterator iter;
+
+	iter = m_mapHorseNames.find(dwPlayerID);
+
+	if (iter != m_mapHorseNames.end())
+	{
+		return iter->second.c_str();
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+void CHorseNameManager::UpdateHorseName(DWORD dwPlayerID, const char* szHorseName, bool broadcast)
+{
+	if (szHorseName == NULL)
+	{
+		sys_err("HORSE_NAME: NULL NAME (%u)", dwPlayerID);
+		szHorseName = "";
+	}
+
+	// [Security Fix] Format-string hardening: block '%' in stored horse names.
+	// Names are normally validated earlier, but this also protects DB/packet edge-cases.
+	if (strchr(szHorseName, '%') != NULL)
+	{
+		sys_err("HORSENAME: invalid character in name (%%) player %u", dwPlayerID);
+		szHorseName = "";
+	}
+
+	sys_log(0, "HORSENAME: update %u %s", dwPlayerID, szHorseName);
+
+	m_mapHorseNames[dwPlayerID] = szHorseName;
+
+	if (broadcast == true)
+	{
+		BroadcastHorseName(dwPlayerID, szHorseName);
+	}
+}
+
+void CHorseNameManager::BroadcastHorseName(DWORD dwPlayerID, const char* szHorseName)
+{
+	TPacketUpdateHorseName packet;
+	packet.dwPlayerID = dwPlayerID;
+	strlcpy(packet.szHorseName, szHorseName, sizeof(packet.szHorseName));
+
+	db_clientdesc->DBPacket(HEADER_GD_UPDATE_HORSE_NAME, 0, &packet, sizeof(TPacketUpdateHorseName));
+}
+
+void CHorseNameManager::Validate(LPCHARACTER pChar)
+{
+	CAffect* pkAff = pChar->FindAffect(AFFECT_HORSE_NAME);
+
+	if (pkAff != NULL)
+	{
+		if (pChar->GetQuestFlag("horse_name.valid_till") < get_global_time())
+		{
+			pChar->HorseSummon(false, true);
+			pChar->RemoveAffect(pkAff);
+			UpdateHorseName(pChar->GetPlayerID(), "", true);
+			pChar->HorseSummon(true, true);
+		}
+		else
+		{
+			++(pkAff->lDuration);
+		}
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/input_login.cpp b/server/metin2/Source/Server/game/src/input_login.cpp
index 5bdfcf8..b52b82e 100644
--- a/server/metin2/Source/Server/game/src/input_login.cpp
+++ b/server/metin2/Source/Server/game/src/input_login.cpp
@@ -1,1292 +1,1318 @@
-#include "stdafx.h"
-#include "constants.h"
-#include "config.h"
-#include "utils.h"
-#include "input.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "cmd.h"
-#include "buffer_manager.h"
-#include "protocol.h"
-#include "pvp.h"
-#include "start_position.h"
-#include "messenger_manager.h"
-#include "guild_manager.h"
-#include "party.h"
-#include "dungeon.h"
-#include "war_map.h"
-#include "questmanager.h"
-#include "building.h"
-#include "wedding.h"
-#include "affect.h"
-#include "arena.h"
-#include "OXEvent.h"
-#include "priv_manager.h"
-#include "block_country.h"
-#include "dev_log.h"
-#include "log.h"
-#include "horsename_manager.h"
-#include "MarkManager.h"
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-#	include "xmas_event.h"
-#endif
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-#ifdef __OFFLINE_SHOP__
-#include "OfflineShop.h"
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	#include "item_manager.h"
-#endif
-
-static void _send_bonus_info(LPCHARACTER ch)
-{
-	int item_drop_bonus = 0;
-	int gold_drop_bonus = 0;
-	int gold10_drop_bonus = 0;
-	int exp_bonus = 0;
-
-	item_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_ITEM_DROP);
-	gold_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD_DROP);
-	gold10_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD10_DROP);
-	exp_bonus = CPrivManager::instance().GetPriv(ch, PRIV_EXP_PCT);
-
-	if (item_drop_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("아이템 드롭률  %d%% 추가 이벤트 중입니다.", item_drop_bonus));
-	}
-	if (gold_drop_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("골드 드롭률 %d%% 추가 이벤트 중입니다.", gold_drop_bonus));
-	}
-	if (gold10_drop_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("대박골드 드롭률 %d%% 추가 이벤트 중입니다.", gold10_drop_bonus));
-	}
-	if (exp_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("경험치 %d%% 추가 획득 이벤트 중입니다.", exp_bonus));
-	}
-}
-
-static bool FN_is_battle_zone(LPCHARACTER ch)
-{
-	switch (ch->GetMapIndex())
-	{
-		case 1: // 신수 1차 마을
-		case 2: // 신수 2차 마을
-		case 21: // 천조 1차 마을
-		case 23: // 천조 2차 마을
-		case 41: // 진노 1차 마을
-		case 43: // 진노 2차 마을
-		case 113: // OX 맵
-			return false;
-	}
-
-	return true;
-}
-
-void CInputLogin::Login(LPDESC d, const char* data)
-{
-	TPacketCGLogin* pinfo = (TPacketCGLogin*)data;
-
-	char login[LOGIN_MAX_LEN + 1];
-	trim_and_lower(pinfo->login, login, sizeof(login));
-
-	sys_log(0, "InputLogin::Login : %s", login);
-
-	TPacketGCLoginFailure failurePacket;
-
-	if (g_iUseLocale && !test_server)
-	{
-		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-		strlcpy(failurePacket.szStatus, "VERSION", sizeof(failurePacket.szStatus));
-		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-		return;
-	}
-
-	if (g_bNoMoreClient)
-	{
-		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
-		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-		return;
-	}
-
-	if (g_iUserLimit > 0)
-	{
-		int iTotal;
-		int* paiEmpireUserCount;
-		int iLocal;
-
-		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-
-		if (g_iUserLimit <= iTotal)
-		{
-			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
-			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-			return;
-		}
-	}
-
-	TLoginPacket login_packet;
-
-	strlcpy(login_packet.login, login, sizeof(login_packet.login));
-	strlcpy(login_packet.passwd, pinfo->passwd, sizeof(login_packet.passwd));
-
-	db_clientdesc->DBPacket(HEADER_GD_LOGIN, d->GetHandle(), &login_packet, sizeof(TLoginPacket));
-}
-
-void CInputLogin::LoginByKey(LPDESC d, const char* data)
-{
-	TPacketCGLogin2* pinfo = (TPacketCGLogin2*)data;
-
-	char login[LOGIN_MAX_LEN + 1];
-	trim_and_lower(pinfo->login, login, sizeof(login));
-
-	// is blocked ip?
-	{
-		dev_log(LOG_DEB0, "check_blocked_country_start");
-
-		if (!is_block_exception(login) && is_blocked_country_ip(d->GetHostName()))
-		{
-			sys_log(0, "BLOCK_COUNTRY_IP (%s)", d->GetHostName());
-			d->SetPhase(PHASE_CLOSE);
-			return;
-		}
-
-		dev_log(LOG_DEB0, "check_blocked_country_end");
-	}
-
-	if (g_bNoMoreClient)
-	{
-		TPacketGCLoginFailure failurePacket;
-
-		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
-		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-		return;
-	}
-
-	if (g_iUserLimit > 0)
-	{
-		int iTotal;
-		int* paiEmpireUserCount;
-		int iLocal;
-
-		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-
-		if (g_iUserLimit <= iTotal)
-		{
-			TPacketGCLoginFailure failurePacket;
-
-			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
-
-			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-			return;
-		}
-	}
-
-	sys_log(0, "LOGIN_BY_KEY: %s key %u", login, pinfo->dwLoginKey);
-
-	d->SetLoginKey(pinfo->dwLoginKey);
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	d->SetSecurityKey(pinfo->adwClientKey);
-#endif
-
-	TPacketGDLoginByKey ptod;
-
-	strlcpy(ptod.szLogin, login, sizeof(ptod.szLogin));
-	ptod.dwLoginKey = pinfo->dwLoginKey;
-	thecore_memcpy(ptod.adwClientKey, pinfo->adwClientKey, sizeof(DWORD) * 4);
-	strlcpy(ptod.szIP, d->GetHostName(), sizeof(ptod.szIP));
-
-	db_clientdesc->DBPacket(HEADER_GD_LOGIN_BY_KEY, d->GetHandle(), &ptod, sizeof(TPacketGDLoginByKey));
-}
-
-void CInputLogin::ChangeName(LPDESC d, const char* data)
-{
-	TPacketCGChangeName* p = (TPacketCGChangeName*)data;
-	const TAccountTable& c_r = d->GetAccountTable();
-
-	if (!c_r.id)
-	{
-		sys_err("no account table");
-		return;
-	}
-
-	if (p->index >= PLAYER_PER_ACCOUNT || p->index < 0)
-	{
-		sys_err("index overflow %d, login: %s", p->index, c_r.login);
-		return;
-	}
-
-	if (!c_r.players[p->index].dwID)
-	{
-		sys_err("no player id, login %s", c_r.login);
-		return;
-	}
-
-	if (!c_r.players[p->index].bChangeName)
-		return;
-
-	if (!check_name(p->name))
-	{
-		TPacketGCCreateFailure pack;
-		pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-		pack.bType = 0;
-		d->Packet(&pack, sizeof(pack));
-		return;
-	}
-
-	TPacketGDChangeName pdb;
-
-	pdb.pid = c_r.players[p->index].dwID;
-	strlcpy(pdb.name, p->name, sizeof(pdb.name));
-	db_clientdesc->DBPacket(HEADER_GD_CHANGE_NAME, d->GetHandle(), &pdb, sizeof(TPacketGDChangeName));
-}
-
-void CInputLogin::CharacterSelect(LPDESC d, const char* data)
-{
-	struct command_player_select* pinfo = (struct command_player_select*)data;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	TAccountTable& c_r = d->GetAccountTable();
-#else
-	const TAccountTable& c_r = d->GetAccountTable();
-#endif
-
-	sys_log(0, "player_select: login: %s index: %d", c_r.login, pinfo->index);
-
-	if (!c_r.id)
-	{
-		sys_err("no account table");
-		return;
-	}
-
-	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
-	{
-		sys_err("index overflow %d, login: %s", pinfo->index, c_r.login);
-		return;
-	}
-
-	if (!c_r.players[pinfo->index].dwID)
-	{
-		sys_err("no player id, login %s", c_r.login);
-		return;
-	}
-
-	if (c_r.players[pinfo->index].bChangeName)
-	{
-		sys_err("name must be changed idx %d, login %s, name %s",
-			pinfo->index, c_r.login, c_r.players[pinfo->index].szName);
-		return;
-	}
-
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	if (!LocaleService_GetLocale(pinfo->country))
-	{
-		sys_err("cannot find locale country %s, login %s, name %s",
-			pinfo->country, c_r.login, c_r.players[pinfo->index].szName);
-		return;
-	}
-
-	if (strcmp(c_r.country, pinfo->country))
-	{
-		thecore_memcpy(c_r.country, pinfo->country, sizeof(c_r.country));
-
-		char query[128];
-		snprintf(query, sizeof(query), "UPDATE `account`.`account` SET `country` = '%s' WHERE `id` = %u",
-			LocaleService_GetCountry(pinfo->country), c_r.id);
-		std::unique_ptr<SQLMsg> msg(DBManager::instance().DirectQuery(query));
-	}
-#endif
-
-	TPlayerLoadPacket player_load_packet;
-
-	player_load_packet.account_id = c_r.id;
-	player_load_packet.player_id = c_r.players[pinfo->index].dwID;
-	player_load_packet.account_index = pinfo->index;
-
-	db_clientdesc->DBPacket(HEADER_GD_PLAYER_LOAD, d->GetHandle(), &player_load_packet, sizeof(TPlayerLoadPacket));
-}
-
-bool NewPlayerTable(TPlayerTable* table,
-	const char* name,
-	BYTE job,
-	BYTE shape,
-	BYTE bEmpire,
-	BYTE bCon,
-	BYTE bInt,
-	BYTE bStr,
-	BYTE bDex)
-{
-	if (job >= JOB_MAX_NUM)
-		return false;
-
-	memset(table, 0, sizeof(TPlayerTable));
-
-	strlcpy(table->name, name, sizeof(table->name));
-
-	table->level = 1;
-	table->job = job;
-	table->voice = 0;
-	table->part_base = shape;
-
-	table->st = JobInitialPoints[job].st;
-	table->dx = JobInitialPoints[job].dx;
-	table->ht = JobInitialPoints[job].ht;
-	table->iq = JobInitialPoints[job].iq;
-
-	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
-	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
-	table->stamina = JobInitialPoints[job].max_stamina;
-
-	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
-	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
-
-	table->z = 0;
-	table->dir = 0;
-	table->playtime = 0;
-	table->gold = 0;
-
-	table->skill_group = 0;
-
-	if (china_event_server)
-	{
-		table->level = 35;
-
-		for (int i = 1; i < 35; ++i)
-		{
-			int iHP = number(JobInitialPoints[job].hp_per_lv_begin, JobInitialPoints[job].hp_per_lv_end);
-			int iSP = number(JobInitialPoints[job].sp_per_lv_begin, JobInitialPoints[job].sp_per_lv_end);
-			table->sRandomHP += iHP;
-			table->sRandomSP += iSP;
-			table->stat_point += 3;
-		}
-
-		table->hp += table->sRandomHP;
-		table->sp += table->sRandomSP;
-
-		table->gold = 1000000;
-	}
-
-	return true;
-}
-
-bool RaceToJob(BYTE race, BYTE* ret_job)
-{
-	*ret_job = 0;
-
-	if (race >= MAIN_RACE_MAX_NUM)
-		return false;
-
-	switch (race)
-	{
-		case MAIN_RACE_WARRIOR_M:
-			*ret_job = JOB_WARRIOR;
-			break;
-
-		case MAIN_RACE_WARRIOR_W:
-			*ret_job = JOB_WARRIOR;
-			break;
-
-		case MAIN_RACE_ASSASSIN_M:
-			*ret_job = JOB_ASSASSIN;
-			break;
-
-		case MAIN_RACE_ASSASSIN_W:
-			*ret_job = JOB_ASSASSIN;
-			break;
-
-		case MAIN_RACE_SURA_M:
-			*ret_job = JOB_SURA;
-			break;
-
-		case MAIN_RACE_SURA_W:
-			*ret_job = JOB_SURA;
-			break;
-
-		case MAIN_RACE_SHAMAN_M:
-			*ret_job = JOB_SHAMAN;
-			break;
-
-		case MAIN_RACE_SHAMAN_W:
-			*ret_job = JOB_SHAMAN;
-			break;
-
-		case MAIN_RACE_WOLFMAN_M:
-			*ret_job = JOB_WOLFMAN;
-			break;
-
-		default:
-			return false;
-			break;
-	}
-	return true;
-}
-
-// 신규 캐릭터 지원
-bool NewPlayerTable2(TPlayerTable* table, const char* name, BYTE race, BYTE shape, BYTE bEmpire)
-{
-	if (race >= MAIN_RACE_MAX_NUM)
-	{
-		sys_err("NewPlayerTable2.OUT_OF_RACE_RANGE(%d >= max(%d))\n", race, MAIN_RACE_MAX_NUM);
-		return false;
-	}
-
-	BYTE job;
-	if (!RaceToJob(race, &job))
-	{
-		sys_err("NewPlayerTable2.RACE_TO_JOB_ERROR(%d)\n", race);
-		return false;
-	}
-
-	sys_log(0, "NewPlayerTable2(name=%s, race=%d, job=%d)", name, race, job);
-
-	memset(table, 0, sizeof(TPlayerTable));
-
-	strlcpy(table->name, name, sizeof(table->name));
-
-	table->level = 1;
-	table->job = race; // 직업대신 종족을 넣는다
-	table->voice = 0;
-	table->part_base = shape;
-
-	table->st = JobInitialPoints[job].st;
-	table->dx = JobInitialPoints[job].dx;
-	table->ht = JobInitialPoints[job].ht;
-	table->iq = JobInitialPoints[job].iq;
-
-	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
-	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
-	table->stamina = JobInitialPoints[job].max_stamina;
-
-	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
-	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
-
-	table->z = 0;
-	table->dir = 0;
-	table->playtime = 0;
-	table->gold = 0;
-
-	table->skill_group = 0;
-
-	return true;
-}
-
-void CInputLogin::CharacterCreate(LPDESC d, const char* data)
-{
-	struct command_player_create* pinfo = (struct command_player_create*)data;
-	TPlayerCreatePacket player_create_packet;
-
-	sys_log(0, "PlayerCreate: name %s pos %d job %d shape %d",
-		pinfo->name,
-		pinfo->index,
-		pinfo->job,
-		pinfo->shape
-	);
-
-	TPacketGCLoginFailure packFailure;
-	memset(&packFailure, 0, sizeof(packFailure));
-	packFailure.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-
-	if (true == g_BlockCharCreation)
-	{
-		d->Packet(&packFailure, sizeof(packFailure));
-		return;
-	}
-
-	if (!g_bWolfmanCreation)
-	{
-		if (pinfo->job == MAIN_RACE_WOLFMAN_M)
-		{
-			d->Packet(&packFailure, sizeof(packFailure));
-			return;
-		}
-	}
-
-	// 사용할 수 없는 이름이거나, 잘못된 평상복이면 생설 실패
-	if (!check_name(pinfo->name) || pinfo->shape > 1)
-	{
-		if (LC_IsCanada() == true)
-		{
-			TPacketGCCreateFailure pack;
-			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-			pack.bType = 1;
-
-			d->Packet(&pack, sizeof(pack));
-			return;
-		}
-
-		d->Packet(&packFailure, sizeof(packFailure));
-		return;
-	}
-
-	if (LC_IsEurope() == true)
-	{
-		const TAccountTable& c_rAccountTable = d->GetAccountTable();
-
-		if (0 == strcmp(c_rAccountTable.login, pinfo->name))
-		{
-			TPacketGCCreateFailure pack;
-			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-			pack.bType = 1;
-
-			d->Packet(&pack, sizeof(pack));
-			return;
-		}
-	}
-
-	memset(&player_create_packet, 0, sizeof(TPlayerCreatePacket));
-
-	if (!NewPlayerTable2(&player_create_packet.player_table, pinfo->name, pinfo->job, pinfo->shape, d->GetEmpire()))
-	{
-		sys_err("player_prototype error: job %d face %d ", pinfo->job);
-		d->Packet(&packFailure, sizeof(packFailure));
-		return;
-	}
-
-	const TAccountTable& c_rAccountTable = d->GetAccountTable();
-
-	trim_and_lower(c_rAccountTable.login, player_create_packet.login, sizeof(player_create_packet.login));
-	strlcpy(player_create_packet.passwd, c_rAccountTable.passwd, sizeof(player_create_packet.passwd));
-
-	player_create_packet.account_id = c_rAccountTable.id;
-	player_create_packet.account_index = pinfo->index;
-
-	sys_log(0, "PlayerCreate: name %s account_id %d, TPlayerCreatePacketSize(%d), Packet->Gold %d",
-		pinfo->name,
-		pinfo->index,
-		sizeof(TPlayerCreatePacket),
-		player_create_packet.player_table.gold);
-
-	db_clientdesc->DBPacket(HEADER_GD_PLAYER_CREATE, d->GetHandle(), &player_create_packet, sizeof(TPlayerCreatePacket));
-}
-
-void CInputLogin::CharacterDelete(LPDESC d, const char* data)
-{
-	struct command_player_delete* pinfo = (struct command_player_delete*)data;
-	const TAccountTable& c_rAccountTable = d->GetAccountTable();
-
-	if (!c_rAccountTable.id)
-	{
-		sys_err("PlayerDelete: no login data");
-		return;
-	}
-
-	sys_log(0, "PlayerDelete: login: %s index: %d, social_id %s", c_rAccountTable.login, pinfo->index, pinfo->private_code);
-
-	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
-	{
-		sys_err("PlayerDelete: index overflow %d, login: %s", pinfo->index, c_rAccountTable.login);
-		return;
-	}
-
-	if (!c_rAccountTable.players[pinfo->index].dwID)
-	{
-		sys_err("PlayerDelete: Wrong Social ID index %d, login: %s", pinfo->index, c_rAccountTable.login);
-		d->Packet(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), 1);
-		return;
-	}
-
-	TPlayerDeletePacket player_delete_packet;
-
-	trim_and_lower(c_rAccountTable.login, player_delete_packet.login, sizeof(player_delete_packet.login));
-	player_delete_packet.player_id = c_rAccountTable.players[pinfo->index].dwID;
-	player_delete_packet.account_index = pinfo->index;
-	strlcpy(player_delete_packet.private_code, pinfo->private_code, sizeof(player_delete_packet.private_code));
-
-	db_clientdesc->DBPacket(HEADER_GD_PLAYER_DELETE, d->GetHandle(), &player_delete_packet, sizeof(TPlayerDeletePacket));
-}
-
-#pragma pack(1)
-typedef struct SPacketGTLogin
-{
-	BYTE header;
-	WORD empty;
-	DWORD id;
-} TPacketGTLogin;
-#pragma pack()
-
-void CInputLogin::Entergame(LPDESC d, const char* data)
-{
-	LPCHARACTER ch;
-
-	if (!(ch = d->GetCharacter()))
-	{
-		d->SetPhase(PHASE_CLOSE);
-		return;
-	}
-
-	PIXEL_POSITION pos = ch->GetXYZ();
-	if (!SECTREE_MANAGER::instance().GetMovablePosition(ch->GetMapIndex(), pos.x, pos.y, pos))
-	{
-		PIXEL_POSITION pos2;
-		SECTREE_MANAGER::instance().GetRecallPositionByEmpire(ch->GetMapIndex(), ch->GetEmpire(), pos2);
-
-		sys_err("!GetMovablePosition (name %s %dx%d map %d changed to %dx%d)",
-			ch->GetName(),
-			pos.x, pos.y,
-			ch->GetMapIndex(),
-			pos2.x, pos2.y);
-		pos = pos2;
-	}
-
-	CGuildManager::instance().LoginMember(ch);
-
-	// 캐릭터를 맵에 추가
-	ch->Show(ch->GetMapIndex(), pos.x, pos.y, pos.z);
-	ch->ReviveInvisible(5);
-
-#if !defined(__BINARY_ATLAS_MARK_INFO__)
-	SECTREE_MANAGER::instance().SendNPCPosition(ch);
-#endif
-
-	d->SetPhase(PHASE_GAME);
-
-#if defined(__HIDE_COSTUME_SYSTEM__)
-	ch->SetHiddenCostumeParts();
-#endif
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	const LPITEM& rkCostumeMount = ch->GetWear(WEAR_COSTUME_MOUNT);
-	if (rkCostumeMount)
-		ch->MountVnum(rkCostumeMount->GetMountVnum());
-	else if (ch->GetHorseLevel() > 0)
-		ch->EnterHorse();
-#else
-	if (ch->GetHorseLevel() > 0)
-		ch->EnterHorse();
-#endif
-
-	if (ch->GetItemAward_cmd()[0] != '\0') // 게임페이즈 들어가면
-		quest::CQuestManager::instance().ItemInformer(ch->GetPlayerID(), ch->GetItemAward_vnum()); // questmanager 호출
-
-	sys_log(0, "ENTERGAME: %s %dx%dx%d %s map_index %d",
-		ch->GetName(), ch->GetX(), ch->GetY(), ch->GetZ(), d->GetHostName(), ch->GetMapIndex());
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	ch->SendExtendInvenPacket();
-#endif
-
-	// Check unwanted quickslot items.
-	ch->CheckQuickSlotItems();
-
-	// 플레이시간 레코딩 시작
-	ch->ResetPlayTime();
-
-	// 자동 저장 이벤트 추가
-	ch->StartSaveEvent();
-	ch->StartRecoveryEvent();
-	ch->StartCheckSpeedHackEvent();
-	ch->SetQuestFlag("item.last_time", get_global_time());
-
-	CPVPManager::instance().Connect(ch);
-	CPVPManager::instance().SendList(d);
-
-	CMessengerManager::instance().Login(ch->GetName());
-
-	CPartyManager::instance().SetParty(ch);
-	CGuildManager::instance().SendGuildWar(ch);
-
-	building::CManager::instance().SendLandList(d, ch->GetMapIndex());
-
-	marriage::CManager::instance().Login(ch);
-
-#ifdef __OFFLINE_SHOP__
-	COfflineShop::Login(ch);
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	TPacketGDEmote GDPacket = {};
-	GDPacket.dwPID = ch->GetPlayerID();
-	db_clientdesc->DBPacket(HEADER_GD_EMOTE_LOAD, ch->GetDesc()->GetHandle(), &GDPacket, sizeof(GDPacket));
-#endif
-
-	TPacketGCTime p;
-	p.bHeader = HEADER_GC_TIME;
-	p.time = get_global_time();
-	d->Packet(&p, sizeof(p));
-
-	TPacketGCChannel p2;
-	p2.header = HEADER_GC_CHANNEL;
-	p2.channel = g_bChannel;
-	d->Packet(&p2, sizeof(p2));
-
-#if defined(__LOOT_FILTER_SYSTEM__) && !defined(__PREMIUM_LOOT_FILTER__)
-	ch->SetLootFilter();
-#endif
-
-#if defined(__MAILBOX__)
-	CMailBox::UnreadData(ch);
-#endif
-
-	ch->SendGreetMessage();
-	_send_bonus_info(ch);
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("UPDATE player%s SET `last_play` = NOW() WHERE `name` = '%s'",
-		get_table_postfix(), ch->GetName())
-	);
-
-	ch->LoadSafeboxBuff();
-
-	for (int i = 0; i <= PREMIUM_MAX_NUM; ++i)
-	{
-		int remain = ch->GetPremiumRemainSeconds(i);
-
-		if (remain <= 0)
-			continue;
-
-#if defined(__CONQUEROR_LEVEL__)
-		int idx = AFFECT_PREMIUM_START + i;
-		if (idx == AFFECT_SUNGMA_BONUS)
-		{
-			for (int affect = POINT_SUNGMA_STR; affect <= POINT_SUNGMA_IMMUNE; ++affect)
-				ch->AddAffect(idx, affect, 10, 0, remain, 0, true, true);
-		}
-		else
-			ch->AddAffect(idx, POINT_NONE, 0, 0, remain, 0, true);
-#else
-		ch->AddAffect(AFFECT_PREMIUM_START + i, POINT_NONE, 0, 0, remain, 0, true);
-#endif
-		sys_log(0, "PREMIUM: %s type %d %dmin", ch->GetName(), i, remain);
-	}
-#ifdef __OFFLINE_SHOP__
-	int remainBuy = ch->GetQuestFlag("decoration.limit_time") - get_global_time();
-	if (remainBuy > 0)
-		ch->AddAffect(AFFECT_OFFLINE_SHOP_DECORATION, POINT_NONE, 0, 0, remainBuy, 0, true);
-#endif
-
-	if (g_bCheckClientVersion)
-	{
-		sys_log(0, "VERSION CHECK %s %s", g_stClientVersion.c_str(), d->GetClientVersion());
-
-		if (!d->GetClientVersion())
-		{
-			d->DelayedDisconnect(10);
-		}
-		else
-		{
-			if (0 != g_stClientVersion.compare(d->GetClientVersion()))
-			{
-				ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("클라이언트 버전이 틀려 로그아웃 됩니다. 정상적으로 패치 후 접속하세요."));
-				d->DelayedDisconnect(0);
-				LogManager::instance().HackLog("VERSION_CONFLICT", ch);
-
-				sys_log(0, "VERSION : WRONG VERSION USER : account:%s name:%s hostName:%s server_version:%s client_version:%s",
-					d->GetAccountTable().login,
-					ch->GetName(),
-					d->GetHostName(),
-					g_stClientVersion.c_str(),
-					d->GetClientVersion());
-			}
-		}
-	}
-	else
-	{
-		sys_log(0, "VERSION : NO CHECK");
-	}
-
-	if (ch->IsGM() == true)
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "ConsoleEnable");
-
-#if defined(__POPUP_NOTICE__)
-	if (quest::CQuestManager::instance().GetEventFlag("PopupNoticeEventFlag") > 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "PopupNoticeProcess %d %s",
-			ch->GetQuestFlag("popup_notice.checkbox"), g_strWebPopupNoticeURL.c_str());
-	}
-#endif
-
-#if defined(__MOVE_CHANNEL__)
-	ch->ChatPacket(CHAT_TYPE_COMMAND, "server_info %d %d", g_bChannel, ch->GetMapIndex());
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	CSnowflakeStickEvent::EnterGame(ch);
-#endif
-
-	if (ch->GetMapIndex() >= 10000)
-	{
-		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()))
-		{
-			ch->SetWarMap(CWarMapManager::instance().Find(ch->GetMapIndex()));
-		}
-		else if (marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
-		{
-			ch->SetWeddingMap(marriage::WeddingManager::instance().Find(ch->GetMapIndex()));
-		}
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-		else if (CGuildDragonLairManager::Instance().IsRedDragonLair(ch->GetMapIndex()))
-		{
-			ch->SetGuildDragonLair(CGuildDragonLairManager::Instance().FindByMapIndex(ch->GetMapIndex()));
-		}
-#endif
-#if defined(__DEFENSE_WAVE__)
-		else if (CDefenseWaveManager::instance().IsDefenseWaveMap(ch->GetMapIndex()))
-		{
-			ch->SetDefenseWave(CDefenseWaveManager::instance().FindByMapIndex(ch->GetMapIndex()));
-		}
-#endif
-		else
-		{
-			ch->SetDungeon(CDungeonManager::instance().FindByMapIndex(ch->GetMapIndex()));
-		}
-	}
-	else if (CArenaManager::instance().IsArenaMap(ch->GetMapIndex()))
-	{
-		int memberFlag = CArenaManager::instance().IsMember(ch->GetMapIndex(), ch->GetPlayerID());
-		if (memberFlag == MEMBER_OBSERVER)
-		{
-			ch->SetObserverMode(true);
-			ch->SetArenaObserverMode(true);
-			if (CArenaManager::instance().RegisterObserverPtr(ch, ch->GetMapIndex(), ch->GetX() / 100, ch->GetY() / 100))
-			{
-				sys_log(0, "ARENA : Observer add failed");
-			}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			ch->UnMount(ch);
-#else
-			if (ch->IsHorseRiding() == true)
-			{
-				ch->StopRiding();
-				ch->HorseSummon(false);
-			}
-#endif
-		}
-		else if (memberFlag == MEMBER_DUELIST)
-		{
-			TPacketGCDuelStart duelStart;
-			duelStart.header = HEADER_GC_DUEL_START;
-			duelStart.wSize = sizeof(TPacketGCDuelStart);
-
-			ch->GetDesc()->Packet(&duelStart, sizeof(TPacketGCDuelStart));
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			ch->UnMount(ch);
-#else
-			if (ch->IsHorseRiding() == true)
-			{
-				ch->StopRiding();
-				ch->HorseSummon(false);
-			}
-#endif
-
-			LPPARTY pParty = ch->GetParty();
-			if (pParty != NULL)
-			{
-				if (pParty->GetMemberCount() == 2)
-				{
-					CPartyManager::instance().DeleteParty(pParty);
-				}
-				else
-				{
-					pParty->Quit(ch->GetPlayerID());
-				}
-			}
-		}
-		/*
-		else if (memberFlag == MEMBER_NO)
-		{
-			if (ch->GetGMLevel() == GM_PLAYER)
-				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-		else
-		{
-			// wtf
-		}
-		*/
-	}
-	else if (ch->GetMapIndex() == MAP_OXEVENT)
-	{
-		// ox 이벤트 맵
-		if (COXEventManager::instance().Enter(ch) == false)
-		{
-			// ox 맵 진입 허가가 나지 않음. 플레이어면 마을로 보내자
-			if (ch->GetGMLevel() == GM_PLAYER)
-				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-	}
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	else if (ch->GetMapIndex() == MAP_N_FLAME_DRAGON)
-	{
-		CGuildDragonLairManager::Instance().Exit(ch);
-	}
-#endif
-	else
-	{
-		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()) ||
-			marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
-		{
-			if (!test_server)
-				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-
-#if defined(__ELEMENTAL_DUNGEON__)
-		if (ch->GetMapIndex() == MAP_ELEMENTAL_04)
-			ch->StartElementalCurseEvent();
-		else
-			ch->StopElementalCurseEvent();
-#endif
-	}
-
-	if (ch->GetHorseLevel() > 0)
-	{
-		DWORD pid = ch->GetPlayerID();
-
-		if (pid > 0)
-		{
-			const char* horseName = CHorseNameManager::instance().GetHorseName(pid);
-			if (!horseName || !*horseName)
-				db_clientdesc->DBPacket(HEADER_GD_REQ_HORSE_NAME, 0, &pid, sizeof(DWORD));
-		}
-	}
-
-	// 중립맵에 들어갔을때 안내하기
-	if (g_noticeBattleZone)
-	{
-		if (FN_is_battle_zone(ch))
-		{
-			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("이 맵에선 강제적인 대전이 있을수 도 있습니다."));
-			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("이 조항에 동의하지 않을시"));
-			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("본인의 주성 및 부성으로 돌아가시기 바랍니다."));
-		}
-	}
-#ifdef __GROWTH_PET_SYSTEM__
-	if (!IS_BLOCKED_PET(ch->GetMapIndex()))
-	{
-		DWORD growthPetID = ch->GetQuestFlag("system.grow_pet_summoned");
-		if (growthPetID)
-		{
-			LPITEM petSeal = ITEM_MANAGER::instance().Find(growthPetID);
-			if (petSeal && petSeal->GetType() == ITEM_PET && petSeal->GetSubType() == PET_UPBRINGING)
-			{
-				LPGROWTH_PET pPet = ch->GetGrowthPet(petSeal->GetSocket(2));
-				if (pPet)
-				{
-					if (!ch->GetActiveGrowthPet())
-					{
-						LPGROWTH_PET pkPet = pPet->Summon(petSeal);
-						ch->SetActiveGrowthPet(pkPet);
-					}
-				}
-			}
-		}
-	}
-#endif
-}
-
-void CInputLogin::Empire(LPDESC d, const char* c_pData)
-{
-	const TPacketCGEmpire* p = reinterpret_cast<const TPacketCGEmpire*>(c_pData);
-
-	if (EMPIRE_MAX_NUM <= p->bEmpire)
-	{
-		d->SetPhase(PHASE_CLOSE);
-		return;
-	}
-
-	const TAccountTable& r = d->GetAccountTable();
-
-	if (r.bEmpire != 0)
-	{
-		for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
-		{
-			if (0 != r.players[i].dwID)
-			{
-				sys_err("EmpireSelectFailed %d", r.players[i].dwID);
-				return;
-			}
-		}
-	}
-
-	TEmpireSelectPacket pd;
-
-	pd.dwAccountID = r.id;
-	pd.bEmpire = p->bEmpire;
-
-	db_clientdesc->DBPacket(HEADER_GD_EMPIRE_SELECT, d->GetHandle(), &pd, sizeof(pd));
-}
-
-int CInputLogin::GuildSymbolUpload(LPDESC d, const char* c_pData, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGGuildSymbolUpload))
-		return -1;
-
-	sys_log(0, "GuildSymbolUpload uiBytes %u", uiBytes);
-
-	TPacketCGGuildSymbolUpload* p = (TPacketCGGuildSymbolUpload*)c_pData;
-
-	if (uiBytes < p->size)
-		return -1;
-
-	int iSymbolSize = p->size - sizeof(TPacketCGGuildSymbolUpload);
-
-	if (iSymbolSize <= 0 || iSymbolSize > 64 * 1024)
-	{
-		// 64k 보다 큰 길드 심볼은 올릴수없다
-		// 접속을 끊고 무시
-		d->SetPhase(PHASE_CLOSE);
-		return 0;
-	}
-
-	// 땅을 소유하지 않은 길드인 경우.
-	if (!test_server)
-		if (!building::CManager::instance().FindLandByGuild(p->guild_id))
-		{
-			d->SetPhase(PHASE_CLOSE);
-			return 0;
-		}
-
-	sys_log(0, "GuildSymbolUpload Do Upload %02X%02X%02X%02X %d", c_pData[7], c_pData[8], c_pData[9], c_pData[10], sizeof(*p));
-
-	CGuildMarkManager::instance().UploadSymbol(p->guild_id, iSymbolSize, (const BYTE*)(c_pData + sizeof(*p)));
-	CGuildMarkManager::instance().SaveSymbol(GUILD_SYMBOL_FILENAME);
-	return iSymbolSize;
-}
-
-void CInputLogin::GuildSymbolCRC(LPDESC d, const char* c_pData)
-{
-	const TPacketCGSymbolCRC& CGPacket = *((TPacketCGSymbolCRC*)c_pData);
-
-	sys_log(0, "GuildSymbolCRC %u %u %u", CGPacket.guild_id, CGPacket.crc, CGPacket.size);
-
-	const CGuildMarkManager::TGuildSymbol* pkGS = CGuildMarkManager::instance().GetGuildSymbol(CGPacket.guild_id);
-
-	if (!pkGS)
-		return;
-
-	sys_log(0, "  Server %u %u", pkGS->crc, pkGS->raw.size());
-
-	if (pkGS->raw.size() != CGPacket.size || pkGS->crc != CGPacket.crc)
-	{
-		TPacketGCGuildSymbolData GCPacket;
-
-		GCPacket.header = HEADER_GC_SYMBOL_DATA;
-		GCPacket.size = sizeof(GCPacket) + pkGS->raw.size();
-		GCPacket.guild_id = CGPacket.guild_id;
-
-		d->BufferedPacket(&GCPacket, sizeof(GCPacket));
-		d->Packet(&pkGS->raw[0], pkGS->raw.size());
-
-		sys_log(0, "SendGuildSymbolHead %02X%02X%02X%02X Size %d",
-			pkGS->raw[0], pkGS->raw[1], pkGS->raw[2], pkGS->raw[3], pkGS->raw.size());
-	}
-}
-
-void CInputLogin::GuildMarkUpload(LPDESC d, const char* c_pData)
-{
-	TPacketCGMarkUpload* p = (TPacketCGMarkUpload*)c_pData;
-	CGuildManager& rkGuildMgr = CGuildManager::instance();
-	CGuild* pkGuild;
-
-	if (!(pkGuild = rkGuildMgr.FindGuild(p->gid)))
-	{
-		sys_err("MARK_SERVER: GuildMarkUpload: no guild. gid %u", p->gid);
-		return;
-	}
-
-	if (pkGuild->GetLevel() < guild_mark_min_level)
-	{
-		sys_log(0, "MARK_SERVER: GuildMarkUpload: level < %u (%u)", guild_mark_min_level, pkGuild->GetLevel());
-		return;
-	}
-
-	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
-
-	sys_log(0, "MARK_SERVER: GuildMarkUpload: gid %u", p->gid);
-
-	bool isEmpty = true;
-
-	for (DWORD iPixel = 0; iPixel < SGuildMark::SIZE; ++iPixel)
-		if (*((DWORD*)p->image + iPixel) != 0x00000000)
-			isEmpty = false;
-
-	if (isEmpty)
-		rkMarkMgr.DeleteMark(p->gid);
-	else
-		rkMarkMgr.SaveMark(p->gid, p->image);
-}
-
-void CInputLogin::GuildMarkIDXList(LPDESC d, const char* c_pData)
-{
-	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
-
-	DWORD bufSize = sizeof(WORD) * 2 * rkMarkMgr.GetMarkCount();
-	char* buf = NULL;
-
-	if (bufSize > 0)
-	{
-		buf = (char*)malloc(bufSize);
-		rkMarkMgr.CopyMarkIdx(buf);
-	}
-
-	TPacketGCMarkIDXList p;
-	p.header = HEADER_GC_MARK_IDXLIST;
-	p.bufSize = sizeof(p) + bufSize;
-	p.count = rkMarkMgr.GetMarkCount();
-
-	if (buf)
-	{
-		d->BufferedPacket(&p, sizeof(p));
-		d->LargePacket(buf, bufSize);
-		free(buf);
-	}
-	else
-		d->Packet(&p, sizeof(p));
-
-	sys_log(0, "MARK_SERVER: GuildMarkIDXList %d bytes sent.", p.bufSize);
-}
-
-void CInputLogin::GuildMarkCRCList(LPDESC d, const char* c_pData)
-{
-	TPacketCGMarkCRCList* pCG = (TPacketCGMarkCRCList*)c_pData;
-
-	std::map<BYTE, const SGuildMarkBlock*> mapDiffBlocks;
-	CGuildMarkManager::instance().GetDiffBlocks(pCG->imgIdx, pCG->crclist, mapDiffBlocks);
-
-	DWORD blockCount = 0;
-	TEMP_BUFFER buf(1024 * 1024); // 1M 버퍼
-
-	for (auto it = mapDiffBlocks.begin(); it != mapDiffBlocks.end(); ++it)
-	{
-		BYTE posBlock = it->first;
-		const SGuildMarkBlock& rkBlock = *it->second;
-
-		buf.write(&posBlock, sizeof(BYTE));
-		buf.write(&rkBlock.m_sizeCompBuf, sizeof(DWORD));
-		buf.write(rkBlock.m_abCompBuf, rkBlock.m_sizeCompBuf);
-
-		++blockCount;
-	}
-
-	TPacketGCMarkBlock pGC;
-
-	pGC.header = HEADER_GC_MARK_BLOCK;
-	pGC.imgIdx = pCG->imgIdx;
-	pGC.bufSize = buf.size() + sizeof(TPacketGCMarkBlock);
-	pGC.count = blockCount;
-
-	sys_log(0, "MARK_SERVER: Sending blocks. (imgIdx %u diff %u size %u)", pCG->imgIdx, mapDiffBlocks.size(), pGC.bufSize);
-
-	if (buf.size() > 0)
-	{
-		d->BufferedPacket(&pGC, sizeof(TPacketGCMarkBlock));
-		d->LargePacket(buf.read_peek(), buf.size());
-	}
-	else
-		d->Packet(&pGC, sizeof(TPacketGCMarkBlock));
-}
-
-int CInputLogin::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	int iExtraLen = 0;
-
-	switch (bHeader)
-	{
-		case HEADER_CG_PONG:
-			Pong(d);
-			break;
-
-		case HEADER_CG_TIME_SYNC:
-			Handshake(d, c_pData);
-			break;
-
-		case HEADER_CG_LOGIN:
-			Login(d, c_pData);
-			break;
-
-		case HEADER_CG_LOGIN2:
-			LoginByKey(d, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_SELECT:
-			CharacterSelect(d, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_CREATE:
-			CharacterCreate(d, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_DELETE:
-			CharacterDelete(d, c_pData);
-			break;
-
-		case HEADER_CG_ENTERGAME:
-			Entergame(d, c_pData);
-			break;
-
-		case HEADER_CG_EMPIRE:
-			Empire(d, c_pData);
-			break;
-
-		case HEADER_CG_MOVE:
-		case HEADER_CG_ITEM_USE:
-		case HEADER_CG_TARGET:
-			break;
-
-			///////////////////////////////////////
-			// Guild Mark
-			/////////////////////////////////////
-		case HEADER_CG_MARK_LOGIN:
-			break;
-
-		case HEADER_CG_MARK_CRCLIST:
-			GuildMarkCRCList(d, c_pData);
-			break;
-
-		case HEADER_CG_MARK_IDXLIST:
-			GuildMarkIDXList(d, c_pData);
-			break;
-
-		case HEADER_CG_MARK_UPLOAD:
-			GuildMarkUpload(d, c_pData);
-			break;
-
-			//////////////////////////////////////
-			// Guild Symbol
-			/////////////////////////////////////
-		case HEADER_CG_GUILD_SYMBOL_UPLOAD:
-			if ((iExtraLen = GuildSymbolUpload(d, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_SYMBOL_CRC:
-			GuildSymbolCRC(d, c_pData);
-			break;
-			/////////////////////////////////////
-
-		case HEADER_CG_HACK:
-			break;
-
-		case HEADER_CG_CHANGE_NAME:
-			ChangeName(d, c_pData);
-			break;
-
-		case HEADER_CG_CLIENT_VERSION:
-			Version(d->GetCharacter(), c_pData);
-			break;
-
-		case HEADER_CG_CLIENT_VERSION2:
-			Version(d->GetCharacter(), c_pData);
-			break;
-
-		default:
-			sys_err("login phase does not handle this packet! header %d", bHeader);
-			//d->SetPhase(PHASE_CLOSE);
-			return (0);
-	}
-
-	return (iExtraLen);
-}
+#include "stdafx.h"
+#include "constants.h"
+#include "config.h"
+#include "utils.h"
+#include "input.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "cmd.h"
+#include "buffer_manager.h"
+#include "protocol.h"
+#include "pvp.h"
+#include "start_position.h"
+#include "messenger_manager.h"
+#include "guild_manager.h"
+#include "party.h"
+#include "dungeon.h"
+#include "war_map.h"
+#include "questmanager.h"
+#include "building.h"
+#include "wedding.h"
+#include "affect.h"
+#include "arena.h"
+#include "OXEvent.h"
+#include "priv_manager.h"
+#include "block_country.h"
+#include "dev_log.h"
+#include "log.h"
+#include "horsename_manager.h"
+#include "MarkManager.h"
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+#	include "xmas_event.h"
+#endif
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+#ifdef __OFFLINE_SHOP__
+#include "OfflineShop.h"
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	#include "item_manager.h"
+#endif
+
+static void _send_bonus_info(LPCHARACTER ch)
+{
+	int item_drop_bonus = 0;
+	int gold_drop_bonus = 0;
+	int gold10_drop_bonus = 0;
+	int exp_bonus = 0;
+
+	item_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_ITEM_DROP);
+	gold_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD_DROP);
+	gold10_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD10_DROP);
+	exp_bonus = CPrivManager::instance().GetPriv(ch, PRIV_EXP_PCT);
+
+	if (item_drop_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING(" 獺  %d%% 煞 遣트 都求.", item_drop_bonus));
+	}
+	if (gold_drop_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING(" 獺 %d%% 煞 遣트 都求.", gold_drop_bonus));
+	}
+	if (gold10_drop_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING("微 獺 %d%% 煞 遣트 都求.", gold10_drop_bonus));
+	}
+	if (exp_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING("치 %d%% 煞 획 遣트 都求.", exp_bonus));
+	}
+}
+
+static bool FN_is_battle_zone(LPCHARACTER ch)
+{
+	switch (ch->GetMapIndex())
+	{
+		case 1: // 탉 1 
+		case 2: // 탉 2 
+		case 21: // 천 1 
+		case 23: // 천 2 
+		case 41: //  1 
+		case 43: //  2 
+		case 113: // OX 
+			return false;
+	}
+
+	return true;
+}
+
+void CInputLogin::Login(LPDESC d, const char* data)
+{
+	TPacketCGLogin* pinfo = (TPacketCGLogin*)data;
+
+	char login[LOGIN_MAX_LEN + 1];
+	trim_and_lower(pinfo->login, login, sizeof(login));
+
+	sys_log(0, "InputLogin::Login : %s", login);
+
+	TPacketGCLoginFailure failurePacket;
+
+	if (g_iUseLocale && !test_server)
+	{
+		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+		strlcpy(failurePacket.szStatus, "VERSION", sizeof(failurePacket.szStatus));
+		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+		return;
+	}
+
+	if (g_bNoMoreClient)
+	{
+		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
+		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+		return;
+	}
+
+	if (g_iUserLimit > 0)
+	{
+		int iTotal;
+		int* paiEmpireUserCount;
+		int iLocal;
+
+		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+
+		if (g_iUserLimit <= iTotal)
+		{
+			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
+			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+			return;
+		}
+	}
+
+	TLoginPacket login_packet;
+
+	strlcpy(login_packet.login, login, sizeof(login_packet.login));
+	strlcpy(login_packet.passwd, pinfo->passwd, sizeof(login_packet.passwd));
+
+	db_clientdesc->DBPacket(HEADER_GD_LOGIN, d->GetHandle(), &login_packet, sizeof(TLoginPacket));
+}
+
+void CInputLogin::LoginByKey(LPDESC d, const char* data)
+{
+	TPacketCGLogin2* pinfo = (TPacketCGLogin2*)data;
+
+	char login[LOGIN_MAX_LEN + 1];
+	trim_and_lower(pinfo->login, login, sizeof(login));
+
+	// is blocked ip?
+	{
+		dev_log(LOG_DEB0, "check_blocked_country_start");
+
+		if (!is_block_exception(login) && is_blocked_country_ip(d->GetHostName()))
+		{
+			sys_log(0, "BLOCK_COUNTRY_IP (%s)", d->GetHostName());
+			d->SetPhase(PHASE_CLOSE);
+			return;
+		}
+
+		dev_log(LOG_DEB0, "check_blocked_country_end");
+	}
+
+	if (g_bNoMoreClient)
+	{
+		TPacketGCLoginFailure failurePacket;
+
+		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
+		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+		return;
+	}
+
+	if (g_iUserLimit > 0)
+	{
+		int iTotal;
+		int* paiEmpireUserCount;
+		int iLocal;
+
+		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+
+		if (g_iUserLimit <= iTotal)
+		{
+			TPacketGCLoginFailure failurePacket;
+
+			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
+
+			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+			return;
+		}
+	}
+
+	sys_log(0, "LOGIN_BY_KEY: %s key %u", login, pinfo->dwLoginKey);
+
+	d->SetLoginKey(pinfo->dwLoginKey);
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	d->SetSecurityKey(pinfo->adwClientKey);
+#endif
+
+	TPacketGDLoginByKey ptod;
+
+	strlcpy(ptod.szLogin, login, sizeof(ptod.szLogin));
+	ptod.dwLoginKey = pinfo->dwLoginKey;
+	thecore_memcpy(ptod.adwClientKey, pinfo->adwClientKey, sizeof(DWORD) * 4);
+	strlcpy(ptod.szIP, d->GetHostName(), sizeof(ptod.szIP));
+
+	db_clientdesc->DBPacket(HEADER_GD_LOGIN_BY_KEY, d->GetHandle(), &ptod, sizeof(TPacketGDLoginByKey));
+}
+
+void CInputLogin::ChangeName(LPDESC d, const char* data)
+{
+	TPacketCGChangeName* p = (TPacketCGChangeName*)data;
+	const TAccountTable& c_r = d->GetAccountTable();
+
+	if (!c_r.id)
+	{
+		sys_err("no account table");
+		return;
+	}
+
+	if (p->index >= PLAYER_PER_ACCOUNT || p->index < 0)
+	{
+		sys_err("index overflow %d, login: %s", p->index, c_r.login);
+		return;
+	}
+
+	if (!c_r.players[p->index].dwID)
+	{
+		sys_err("no player id, login %s", c_r.login);
+		return;
+	}
+
+	if (!c_r.players[p->index].bChangeName)
+		return;
+
+	if (!check_name(p->name))
+	{
+		TPacketGCCreateFailure pack;
+		pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+		pack.bType = 0;
+		d->Packet(&pack, sizeof(pack));
+		return;
+	}
+
+	TPacketGDChangeName pdb;
+
+	pdb.pid = c_r.players[p->index].dwID;
+	strlcpy(pdb.name, p->name, sizeof(pdb.name));
+	db_clientdesc->DBPacket(HEADER_GD_CHANGE_NAME, d->GetHandle(), &pdb, sizeof(TPacketGDChangeName));
+}
+
+void CInputLogin::CharacterSelect(LPDESC d, const char* data)
+{
+	struct command_player_select* pinfo = (struct command_player_select*)data;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	TAccountTable& c_r = d->GetAccountTable();
+#else
+	const TAccountTable& c_r = d->GetAccountTable();
+#endif
+
+	sys_log(0, "player_select: login: %s index: %d", c_r.login, pinfo->index);
+
+	if (!c_r.id)
+	{
+		sys_err("no account table");
+		return;
+	}
+
+	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
+	{
+		sys_err("index overflow %d, login: %s", pinfo->index, c_r.login);
+		return;
+	}
+
+	if (!c_r.players[pinfo->index].dwID)
+	{
+		sys_err("no player id, login %s", c_r.login);
+		return;
+	}
+
+	if (c_r.players[pinfo->index].bChangeName)
+	{
+		sys_err("name must be changed idx %d, login %s, name %s",
+			pinfo->index, c_r.login, c_r.players[pinfo->index].szName);
+		return;
+	}
+
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	if (!LocaleService_GetLocale(pinfo->country))
+	{
+		sys_err("cannot find locale country %s, login %s, name %s",
+			pinfo->country, c_r.login, c_r.players[pinfo->index].szName);
+		return;
+	}
+
+	if (strcmp(c_r.country, pinfo->country))
+	{
+		thecore_memcpy(c_r.country, pinfo->country, sizeof(c_r.country));
+
+		char query[128];
+		snprintf(query, sizeof(query), "UPDATE `account`.`account` SET `country` = '%s' WHERE `id` = %u",
+			LocaleService_GetCountry(pinfo->country), c_r.id);
+		std::unique_ptr<SQLMsg> msg(DBManager::instance().DirectQuery(query));
+	}
+#endif
+
+	TPlayerLoadPacket player_load_packet;
+
+	player_load_packet.account_id = c_r.id;
+	player_load_packet.player_id = c_r.players[pinfo->index].dwID;
+	player_load_packet.account_index = pinfo->index;
+
+	db_clientdesc->DBPacket(HEADER_GD_PLAYER_LOAD, d->GetHandle(), &player_load_packet, sizeof(TPlayerLoadPacket));
+}
+
+bool NewPlayerTable(TPlayerTable* table,
+	const char* name,
+	BYTE job,
+	BYTE shape,
+	BYTE bEmpire,
+	BYTE bCon,
+	BYTE bInt,
+	BYTE bStr,
+	BYTE bDex)
+{
+	if (job >= JOB_MAX_NUM)
+		return false;
+
+	memset(table, 0, sizeof(TPlayerTable));
+
+	strlcpy(table->name, name, sizeof(table->name));
+
+	table->level = 1;
+	table->job = job;
+	table->voice = 0;
+	table->part_base = shape;
+
+	table->st = JobInitialPoints[job].st;
+	table->dx = JobInitialPoints[job].dx;
+	table->ht = JobInitialPoints[job].ht;
+	table->iq = JobInitialPoints[job].iq;
+
+	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
+	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
+	table->stamina = JobInitialPoints[job].max_stamina;
+
+	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
+	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
+
+	table->z = 0;
+	table->dir = 0;
+	table->playtime = 0;
+	table->gold = 0;
+
+	table->skill_group = 0;
+
+	if (china_event_server)
+	{
+		table->level = 35;
+
+		for (int i = 1; i < 35; ++i)
+		{
+			int iHP = number(JobInitialPoints[job].hp_per_lv_begin, JobInitialPoints[job].hp_per_lv_end);
+			int iSP = number(JobInitialPoints[job].sp_per_lv_begin, JobInitialPoints[job].sp_per_lv_end);
+			table->sRandomHP += iHP;
+			table->sRandomSP += iSP;
+			table->stat_point += 3;
+		}
+
+		table->hp += table->sRandomHP;
+		table->sp += table->sRandomSP;
+
+		table->gold = 1000000;
+	}
+
+	return true;
+}
+
+bool RaceToJob(BYTE race, BYTE* ret_job)
+{
+	*ret_job = 0;
+
+	if (race >= MAIN_RACE_MAX_NUM)
+		return false;
+
+	switch (race)
+	{
+		case MAIN_RACE_WARRIOR_M:
+			*ret_job = JOB_WARRIOR;
+			break;
+
+		case MAIN_RACE_WARRIOR_W:
+			*ret_job = JOB_WARRIOR;
+			break;
+
+		case MAIN_RACE_ASSASSIN_M:
+			*ret_job = JOB_ASSASSIN;
+			break;
+
+		case MAIN_RACE_ASSASSIN_W:
+			*ret_job = JOB_ASSASSIN;
+			break;
+
+		case MAIN_RACE_SURA_M:
+			*ret_job = JOB_SURA;
+			break;
+
+		case MAIN_RACE_SURA_W:
+			*ret_job = JOB_SURA;
+			break;
+
+		case MAIN_RACE_SHAMAN_M:
+			*ret_job = JOB_SHAMAN;
+			break;
+
+		case MAIN_RACE_SHAMAN_W:
+			*ret_job = JOB_SHAMAN;
+			break;
+
+		case MAIN_RACE_WOLFMAN_M:
+			*ret_job = JOB_WOLFMAN;
+			break;
+
+		default:
+			return false;
+			break;
+	}
+	return true;
+}
+
+// 킥 캐 
+bool NewPlayerTable2(TPlayerTable* table, const char* name, BYTE race, BYTE shape, BYTE bEmpire)
+{
+	if (race >= MAIN_RACE_MAX_NUM)
+	{
+		sys_err("NewPlayerTable2.OUT_OF_RACE_RANGE(%d >= max(%d))\n", race, MAIN_RACE_MAX_NUM);
+		return false;
+	}
+
+	BYTE job;
+	if (!RaceToJob(race, &job))
+	{
+		sys_err("NewPlayerTable2.RACE_TO_JOB_ERROR(%d)\n", race);
+		return false;
+	}
+
+	sys_log(0, "NewPlayerTable2(name=%s, race=%d, job=%d)", name, race, job);
+
+	memset(table, 0, sizeof(TPlayerTable));
+
+	strlcpy(table->name, name, sizeof(table->name));
+
+	table->level = 1;
+	table->job = race; //   獵쨈
+	table->voice = 0;
+	table->part_base = shape;
+
+	table->st = JobInitialPoints[job].st;
+	table->dx = JobInitialPoints[job].dx;
+	table->ht = JobInitialPoints[job].ht;
+	table->iq = JobInitialPoints[job].iq;
+
+	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
+	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
+	table->stamina = JobInitialPoints[job].max_stamina;
+
+	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
+	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
+
+	table->z = 0;
+	table->dir = 0;
+	table->playtime = 0;
+	table->gold = 0;
+
+	table->skill_group = 0;
+
+	return true;
+}
+
+void CInputLogin::CharacterCreate(LPDESC d, const char* data)
+{
+	struct command_player_create* pinfo = (struct command_player_create*)data;
+	TPlayerCreatePacket player_create_packet;
+
+	sys_log(0, "PlayerCreate: name %s pos %d job %d shape %d",
+		pinfo->name,
+		pinfo->index,
+		pinfo->job,
+		pinfo->shape
+	);
+
+	TPacketGCLoginFailure packFailure;
+	memset(&packFailure, 0, sizeof(packFailure));
+	packFailure.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+
+	if (true == g_BlockCharCreation)
+	{
+		d->Packet(&packFailure, sizeof(packFailure));
+		return;
+	}
+
+	if (!g_bWolfmanCreation)
+	{
+		if (pinfo->job == MAIN_RACE_WOLFMAN_M)
+		{
+			d->Packet(&packFailure, sizeof(packFailure));
+			return;
+		}
+	}
+
+	//    見隔킬, 蔘 見  
+	if (!check_name(pinfo->name) || pinfo->shape > 1)
+	{
+		if (LC_IsCanada() == true)
+		{
+			TPacketGCCreateFailure pack;
+			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+			pack.bType = 1;
+
+			d->Packet(&pack, sizeof(pack));
+			return;
+		}
+
+		d->Packet(&packFailure, sizeof(packFailure));
+		return;
+	}
+
+	if (LC_IsEurope() == true)
+	{
+		const TAccountTable& c_rAccountTable = d->GetAccountTable();
+
+		if (0 == strcmp(c_rAccountTable.login, pinfo->name))
+		{
+			TPacketGCCreateFailure pack;
+			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+			pack.bType = 1;
+
+			d->Packet(&pack, sizeof(pack));
+			return;
+		}
+	}
+
+	memset(&player_create_packet, 0, sizeof(TPlayerCreatePacket));
+
+	if (!NewPlayerTable2(&player_create_packet.player_table, pinfo->name, pinfo->job, pinfo->shape, d->GetEmpire()))
+	{
+		sys_err("player_prototype error: job %d face %d ", pinfo->job);
+		d->Packet(&packFailure, sizeof(packFailure));
+		return;
+	}
+
+	const TAccountTable& c_rAccountTable = d->GetAccountTable();
+
+	trim_and_lower(c_rAccountTable.login, player_create_packet.login, sizeof(player_create_packet.login));
+	strlcpy(player_create_packet.passwd, c_rAccountTable.passwd, sizeof(player_create_packet.passwd));
+
+	player_create_packet.account_id = c_rAccountTable.id;
+	player_create_packet.account_index = pinfo->index;
+
+	sys_log(0, "PlayerCreate: name %s account_id %d, TPlayerCreatePacketSize(%d), Packet->Gold %d",
+		pinfo->name,
+		pinfo->index,
+		sizeof(TPlayerCreatePacket),
+		player_create_packet.player_table.gold);
+
+	db_clientdesc->DBPacket(HEADER_GD_PLAYER_CREATE, d->GetHandle(), &player_create_packet, sizeof(TPlayerCreatePacket));
+}
+
+void CInputLogin::CharacterDelete(LPDESC d, const char* data)
+{
+	struct command_player_delete* pinfo = (struct command_player_delete*)data;
+	const TAccountTable& c_rAccountTable = d->GetAccountTable();
+
+	if (!c_rAccountTable.id)
+	{
+		sys_err("PlayerDelete: no login data");
+		return;
+	}
+
+	sys_log(0, "PlayerDelete: login: %s index: %d, social_id %s", c_rAccountTable.login, pinfo->index, pinfo->private_code);
+
+	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
+	{
+		sys_err("PlayerDelete: index overflow %d, login: %s", pinfo->index, c_rAccountTable.login);
+		return;
+	}
+
+	if (!c_rAccountTable.players[pinfo->index].dwID)
+	{
+		sys_err("PlayerDelete: Wrong Social ID index %d, login: %s", pinfo->index, c_rAccountTable.login);
+		d->Packet(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), 1);
+		return;
+	}
+
+	TPlayerDeletePacket player_delete_packet;
+
+	trim_and_lower(c_rAccountTable.login, player_delete_packet.login, sizeof(player_delete_packet.login));
+	player_delete_packet.player_id = c_rAccountTable.players[pinfo->index].dwID;
+	player_delete_packet.account_index = pinfo->index;
+	strlcpy(player_delete_packet.private_code, pinfo->private_code, sizeof(player_delete_packet.private_code));
+
+	db_clientdesc->DBPacket(HEADER_GD_PLAYER_DELETE, d->GetHandle(), &player_delete_packet, sizeof(TPlayerDeletePacket));
+}
+
+#pragma pack(1)
+typedef struct SPacketGTLogin
+{
+	BYTE header;
+	WORD empty;
+	DWORD id;
+} TPacketGTLogin;
+#pragma pack()
+
+void CInputLogin::Entergame(LPDESC d, const char* data)
+{
+	LPCHARACTER ch;
+
+	if (!(ch = d->GetCharacter()))
+	{
+		d->SetPhase(PHASE_CLOSE);
+		return;
+	}
+
+	PIXEL_POSITION pos = ch->GetXYZ();
+	if (!SECTREE_MANAGER::instance().GetMovablePosition(ch->GetMapIndex(), pos.x, pos.y, pos))
+	{
+		PIXEL_POSITION pos2;
+		SECTREE_MANAGER::instance().GetRecallPositionByEmpire(ch->GetMapIndex(), ch->GetEmpire(), pos2);
+
+		sys_err("!GetMovablePosition (name %s %dx%d map %d changed to %dx%d)",
+			ch->GetName(),
+			pos.x, pos.y,
+			ch->GetMapIndex(),
+			pos2.x, pos2.y);
+		pos = pos2;
+	}
+
+	CGuildManager::instance().LoginMember(ch);
+
+	// 캐拷 却 煞
+	ch->Show(ch->GetMapIndex(), pos.x, pos.y, pos.z);
+	ch->ReviveInvisible(5);
+
+#if !defined(__BINARY_ATLAS_MARK_INFO__)
+	SECTREE_MANAGER::instance().SendNPCPosition(ch);
+#endif
+
+	d->SetPhase(PHASE_GAME);
+
+#if defined(__HIDE_COSTUME_SYSTEM__)
+	ch->SetHiddenCostumeParts();
+#endif
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	const LPITEM& rkCostumeMount = ch->GetWear(WEAR_COSTUME_MOUNT);
+	if (rkCostumeMount)
+		ch->MountVnum(rkCostumeMount->GetMountVnum());
+	else if (ch->GetHorseLevel() > 0)
+		ch->EnterHorse();
+#else
+	if (ch->GetHorseLevel() > 0)
+		ch->EnterHorse();
+#endif
+
+	if (ch->GetItemAward_cmd()[0] != '\0') //  載
+		quest::CQuestManager::instance().ItemInformer(ch->GetPlayerID(), ch->GetItemAward_vnum()); // questmanager 호
+
+	sys_log(0, "ENTERGAME: %s %dx%dx%d %s map_index %d",
+		ch->GetName(), ch->GetX(), ch->GetY(), ch->GetZ(), d->GetHostName(), ch->GetMapIndex());
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	ch->SendExtendInvenPacket();
+#endif
+
+	// Check unwanted quickslot items.
+	ch->CheckQuickSlotItems();
+
+	// 첨決챨 湄 
+	ch->ResetPlayTime();
+
+	// 湄  遣트 煞
+	ch->StartSaveEvent();
+	ch->StartRecoveryEvent();
+	ch->StartCheckSpeedHackEvent();
+	ch->SetQuestFlag("item.last_time", get_global_time());
+
+	CPVPManager::instance().Connect(ch);
+	CPVPManager::instance().SendList(d);
+
+	CMessengerManager::instance().Login(ch->GetName());
+
+	CPartyManager::instance().SetParty(ch);
+	CGuildManager::instance().SendGuildWar(ch);
+
+	building::CManager::instance().SendLandList(d, ch->GetMapIndex());
+
+	marriage::CManager::instance().Login(ch);
+
+#ifdef __OFFLINE_SHOP__
+	COfflineShop::Login(ch);
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	TPacketGDEmote GDPacket = {};
+	GDPacket.dwPID = ch->GetPlayerID();
+	db_clientdesc->DBPacket(HEADER_GD_EMOTE_LOAD, ch->GetDesc()->GetHandle(), &GDPacket, sizeof(GDPacket));
+#endif
+
+	TPacketGCTime p;
+	p.bHeader = HEADER_GC_TIME;
+	p.time = get_global_time();
+	d->Packet(&p, sizeof(p));
+
+	TPacketGCChannel p2;
+	p2.header = HEADER_GC_CHANNEL;
+	p2.channel = g_bChannel;
+	d->Packet(&p2, sizeof(p2));
+
+#if defined(__LOOT_FILTER_SYSTEM__) && !defined(__PREMIUM_LOOT_FILTER__)
+	ch->SetLootFilter();
+#endif
+
+#if defined(__MAILBOX__)
+	CMailBox::UnreadData(ch);
+#endif
+
+	ch->SendGreetMessage();
+	_send_bonus_info(ch);
+
+	char szNameEsc[(CHARACTER_NAME_MAX_LEN + 1) * 2 + 1];
+	DBManager::instance().EscapeString(szNameEsc, sizeof(szNameEsc), ch->GetName(), strlen(ch->GetName()));
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("UPDATE player%s SET `last_play` = NOW() WHERE `name` = '%s'",
+		get_table_postfix(), szNameEsc)
+	);
+
+	ch->LoadSafeboxBuff();
+
+	for (int i = 0; i <= PREMIUM_MAX_NUM; ++i)
+	{
+		int remain = ch->GetPremiumRemainSeconds(i);
+
+		if (remain <= 0)
+			continue;
+
+#if defined(__CONQUEROR_LEVEL__)
+		int idx = AFFECT_PREMIUM_START + i;
+		if (idx == AFFECT_SUNGMA_BONUS)
+		{
+			for (int affect = POINT_SUNGMA_STR; affect <= POINT_SUNGMA_IMMUNE; ++affect)
+				ch->AddAffect(idx, affect, 10, 0, remain, 0, true, true);
+		}
+		else
+			ch->AddAffect(idx, POINT_NONE, 0, 0, remain, 0, true);
+#else
+		ch->AddAffect(AFFECT_PREMIUM_START + i, POINT_NONE, 0, 0, remain, 0, true);
+#endif
+		sys_log(0, "PREMIUM: %s type %d %dmin", ch->GetName(), i, remain);
+	}
+#ifdef __OFFLINE_SHOP__
+	int remainBuy = ch->GetQuestFlag("decoration.limit_time") - get_global_time();
+	if (remainBuy > 0)
+		ch->AddAffect(AFFECT_OFFLINE_SHOP_DECORATION, POINT_NONE, 0, 0, remainBuy, 0, true);
+#endif
+
+	if (g_bCheckClientVersion)
+	{
+		sys_log(0, "VERSION CHECK %s %s", g_stClientVersion.c_str(), d->GetClientVersion());
+
+		if (!d->GetClientVersion())
+		{
+			d->DelayedDisconnect(10);
+		}
+		else
+		{
+			if (0 != g_stClientVersion.compare(d->GetClientVersion()))
+			{
+				ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("클潔트  틀 慣類틸 絳求.  치  究."));
+				d->DelayedDisconnect(0);
+				LogManager::instance().HackLog("VERSION_CONFLICT", ch);
+
+				sys_log(0, "VERSION : WRONG VERSION USER : account:%s name:%s hostName:%s server_version:%s client_version:%s",
+					d->GetAccountTable().login,
+					ch->GetName(),
+					d->GetHostName(),
+					g_stClientVersion.c_str(),
+					d->GetClientVersion());
+			}
+		}
+	}
+	else
+	{
+		sys_log(0, "VERSION : NO CHECK");
+	}
+
+	if (ch->IsGM() == true)
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "ConsoleEnable");
+
+#if defined(__POPUP_NOTICE__)
+	if (quest::CQuestManager::instance().GetEventFlag("PopupNoticeEventFlag") > 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "PopupNoticeProcess %d %s",
+			ch->GetQuestFlag("popup_notice.checkbox"), g_strWebPopupNoticeURL.c_str());
+	}
+#endif
+
+#if defined(__MOVE_CHANNEL__)
+	ch->ChatPacket(CHAT_TYPE_COMMAND, "server_info %d %d", g_bChannel, ch->GetMapIndex());
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	CSnowflakeStickEvent::EnterGame(ch);
+#endif
+
+	if (ch->GetMapIndex() >= 10000)
+	{
+		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()))
+		{
+			ch->SetWarMap(CWarMapManager::instance().Find(ch->GetMapIndex()));
+		}
+		else if (marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
+		{
+			ch->SetWeddingMap(marriage::WeddingManager::instance().Find(ch->GetMapIndex()));
+		}
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+		else if (CGuildDragonLairManager::Instance().IsRedDragonLair(ch->GetMapIndex()))
+		{
+			ch->SetGuildDragonLair(CGuildDragonLairManager::Instance().FindByMapIndex(ch->GetMapIndex()));
+		}
+#endif
+#if defined(__DEFENSE_WAVE__)
+		else if (CDefenseWaveManager::instance().IsDefenseWaveMap(ch->GetMapIndex()))
+		{
+			ch->SetDefenseWave(CDefenseWaveManager::instance().FindByMapIndex(ch->GetMapIndex()));
+		}
+#endif
+		else
+		{
+			ch->SetDungeon(CDungeonManager::instance().FindByMapIndex(ch->GetMapIndex()));
+			// Dungeon re-entry hardening: if the player disconnected inside a dungeon and reconnects after a grace period, warp them out.
+			if (ch->GetDungeon())
+			{
+				const int logoutMap = ch->GetQuestFlag("dungeon_reentry.logout_map");
+				const int logoutTime = ch->GetQuestFlag("dungeon_reentry.logout_time");
+				const int now = get_global_time();
+
+				if (logoutMap == ch->GetMapIndex() && logoutTime > 0 && (now - logoutTime) <= 300)
+				{
+					// Still inside the grace period; allow re-entry and clear flags.
+					ch->SetQuestFlag("dungeon_reentry.logout_map", 0);
+					ch->SetQuestFlag("dungeon_reentry.logout_time", 0);
+				}
+				else
+				{
+					ch->SetQuestFlag("dungeon_reentry.logout_map", 0);
+					ch->SetQuestFlag("dungeon_reentry.logout_time", 0);
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You were removed from the dungeon due to disconnect."));
+					ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+				}
+			}
+		}
+	}
+	else if (CArenaManager::instance().IsArenaMap(ch->GetMapIndex()))
+	{
+		int memberFlag = CArenaManager::instance().IsMember(ch->GetMapIndex(), ch->GetPlayerID());
+		if (memberFlag == MEMBER_OBSERVER)
+		{
+			ch->SetObserverMode(true);
+			ch->SetArenaObserverMode(true);
+			if (CArenaManager::instance().RegisterObserverPtr(ch, ch->GetMapIndex(), ch->GetX() / 100, ch->GetY() / 100))
+			{
+				sys_log(0, "ARENA : Observer add failed");
+			}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			ch->UnMount(ch);
+#else
+			if (ch->IsHorseRiding() == true)
+			{
+				ch->StopRiding();
+				ch->HorseSummon(false);
+			}
+#endif
+		}
+		else if (memberFlag == MEMBER_DUELIST)
+		{
+			TPacketGCDuelStart duelStart;
+			duelStart.header = HEADER_GC_DUEL_START;
+			duelStart.wSize = sizeof(TPacketGCDuelStart);
+
+			ch->GetDesc()->Packet(&duelStart, sizeof(TPacketGCDuelStart));
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			ch->UnMount(ch);
+#else
+			if (ch->IsHorseRiding() == true)
+			{
+				ch->StopRiding();
+				ch->HorseSummon(false);
+			}
+#endif
+
+			LPPARTY pParty = ch->GetParty();
+			if (pParty != NULL)
+			{
+				if (pParty->GetMemberCount() == 2)
+				{
+					CPartyManager::instance().DeleteParty(pParty);
+				}
+				else
+				{
+					pParty->Quit(ch->GetPlayerID());
+				}
+			}
+		}
+		/*
+		else if (memberFlag == MEMBER_NO)
+		{
+			if (ch->GetGMLevel() == GM_PLAYER)
+				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+		else
+		{
+			// wtf
+		}
+		*/
+	}
+	else if (ch->GetMapIndex() == MAP_OXEVENT)
+	{
+		// ox 遣트 
+		if (COXEventManager::instance().Enter(ch) == false)
+		{
+			// ox   昇  . 첨潔  
+			if (ch->GetGMLevel() == GM_PLAYER)
+				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+	}
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	else if (ch->GetMapIndex() == MAP_N_FLAME_DRAGON)
+	{
+		CGuildDragonLairManager::Instance().Exit(ch);
+	}
+#endif
+	else
+	{
+		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()) ||
+			marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
+		{
+			if (!test_server)
+				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+
+#if defined(__ELEMENTAL_DUNGEON__)
+		if (ch->GetMapIndex() == MAP_ELEMENTAL_04)
+			ch->StartElementalCurseEvent();
+		else
+			ch->StopElementalCurseEvent();
+#endif
+	}
+
+	if (ch->GetHorseLevel() > 0)
+	{
+		DWORD pid = ch->GetPlayerID();
+
+		if (pid > 0)
+		{
+			const char* horseName = CHorseNameManager::instance().GetHorseName(pid);
+			if (!horseName || !*horseName)
+				db_clientdesc->DBPacket(HEADER_GD_REQ_HORSE_NAME, 0, &pid, sizeof(DWORD));
+		}
+	}
+
+	// 蔘却 載 홰歐
+	if (g_noticeBattleZone)
+	{
+		if (FN_is_battle_zone(ch))
+		{
+			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING(" 却     笭求."));
+			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING(" 六  "));
+			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING(" 玲  關 튼챰 帽求."));
+		}
+	}
+#ifdef __GROWTH_PET_SYSTEM__
+	if (!IS_BLOCKED_PET(ch->GetMapIndex()))
+	{
+		DWORD growthPetID = ch->GetQuestFlag("system.grow_pet_summoned");
+		if (growthPetID)
+		{
+			LPITEM petSeal = ITEM_MANAGER::instance().Find(growthPetID);
+			if (petSeal && petSeal->GetType() == ITEM_PET && petSeal->GetSubType() == PET_UPBRINGING)
+			{
+				LPGROWTH_PET pPet = ch->GetGrowthPet(petSeal->GetSocket(2));
+				if (pPet)
+				{
+					if (!ch->GetActiveGrowthPet())
+					{
+						LPGROWTH_PET pkPet = pPet->Summon(petSeal);
+						ch->SetActiveGrowthPet(pkPet);
+					}
+				}
+			}
+		}
+	}
+#endif
+}
+
+void CInputLogin::Empire(LPDESC d, const char* c_pData)
+{
+	const TPacketCGEmpire* p = reinterpret_cast<const TPacketCGEmpire*>(c_pData);
+
+	if (EMPIRE_MAX_NUM <= p->bEmpire)
+	{
+		d->SetPhase(PHASE_CLOSE);
+		return;
+	}
+
+	const TAccountTable& r = d->GetAccountTable();
+
+	if (r.bEmpire != 0)
+	{
+		for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
+		{
+			if (0 != r.players[i].dwID)
+			{
+				sys_err("EmpireSelectFailed %d", r.players[i].dwID);
+				return;
+			}
+		}
+	}
+
+	TEmpireSelectPacket pd;
+
+	pd.dwAccountID = r.id;
+	pd.bEmpire = p->bEmpire;
+
+	db_clientdesc->DBPacket(HEADER_GD_EMPIRE_SELECT, d->GetHandle(), &pd, sizeof(pd));
+}
+
+int CInputLogin::GuildSymbolUpload(LPDESC d, const char* c_pData, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGGuildSymbolUpload))
+		return -1;
+
+	sys_log(0, "GuildSymbolUpload uiBytes %u", uiBytes);
+
+	TPacketCGGuildSymbolUpload* p = (TPacketCGGuildSymbolUpload*)c_pData;
+
+	if (uiBytes < p->size)
+		return -1;
+
+	int iSymbolSize = p->size - sizeof(TPacketCGGuildSymbolUpload);
+
+	if (iSymbolSize <= 0 || iSymbolSize > 64 * 1024)
+	{
+		// 64k  큰   첩
+		//   
+		d->SetPhase(PHASE_CLOSE);
+		return 0;
+	}
+
+	//     .
+	if (!test_server)
+		if (!building::CManager::instance().FindLandByGuild(p->guild_id))
+		{
+			d->SetPhase(PHASE_CLOSE);
+			return 0;
+		}
+
+	sys_log(0, "GuildSymbolUpload Do Upload %02X%02X%02X%02X %d", c_pData[7], c_pData[8], c_pData[9], c_pData[10], sizeof(*p));
+
+	CGuildMarkManager::instance().UploadSymbol(p->guild_id, iSymbolSize, (const BYTE*)(c_pData + sizeof(*p)));
+	CGuildMarkManager::instance().SaveSymbol(GUILD_SYMBOL_FILENAME);
+	return iSymbolSize;
+}
+
+void CInputLogin::GuildSymbolCRC(LPDESC d, const char* c_pData)
+{
+	const TPacketCGSymbolCRC& CGPacket = *((TPacketCGSymbolCRC*)c_pData);
+
+	sys_log(0, "GuildSymbolCRC %u %u %u", CGPacket.guild_id, CGPacket.crc, CGPacket.size);
+
+	const CGuildMarkManager::TGuildSymbol* pkGS = CGuildMarkManager::instance().GetGuildSymbol(CGPacket.guild_id);
+
+	if (!pkGS)
+		return;
+
+	sys_log(0, "  Server %u %u", pkGS->crc, pkGS->raw.size());
+
+	if (pkGS->raw.size() != CGPacket.size || pkGS->crc != CGPacket.crc)
+	{
+		TPacketGCGuildSymbolData GCPacket;
+
+		GCPacket.header = HEADER_GC_SYMBOL_DATA;
+		GCPacket.size = sizeof(GCPacket) + pkGS->raw.size();
+		GCPacket.guild_id = CGPacket.guild_id;
+
+		d->BufferedPacket(&GCPacket, sizeof(GCPacket));
+		d->Packet(&pkGS->raw[0], pkGS->raw.size());
+
+		sys_log(0, "SendGuildSymbolHead %02X%02X%02X%02X Size %d",
+			pkGS->raw[0], pkGS->raw[1], pkGS->raw[2], pkGS->raw[3], pkGS->raw.size());
+	}
+}
+
+void CInputLogin::GuildMarkUpload(LPDESC d, const char* c_pData)
+{
+	TPacketCGMarkUpload* p = (TPacketCGMarkUpload*)c_pData;
+	CGuildManager& rkGuildMgr = CGuildManager::instance();
+	CGuild* pkGuild;
+
+	if (!(pkGuild = rkGuildMgr.FindGuild(p->gid)))
+	{
+		sys_err("MARK_SERVER: GuildMarkUpload: no guild. gid %u", p->gid);
+		return;
+	}
+
+	if (pkGuild->GetLevel() < guild_mark_min_level)
+	{
+		sys_log(0, "MARK_SERVER: GuildMarkUpload: level < %u (%u)", guild_mark_min_level, pkGuild->GetLevel());
+		return;
+	}
+
+	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
+
+	sys_log(0, "MARK_SERVER: GuildMarkUpload: gid %u", p->gid);
+
+	bool isEmpty = true;
+
+	for (DWORD iPixel = 0; iPixel < SGuildMark::SIZE; ++iPixel)
+		if (*((DWORD*)p->image + iPixel) != 0x00000000)
+			isEmpty = false;
+
+	if (isEmpty)
+		rkMarkMgr.DeleteMark(p->gid);
+	else
+		rkMarkMgr.SaveMark(p->gid, p->image);
+}
+
+void CInputLogin::GuildMarkIDXList(LPDESC d, const char* c_pData)
+{
+	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
+
+	DWORD bufSize = sizeof(WORD) * 2 * rkMarkMgr.GetMarkCount();
+	char* buf = NULL;
+
+	if (bufSize > 0)
+	{
+		buf = (char*)malloc(bufSize);
+		rkMarkMgr.CopyMarkIdx(buf);
+	}
+
+	TPacketGCMarkIDXList p;
+	p.header = HEADER_GC_MARK_IDXLIST;
+	p.bufSize = sizeof(p) + bufSize;
+	p.count = rkMarkMgr.GetMarkCount();
+
+	if (buf)
+	{
+		d->BufferedPacket(&p, sizeof(p));
+		d->LargePacket(buf, bufSize);
+		free(buf);
+	}
+	else
+		d->Packet(&p, sizeof(p));
+
+	sys_log(0, "MARK_SERVER: GuildMarkIDXList %d bytes sent.", p.bufSize);
+}
+
+void CInputLogin::GuildMarkCRCList(LPDESC d, const char* c_pData)
+{
+	TPacketCGMarkCRCList* pCG = (TPacketCGMarkCRCList*)c_pData;
+
+	std::map<BYTE, const SGuildMarkBlock*> mapDiffBlocks;
+	CGuildMarkManager::instance().GetDiffBlocks(pCG->imgIdx, pCG->crclist, mapDiffBlocks);
+
+	DWORD blockCount = 0;
+	TEMP_BUFFER buf(1024 * 1024); // 1M 
+
+	for (auto it = mapDiffBlocks.begin(); it != mapDiffBlocks.end(); ++it)
+	{
+		BYTE posBlock = it->first;
+		const SGuildMarkBlock& rkBlock = *it->second;
+
+		buf.write(&posBlock, sizeof(BYTE));
+		buf.write(&rkBlock.m_sizeCompBuf, sizeof(DWORD));
+		buf.write(rkBlock.m_abCompBuf, rkBlock.m_sizeCompBuf);
+
+		++blockCount;
+	}
+
+	TPacketGCMarkBlock pGC;
+
+	pGC.header = HEADER_GC_MARK_BLOCK;
+	pGC.imgIdx = pCG->imgIdx;
+	pGC.bufSize = buf.size() + sizeof(TPacketGCMarkBlock);
+	pGC.count = blockCount;
+
+	sys_log(0, "MARK_SERVER: Sending blocks. (imgIdx %u diff %u size %u)", pCG->imgIdx, mapDiffBlocks.size(), pGC.bufSize);
+
+	if (buf.size() > 0)
+	{
+		d->BufferedPacket(&pGC, sizeof(TPacketGCMarkBlock));
+		d->LargePacket(buf.read_peek(), buf.size());
+	}
+	else
+		d->Packet(&pGC, sizeof(TPacketGCMarkBlock));
+}
+
+int CInputLogin::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	int iExtraLen = 0;
+
+	switch (bHeader)
+	{
+		case HEADER_CG_PONG:
+			Pong(d);
+			break;
+
+		case HEADER_CG_TIME_SYNC:
+			Handshake(d, c_pData);
+			break;
+
+		case HEADER_CG_LOGIN:
+			Login(d, c_pData);
+			break;
+
+		case HEADER_CG_LOGIN2:
+			LoginByKey(d, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_SELECT:
+			CharacterSelect(d, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_CREATE:
+			CharacterCreate(d, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_DELETE:
+			CharacterDelete(d, c_pData);
+			break;
+
+		case HEADER_CG_ENTERGAME:
+			Entergame(d, c_pData);
+			break;
+
+		case HEADER_CG_EMPIRE:
+			Empire(d, c_pData);
+			break;
+
+		case HEADER_CG_MOVE:
+		case HEADER_CG_ITEM_USE:
+		case HEADER_CG_TARGET:
+			sys_err("CInputLogin: received GAME packet in LOGIN phase (header=%d)", bHeader);
+			d->SetPhase(PHASE_CLOSE);
+			return 0;
+
+			///////////////////////////////////////
+			// Guild Mark
+			/////////////////////////////////////
+		case HEADER_CG_MARK_LOGIN:
+			break;
+
+		case HEADER_CG_MARK_CRCLIST:
+			GuildMarkCRCList(d, c_pData);
+			break;
+
+		case HEADER_CG_MARK_IDXLIST:
+			GuildMarkIDXList(d, c_pData);
+			break;
+
+		case HEADER_CG_MARK_UPLOAD:
+			GuildMarkUpload(d, c_pData);
+			break;
+
+			//////////////////////////////////////
+			// Guild Symbol
+			/////////////////////////////////////
+		case HEADER_CG_GUILD_SYMBOL_UPLOAD:
+			if ((iExtraLen = GuildSymbolUpload(d, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_SYMBOL_CRC:
+			GuildSymbolCRC(d, c_pData);
+			break;
+			/////////////////////////////////////
+
+		case HEADER_CG_HACK:
+			break;
+
+		case HEADER_CG_CHANGE_NAME:
+			ChangeName(d, c_pData);
+			break;
+
+		case HEADER_CG_CLIENT_VERSION:
+			Version(d->GetCharacter(), c_pData);
+			break;
+
+		case HEADER_CG_CLIENT_VERSION2:
+			Version(d->GetCharacter(), c_pData);
+			break;
+
+		default:
+			sys_err("login phase does not handle this packet! header %d", bHeader);
+			//d->SetPhase(PHASE_CLOSE);
+			return (0);
+	}
+
+	return (iExtraLen);
+}
diff --git a/server/metin2/Source/Server/game/src/input_p2p.cpp b/server/metin2/Source/Server/game/src/input_p2p.cpp
index 715673e..92f02fe 100644
--- a/server/metin2/Source/Server/game/src/input_p2p.cpp
+++ b/server/metin2/Source/Server/game/src/input_p2p.cpp
@@ -1,657 +1,696 @@
-#include "stdafx.h"
-
-#include "config.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "p2p.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "party.h"
-#include "messenger_manager.h"
-#include "empire_text_convert.h"
-#include "unique_item.h"
-#include "xmas_event.h"
-#include "affect.h"
-#include "castle.h"
-#include "dev_log.h"
-#include "locale_service.h"
-#include "questmanager.h"
-#include "pcbang.h"
-#include "skill.h"
-#include "threeway_war.h"
-#ifdef __OFFLINE_SHOP__
-#include "OfflineShop.h"
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// Input Processor
-CInputP2P::CInputP2P()
-{
-	BindPacketInfo(&m_packetInfoGG);
-}
-
-void CInputP2P::Login(LPDESC d, const char* c_pData)
-{
-	P2P_MANAGER::instance().Login(d, (TPacketGGLogin*)c_pData);
-}
-
-void CInputP2P::Logout(LPDESC d, const char* c_pData)
-{
-	TPacketGGLogout* p = (TPacketGGLogout*)c_pData;
-	P2P_MANAGER::instance().Logout(p->szName);
-}
-
-int CInputP2P::Relay(LPDESC d, const char* c_pData, size_t uiBytes)
-{
-	TPacketGGRelay* p = (TPacketGGRelay*)c_pData;
-
-	if (uiBytes < sizeof(TPacketGGRelay) + p->lSize)
-		return -1;
-
-	if (p->lSize < 0)
-	{
-		sys_err("invalid packet length %d", p->lSize);
-		d->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	sys_log(0, "InputP2P::Relay : %s size %d", p->szName, p->lSize);
-
-	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().FindPC(p->szName);
-
-	const BYTE* c_pbData = (const BYTE*)(c_pData + sizeof(TPacketGGRelay));
-
-	if (!pkChr)
-	{
-		sys_log(0, "Relay could not find %s", p->szName);
-		return p->lSize;
-	}
-
-	if (*c_pbData == HEADER_GC_WHISPER)
-	{
-		char buf[1024];
-		memcpy(buf, c_pbData, MIN(p->lSize, sizeof(buf)));
-		TPacketGCWhisper* p2 = (TPacketGCWhisper*)buf;
-
-		if (pkChr->IsBlockMode(BLOCK_WHISPER) && !IS_SET(p2->bType, WHISPER_TYPE_GM))
-		{
-			// 귓속말 거부 상태에서 귓속말 거부.
-			return p->lSize;
-		}
-
-		// bType 상위 4비트: Empire 번호
-		// bType 하위 4비트: EWhisperType
-		BYTE bToEmpire = (p2->bType >> 4);
-		p2->bType = p2->bType & 0x0F;
-		if (p2->bType == 0x0F)
-		{
-			// 시스템 메세지 귓속말은 bType의 상위비트까지 모두 사용함.
-			p2->bType = WHISPER_TYPE_SYSTEM;
-		}
-		else
-		{
-			if (!pkChr->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-			{
-				if (bToEmpire >= 1 && bToEmpire <= 3 && pkChr->GetEmpire() != bToEmpire)
-				{
-					ConvertEmpireText(bToEmpire,
-						buf + sizeof(TPacketGCWhisper),
-						p2->wSize - sizeof(TPacketGCWhisper),
-						10 + 2 * pkChr->GetSkillPower(SKILL_LANGUAGE1 + bToEmpire - 1));
-				}
-			}
-		}
-
-		pkChr->GetDesc()->Packet(buf, p->lSize);
-	}
-	else
-		pkChr->GetDesc()->Packet(c_pbData, p->lSize);
-
-	return p->lSize;
-}
-
-int CInputP2P::Notice(LPDESC d, const char* c_pData, size_t uiBytes)
-{
-	TPacketGGNotice* p = (TPacketGGNotice*)c_pData;
-
-	if (uiBytes < sizeof(TPacketGGNotice) + p->lSize)
-		return -1;
-
-	if (p->lSize < 0)
-	{
-		sys_err("invalid packet length %d", p->lSize);
-		d->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	char szBuf[256 + 1];
-	strlcpy(szBuf, c_pData + sizeof(TPacketGGNotice), MIN(p->lSize + 1, sizeof(szBuf)));
-	SendNotice(szBuf, p->bBigFont);
-	return (p->lSize);
-}
-
-int CInputP2P::MonarchNotice(LPDESC d, const char* c_pData, size_t uiBytes)
-{
-	TPacketGGMonarchNotice* p = (TPacketGGMonarchNotice*)c_pData;
-
-	if (uiBytes < p->lSize + sizeof(TPacketGGMonarchNotice))
-		return -1;
-
-	if (p->lSize < 0)
-	{
-		sys_err("invalid packet length %d", p->lSize);
-		d->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	char szBuf[256 + 1];
-	strlcpy(szBuf, c_pData + sizeof(TPacketGGMonarchNotice), MIN(p->lSize + 1, sizeof(szBuf)));
-	SendMonarchNotice(p->bEmpire, szBuf);
-	return (p->lSize);
-}
-
-int CInputP2P::MonarchTransfer(LPDESC d, const char* c_pData)
-{
-	TPacketMonarchGGTransfer* p = (TPacketMonarchGGTransfer*)c_pData;
-	LPCHARACTER pTargetChar = CHARACTER_MANAGER::instance().FindByPID(p->dwTargetPID);
-
-	if (pTargetChar != NULL)
-	{
-		unsigned int qIndex = quest::CQuestManager::instance().GetQuestIndexByName("monarch_transfer");
-
-		if (qIndex != 0)
-		{
-			pTargetChar->SetQuestFlag("monarch_transfer.x", p->x);
-			pTargetChar->SetQuestFlag("monarch_transfer.y", p->y);
-			quest::CQuestManager::instance().Letter(pTargetChar->GetPlayerID(), qIndex, 0);
-		}
-	}
-
-	return 0;
-}
-
-int CInputP2P::Guild(LPDESC d, const char* c_pData, size_t uiBytes)
-{
-	TPacketGGGuild* p = (TPacketGGGuild*)c_pData;
-	uiBytes -= sizeof(TPacketGGGuild);
-	c_pData += sizeof(TPacketGGGuild);
-
-	CGuild* g = CGuildManager::instance().FindGuild(p->dwGuild);
-
-	switch (p->bSubHeader)
-	{
-		case GUILD_SUBHEADER_GG_CHAT:
-		{
-			if (uiBytes < sizeof(TPacketGGGuildChat))
-				return -1;
-
-			TPacketGGGuildChat* p = (TPacketGGGuildChat*)c_pData;
-
-			if (g)
-				g->P2PChat(p->szText);
-
-			return sizeof(TPacketGGGuildChat);
-		}
-
-		case GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS:
-		{
-			if (uiBytes < sizeof(int))
-				return -1;
-
-			int iBonus = *((int*)c_pData);
-			CGuild* pGuild = CGuildManager::instance().FindGuild(p->dwGuild);
-			if (pGuild)
-			{
-				pGuild->SetMemberCountBonus(iBonus);
-			}
-			return sizeof(int);
-		}
-		default:
-			sys_err("UNKNOWN GUILD SUB PACKET");
-			break;
-	}
-	return 0;
-}
-
-struct FuncShout
-{
-	FuncShout(const char* c_szText, BYTE bEmpire
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		, const char* c_szName
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		, const char* c_szCountry
-#endif
-	) : m_szText(c_szText), m_bEmpire(bEmpire)
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		, m_szName(c_szName)
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		, m_szCountry(c_szCountry)
-#endif
-	{
-	}
-
-	void operator () (LPDESC d)
-	{
-		if (g_bGlobalShout)
-		{
-			if (!d->GetCharacter())
-				return;
-		}
-		else
-		{
-			if (!d->GetCharacter() || (d->GetCharacter()->GetGMLevel() == GM_PLAYER && d->GetEmpire() != m_bEmpire))
-				return;
-		}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		if (CMessengerManager::instance().IsBlocked(d->GetCharacter()->GetName(), m_szName))
-			return;
-#endif
-
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		packet_chat pack_chat;
-		pack_chat.type = CHAT_TYPE_SHOUT;
-		strlcpy(pack_chat.szCountry, m_szCountry, sizeof(pack_chat.szCountry));
-
-		d->GetCharacter()->ChatPacket(pack_chat, "%s", m_szText);
-#else
-		d->GetCharacter()->ChatPacket(CHAT_TYPE_SHOUT, "%s", m_szText);
-#endif
-	}
-
-	const char* m_szText;
-	BYTE m_bEmpire;
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	const char* m_szName;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	const char* m_szCountry;
-#endif
-};
-
-void SendShout(const char* c_szText, BYTE bEmpire
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	, const char* c_szName
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	, const char* c_szCountry
-#endif
-)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), FuncShout(c_szText, bEmpire
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		, c_szName
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		, c_szCountry
-#endif
-	));
-}
-
-void CInputP2P::Shout(const char* c_pData)
-{
-	TPacketGGShout* p = (TPacketGGShout*)c_pData;
-	SendShout(p->szText, p->bEmpire
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		, p->szName
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		, p->szCountry
-#endif
-	);
-}
-
-void CInputP2P::Disconnect(const char* c_pData)
-{
-	TPacketGGDisconnect* p = (TPacketGGDisconnect*)c_pData;
-
-	LPDESC d = DESC_MANAGER::instance().FindByLoginName(p->szLogin);
-
-	if (!d)
-		return;
-
-	if (!d->GetCharacter())
-	{
-		d->SetPhase(PHASE_CLOSE);
-	}
-	else
-		d->DisconnectOfSameLogin();
-}
-
-void CInputP2P::Setup(LPDESC d, const char* c_pData)
-{
-	TPacketGGSetup* p = (TPacketGGSetup*)c_pData;
-	sys_log(0, "P2P: Setup %s:%d", d->GetHostName(), p->wPort);
-	d->SetP2P(d->GetHostName(), p->wPort, p->bChannel);
-}
-
-void CInputP2P::MessengerAdd(const char* c_pData)
-{
-	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
-	sys_log(0, "P2P: Messenger Add %s %s", p->szAccount, p->szCompanion);
-	CMessengerManager::instance().__AddToList(p->szAccount, p->szCompanion);
-}
-
-void CInputP2P::MessengerRemove(const char* c_pData)
-{
-	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
-	sys_log(0, "P2P: Messenger Remove %s %s", p->szAccount, p->szCompanion);
-	CMessengerManager::instance().__RemoveFromList(p->szAccount, p->szCompanion);
-}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-void CInputP2P::MessengerBlockAdd(const char* c_pData)
-{
-	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
-	CMessengerManager::instance().__AddToBlockList(p->szAccount, p->szCompanion);
-}
-
-void CInputP2P::MessengerBlockRemove(const char* c_pData)
-{
-	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
-	CMessengerManager::instance().__RemoveFromBlockList(p->szAccount, p->szCompanion);
-}
-#endif
-
-void CInputP2P::FindPosition(LPDESC d, const char* c_pData)
-{
-	TPacketGGFindPosition* p = (TPacketGGFindPosition*)c_pData;
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(p->dwTargetPID);
-	if (ch && ch->GetMapIndex() < 10000)
-	{
-		TPacketGGWarpCharacter pw;
-		pw.header = HEADER_GG_WARP_CHARACTER;
-		pw.pid = p->dwFromPID;
-		pw.x = ch->GetX();
-		pw.y = ch->GetY();
-		d->Packet(&pw, sizeof(pw));
-	}
-}
-
-#ifdef __OFFLINE_SHOP__
-void CInputP2P::UpdateSellHistory(LPDESC d, const char* c_pData)
-{
-	TPacketGGUpdateSellHistory* p = (TPacketGGUpdateSellHistory*) c_pData;
-	
-	TMySellHistory newItem;
-	thecore_memcpy(&newItem, &p->sellItem, sizeof(newItem));
-	
-	LPCHARACTER chUpdate = CHARACTER_MANAGER::instance().FindByPID(newItem.pid);
-	if (chUpdate)
-	{
-		chUpdate->AddToSellHistory(newItem);
-	}
-}
-#endif
-
-void CInputP2P::WarpCharacter(const char* c_pData)
-{
-	TPacketGGWarpCharacter* p = (TPacketGGWarpCharacter*)c_pData;
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(p->pid);
-	if (ch)
-	{
-		ch->WarpSet(p->x, p->y);
-	}
-}
-
-void CInputP2P::GuildWarZoneMapIndex(const char* c_pData)
-{
-	TPacketGGGuildWarMapIndex* p = (TPacketGGGuildWarMapIndex*)c_pData;
-	CGuildManager& gm = CGuildManager::instance();
-
-	sys_log(0, "P2P: GuildWarZoneMapIndex g1(%u) vs g2(%u), mapIndex(%d)", p->dwGuildID1, p->dwGuildID2, p->lMapIndex);
-
-	CGuild* g1 = gm.FindGuild(p->dwGuildID1);
-	CGuild* g2 = gm.FindGuild(p->dwGuildID2);
-
-	if (g1 && g2)
-	{
-		g1->SetGuildWarMapIndex(p->dwGuildID2, p->lMapIndex);
-		g2->SetGuildWarMapIndex(p->dwGuildID1, p->lMapIndex);
-	}
-}
-
-void CInputP2P::Transfer(const char* c_pData)
-{
-	TPacketGGTransfer* p = (TPacketGGTransfer*)c_pData;
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindPC(p->szName);
-
-	if (ch)
-		ch->WarpSet(p->lX, p->lY);
-}
-
-#if defined(__XMAS_EVENT_2008__)
-void CInputP2P::XmasWarpSanta(const char* c_pData)
-{
-	TPacketGGXmasWarpSanta* p = (TPacketGGXmasWarpSanta*)c_pData;
-
-	if (p->bChannel == g_bChannel && map_allow_find(p->lMapIndex))
-	{
-		int iNextSpawnDelay = 60;
-
-		if (LC_IsYMIR())
-			iNextSpawnDelay = 20 * 60;
-		else
-			iNextSpawnDelay = 50 * 60;
-
-		xmas::SpawnSanta(p->lMapIndex, iNextSpawnDelay); // 50분있다가 새로운 산타가 나타남 (한국은 20분)
-
-		TPacketGGXmasWarpSantaReply pack_reply;
-		pack_reply.bHeader = HEADER_GG_XMAS_WARP_SANTA_REPLY;
-		pack_reply.bChannel = g_bChannel;
-		P2P_MANAGER::instance().Send(&pack_reply, sizeof(pack_reply));
-	}
-}
-
-void CInputP2P::XmasWarpSantaReply(const char* c_pData)
-{
-	TPacketGGXmasWarpSantaReply* p = (TPacketGGXmasWarpSantaReply*)c_pData;
-
-	if (p->bChannel == g_bChannel)
-	{
-		CharacterVectorInteractor vec;
-		if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(xmas::MOB_XMAS_SANTA_VNUM, vec))
-		{
-			CharacterVectorInteractor::iterator it = vec.begin();
-			while (it != vec.end())
-				M2_DESTROY_CHARACTER(*it++);
-		}
-	}
-}
-#endif
-
-void CInputP2P::LoginPing(LPDESC d, const char* c_pData)
-{
-	TPacketGGLoginPing* p = (TPacketGGLoginPing*)c_pData;
-
-	if (!g_pkAuthMasterDesc) // If I am master, I have to broadcast
-		P2P_MANAGER::instance().Send(p, sizeof(TPacketGGLoginPing), d);
-}
-
-// BLOCK_CHAT
-void CInputP2P::BlockChat(const char* c_pData)
-{
-	TPacketGGBlockChat* p = (TPacketGGBlockChat*)c_pData;
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindPC(p->szName);
-
-	if (ch)
-	{
-		sys_log(0, "BLOCK CHAT apply name %s dur %d", p->szName, p->lBlockDuration);
-		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, p->lBlockDuration, 0, true);
-	}
-	else
-	{
-		sys_log(0, "BLOCK CHAT fail name %s dur %d", p->szName, p->lBlockDuration);
-	}
-}
-// END_OF_BLOCK_CHAT
-//
-
-void CInputP2P::PCBangUpdate(const char* c_pData)
-{
-	TPacketPCBangUpdate* p = (TPacketPCBangUpdate*)c_pData;
-
-	CPCBangManager::instance().RequestUpdateIPList(p->ulPCBangID);
-}
-
-void CInputP2P::IamAwake(LPDESC d, const char* c_pData)
-{
-	std::string hostNames;
-	P2P_MANAGER::instance().GetP2PHostNames(hostNames);
-	sys_log(0, "P2P Awakeness check from %s. My P2P connection number is %d. and details...\n%s", d->GetHostName(), P2P_MANAGER::instance().GetDescCount(), hostNames.c_str());
-}
-
-int CInputP2P::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	if (test_server)
-		sys_log(0, "CInputP2P::Anlayze[Header %d]", bHeader);
-
-	int iExtraLen = 0;
-
-	switch (bHeader)
-	{
-		case HEADER_GG_SETUP:
-			Setup(d, c_pData);
-			break;
-
-		case HEADER_GG_LOGIN:
-			Login(d, c_pData);
-			break;
-
-		case HEADER_GG_LOGOUT:
-			Logout(d, c_pData);
-			break;
-
-		case HEADER_GG_RELAY:
-			if ((iExtraLen = Relay(d, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_GG_NOTICE:
-			if ((iExtraLen = Notice(d, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_GG_SHUTDOWN:
-			sys_err("Accept shutdown p2p command from %s.", d->GetHostName());
-			Shutdown(10);
-			break;
-
-		case HEADER_GG_GUILD:
-			if ((iExtraLen = Guild(d, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_GG_SHOUT:
-			Shout(c_pData);
-			break;
-
-		case HEADER_GG_DISCONNECT:
-			Disconnect(c_pData);
-			break;
-
-		case HEADER_GG_MESSENGER_ADD:
-			MessengerAdd(c_pData);
-			break;
-
-		case HEADER_GG_MESSENGER_REMOVE:
-			MessengerRemove(c_pData);
-			break;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		case HEADER_GG_MESSENGER_BLOCK_ADD:
-			MessengerBlockAdd(c_pData);
-			break;
-
-		case HEADER_GG_MESSENGER_BLOCK_REMOVE:
-			MessengerBlockRemove(c_pData);
-			break;
-#endif
-
-		case HEADER_GG_FIND_POSITION:
-			FindPosition(d, c_pData);
-			break;
-
-		case HEADER_GG_WARP_CHARACTER:
-			WarpCharacter(c_pData);
-			break;
-
-		case HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX:
-			GuildWarZoneMapIndex(c_pData);
-			break;
-
-		case HEADER_GG_TRANSFER:
-			Transfer(c_pData);
-			break;
-
-#if defined(__XMAS_EVENT_2008__)
-		case HEADER_GG_XMAS_WARP_SANTA:
-			XmasWarpSanta(c_pData);
-			break;
-
-		case HEADER_GG_XMAS_WARP_SANTA_REPLY:
-			XmasWarpSantaReply(c_pData);
-			break;
-#endif
-
-		case HEADER_GG_RELOAD_CRC_LIST:
-			LoadValidCRCList();
-			break;
-
-		case HEADER_GG_CHECK_CLIENT_VERSION:
-			CheckClientVersion();
-			break;
-
-		case HEADER_GG_LOGIN_PING:
-			LoginPing(d, c_pData);
-			break;
-
-		case HEADER_GG_BLOCK_CHAT:
-			BlockChat(c_pData);
-			break;
-
-		case HEADER_GG_SIEGE:
-		{
-			TPacketGGSiege* pSiege = (TPacketGGSiege*)c_pData;
-			castle_siege(pSiege->bEmpire, pSiege->bTowerCount);
-		}
-		break;
-
-		case HEADER_GG_MONARCH_NOTICE:
-			if ((iExtraLen = MonarchNotice(d, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_GG_MONARCH_TRANSFER:
-			MonarchTransfer(d, c_pData);
-			break;
-
-		case HEADER_GG_PCBANG_UPDATE:
-			PCBangUpdate(c_pData);
-			break;
-
-		case HEADER_GG_CHECK_AWAKENESS:
-			IamAwake(d, c_pData);
-			break;
-
-#if defined(__OFFLINE_SHOP__)
-		case HEADER_GG_OFFLINE_SHOP:
-			if ((iExtraLen = COfflineShop::ReceiveInterprocessPacket(d, c_pData)) < 0) {
-				return -1;
-			}
-			break;
-		case HEADER_GG_UPDATE_SELL_HISTORY:
-			UpdateSellHistory(d, c_pData);
-			break;
-#endif
-	}
-
-	return (iExtraLen);
-}
+#include "stdafx.h"
+#include <vector>
+
+#include "config.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "p2p.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "party.h"
+#include "messenger_manager.h"
+#include "empire_text_convert.h"
+#include "unique_item.h"
+#include "xmas_event.h"
+#include "affect.h"
+#include "castle.h"
+#include "dev_log.h"
+#include "locale_service.h"
+#include "questmanager.h"
+#include "pcbang.h"
+#include "skill.h"
+#include "threeway_war.h"
+#ifdef __OFFLINE_SHOP__
+#include "OfflineShop.h"
+#endif
+
+namespace
+{
+	static bool IsTrustedP2PIPv4(DWORD ip)
+	{
+		// ip is host-order (ntohl)
+		// allow loopback 127.0.0.0/8
+		if ((ip & 0xFF000000) == 0x7F000000)
+			return true;
+		// allow private ranges
+		if ((ip & 0xFF000000) == 0x0A000000) // 10.0.0.0/8
+			return true;
+		if ((ip & 0xFFF00000) == 0xAC100000) // 172.16.0.0/12
+			return true;
+		if ((ip & 0xFFFF0000) == 0xC0A80000) // 192.168.0.0/16
+			return true;
+		return false;
+	}
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Input Processor
+CInputP2P::CInputP2P()
+{
+	BindPacketInfo(&m_packetInfoGG);
+}
+
+void CInputP2P::Login(LPDESC d, const char* c_pData)
+{
+	// [Security] Do not rely solely on firewall: reject untrusted P2P origins
+	{
+		const struct sockaddr_in& a = d->GetAddr();
+		const DWORD ip = ntohl(a.sin_addr.s_addr);
+		if (!IsTrustedP2PIPv4(ip))
+		{
+			sys_err("P2P rejected from %s", d->GetHostName());
+			d->SetPhase(PHASE_CLOSE);
+			return;
+		}
+	}
+	P2P_MANAGER::instance().Login(d, (TPacketGGLogin*)c_pData);
+}
+
+void CInputP2P::Logout(LPDESC d, const char* c_pData)
+{
+	TPacketGGLogout* p = (TPacketGGLogout*)c_pData;
+	P2P_MANAGER::instance().Logout(p->szName);
+}
+
+int CInputP2P::Relay(LPDESC d, const char* c_pData, size_t uiBytes)
+{
+	TPacketGGRelay* p = (TPacketGGRelay*)c_pData;
+
+	if (uiBytes < sizeof(TPacketGGRelay) + p->lSize)
+		return -1;
+
+	if (p->lSize < 0)
+	{
+		sys_err("invalid packet length %d", p->lSize);
+		d->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	sys_log(0, "InputP2P::Relay : %s size %d", p->szName, p->lSize);
+
+	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().FindPC(p->szName);
+
+	const BYTE* c_pbData = (const BYTE*)(c_pData + sizeof(TPacketGGRelay));
+
+	if (!pkChr)
+	{
+		sys_log(0, "Relay could not find %s", p->szName);
+		return p->lSize;
+	}
+
+	LPDESC pkChrDesc = pkChr->GetDesc();
+	if (!pkChrDesc)
+		return p->lSize;
+
+	if (*c_pbData == HEADER_GC_WHISPER)
+	{
+		std::vector<char> buf;
+		buf.resize(p->lSize);
+		memcpy(buf.data(), c_pbData, p->lSize);
+
+		TPacketGCWhisper* p2 = reinterpret_cast<TPacketGCWhisper*>(buf.data());
+		if (p2->wSize < sizeof(TPacketGCWhisper) || p2->wSize > p->lSize)
+			return p->lSize;
+
+		if (pkChr->IsBlockMode(BLOCK_WHISPER) && !IS_SET(p2->bType, WHISPER_TYPE_GM))
+		{
+			// \xb1憺疸\xbb \xb0탄\xce \xbb\xf3\xc5쩔\xa1\xbc\xad \xb1憺疸\xbb \xb0탄\xce.
+			return p->lSize;
+		}
+
+		// bType  4트: Empire 호
+		// bType  4트: EWhisperType
+		BYTE bToEmpire = (p2->bType >> 4);
+		p2->bType = p2->bType & 0x0F;
+		if (p2->bType == 0x0F)
+		{
+			// 첵 氷 憺疸 bType 트  .
+			p2->bType = WHISPER_TYPE_SYSTEM;
+		}
+		else
+		{
+			if (!pkChr->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+			{
+				if (bToEmpire >= 1 && bToEmpire <= 3 && pkChr->GetEmpire() != bToEmpire)
+				{
+					ConvertEmpireText(bToEmpire,
+						buf.data() + sizeof(TPacketGCWhisper),
+						p2->wSize - sizeof(TPacketGCWhisper),
+						10 + 2 * pkChr->GetSkillPower(SKILL_LANGUAGE1 + bToEmpire - 1));
+				}
+			}
+		}
+
+		pkChrDesc->Packet(buf.data(), p->lSize);
+	}
+	else
+		pkChrDesc->Packet(c_pbData, p->lSize);
+
+	return p->lSize;
+}
+
+int CInputP2P::Notice(LPDESC d, const char* c_pData, size_t uiBytes)
+{
+	TPacketGGNotice* p = (TPacketGGNotice*)c_pData;
+
+	if (uiBytes < sizeof(TPacketGGNotice) + p->lSize)
+		return -1;
+
+	if (p->lSize < 0)
+	{
+		sys_err("invalid packet length %d", p->lSize);
+		d->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	char szBuf[256 + 1];
+	strlcpy(szBuf, c_pData + sizeof(TPacketGGNotice), MIN(p->lSize + 1, sizeof(szBuf)));
+	SendNotice(szBuf, p->bBigFont);
+	return (p->lSize);
+}
+
+int CInputP2P::MonarchNotice(LPDESC d, const char* c_pData, size_t uiBytes)
+{
+	TPacketGGMonarchNotice* p = (TPacketGGMonarchNotice*)c_pData;
+
+	if (uiBytes < p->lSize + sizeof(TPacketGGMonarchNotice))
+		return -1;
+
+	if (p->lSize < 0)
+	{
+		sys_err("invalid packet length %d", p->lSize);
+		d->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	char szBuf[256 + 1];
+	strlcpy(szBuf, c_pData + sizeof(TPacketGGMonarchNotice), MIN(p->lSize + 1, sizeof(szBuf)));
+	SendMonarchNotice(p->bEmpire, szBuf);
+	return (p->lSize);
+}
+
+int CInputP2P::MonarchTransfer(LPDESC d, const char* c_pData)
+{
+	TPacketMonarchGGTransfer* p = (TPacketMonarchGGTransfer*)c_pData;
+	LPCHARACTER pTargetChar = CHARACTER_MANAGER::instance().FindByPID(p->dwTargetPID);
+
+	if (pTargetChar != NULL)
+	{
+		unsigned int qIndex = quest::CQuestManager::instance().GetQuestIndexByName("monarch_transfer");
+
+		if (qIndex != 0)
+		{
+			pTargetChar->SetQuestFlag("monarch_transfer.x", p->x);
+			pTargetChar->SetQuestFlag("monarch_transfer.y", p->y);
+			quest::CQuestManager::instance().Letter(pTargetChar->GetPlayerID(), qIndex, 0);
+		}
+	}
+
+	return 0;
+}
+
+int CInputP2P::Guild(LPDESC d, const char* c_pData, size_t uiBytes)
+{
+	TPacketGGGuild* p = (TPacketGGGuild*)c_pData;
+	uiBytes -= sizeof(TPacketGGGuild);
+	c_pData += sizeof(TPacketGGGuild);
+
+	CGuild* g = CGuildManager::instance().FindGuild(p->dwGuild);
+
+	switch (p->bSubHeader)
+	{
+		case GUILD_SUBHEADER_GG_CHAT:
+		{
+			if (uiBytes < sizeof(TPacketGGGuildChat))
+				return -1;
+
+			TPacketGGGuildChat* p = (TPacketGGGuildChat*)c_pData;
+
+			if (g)
+				g->P2PChat(p->szText);
+
+			return sizeof(TPacketGGGuildChat);
+		}
+
+		case GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS:
+		{
+			if (uiBytes < sizeof(int))
+				return -1;
+
+			int iBonus = *((int*)c_pData);
+			CGuild* pGuild = CGuildManager::instance().FindGuild(p->dwGuild);
+			if (pGuild)
+			{
+				pGuild->SetMemberCountBonus(iBonus);
+			}
+			return sizeof(int);
+		}
+		default:
+			sys_err("UNKNOWN GUILD SUB PACKET");
+			break;
+	}
+	return 0;
+}
+
+struct FuncShout
+{
+	FuncShout(const char* c_szText, BYTE bEmpire
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		, const char* c_szName
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		, const char* c_szCountry
+#endif
+	) : m_szText(c_szText), m_bEmpire(bEmpire)
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		, m_szName(c_szName)
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		, m_szCountry(c_szCountry)
+#endif
+	{
+	}
+
+	void operator () (LPDESC d)
+	{
+		if (g_bGlobalShout)
+		{
+			if (!d->GetCharacter())
+				return;
+		}
+		else
+		{
+			if (!d->GetCharacter() || (d->GetCharacter()->GetGMLevel() == GM_PLAYER && d->GetEmpire() != m_bEmpire))
+				return;
+		}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		if (CMessengerManager::instance().IsBlocked(d->GetCharacter()->GetName(), m_szName))
+			return;
+#endif
+
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		packet_chat pack_chat;
+		pack_chat.type = CHAT_TYPE_SHOUT;
+		strlcpy(pack_chat.szCountry, m_szCountry, sizeof(pack_chat.szCountry));
+
+		d->GetCharacter()->ChatPacket(pack_chat, "%s", m_szText);
+#else
+		d->GetCharacter()->ChatPacket(CHAT_TYPE_SHOUT, "%s", m_szText);
+#endif
+	}
+
+	const char* m_szText;
+	BYTE m_bEmpire;
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	const char* m_szName;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	const char* m_szCountry;
+#endif
+};
+
+void SendShout(const char* c_szText, BYTE bEmpire
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	, const char* c_szName
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	, const char* c_szCountry
+#endif
+)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), FuncShout(c_szText, bEmpire
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		, c_szName
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		, c_szCountry
+#endif
+	));
+}
+
+void CInputP2P::Shout(const char* c_pData)
+{
+	TPacketGGShout* p = (TPacketGGShout*)c_pData;
+	SendShout(p->szText, p->bEmpire
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		, p->szName
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		, p->szCountry
+#endif
+	);
+}
+
+void CInputP2P::Disconnect(const char* c_pData)
+{
+	TPacketGGDisconnect* p = (TPacketGGDisconnect*)c_pData;
+
+	LPDESC d = DESC_MANAGER::instance().FindByLoginName(p->szLogin);
+
+	if (!d)
+		return;
+
+	if (!d->GetCharacter())
+	{
+		d->SetPhase(PHASE_CLOSE);
+	}
+	else
+		d->DisconnectOfSameLogin();
+}
+
+void CInputP2P::Setup(LPDESC d, const char* c_pData)
+{
+	TPacketGGSetup* p = (TPacketGGSetup*)c_pData;
+	sys_log(0, "P2P: Setup %s:%d", d->GetHostName(), p->wPort);
+	d->SetP2P(d->GetHostName(), p->wPort, p->bChannel);
+}
+
+void CInputP2P::MessengerAdd(const char* c_pData)
+{
+	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
+	sys_log(0, "P2P: Messenger Add %s %s", p->szAccount, p->szCompanion);
+	CMessengerManager::instance().__AddToList(p->szAccount, p->szCompanion);
+}
+
+void CInputP2P::MessengerRemove(const char* c_pData)
+{
+	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
+	sys_log(0, "P2P: Messenger Remove %s %s", p->szAccount, p->szCompanion);
+	CMessengerManager::instance().__RemoveFromList(p->szAccount, p->szCompanion);
+}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+void CInputP2P::MessengerBlockAdd(const char* c_pData)
+{
+	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
+	CMessengerManager::instance().__AddToBlockList(p->szAccount, p->szCompanion);
+}
+
+void CInputP2P::MessengerBlockRemove(const char* c_pData)
+{
+	TPacketGGMessenger* p = (TPacketGGMessenger*)c_pData;
+	CMessengerManager::instance().__RemoveFromBlockList(p->szAccount, p->szCompanion);
+}
+#endif
+
+void CInputP2P::FindPosition(LPDESC d, const char* c_pData)
+{
+	TPacketGGFindPosition* p = (TPacketGGFindPosition*)c_pData;
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(p->dwTargetPID);
+	if (ch && ch->GetMapIndex() < 10000)
+	{
+		TPacketGGWarpCharacter pw;
+		pw.header = HEADER_GG_WARP_CHARACTER;
+		pw.pid = p->dwFromPID;
+		pw.x = ch->GetX();
+		pw.y = ch->GetY();
+		d->Packet(&pw, sizeof(pw));
+	}
+}
+
+#ifdef __OFFLINE_SHOP__
+void CInputP2P::UpdateSellHistory(LPDESC d, const char* c_pData)
+{
+	TPacketGGUpdateSellHistory* p = (TPacketGGUpdateSellHistory*) c_pData;
+	
+	TMySellHistory newItem;
+	thecore_memcpy(&newItem, &p->sellItem, sizeof(newItem));
+	
+	LPCHARACTER chUpdate = CHARACTER_MANAGER::instance().FindByPID(newItem.pid);
+	if (chUpdate)
+	{
+		chUpdate->AddToSellHistory(newItem);
+	}
+}
+#endif
+
+void CInputP2P::WarpCharacter(const char* c_pData)
+{
+	TPacketGGWarpCharacter* p = (TPacketGGWarpCharacter*)c_pData;
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(p->pid);
+	if (ch)
+	{
+		ch->WarpSet(p->x, p->y);
+	}
+}
+
+void CInputP2P::GuildWarZoneMapIndex(const char* c_pData)
+{
+	TPacketGGGuildWarMapIndex* p = (TPacketGGGuildWarMapIndex*)c_pData;
+	CGuildManager& gm = CGuildManager::instance();
+
+	sys_log(0, "P2P: GuildWarZoneMapIndex g1(%u) vs g2(%u), mapIndex(%d)", p->dwGuildID1, p->dwGuildID2, p->lMapIndex);
+
+	CGuild* g1 = gm.FindGuild(p->dwGuildID1);
+	CGuild* g2 = gm.FindGuild(p->dwGuildID2);
+
+	if (g1 && g2)
+	{
+		g1->SetGuildWarMapIndex(p->dwGuildID2, p->lMapIndex);
+		g2->SetGuildWarMapIndex(p->dwGuildID1, p->lMapIndex);
+	}
+}
+
+void CInputP2P::Transfer(const char* c_pData)
+{
+	TPacketGGTransfer* p = (TPacketGGTransfer*)c_pData;
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindPC(p->szName);
+
+	if (ch)
+		ch->WarpSet(p->lX, p->lY);
+}
+
+#if defined(__XMAS_EVENT_2008__)
+void CInputP2P::XmasWarpSanta(const char* c_pData)
+{
+	TPacketGGXmasWarpSanta* p = (TPacketGGXmasWarpSanta*)c_pData;
+
+	if (p->bChannel == g_bChannel && map_allow_find(p->lMapIndex))
+	{
+		int iNextSpawnDelay = 60;
+
+		if (LC_IsYMIR())
+			iNextSpawnDelay = 20 * 60;
+		else
+			iNextSpawnDelay = 50 * 60;
+
+		xmas::SpawnSanta(p->lMapIndex, iNextSpawnDelay); // 50獵鳴 恝 타 타 (畸 20)
+
+		TPacketGGXmasWarpSantaReply pack_reply;
+		pack_reply.bHeader = HEADER_GG_XMAS_WARP_SANTA_REPLY;
+		pack_reply.bChannel = g_bChannel;
+		P2P_MANAGER::instance().Send(&pack_reply, sizeof(pack_reply));
+	}
+}
+
+void CInputP2P::XmasWarpSantaReply(const char* c_pData)
+{
+	TPacketGGXmasWarpSantaReply* p = (TPacketGGXmasWarpSantaReply*)c_pData;
+
+	if (p->bChannel == g_bChannel)
+	{
+		CharacterVectorInteractor vec;
+		if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(xmas::MOB_XMAS_SANTA_VNUM, vec))
+		{
+			CharacterVectorInteractor::iterator it = vec.begin();
+			while (it != vec.end())
+				M2_DESTROY_CHARACTER(*it++);
+		}
+	}
+}
+#endif
+
+void CInputP2P::LoginPing(LPDESC d, const char* c_pData)
+{
+	TPacketGGLoginPing* p = (TPacketGGLoginPing*)c_pData;
+
+	if (!g_pkAuthMasterDesc) // If I am master, I have to broadcast
+		P2P_MANAGER::instance().Send(p, sizeof(TPacketGGLoginPing), d);
+}
+
+// BLOCK_CHAT
+void CInputP2P::BlockChat(const char* c_pData)
+{
+	TPacketGGBlockChat* p = (TPacketGGBlockChat*)c_pData;
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindPC(p->szName);
+
+	if (ch)
+	{
+		sys_log(0, "BLOCK CHAT apply name %s dur %d", p->szName, p->lBlockDuration);
+		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, p->lBlockDuration, 0, true);
+	}
+	else
+	{
+		sys_log(0, "BLOCK CHAT fail name %s dur %d", p->szName, p->lBlockDuration);
+	}
+}
+// END_OF_BLOCK_CHAT
+//
+
+void CInputP2P::PCBangUpdate(const char* c_pData)
+{
+	TPacketPCBangUpdate* p = (TPacketPCBangUpdate*)c_pData;
+
+	CPCBangManager::instance().RequestUpdateIPList(p->ulPCBangID);
+}
+
+void CInputP2P::IamAwake(LPDESC d, const char* c_pData)
+{
+	std::string hostNames;
+	P2P_MANAGER::instance().GetP2PHostNames(hostNames);
+	sys_log(0, "P2P Awakeness check from %s. My P2P connection number is %d. and details...\n%s", d->GetHostName(), P2P_MANAGER::instance().GetDescCount(), hostNames.c_str());
+}
+
+int CInputP2P::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	if (test_server)
+		sys_log(0, "CInputP2P::Anlayze[Header %d]", bHeader);
+
+	int iExtraLen = 0;
+
+	switch (bHeader)
+	{
+		case HEADER_GG_SETUP:
+			Setup(d, c_pData);
+			break;
+
+		case HEADER_GG_LOGIN:
+			Login(d, c_pData);
+			break;
+
+		case HEADER_GG_LOGOUT:
+			Logout(d, c_pData);
+			break;
+
+		case HEADER_GG_RELAY:
+			if ((iExtraLen = Relay(d, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_GG_NOTICE:
+			if ((iExtraLen = Notice(d, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_GG_SHUTDOWN:
+			sys_err("Accept shutdown p2p command from %s.", d->GetHostName());
+			Shutdown(10);
+			break;
+
+		case HEADER_GG_GUILD:
+			if ((iExtraLen = Guild(d, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_GG_SHOUT:
+			Shout(c_pData);
+			break;
+
+		case HEADER_GG_DISCONNECT:
+			Disconnect(c_pData);
+			break;
+
+		case HEADER_GG_MESSENGER_ADD:
+			MessengerAdd(c_pData);
+			break;
+
+		case HEADER_GG_MESSENGER_REMOVE:
+			MessengerRemove(c_pData);
+			break;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		case HEADER_GG_MESSENGER_BLOCK_ADD:
+			MessengerBlockAdd(c_pData);
+			break;
+
+		case HEADER_GG_MESSENGER_BLOCK_REMOVE:
+			MessengerBlockRemove(c_pData);
+			break;
+#endif
+
+		case HEADER_GG_FIND_POSITION:
+			FindPosition(d, c_pData);
+			break;
+
+		case HEADER_GG_WARP_CHARACTER:
+			WarpCharacter(c_pData);
+			break;
+
+		case HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX:
+			GuildWarZoneMapIndex(c_pData);
+			break;
+
+		case HEADER_GG_TRANSFER:
+			Transfer(c_pData);
+			break;
+
+#if defined(__XMAS_EVENT_2008__)
+		case HEADER_GG_XMAS_WARP_SANTA:
+			XmasWarpSanta(c_pData);
+			break;
+
+		case HEADER_GG_XMAS_WARP_SANTA_REPLY:
+			XmasWarpSantaReply(c_pData);
+			break;
+#endif
+
+		case HEADER_GG_RELOAD_CRC_LIST:
+			LoadValidCRCList();
+			break;
+
+		case HEADER_GG_CHECK_CLIENT_VERSION:
+			CheckClientVersion();
+			break;
+
+		case HEADER_GG_LOGIN_PING:
+			LoginPing(d, c_pData);
+			break;
+
+		case HEADER_GG_BLOCK_CHAT:
+			BlockChat(c_pData);
+			break;
+
+		case HEADER_GG_SIEGE:
+		{
+			TPacketGGSiege* pSiege = (TPacketGGSiege*)c_pData;
+			castle_siege(pSiege->bEmpire, pSiege->bTowerCount);
+		}
+		break;
+
+		case HEADER_GG_MONARCH_NOTICE:
+			if ((iExtraLen = MonarchNotice(d, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_GG_MONARCH_TRANSFER:
+			MonarchTransfer(d, c_pData);
+			break;
+
+		case HEADER_GG_PCBANG_UPDATE:
+			PCBangUpdate(c_pData);
+			break;
+
+		case HEADER_GG_CHECK_AWAKENESS:
+			IamAwake(d, c_pData);
+			break;
+
+#if defined(__OFFLINE_SHOP__)
+		case HEADER_GG_OFFLINE_SHOP:
+			if ((iExtraLen = COfflineShop::ReceiveInterprocessPacket(d, c_pData)) < 0) {
+				return -1;
+			}
+			break;
+		case HEADER_GG_UPDATE_SELL_HISTORY:
+			UpdateSellHistory(d, c_pData);
+			break;
+#endif
+	}
+
+	return (iExtraLen);
+}
diff --git a/server/metin2/Source/Server/game/src/log.cpp b/server/metin2/Source/Server/game/src/log.cpp
index 499fbc6..f1b1218 100644
--- a/server/metin2/Source/Server/game/src/log.cpp
+++ b/server/metin2/Source/Server/game/src/log.cpp
@@ -1,360 +1,380 @@
-#include "stdafx.h"
-#include "constants.h"
-#include "config.h"
-#include "log.h"
-
-#include "char.h"
-#include "desc.h"
-#include "item.h"
-#include "locale_service.h"
-
-static char __escape_hint[1024];
-
-LogManager::LogManager() : m_bIsConnect(false)
-{
-}
-
-LogManager::~LogManager()
-{
-}
-
-bool LogManager::Connect(const char* host, const int port, const char* user, const char* pwd, const char* db)
-{
-	if (m_sql.Setup(host, user, pwd, db, g_stLocale.c_str(), false, port))
-		m_bIsConnect = true;
-
-	return m_bIsConnect;
-}
-
-void LogManager::Query(const char* c_pszFormat, ...)
-{
-	char szQuery[4096];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
-	va_end(args);
-
-	if (test_server)
-		sys_log(0, "LOG: %s", szQuery);
-
-	m_sql.AsyncQuery(szQuery);
-}
-
-bool LogManager::IsConnected()
-{
-	return m_bIsConnect;
-}
-
-void LogManager::ItemLog(DWORD dwPID, DWORD x, DWORD y, DWORD dwItemID, const char* c_pszText, const char* c_pszHint, const char* c_pszIP, DWORD dwVnum)
-{
-	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), c_pszHint, strlen(c_pszHint));
-
-	Query("INSERT DELAYED INTO log%s (type, time, who, x, y, what, how, hint, ip, vnum) VALUES('ITEM', NOW(), %u, %u, %u, %u, '%s', '%s', '%s', %u)",
-		get_table_postfix(), dwPID, x, y, dwItemID, c_pszText, __escape_hint, c_pszIP, dwVnum);
-}
-
-void LogManager::ItemLog(LPCHARACTER ch, LPITEM item, const char* c_pszText, const char* c_pszHint)
-{
-	if (NULL == ch || NULL == item)
-	{
-		sys_err("character or item nil (ch %p item %p text %s)", get_pointer(ch), get_pointer(item), c_pszText);
-		return;
-	}
-
-	ItemLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(), item->GetID(),
-		NULL == c_pszText ? "" : c_pszText,
-		c_pszHint, ch->GetDesc() ? ch->GetDesc()->GetHostName() : "",
-		item->GetOriginalVnum());
-}
-
-void LogManager::ItemLog(LPCHARACTER ch, int itemID, int itemVnum, const char* c_pszText, const char* c_pszHint)
-{
-	ItemLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(), itemID, c_pszText, c_pszHint, ch->GetDesc() ? ch->GetDesc()->GetHostName() : "", itemVnum);
-}
-
-void LogManager::CharLog(DWORD dwPID, DWORD x, DWORD y, DWORD dwValue, const char* c_pszText, const char* c_pszHint, const char* c_pszIP)
-{
-	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), c_pszHint, strlen(c_pszHint));
-
-	Query("INSERT DELAYED INTO log%s (type, time, who, x, y, what, how, hint, ip) VALUES('CHARACTER', NOW(), %u, %u, %u, %u, '%s', '%s', '%s')",
-		get_table_postfix(), dwPID, x, y, dwValue, c_pszText, __escape_hint, c_pszIP);
-}
-
-void LogManager::CharLog(LPCHARACTER ch, DWORD dw, const char* c_pszText, const char* c_pszHint)
-{
-	if (ch)
-		CharLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(), dw, c_pszText, c_pszHint, ch->GetDesc() ? ch->GetDesc()->GetHostName() : "");
-	else
-		CharLog(0, 0, 0, dw, c_pszText, c_pszHint, "");
-}
-
-void LogManager::LoginLog(bool isLogin, DWORD dwAccountID, DWORD dwPID, BYTE bLevel, BYTE bJob, DWORD dwPlayTime)
-{
-	Query("INSERT DELAYED INTO loginlog%s (type, time, channel, account_id, pid, level, job, playtime) VALUES (%s, NOW(), %d, %u, %u, %d, %d, %u)",
-		get_table_postfix(), isLogin ? "'LOGIN'" : "'LOGOUT'", g_bChannel, dwAccountID, dwPID, bLevel, bJob, dwPlayTime);
-}
-
-void LogManager::MoneyLog(BYTE type, DWORD vnum, int gold
-#if defined(__CHEQUE_SYSTEM__)
-	, int cheque
-#endif
-)
-{
-	if (type == MONEY_LOG_RESERVED || type >= MONEY_LOG_TYPE_MAX_NUM)
-	{
-#if defined(__CHEQUE_SYSTEM__)
-		sys_err("TYPE ERROR: type %d vnum %u gold %d cheque %d", type, vnum, gold, cheque);
-#else
-		sys_err("TYPE ERROR: type %d vnum %u gold %d", type, vnum, gold);
-#endif
-		return;
-	}
-
-	Query("INSERT DELAYED INTO money_log%s VALUES (NOW(), %d, %d, %d"
-#if defined(__CHEQUE_SYSTEM__)
-		", %d"
-#endif
-		")", get_table_postfix(), type, vnum, gold
-#if defined(__CHEQUE_SYSTEM__)
-		, cheque
-#endif
-	);
-}
-
-void LogManager::HackLog(const char* c_pszHackName, const char* c_pszLogin, const char* c_pszName, const char* c_pszIP)
-{
-	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), c_pszHackName, strlen(c_pszHackName));
-
-	Query("INSERT INTO hack_log (time, login, name, ip, server, why) VALUES(NOW(), '%s', '%s', '%s', '%s', '%s')", c_pszLogin, c_pszName, c_pszIP, g_stHostname.c_str(), __escape_hint);
-}
-
-void LogManager::HackLog(const char* c_pszHackName, LPCHARACTER ch)
-{
-	if (ch->GetDesc())
-	{
-		HackLog(c_pszHackName,
-			ch->GetDesc()->GetAccountTable().login,
-			ch->GetName(),
-			ch->GetDesc()->GetHostName());
-	}
-}
-
-void LogManager::HackCRCLog(const char* c_pszHackName, const char* c_pszLogin, const char* c_pszName, const char* c_pszIP, DWORD dwCRC)
-{
-	Query("INSERT INTO hack_crc_log (time, login, name, ip, server, why, crc) VALUES(NOW(), '%s', '%s', '%s', '%s', '%s', %u)", c_pszLogin, c_pszName, c_pszIP, g_stHostname.c_str(), c_pszHackName, dwCRC);
-}
-
-void LogManager::PCBangLoginLog(DWORD dwPCBangID, const char* c_szPCBangIP, DWORD dwPlayerID, DWORD dwPlayTime)
-{
-	Query("INSERT INTO pcbang_loginlog (time, pcbang_id, ip, pid, play_time) VALUES (NOW(), %u, '%s', %u, %u)",
-		dwPCBangID, c_szPCBangIP, dwPlayerID, dwPlayTime);
-}
-
-void LogManager::GoldBarLog(DWORD dwPID, DWORD dwItemID, GOLDBAR_HOW eHow, const char* c_pszHint)
-{
-	char szHow[32 + 1];
-
-	switch (eHow)
-	{
-	case PERSONAL_SHOP_BUY:
-		snprintf(szHow, sizeof(szHow), "'BUY'");
-		break;
-
-	case PERSONAL_SHOP_SELL:
-		snprintf(szHow, sizeof(szHow), "'SELL'");
-		break;
-
-	case SHOP_BUY:
-		snprintf(szHow, sizeof(szHow), "'SHOP_BUY'");
-		break;
-
-	case SHOP_SELL:
-		snprintf(szHow, sizeof(szHow), "'SHOP_SELL'");
-		break;
-
-	case EXCHANGE_TAKE:
-		snprintf(szHow, sizeof(szHow), "'EXCHANGE_TAKE'");
-		break;
-
-	case EXCHANGE_GIVE:
-		snprintf(szHow, sizeof(szHow), "'EXCHANGE_GIVE'");
-		break;
-
-	case QUEST:
-		snprintf(szHow, sizeof(szHow), "'QUEST'");
-		break;
-
-	default:
-		snprintf(szHow, sizeof(szHow), "''");
-		break;
-	}
-
-	Query("INSERT DELAYED INTO goldlog%s (date, time, pid, what, how, hint) VALUES(CURDATE(), CURTIME(), %u, %u, %s, '%s')",
-		get_table_postfix(), dwPID, dwItemID, szHow, c_pszHint);
-}
-
-void LogManager::CubeLog(DWORD dwPID, DWORD x, DWORD y, DWORD item_vnum, DWORD item_uid, int item_count, bool success)
-{
-	Query("INSERT DELAYED INTO cube%s (pid, time, x, y, item_vnum, item_uid, item_count, success) "
-		"VALUES(%u, NOW(), %u, %u, %u, %u, %d, %d)",
-		get_table_postfix(), dwPID, x, y, item_vnum, item_uid, item_count, success ? 1 : 0);
-}
-
-void LogManager::WhisperLog(DWORD fromPID, DWORD toPID, const char* message)
-{
-	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), message, strlen(message)); // Message mysql_real_escape_string Output = __escape_hint;
-	Query("INSERT INTO whisper_log%s (`time`, `from`, `to`, `message`) VALUES(NOW(), %u, %u, '%s');", get_table_postfix(), fromPID, toPID, __escape_hint);
-}
-
-void LogManager::SpeedHackLog(DWORD pid, DWORD x, DWORD y, int hack_count)
-{
-	Query("INSERT INTO speed_hack%s (pid, time, x, y, hack_count) "
-		"VALUES(%u, NOW(), %u, %u, %d)",
-		get_table_postfix(), pid, x, y, hack_count);
-}
-
-void LogManager::ChangeNameLog(DWORD pid, const char* old_name, const char* new_name, const char* ip)
-{
-	Query("INSERT DELAYED INTO change_name%s (pid, old_name, new_name, time, ip) "
-		"VALUES(%u, '%s', '%s', NOW(), '%s') ",
-		get_table_postfix(), pid, old_name, new_name, ip);
-}
-
-void LogManager::GMCommandLog(DWORD dwPID, const char* szName, const char* szIP, BYTE byChannel, const char* szCommand)
-{
-	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), szCommand, strlen(szCommand));
-
-	Query("INSERT DELAYED INTO command_log%s (userid, server, ip, port, username, command, date ) "
-		"VALUES(%u, 999, '%s', %u, '%s', '%s', NOW()) ",
-		get_table_postfix(), dwPID, szIP, byChannel, szName, __escape_hint);
-}
-
-void LogManager::RefineLog(DWORD pid, const char* item_name, DWORD item_id, int item_refine_level, int is_success, const char* how)
-{
-	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), item_name, strlen(item_name));
-
-	Query("INSERT INTO refinelog%s (pid, item_name, item_id, step, time, is_success, setType) VALUES(%u, '%s', %u, %d, NOW(), %d, '%s')",
-		get_table_postfix(), pid, __escape_hint, item_id, item_refine_level, is_success, how);
-}
-
-void LogManager::ShoutLog(BYTE bChannel, BYTE bEmpire, const char* pszText)
-{
-	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), pszText, strlen(pszText));
-
-	Query("INSERT INTO shout_log%s VALUES(NOW(), %d, %d,'%s')", get_table_postfix(), bChannel, bEmpire, __escape_hint);
-}
-
-void LogManager::LevelLog(LPCHARACTER pChar, unsigned int level, unsigned int playhour)
-{
-	if (true == LC_IsEurope())
-	{
-		DWORD aid = 0;
-
-		if (NULL != pChar->GetDesc())
-		{
-			aid = pChar->GetDesc()->GetAccountTable().id;
-		}
-
-		Query("REPLACE INTO levellog%s (name, level, time, account_id, pid, playtime) VALUES('%s', %u, NOW(), %u, %u, %d)",
-			get_table_postfix(), pChar->GetName(), level, aid, pChar->GetPlayerID(), playhour);
-	}
-	else
-	{
-		Query("REPLACE INTO levellog%s (name, level, time, playtime) VALUES('%s', %u, NOW(), %d)",
-			get_table_postfix(), pChar->GetName(), level, playhour);
-	}
-}
-
-void LogManager::BootLog(const char* c_pszHostName, BYTE bChannel)
-{
-	Query("INSERT INTO bootlog (time, hostname, channel) VALUES(NOW(), '%s', %d)",
-		c_pszHostName, bChannel);
-}
-
-void LogManager::FishLog(DWORD dwPID, int prob_idx, int fish_id, int fish_level, DWORD dwMiliseconds, DWORD dwVnum, DWORD dwValue)
-{
-	Query("INSERT INTO fish_log%s VALUES(NOW(), %u, %d, %u, %d, %u, %u, %u)",
-		get_table_postfix(),
-		dwPID,
-		prob_idx,
-		fish_id,
-		fish_level,
-		dwMiliseconds,
-		dwVnum,
-		dwValue);
-}
-
-void LogManager::QuestRewardLog(const char* c_pszQuestName, DWORD dwPID, DWORD dwLevel, int iValue1, int iValue2)
-{
-	Query("INSERT INTO quest_reward_log%s VALUES('%s',%u,%u,2,%u,%u,NOW())",
-		get_table_postfix(),
-		c_pszQuestName,
-		dwPID,
-		dwLevel,
-		iValue1,
-		iValue2);
-}
-
-void LogManager::DetailLoginLog(bool isLogin, LPCHARACTER ch)
-{
-	if (NULL == ch->GetDesc())
-		return;
-
-	if (true == isLogin)
-	{
-		Query("INSERT INTO loginlog2(type, is_gm, login_time, channel, account_id, pid, ip, client_version) "
-			"VALUES('INVALID', %s, NOW(), %d, %u, %u, inet_aton('%s'), '%s')",
-			ch->IsGM() == TRUE ? "'Y'" : "'N'",
-			g_bChannel,
-			ch->GetDesc()->GetAccountTable().id,
-			ch->GetPlayerID(),
-			ch->GetDesc()->GetHostName(),
-			ch->GetDesc()->GetClientVersion());
-	}
-	else
-	{
-		Query("SET @i = (SELECT MAX(id) FROM loginlog2 WHERE account_id=%u AND pid=%u)",
-			ch->GetDesc()->GetAccountTable().id,
-			ch->GetPlayerID());
-
-		Query("UPDATE loginlog2 SET type='VALID', logout_time=NOW(), playtime=TIMEDIFF(logout_time,login_time) WHERE id=@i");
-	}
-}
-
-void LogManager::DragonSlayLog(DWORD dwGuildID, DWORD dwDragonVnum, DWORD dwStartTime, DWORD dwEndTime)
-{
-	Query("INSERT INTO dragon_slay_log%s VALUES( %d, %d, FROM_UNIXTIME(%d), FROM_UNIXTIME(%d) )",
-		get_table_postfix(),
-		dwGuildID, dwDragonVnum, dwStartTime, dwEndTime);
-}
-
-#ifdef __OFFLINE_SHOP__
-void LogManager::OfflineShopLog(uint32_t sellerPid, uint32_t sellerOfflineShopId, const std::string& type, uint32_t buyerPid, uint32_t itemId, uint32_t vnum, uint32_t count, int64_t gold)
-{
-	Query("INSERT INTO offline_shop%s (owner_pid, shop_id, type, buyer_pid, item_id, vnum, count, gold, time) VALUES(%u, %u, '%s', %u, %u, %u, %u, %lld, NOW())",
-		get_table_postfix(), sellerPid, sellerOfflineShopId, type.c_str(), buyerPid, itemId, vnum, count, gold);
-}
-
-void LogManager::CloseOfflineShopByGM(DWORD gmPid, const char* gmName, const char* gmIP, DWORD shopId, const char* shopName, const char* shopOwnerName, DWORD shopOwnerPid)
-{
-	Query("INSERT DELAYED INTO gm_close_shop%s (gm_pid, gm_playername, gm_ip, shop_id, "
-		  "shop_name, shop_owner_name, shop_owner_pid) VALUES(%u, '%s', '%s', %u, '%s', '%s', %u)",
-		get_table_postfix(), gmPid, gmName, gmIP, shopId, shopName, shopOwnerName, shopOwnerPid);
-}
-#endif
-
-#if defined(__MAILBOX__)
-void LogManager::MailLog(const char* const szName, const char* const szWho, const char* const szTitle, const char* const szMessage, const bool bIsGM, const DWORD dwItemVnum, const DWORD dwItemCount, const int iYang, const int iWon)
-{
-	char szEscapeTitle[1024];
-	m_sql.EscapeString(szEscapeTitle, sizeof(szEscapeTitle), szTitle, strlen(szTitle));
-
-	char szEscapeMessage[1024];
-	m_sql.EscapeString(szEscapeMessage, sizeof(szEscapeMessage), szMessage, strlen(szMessage));
-
-	Query("INSERT DELAYED INTO mailbox_log%s (name, who, title, message, gm, gold, won, ivnum, icount, date) "
-		"VALUES('%s', '%s', '%s', '%s', %d, %d, %d, %lu, %lu, NOW()) ",
-		get_table_postfix(), szName, szWho, szEscapeTitle, szEscapeMessage, bIsGM, iYang, iWon, dwItemVnum, dwItemCount);
-}
-#endif
+#include <cstdarg>
+
+// Safe formatting helper to avoid sprintf overflow in log formatting.
+static void SafeVsnprintf(char* out, size_t cap, const char* fmt, va_list ap)
+{
+	if (!out || cap == 0) return;
+	int n = vsnprintf(out, cap, fmt, ap);
+	if (n < 0)
+		out[0] = '\0';
+	else
+		out[cap - 1] = '\0';
+}
+
+static void SafeSnprintf(char* out, size_t cap, const char* fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	SafeVsnprintf(out, cap, fmt, ap);
+	va_end(ap);
+}
+#include "stdafx.h"
+#include "constants.h"
+#include "config.h"
+#include "log.h"
+
+#include "char.h"
+#include "desc.h"
+#include "item.h"
+#include "locale_service.h"
+
+static char __escape_hint[1024];
+
+LogManager::LogManager() : m_bIsConnect(false)
+{
+}
+
+LogManager::~LogManager()
+{
+}
+
+bool LogManager::Connect(const char* host, const int port, const char* user, const char* pwd, const char* db)
+{
+	if (m_sql.Setup(host, user, pwd, db, g_stLocale.c_str(), false, port))
+		m_bIsConnect = true;
+
+	return m_bIsConnect;
+}
+
+void LogManager::Query(const char* c_pszFormat, ...)
+{
+	char szQuery[4096];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
+	va_end(args);
+
+	if (test_server)
+		sys_log(0, "LOG: %s", szQuery);
+
+	m_sql.AsyncQuery(szQuery);
+}
+
+bool LogManager::IsConnected()
+{
+	return m_bIsConnect;
+}
+
+void LogManager::ItemLog(DWORD dwPID, DWORD x, DWORD y, DWORD dwItemID, const char* c_pszText, const char* c_pszHint, const char* c_pszIP, DWORD dwVnum)
+{
+	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), c_pszHint, strlen(c_pszHint));
+
+	Query("INSERT DELAYED INTO log%s (type, time, who, x, y, what, how, hint, ip, vnum) VALUES('ITEM', NOW(), %u, %u, %u, %u, '%s', '%s', '%s', %u)",
+		get_table_postfix(), dwPID, x, y, dwItemID, c_pszText, __escape_hint, c_pszIP, dwVnum);
+}
+
+void LogManager::ItemLog(LPCHARACTER ch, LPITEM item, const char* c_pszText, const char* c_pszHint)
+{
+	if (NULL == ch || NULL == item)
+	{
+		sys_err("character or item nil (ch %p item %p text %s)", get_pointer(ch), get_pointer(item), c_pszText);
+		return;
+	}
+
+	ItemLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(), item->GetID(),
+		NULL == c_pszText ? "" : c_pszText,
+		c_pszHint, ch->GetDesc() ? ch->GetDesc()->GetHostName() : "",
+		item->GetOriginalVnum());
+}
+
+void LogManager::ItemLog(LPCHARACTER ch, int itemID, int itemVnum, const char* c_pszText, const char* c_pszHint)
+{
+	ItemLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(), itemID, c_pszText, c_pszHint, ch->GetDesc() ? ch->GetDesc()->GetHostName() : "", itemVnum);
+}
+
+void LogManager::CharLog(DWORD dwPID, DWORD x, DWORD y, DWORD dwValue, const char* c_pszText, const char* c_pszHint, const char* c_pszIP)
+{
+	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), c_pszHint, strlen(c_pszHint));
+
+	Query("INSERT DELAYED INTO log%s (type, time, who, x, y, what, how, hint, ip) VALUES('CHARACTER', NOW(), %u, %u, %u, %u, '%s', '%s', '%s')",
+		get_table_postfix(), dwPID, x, y, dwValue, c_pszText, __escape_hint, c_pszIP);
+}
+
+void LogManager::CharLog(LPCHARACTER ch, DWORD dw, const char* c_pszText, const char* c_pszHint)
+{
+	if (ch)
+		CharLog(ch->GetPlayerID(), ch->GetX(), ch->GetY(), dw, c_pszText, c_pszHint, ch->GetDesc() ? ch->GetDesc()->GetHostName() : "");
+	else
+		CharLog(0, 0, 0, dw, c_pszText, c_pszHint, "");
+}
+
+void LogManager::LoginLog(bool isLogin, DWORD dwAccountID, DWORD dwPID, BYTE bLevel, BYTE bJob, DWORD dwPlayTime)
+{
+	Query("INSERT DELAYED INTO loginlog%s (type, time, channel, account_id, pid, level, job, playtime) VALUES (%s, NOW(), %d, %u, %u, %d, %d, %u)",
+		get_table_postfix(), isLogin ? "'LOGIN'" : "'LOGOUT'", g_bChannel, dwAccountID, dwPID, bLevel, bJob, dwPlayTime);
+}
+
+void LogManager::MoneyLog(BYTE type, DWORD vnum, int gold
+#if defined(__CHEQUE_SYSTEM__)
+	, int cheque
+#endif
+)
+{
+	if (type == MONEY_LOG_RESERVED || type >= MONEY_LOG_TYPE_MAX_NUM)
+	{
+#if defined(__CHEQUE_SYSTEM__)
+		sys_err("TYPE ERROR: type %d vnum %u gold %d cheque %d", type, vnum, gold, cheque);
+#else
+		sys_err("TYPE ERROR: type %d vnum %u gold %d", type, vnum, gold);
+#endif
+		return;
+	}
+
+	Query("INSERT DELAYED INTO money_log%s VALUES (NOW(), %d, %d, %d"
+#if defined(__CHEQUE_SYSTEM__)
+		", %d"
+#endif
+		")", get_table_postfix(), type, vnum, gold
+#if defined(__CHEQUE_SYSTEM__)
+		, cheque
+#endif
+	);
+}
+
+void LogManager::HackLog(const char* c_pszHackName, const char* c_pszLogin, const char* c_pszName, const char* c_pszIP)
+{
+	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), c_pszHackName, strlen(c_pszHackName));
+
+	Query("INSERT INTO hack_log (time, login, name, ip, server, why) VALUES(NOW(), '%s', '%s', '%s', '%s', '%s')", c_pszLogin, c_pszName, c_pszIP, g_stHostname.c_str(), __escape_hint);
+}
+
+void LogManager::HackLog(const char* c_pszHackName, LPCHARACTER ch)
+{
+	if (ch->GetDesc())
+	{
+		HackLog(c_pszHackName,
+			ch->GetDesc()->GetAccountTable().login,
+			ch->GetName(),
+			ch->GetDesc()->GetHostName());
+	}
+}
+
+void LogManager::HackCRCLog(const char* c_pszHackName, const char* c_pszLogin, const char* c_pszName, const char* c_pszIP, DWORD dwCRC)
+{
+	Query("INSERT INTO hack_crc_log (time, login, name, ip, server, why, crc) VALUES(NOW(), '%s', '%s', '%s', '%s', '%s', %u)", c_pszLogin, c_pszName, c_pszIP, g_stHostname.c_str(), c_pszHackName, dwCRC);
+}
+
+void LogManager::PCBangLoginLog(DWORD dwPCBangID, const char* c_szPCBangIP, DWORD dwPlayerID, DWORD dwPlayTime)
+{
+	Query("INSERT INTO pcbang_loginlog (time, pcbang_id, ip, pid, play_time) VALUES (NOW(), %u, '%s', %u, %u)",
+		dwPCBangID, c_szPCBangIP, dwPlayerID, dwPlayTime);
+}
+
+void LogManager::GoldBarLog(DWORD dwPID, DWORD dwItemID, GOLDBAR_HOW eHow, const char* c_pszHint)
+{
+	char szHow[32 + 1];
+
+	switch (eHow)
+	{
+	case PERSONAL_SHOP_BUY:
+		snprintf(szHow, sizeof(szHow), "'BUY'");
+		break;
+
+	case PERSONAL_SHOP_SELL:
+		snprintf(szHow, sizeof(szHow), "'SELL'");
+		break;
+
+	case SHOP_BUY:
+		snprintf(szHow, sizeof(szHow), "'SHOP_BUY'");
+		break;
+
+	case SHOP_SELL:
+		snprintf(szHow, sizeof(szHow), "'SHOP_SELL'");
+		break;
+
+	case EXCHANGE_TAKE:
+		snprintf(szHow, sizeof(szHow), "'EXCHANGE_TAKE'");
+		break;
+
+	case EXCHANGE_GIVE:
+		snprintf(szHow, sizeof(szHow), "'EXCHANGE_GIVE'");
+		break;
+
+	case QUEST:
+		snprintf(szHow, sizeof(szHow), "'QUEST'");
+		break;
+
+	default:
+		snprintf(szHow, sizeof(szHow), "''");
+		break;
+	}
+
+	Query("INSERT DELAYED INTO goldlog%s (date, time, pid, what, how, hint) VALUES(CURDATE(), CURTIME(), %u, %u, %s, '%s')",
+		get_table_postfix(), dwPID, dwItemID, szHow, c_pszHint);
+}
+
+void LogManager::CubeLog(DWORD dwPID, DWORD x, DWORD y, DWORD item_vnum, DWORD item_uid, int item_count, bool success)
+{
+	Query("INSERT DELAYED INTO cube%s (pid, time, x, y, item_vnum, item_uid, item_count, success) "
+		"VALUES(%u, NOW(), %u, %u, %u, %u, %d, %d)",
+		get_table_postfix(), dwPID, x, y, item_vnum, item_uid, item_count, success ? 1 : 0);
+}
+
+void LogManager::WhisperLog(DWORD fromPID, DWORD toPID, const char* message)
+{
+	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), message, strlen(message)); // Message mysql_real_escape_string Output = __escape_hint;
+	Query("INSERT INTO whisper_log%s (`time`, `from`, `to`, `message`) VALUES(NOW(), %u, %u, '%s');", get_table_postfix(), fromPID, toPID, __escape_hint);
+}
+
+void LogManager::SpeedHackLog(DWORD pid, DWORD x, DWORD y, int hack_count)
+{
+	Query("INSERT INTO speed_hack%s (pid, time, x, y, hack_count) "
+		"VALUES(%u, NOW(), %u, %u, %d)",
+		get_table_postfix(), pid, x, y, hack_count);
+}
+
+void LogManager::ChangeNameLog(DWORD pid, const char* old_name, const char* new_name, const char* ip)
+{
+	Query("INSERT DELAYED INTO change_name%s (pid, old_name, new_name, time, ip) "
+		"VALUES(%u, '%s', '%s', NOW(), '%s') ",
+		get_table_postfix(), pid, old_name, new_name, ip);
+}
+
+void LogManager::GMCommandLog(DWORD dwPID, const char* szName, const char* szIP, BYTE byChannel, const char* szCommand)
+{
+	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), szCommand, strlen(szCommand));
+
+	Query("INSERT DELAYED INTO command_log%s (userid, server, ip, port, username, command, date ) "
+		"VALUES(%u, 999, '%s', %u, '%s', '%s', NOW()) ",
+		get_table_postfix(), dwPID, szIP, byChannel, szName, __escape_hint);
+}
+
+void LogManager::RefineLog(DWORD pid, const char* item_name, DWORD item_id, int item_refine_level, int is_success, const char* how)
+{
+	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), item_name, strlen(item_name));
+
+	Query("INSERT INTO refinelog%s (pid, item_name, item_id, step, time, is_success, setType) VALUES(%u, '%s', %u, %d, NOW(), %d, '%s')",
+		get_table_postfix(), pid, __escape_hint, item_id, item_refine_level, is_success, how);
+}
+
+void LogManager::ShoutLog(BYTE bChannel, BYTE bEmpire, const char* pszText)
+{
+	m_sql.EscapeString(__escape_hint, sizeof(__escape_hint), pszText, strlen(pszText));
+
+	Query("INSERT INTO shout_log%s VALUES(NOW(), %d, %d,'%s')", get_table_postfix(), bChannel, bEmpire, __escape_hint);
+}
+
+void LogManager::LevelLog(LPCHARACTER pChar, unsigned int level, unsigned int playhour)
+{
+	if (true == LC_IsEurope())
+	{
+		DWORD aid = 0;
+
+		if (NULL != pChar->GetDesc())
+		{
+			aid = pChar->GetDesc()->GetAccountTable().id;
+		}
+
+		Query("REPLACE INTO levellog%s (name, level, time, account_id, pid, playtime) VALUES('%s', %u, NOW(), %u, %u, %d)",
+			get_table_postfix(), pChar->GetName(), level, aid, pChar->GetPlayerID(), playhour);
+	}
+	else
+	{
+		Query("REPLACE INTO levellog%s (name, level, time, playtime) VALUES('%s', %u, NOW(), %d)",
+			get_table_postfix(), pChar->GetName(), level, playhour);
+	}
+}
+
+void LogManager::BootLog(const char* c_pszHostName, BYTE bChannel)
+{
+	Query("INSERT INTO bootlog (time, hostname, channel) VALUES(NOW(), '%s', %d)",
+		c_pszHostName, bChannel);
+}
+
+void LogManager::FishLog(DWORD dwPID, int prob_idx, int fish_id, int fish_level, DWORD dwMiliseconds, DWORD dwVnum, DWORD dwValue)
+{
+	Query("INSERT INTO fish_log%s VALUES(NOW(), %u, %d, %u, %d, %u, %u, %u)",
+		get_table_postfix(),
+		dwPID,
+		prob_idx,
+		fish_id,
+		fish_level,
+		dwMiliseconds,
+		dwVnum,
+		dwValue);
+}
+
+void LogManager::QuestRewardLog(const char* c_pszQuestName, DWORD dwPID, DWORD dwLevel, int iValue1, int iValue2)
+{
+	Query("INSERT INTO quest_reward_log%s VALUES('%s',%u,%u,2,%u,%u,NOW())",
+		get_table_postfix(),
+		c_pszQuestName,
+		dwPID,
+		dwLevel,
+		iValue1,
+		iValue2);
+}
+
+void LogManager::DetailLoginLog(bool isLogin, LPCHARACTER ch)
+{
+	if (NULL == ch->GetDesc())
+		return;
+
+	if (true == isLogin)
+	{
+		Query("INSERT INTO loginlog2(type, is_gm, login_time, channel, account_id, pid, ip, client_version) "
+			"VALUES('INVALID', %s, NOW(), %d, %u, %u, inet_aton('%s'), '%s')",
+			ch->IsGM() == TRUE ? "'Y'" : "'N'",
+			g_bChannel,
+			ch->GetDesc()->GetAccountTable().id,
+			ch->GetPlayerID(),
+			ch->GetDesc()->GetHostName(),
+			ch->GetDesc()->GetClientVersion());
+	}
+	else
+	{
+		Query("SET @i = (SELECT MAX(id) FROM loginlog2 WHERE account_id=%u AND pid=%u)",
+			ch->GetDesc()->GetAccountTable().id,
+			ch->GetPlayerID());
+
+		Query("UPDATE loginlog2 SET type='VALID', logout_time=NOW(), playtime=TIMEDIFF(logout_time,login_time) WHERE id=@i");
+	}
+}
+
+void LogManager::DragonSlayLog(DWORD dwGuildID, DWORD dwDragonVnum, DWORD dwStartTime, DWORD dwEndTime)
+{
+	Query("INSERT INTO dragon_slay_log%s VALUES( %d, %d, FROM_UNIXTIME(%d), FROM_UNIXTIME(%d) )",
+		get_table_postfix(),
+		dwGuildID, dwDragonVnum, dwStartTime, dwEndTime);
+}
+
+#ifdef __OFFLINE_SHOP__
+void LogManager::OfflineShopLog(uint32_t sellerPid, uint32_t sellerOfflineShopId, const std::string& type, uint32_t buyerPid, uint32_t itemId, uint32_t vnum, uint32_t count, int64_t gold)
+{
+	Query("INSERT INTO offline_shop%s (owner_pid, shop_id, type, buyer_pid, item_id, vnum, count, gold, time) VALUES(%u, %u, '%s', %u, %u, %u, %u, %lld, NOW())",
+		get_table_postfix(), sellerPid, sellerOfflineShopId, type.c_str(), buyerPid, itemId, vnum, count, gold);
+}
+
+void LogManager::CloseOfflineShopByGM(DWORD gmPid, const char* gmName, const char* gmIP, DWORD shopId, const char* shopName, const char* shopOwnerName, DWORD shopOwnerPid)
+{
+	Query("INSERT DELAYED INTO gm_close_shop%s (gm_pid, gm_playername, gm_ip, shop_id, "
+		  "shop_name, shop_owner_name, shop_owner_pid) VALUES(%u, '%s', '%s', %u, '%s', '%s', %u)",
+		get_table_postfix(), gmPid, gmName, gmIP, shopId, shopName, shopOwnerName, shopOwnerPid);
+}
+#endif
+
+#if defined(__MAILBOX__)
+void LogManager::MailLog(const char* const szName, const char* const szWho, const char* const szTitle, const char* const szMessage, const bool bIsGM, const DWORD dwItemVnum, const DWORD dwItemCount, const int iYang, const int iWon)
+{
+	char szEscapeTitle[1024];
+	m_sql.EscapeString(szEscapeTitle, sizeof(szEscapeTitle), szTitle, strlen(szTitle));
+
+	char szEscapeMessage[1024];
+	m_sql.EscapeString(szEscapeMessage, sizeof(szEscapeMessage), szMessage, strlen(szMessage));
+
+	Query("INSERT DELAYED INTO mailbox_log%s (name, who, title, message, gm, gold, won, ivnum, icount, date) "
+		"VALUES('%s', '%s', '%s', '%s', %d, %d, %d, %lu, %lu, NOW()) ",
+		get_table_postfix(), szName, szWho, szEscapeTitle, szEscapeMessage, bIsGM, iYang, iWon, dwItemVnum, dwItemCount);
+}
+#endif
diff --git a/server/metin2/Source/Server/game/src/main.cpp b/server/metin2/Source/Server/game/src/main.cpp
index 16fd11e..c949c62 100644
--- a/server/metin2/Source/Server/game/src/main.cpp
+++ b/server/metin2/Source/Server/game/src/main.cpp
@@ -1,1058 +1,1061 @@
-#include "stdafx.h"
-#include "constants.h"
-#include "config.h"
-#include "event.h"
-#include "minilzo.h"
-#include "packet.h"
-#include "desc_manager.h"
-#include "item_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "mob_manager.h"
-#include "motion.h"
-#include "sectree_manager.h"
-#include "shop_manager.h"
-#include "regen.h"
-#include "text_file_loader.h"
-#include "skill.h"
-#include "pvp.h"
-#include "party.h"
-#include "questmanager.h"
-#include "profiler.h"
-#include "lzo_manager.h"
-#include "messenger_manager.h"
-#include "db.h"
-#include "log.h"
-#include "p2p.h"
-#include "guild_manager.h"
-#include "dungeon.h"
-#include "cmd.h"
-#include "refine.h"
-#include "banword.h"
-#include "priv_manager.h"
-#include "war_map.h"
-#include "building.h"
-#include "login_sim.h"
-#include "target.h"
-#include "marriage.h"
-#include "wedding.h"
-#include "fishing.h"
-#include "item_addon.h"
-#include "TrafficProfiler.h"
-#include "locale_service.h"
-#include "arena.h"
-#include "OXEvent.h"
-#include "monarch.h"
-#include "polymorph.h"
-#include "blend_item.h"
-#include "castle.h"
-#include "ani.h"
-#include "BattleArena.h"
-#include "over9refine.h"
-#include "horsename_manager.h"
-#include "pcbang.h"
-#include "MarkManager.h"
-#include "spam.h"
-#include "panama.h"
-#include "threeway_war.h"
-#include "auth_brazil.h"
-#include "DragonLair.h"
-#include "skill_power.h"
-#include "DragonSoul.h"
-#if defined(__CUBE_RENEWAL__)
-#	include "cube.h"
-#endif
-#ifndef __WIN32__
-#	include "limit_time.h"
-#endif
-
-//#define __FILEMONITOR__
-
-#if defined (__FreeBSD__) && defined(__FILEMONITOR__)
-#	include "FileMonitor_FreeBSD.h"
-#endif
-
-#if defined(__MT_THUNDER_DUNGEON__)
-#	include "mt_thunder_dungeon.h"
-#endif
-#if defined(__DAWNMIST_DUNGEON__)
-#	include "dawnmist_dungeon.h"
-#endif
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-#	include "guild_dragonlair.h"
-#endif
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-//#ifndef __WIN32__
-//#include <gtest/gtest.h>
-//#endif
-
-#ifdef USE_STACKTRACE
-#include <execinfo.h>
-#endif
-
-#include "check_server.h"
-#ifdef ENABLE_QUEEN_NETHIS
-#include "SnakeLair.h"
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-#include "OfflineShop.h"
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-#include "battlepass_manager.h"
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-
-//extern const char * _malloc_options;
-#if defined(__FreeBSD__) && defined(DEBUG_ALLOC)
-extern void (*_malloc_message)(const char* p1, const char* p2, const char* p3, const char* p4);
-// FreeBSD _malloc_message replacement
-void WriteMallocMessage(const char* p1, const char* p2, const char* p3, const char* p4)
-{
-	FILE* fp = ::fopen(DBGALLOC_LOG_FILENAME, "a");
-	if (fp == NULL)
-		return;
-
-	::fprintf(fp, "%s %s %s %s\n", p1, p2, p3, p4);
-	::fclose(fp);
-}
-#endif
-
-// TRAFFIC_PROFILER
-static const DWORD TRAFFIC_PROFILE_FLUSH_CYCLE = 3600; ///< TrafficProfiler 의 Flush cycle. 1시간 간격
-// END_OF_TRAFFIC_PROFILER
-
-// 게임과 연결되는 소켓
-volatile int num_events_called = 0;
-int max_bytes_written = 0;
-int current_bytes_written = 0;
-int total_bytes_written = 0;
-BYTE g_bLogLevel = 0;
-
-socket_t tcp_socket = 0;
-socket_t udp_socket = 0;
-socket_t p2p_socket = 0;
-
-LPFDWATCH main_fdw = NULL;
-
-int io_loop(LPFDWATCH fdw);
-
-int start(int argc, char** argv);
-int idle();
-void destroy();
-
-void test();
-
-enum EProfile
-{
-	PROF_EVENT,
-	PROF_CHR_UPDATE,
-	PROF_IO,
-	PROF_HEARTBEAT,
-	PROF_MAX_NUM
-};
-
-static DWORD s_dwProfiler[PROF_MAX_NUM];
-
-int g_shutdown_disconnect_pulse;
-int g_shutdown_disconnect_force_pulse;
-int g_shutdown_core_pulse;
-bool g_bShutdown = false;
-
-extern void CancelReloadSpamEvent();
-
-void ContinueOnFatalError()
-{
-#ifdef USE_STACKTRACE
-	void* array[200];
-	std::size_t size;
-	char** symbols;
-
-	size = backtrace(array, 200);
-	symbols = backtrace_symbols(array, size);
-
-	std::ostringstream oss;
-	oss << std::endl;
-	for (std::size_t i = 0; i < size; ++i)
-	{
-		oss << "  Stack> " << symbols[i] << std::endl;
-	}
-
-	free(symbols);
-
-	sys_err("FatalError on %s", oss.str().c_str());
-#else
-	sys_err("FatalError");
-#endif
-}
-
-void ShutdownOnFatalError()
-{
-	if (!g_bShutdown)
-	{
-		sys_err("ShutdownOnFatalError!!!!!!!!!!");
-		{
-			SendNotice(LC_STRING("서버에 치명적인 오류가 발생하여 자동으로 재부팅됩니다."));
-			SendNotice(LC_STRING("10초후 자동으로 접속이 종료되며,"));
-			SendNotice(LC_STRING("5분 후에 정상적으로 접속하실수 있습니다."));
-		}
-
-		g_bShutdown = true;
-		g_bNoMoreClient = true;
-
-		g_shutdown_disconnect_pulse = thecore_pulse() + PASSES_PER_SEC(10);
-		g_shutdown_disconnect_force_pulse = thecore_pulse() + PASSES_PER_SEC(20);
-		g_shutdown_core_pulse = thecore_pulse() + PASSES_PER_SEC(30);
-	}
-}
-
-namespace
-{
-	struct SendDisconnectFunc
-	{
-		void operator () (LPDESC d)
-		{
-			if (d->GetCharacter())
-			{
-				if (d->GetCharacter()->GetGMLevel() == GM_PLAYER)
-					d->GetCharacter()->ChatPacket(CHAT_TYPE_COMMAND, "quit Shutdown(SendDisconnectFunc)");
-			}
-		}
-	};
-
-	struct DisconnectFunc
-	{
-		void operator () (LPDESC d)
-		{
-			if (d->GetType() == DESC_TYPE_CONNECTOR)
-				return;
-
-			if (d->IsPhase(PHASE_P2P))
-				return;
-
-			d->SetPhase(PHASE_CLOSE);
-		}
-	};
-}
-
-extern std::map<DWORD, CLoginSim*> g_sim; // first: AID
-extern std::map<DWORD, CLoginSim*> g_simByPID;
-extern std::vector<TPlayerTable> g_vec_save;
-unsigned int save_idx = 0;
-
-void heartbeat(LPHEART ht, int pulse)
-{
-	DWORD t;
-
-	t = get_dword_time();
-	num_events_called += event_process(pulse);
-	s_dwProfiler[PROF_EVENT] += (get_dword_time() - t);
-
-	t = get_dword_time();
-
-	// 1초마다
-	if (!(pulse % ht->passes_per_sec))
-	{
-		if (g_bAuthServer && LC_IsBrazil() && !test_server)
-			auth_brazil_log();
-
-		if (!g_bAuthServer)
-		{
-			TPlayerCountPacket pack;
-			pack.dwCount = DESC_MANAGER::instance().GetLocalUserCount();
-			db_clientdesc->DBPacket(HEADER_GD_PLAYER_COUNT, 0, &pack, sizeof(TPlayerCountPacket));
-		}
-		else
-		{
-			DESC_MANAGER::instance().ProcessExpiredLoginKey();
-		}
-
-		{
-			int count = 0;
-			auto it = g_sim.begin();
-			while (it != g_sim.end())
-			{
-				if (!it->second->IsCheck())
-				{
-					it->second->SendLogin();
-
-					if (++count > 50)
-					{
-						sys_log(0, "FLUSH_SENT");
-						break;
-					}
-				}
-
-				it++;
-			}
-
-			if (save_idx < g_vec_save.size())
-			{
-				count = MIN(100, g_vec_save.size() - save_idx);
-
-				for (int i = 0; i < count; ++i, ++save_idx)
-					db_clientdesc->DBPacket(HEADER_GD_PLAYER_SAVE, 0, &g_vec_save[save_idx], sizeof(TPlayerTable));
-
-				sys_log(0, "SAVE_FLUSH %d", count);
-			}
-		}
-	}
-
-	//
-	// 25 PPS(Pulse per second) 라고 가정할 때
-	//
-
-	// 약 1.16초마다
-	if (!(pulse % (passes_per_sec + 4)))
-		CHARACTER_MANAGER::instance().ProcessDelayedSave();
-
-	// 4초 마다
-#if defined (__FreeBSD__) && defined(__FILEMONITOR__)
-	if (!(pulse % (passes_per_sec * 5)))
-	{
-		FileMonitorFreeBSD::Instance().Update(pulse);
-	}
-#endif
-
-	// 약 5.08초마다
-	if (!(pulse % (passes_per_sec * 5 + 2)))
-	{
-		ITEM_MANAGER::instance().Update();
-		DESC_MANAGER::instance().UpdateLocalUserCount();
-
-#if defined(__MINI_GAME_RUMI__) || defined(__MINI_GAME_YUTNORI__) || defined(__MINI_GAME_CATCH_KING__)
-		CInGameEventManager::Instance().UpdateInGameEvent();
-#endif
-	}
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	if (!(pulse % (passes_per_sec * 1)))
-	{
-		CBattlePassManager::instance().CheckBattlePassTimes();
-	}
-#endif
-
-	s_dwProfiler[PROF_HEARTBEAT] += (get_dword_time() - t);
-
-	DBManager::instance().Process();
-	AccountDB::instance().Process();
-	CPVPManager::instance().Process();
-#ifdef __OFFLINE_SHOP__
-	if (!g_bAuthServer) {
-		COfflineShop::Process();
-	}
-#endif
-	if (g_bShutdown)
-	{
-		if (thecore_pulse() > g_shutdown_disconnect_pulse)
-		{
-			const DESC_MANAGER::DESC_SET& c_set_desc = DESC_MANAGER::instance().GetClientSet();
-			std::for_each(c_set_desc.begin(), c_set_desc.end(), ::SendDisconnectFunc());
-			g_shutdown_disconnect_pulse = INT_MAX;
-		}
-		else if (thecore_pulse() > g_shutdown_disconnect_force_pulse)
-		{
-			const DESC_MANAGER::DESC_SET& c_set_desc = DESC_MANAGER::instance().GetClientSet();
-			std::for_each(c_set_desc.begin(), c_set_desc.end(), ::DisconnectFunc());
-		}
-		else if (thecore_pulse() > g_shutdown_disconnect_force_pulse + PASSES_PER_SEC(5))
-		{
-			thecore_shutdown();
-		}
-	}
-}
-
-static void CleanUpForEarlyExit()
-{
-	CancelReloadSpamEvent();
-}
-
-int main(int argc, char** argv)
-{
-	//_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
-
-#ifdef DEBUG_ALLOC
-	DebugAllocator::StaticSetUp();
-#endif
-
-	/*
-	#ifndef __WIN32__
-		// <Factor> start unit tests if option is set
-		if (argc > 1)
-		{
-			if (strcmp(argv[1], "unittest") == 0)
-			{
-				::testing::InitGoogleTest(&argc, argv);
-				return RUN_ALL_TESTS();
-			}
-		}
-	#endif
-	*/
-
-	ilInit(); // DevIL Initialize
-#ifndef __WIN32__
-	mkdir("log", S_IRWXU);
-#else
-	_mkdir("log");
-#endif
-
-	SECTREE_MANAGER sectree_manager;
-	CHARACTER_MANAGER char_manager;
-	ITEM_MANAGER item_manager;
-	CShopManager shop_manager;
-	CMobManager mob_manager;
-	CMotionManager motion_manager;
-	CPartyManager party_manager;
-	CSkillManager skill_manager;
-	CPVPManager pvp_manager;
-	LZOManager lzo_manager;
-	DBManager db_manager;
-	AccountDB account_db;
-
-	LogManager log_manager;
-	CMessengerManager messenger_manager;
-	P2P_MANAGER p2p_manager;
-	CGuildManager guild_manager;
-	CGuildMarkManager mark_manager;
-	CDungeonManager dungeon_manager;
-	CRefineManager refine_manager;
-	CBanwordManager banword_manager;
-	CPrivManager priv_manager;
-	CWarMapManager war_map_manager;
-	building::CManager building_manager;
-	CTargetManager target_manager;
-	marriage::CManager marriage_manager;
-	marriage::WeddingManager wedding_manager;
-	CItemAddonManager item_addon_manager;
-	CArenaManager arena_manager;
-	COXEventManager OXEvent_manager;
-	CMonarch Monarch;
-	CHorseNameManager horsename_manager;
-	CPCBangManager pcbang_manager;
-
-	DESC_MANAGER desc_manager;
-
-	TrafficProfiler trafficProfiler;
-	CTableBySkill SkillPowerByLevel;
-	CPolymorphUtils polymorph_utils;
-	CProfiler profiler;
-	CBattleArena ba;
-	COver9RefineManager o9r;
-	SpamManager spam_mgr;
-	CThreeWayWar threeway_war;
-	CDragonLairManager dl_manager;
-#if defined(__MT_THUNDER_DUNGEON__)
-	CMTThunderDungeon mt_thunder_dungeon;
-#endif
-#if defined(__DAWNMIST_DUNGEON__)
-	CDawnMistDungeon dawnmist_dungeon;
-#endif
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	CGuildDragonLairManager guild_dragonlair_mgr;
-#endif
-#if defined(__DEFENSE_WAVE__)
-	CDefenseWaveManager dw_manager;
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	DSManager dsManager;
-#endif
-#if defined(__CUBE_RENEWAL__)
-	CCubeManager CubeManager;
-#endif
-#if defined(__INGAME_EVENT_MANAGER__)
-	CInGameEventManager ingame_event_manager;
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	CRouletteManager roulette_manager;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	CGrowthPetManager growth_pet_manager;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	CBattlePassManager battlepass_manager;
-#endif
-
-	if (!start(argc, argv))
-	{
-		CleanUpForEarlyExit();
-		return 0;
-	}
-
-#ifdef ENABLE_QUEEN_NETHIS
-	SnakeLair::CSnk SnakeLair_manager;
-#endif
-
-	quest::CQuestManager quest_manager;
-	if (!quest_manager.Initialize())
-	{
-		CleanUpForEarlyExit();
-		return 0;
-	}
-
-	messenger_manager.Initialize();
-	guild_manager.Initialize();
-	fishing::Initialize();
-	OXEvent_manager.Initialize();
-
-#if defined(__CUBE_RENEWAL__)
-	CubeManager.Initialize();
-#else
-	Cube_init();
-#endif
-
-#ifdef ENABLE_QUEEN_NETHIS
-	SnakeLair_manager.Initialize();
-#endif
-
-	Blend_Item_init();
-	ani_init();
-	PanamaLoad();
-
-	if (g_bTrafficProfileOn)
-		TrafficProfiler::instance().Initialize(TRAFFIC_PROFILE_FLUSH_CYCLE, "ProfileLog");
-
-	// if game server
-	if (!g_bAuthServer)
-	{
-	}
-
-	// Client PackageCrypt
-
-	// TODO : make it config
-	const std::string strPackageCryptInfoDir = "package/";
-	if (!desc_manager.LoadClientPackageCryptInfo(strPackageCryptInfoDir.c_str()))
-	{
-		sys_err("Failed to Load ClientPackageCryptInfo File(%s)", strPackageCryptInfoDir.c_str());
-	}
-
-#if defined (__FreeBSD__) && defined(__FILEMONITOR__)
-	PFN_FileChangeListener pPackageNotifyFunc = &(DESC_MANAGER::NotifyClientPackageFileChanged);
-	//FileMonitorFreeBSD::Instance().AddWatch(strPackageCryptInfoName, pPackageNotifyFunc);
-#endif
-
-	while (idle());
-
-	sys_log(0, "<shutdown> Starting...");
-	g_bShutdown = true;
-	g_bNoMoreClient = true;
-
-	if (g_bAuthServer)
-	{
-		int iLimit = DBManager::instance().CountQuery() / 50;
-		int i = 0;
-
-		do
-		{
-			DWORD dwCount = DBManager::instance().CountQuery();
-			sys_log(0, "Queries %u", dwCount);
-
-			if (dwCount == 0)
-				break;
-
-			usleep(500000);
-
-			if (++i >= iLimit)
-				if (dwCount == DBManager::instance().CountQuery())
-					break;
-		} while (1);
-	}
-
-#if defined(__OFFLINE_SHOP__)
-	sys_log(0, "<shutdown> Destroying COfflineShop...");
-	COfflineShop::DestroyAll();
-#endif
-
-	sys_log(0, "<shutdown> Destroying CArenaManager...");
-	arena_manager.Destroy();
-	sys_log(0, "<shutdown> Destroying COXEventManager...");
-	OXEvent_manager.Destroy();
-
-	sys_log(0, "<shutdown> Disabling signal timer...");
-	signal_timer_disable();
-
-	sys_log(0, "<shutdown> Shutting down CHARACTER_MANAGER...");
-	char_manager.GracefulShutdown();
-	sys_log(0, "<shutdown> Shutting down ITEM_MANAGER...");
-	item_manager.GracefulShutdown();
-
-	sys_log(0, "<shutdown> Flushing db_clientdesc...");
-	db_clientdesc->FlushOutput();
-	sys_log(0, "<shutdown> Flushing p2p_manager...");
-	p2p_manager.FlushOutput();
-
-	sys_log(0, "<shutdown> Destroying CShopManager...");
-	shop_manager.Destroy();
-	sys_log(0, "<shutdown> Destroying CHARACTER_MANAGER...");
-	char_manager.Destroy();
-	sys_log(0, "<shutdown> Destroying ITEM_MANAGER...");
-	item_manager.Destroy();
-	sys_log(0, "<shutdown> Destroying DESC_MANAGER...");
-	desc_manager.Destroy();
-	sys_log(0, "<shutdown> Destroying quest::CQuestManager...");
-	quest_manager.Destroy();
-	sys_log(0, "<shutdown> Destroying building::CManager...");
-	building_manager.Destroy();
-
-	sys_log(0, "<shutdown> Flushing TrafficProfiler...");
-	trafficProfiler.Flush();
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	sys_log(0, "<shutdown> Destroying CGuildDragonLairManager...");
-	guild_dragonlair_mgr.Destroy();
-#endif
-
-#if defined(__MT_THUNDER_DUNGEON__)
-	sys_log(0, "<shutdown> Destroying CMTThunderDungeon...");
-	mt_thunder_dungeon.Destroy();
-#endif
-
-	destroy();
-
-#ifdef DEBUG_ALLOC
-	DebugAllocator::StaticTearDown();
-#endif
-
-	return 1;
-}
-
-void usage()
-{
-	printf("Option list\n"
-		"-p <port>    : bind port number (port must be over 1024)\n"
-		"-l <level>   : sets log level\n"
-		"-v           : log to stdout\n"
-		"-r           : do not load regen tables\n"
-		"-t           : traffic proflie on\n");
-}
-
-int start(int argc, char** argv)
-{
-	std::string st_localeServiceName;
-
-	bool bVerbose = false;
-	char ch;
-
-	//_malloc_options = "A";
-#if defined(__FreeBSD__) && defined(DEBUG_ALLOC)
-	_malloc_message = WriteMallocMessage;
-#endif
-
-	//TCHAR tszArg[] = { "npverltI" };
-	//while ((ch = getopt(argc, argv, tszArg)) != -1)
-	while (false /*(ch = getopt(argc, argv, "npverltI")) != -1*/)
-	{
-		char* ep = NULL;
-
-		switch (ch)
-		{
-			case 'I': // IP
-				strlcpy(g_szPublicIP, argv[optind], sizeof(g_szPublicIP));
-
-				printf("IP %s\n", g_szPublicIP);
-
-				optind++;
-				optreset = 1;
-				break;
-
-#if defined(__PROXY_IP__)
-			case 'P': // Proxy
-				g_stProxyIP = argv[optind];
-
-				printf("PROXY_IP %s\n", g_stProxyIP.c_str());
-
-				optind++;
-				optreset = 1;
-				break;
-#endif
-
-			case 'p': // port
-				mother_port = static_cast<WORD>(strtol(argv[optind], &ep, 10));
-
-				if (mother_port <= 1024)
-				{
-					usage();
-					return 0;
-				}
-
-				printf("port %d\n", mother_port);
-
-				optind++;
-				optreset = 1;
-				break;
-
-			case 'l':
-			{
-				long l = strtol(argv[optind], &ep, 10);
-
-				log_set_level(l);
-
-				optind++;
-				optreset = 1;
-			}
-			break;
-
-			// LOCALE_SERVICE
-			case 'n':
-			{
-				if (optind < argc)
-				{
-					st_localeServiceName = argv[optind++];
-					optreset = 1;
-				}
-			}
-			break;
-			// END_OF_LOCALE_SERVICE
-
-			case 'v': // verbose
-				bVerbose = true;
-				break;
-
-			case 'r':
-				g_bNoRegen = true;
-				break;
-
-				// TRAFFIC_PROFILER
-			case 't':
-				g_bTrafficProfileOn = true;
-				break;
-				// END_OF_TRAFFIC_PROFILER
-		}
-	}
-
-	// LOCALE_SERVICE
-	config_init(st_localeServiceName);
-	// END_OF_LOCALE_SERVICE
-
-#ifdef __WIN32__
-	// In Windows dev mode, "verbose" option is [on] by default.
-	bVerbose = true;
-#endif
-	if (!bVerbose)
-		freopen("stdout", "a", stdout);
-
-	bool is_thecore_initialized = thecore_init(25, heartbeat);
-
-	if (!is_thecore_initialized)
-	{
-		fprintf(stderr, "Could not initialize thecore, check owner of pid, syslog\n");
-		exit(0);
-	}
-
-	if (false == CThreeWayWar::instance().LoadSetting("forkedmapindex.txt"))
-	{
-		if (false == g_bAuthServer)
-		{
-			fprintf(stderr, "Could not Load ThreeWayWar Setting file");
-			exit(0);
-		}
-	}
-
-	signal_timer_disable();
-
-	main_fdw = fdwatch_new(4096);
-
-	if ((tcp_socket = socket_tcp_bind(g_szPublicIP, mother_port)) == INVALID_SOCKET)
-	{
-		perror("socket_tcp_bind: tcp_socket");
-		return 0;
-	}
-
-#if !defined(__UDP_BLOCK__)
-	if ((udp_socket = socket_udp_bind(g_szPublicIP, mother_port)) == INVALID_SOCKET)
-	{
-		perror("socket_udp_bind: udp_socket");
-		return 0;
-	}
-#endif
-
-	// if internal ip exists, p2p socket uses internal ip, if not use public ip
-	//if ((p2p_socket = socket_tcp_bind(*g_szInternalIP ? g_szInternalIP : g_szPublicIP, p2p_port)) == INVALID_SOCKET)
-	if ((p2p_socket = socket_tcp_bind(g_szPublicIP, p2p_port)) == INVALID_SOCKET)
-	{
-		perror("socket_tcp_bind: p2p_socket");
-		return 0;
-	}
-
-	fdwatch_add_fd(main_fdw, tcp_socket, NULL, FDW_READ, false);
-#if !defined(__UDP_BLOCK__)
-	fdwatch_add_fd(main_fdw, udp_socket, NULL, FDW_READ, false);
-#endif
-	fdwatch_add_fd(main_fdw, p2p_socket, NULL, FDW_READ, false);
-
-	db_clientdesc = DESC_MANAGER::instance().CreateConnectionDesc(main_fdw, db_addr, db_port, PHASE_DBCLIENT, true);
-	if (!g_bAuthServer)
-	{
-		db_clientdesc->UpdateChannelStatus(0, true);
-	}
-
-	if (g_bAuthServer)
-	{
-		if (g_stAuthMasterIP.length() != 0)
-		{
-			fprintf(stderr, "SlaveAuth");
-			g_pkAuthMasterDesc = DESC_MANAGER::instance().CreateConnectionDesc(main_fdw, g_stAuthMasterIP.c_str(), g_wAuthMasterPort, PHASE_P2P, true);
-			P2P_MANAGER::instance().RegisterConnector(g_pkAuthMasterDesc);
-			g_pkAuthMasterDesc->SetP2P(g_stAuthMasterIP.c_str(), g_wAuthMasterPort, g_bChannel);
-
-		}
-		else
-		{
-			fprintf(stderr, "MasterAuth %d", LC_GetLocalType());
-		}
-	}
-	/* game server to teen server */
-	/*
-	else
-	{
-		extern unsigned int g_uiSpamBlockDuration;
-		extern unsigned int g_uiSpamBlockScore;
-		extern unsigned int g_uiSpamReloadCycle;
-
-		sys_log(0, "SPAM_CONFIG: duration %u score %u reload cycle %u\n",
-			g_uiSpamBlockDuration, g_uiSpamBlockScore, g_uiSpamReloadCycle);
-
-		extern void LoadSpamDB();
-		LoadSpamDB();
-	}
-	*/
-
-	signal_timer_enable(30);
-	return 1;
-}
-
-void destroy()
-{
-	sys_log(0, "<shutdown> Canceling ReloadSpamEvent...");
-	CancelReloadSpamEvent();
-
-	sys_log(0, "<shutdown> regen_free()...");
-	regen_free();
-
-	sys_log(0, "<shutdown> Closing sockets...");
-	socket_close(tcp_socket);
-#if !defined(__UDP_BLOCK__)
-	socket_close(udp_socket);
-#endif
-	socket_close(p2p_socket);
-
-#ifdef ENABLE_QUEEN_NETHIS
-	sys_log(0, "<shutdown> Destroying SnakeLair_manager.");
-#endif
-
-	sys_log(0, "<shutdown> fdwatch_delete()...");
-	fdwatch_delete(main_fdw);
-
-	sys_log(0, "<shutdown> event_destroy()...");
-	event_destroy();
-
-	sys_log(0, "<shutdown> CTextFileLoader::DestroySystem()...");
-	CTextFileLoader::DestroySystem();
-
-	sys_log(0, "<shutdown> thecore_destroy()...");
-	thecore_destroy();
-}
-
-int idle()
-{
-	static struct timeval pta = { 0, 0 };
-	static int process_time_count = 0;
-	struct timeval now;
-
-	if (pta.tv_sec == 0)
-		gettimeofday(&pta, (struct timezone*)0);
-
-	int passed_pulses;
-
-	if (!(passed_pulses = thecore_idle()))
-		return 0;
-
-	assert(passed_pulses > 0);
-
-	DWORD t;
-
-	while (passed_pulses--)
-	{
-		heartbeat(thecore_heart, ++thecore_heart->pulse);
-
-		// To reduce the possibility of abort() in checkpointing
-		thecore_tick();
-	}
-
-	t = get_dword_time();
-	CHARACTER_MANAGER::instance().Update(thecore_heart->pulse);
-	db_clientdesc->Update(t);
-	s_dwProfiler[PROF_CHR_UPDATE] += (get_dword_time() - t);
-
-	t = get_dword_time();
-	if (!io_loop(main_fdw)) return 0;
-	s_dwProfiler[PROF_IO] += (get_dword_time() - t);
-
-	log_rotate();
-
-	gettimeofday(&now, (struct timezone*)0);
-	++process_time_count;
-
-	if (now.tv_sec - pta.tv_sec > 0)
-	{
-		pt_log("[%3d] event %5d/%-5d idle %-4ld event %-4ld heartbeat %-4ld I/O %-4ld chrUpate %-4ld | WRITE: %-7d | PULSE: %d",
-			process_time_count,
-			num_events_called,
-			event_count(),
-			thecore_profiler[PF_IDLE],
-			s_dwProfiler[PROF_EVENT],
-			s_dwProfiler[PROF_HEARTBEAT],
-			s_dwProfiler[PROF_IO],
-			s_dwProfiler[PROF_CHR_UPDATE],
-			current_bytes_written,
-			thecore_pulse());
-
-		num_events_called = 0;
-		current_bytes_written = 0;
-
-		process_time_count = 0;
-		gettimeofday(&pta, (struct timezone*)0);
-
-		memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
-		memset(&s_dwProfiler[0], 0, sizeof(s_dwProfiler));
-	}
-
-#ifdef __WIN32__
-	if (_kbhit())
-	{
-		int c = _getch();
-		switch (c)
-		{
-			case 0x1b: // Esc
-				return 0; // shutdown
-				break;
-			default:
-				break;
-		}
-	}
-#endif
-
-	return 1;
-}
-
-int io_loop(LPFDWATCH fdw)
-{
-	LPDESC d;
-	int num_events, event_idx;
-
-	DESC_MANAGER::instance().DestroyClosed(); // PHASE_CLOSE 인 접속들을 끊어준다.
-	DESC_MANAGER::instance().TryConnect();
-
-	if ((num_events = fdwatch(fdw, 0)) < 0)
-		return 0;
-
-	for (event_idx = 0; event_idx < num_events; ++event_idx)
-	{
-		d = (LPDESC)fdwatch_get_client_data(fdw, event_idx);
-
-		if (!d)
-		{
-			if (FDW_READ == fdwatch_check_event(fdw, tcp_socket, event_idx))
-			{
-				DESC_MANAGER::instance().AcceptDesc(fdw, tcp_socket);
-				fdwatch_clear_event(fdw, tcp_socket, event_idx);
-			}
-			else if (FDW_READ == fdwatch_check_event(fdw, p2p_socket, event_idx))
-			{
-				DESC_MANAGER::instance().AcceptP2PDesc(fdw, p2p_socket);
-				fdwatch_clear_event(fdw, p2p_socket, event_idx);
-			}
-			/*
-			else if (FDW_READ == fdwatch_check_event(fdw, udp_socket, event_idx))
-			{
-				char buf[256];
-				struct sockaddr_in cliaddr;
-				socklen_t socklen = sizeof(cliaddr);
-
-				int iBytesRead;
-
-				if ((iBytesRead = socket_udp_read(udp_socket, buf, 256, (struct sockaddr*) & cliaddr, &socklen)) > 0)
-				{
-					static CInputUDP s_inputUDP;
-
-					s_inputUDP.SetSockAddr(cliaddr);
-
-					int iBytesProceed;
-					s_inputUDP.Process(NULL, buf, iBytesRead, iBytesProceed);
-				}
-
-				fdwatch_clear_event(fdw, udp_socket, event_idx);
-			}
-			*/
-			continue;
-		}
-
-		int iRet = fdwatch_check_event(fdw, d->GetSocket(), event_idx);
-
-		switch (iRet)
-		{
-			case FDW_READ:
-				if (db_clientdesc == d)
-				{
-					int size = d->ProcessInput();
-
-					if (size)
-						sys_log(1, "DB_BYTES_READ: %d", size);
-
-					if (size < 0)
-					{
-						d->SetPhase(PHASE_CLOSE);
-					}
-				}
-				else if (d->ProcessInput() < 0)
-				{
-					d->SetPhase(PHASE_CLOSE);
-				}
-				break;
-
-			case FDW_WRITE:
-				if (db_clientdesc == d)
-				{
-					int buf_size = buffer_size(d->GetOutputBuffer());
-					int sock_buf_size = fdwatch_get_buffer_size(fdw, d->GetSocket());
-
-					int ret = d->ProcessOutput();
-
-					if (ret < 0)
-					{
-						d->SetPhase(PHASE_CLOSE);
-					}
-
-					if (buf_size)
-						sys_log(1, "DB_BYTES_WRITE: size %d sock_buf %d ret %d", buf_size, sock_buf_size, ret);
-				}
-				else if (d->ProcessOutput() < 0)
-				{
-					d->SetPhase(PHASE_CLOSE);
-				}
-				break;
-
-			case FDW_EOF:
-			{
-				d->SetPhase(PHASE_CLOSE);
-			}
-			break;
-
-			default:
-				sys_err("fdwatch_check_event returned unknown %d", iRet);
-				d->SetPhase(PHASE_CLOSE);
-				break;
-		}
-	}
-
-	return 1;
-}
+#include "stdafx.h"
+#include "constants.h"
+#include "config.h"
+#include "event.h"
+#include "minilzo.h"
+#include "packet.h"
+#include "desc_manager.h"
+#include "item_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "mob_manager.h"
+#include "motion.h"
+#include "sectree_manager.h"
+#include "shop_manager.h"
+#include "regen.h"
+#include "text_file_loader.h"
+#include "skill.h"
+#include "pvp.h"
+#include "party.h"
+#include "questmanager.h"
+#include "profiler.h"
+#include "lzo_manager.h"
+#include "messenger_manager.h"
+#include "db.h"
+#include "log.h"
+#include "p2p.h"
+#include "guild_manager.h"
+#include "dungeon.h"
+#include "cmd.h"
+#include "refine.h"
+#include "banword.h"
+#include "priv_manager.h"
+#include "war_map.h"
+#include "building.h"
+#include "login_sim.h"
+#include "target.h"
+#include "marriage.h"
+#include "wedding.h"
+#include "fishing.h"
+#include "item_addon.h"
+#include "TrafficProfiler.h"
+#include "locale_service.h"
+#include "arena.h"
+#include "OXEvent.h"
+#include "monarch.h"
+#include "polymorph.h"
+#include "blend_item.h"
+#include "castle.h"
+#include "ani.h"
+#include "BattleArena.h"
+#include "over9refine.h"
+#include "horsename_manager.h"
+#include "pcbang.h"
+#include "MarkManager.h"
+#include "spam.h"
+#include "panama.h"
+#include "threeway_war.h"
+#include "auth_brazil.h"
+#include "DragonLair.h"
+#include "skill_power.h"
+#include "DragonSoul.h"
+#if defined(__CUBE_RENEWAL__)
+#	include "cube.h"
+#endif
+#ifndef __WIN32__
+#	include "limit_time.h"
+#endif
+
+//#define __FILEMONITOR__
+
+#if defined (__FreeBSD__) && defined(__FILEMONITOR__)
+#	include "FileMonitor_FreeBSD.h"
+#endif
+
+#if defined(__MT_THUNDER_DUNGEON__)
+#	include "mt_thunder_dungeon.h"
+#endif
+#if defined(__DAWNMIST_DUNGEON__)
+#	include "dawnmist_dungeon.h"
+#endif
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+#	include "guild_dragonlair.h"
+#endif
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+//#ifndef __WIN32__
+//#include <gtest/gtest.h>
+//#endif
+
+#ifdef USE_STACKTRACE
+#include <execinfo.h>
+#endif
+
+#include "check_server.h"
+#ifdef ENABLE_QUEEN_NETHIS
+#include "SnakeLair.h"
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+#include "OfflineShop.h"
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+#include "battlepass_manager.h"
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+
+//extern const char * _malloc_options;
+#if defined(__FreeBSD__) && defined(DEBUG_ALLOC)
+extern void (*_malloc_message)(const char* p1, const char* p2, const char* p3, const char* p4);
+// FreeBSD _malloc_message replacement
+void WriteMallocMessage(const char* p1, const char* p2, const char* p3, const char* p4)
+{
+	FILE* fp = ::fopen(DBGALLOC_LOG_FILENAME, "a");
+	if (fp == NULL)
+		return;
+
+	::fprintf(fp, "%s %s %s %s\n", p1, p2, p3, p4);
+	::fclose(fp);
+}
+#endif
+
+// TRAFFIC_PROFILER
+static const DWORD TRAFFIC_PROFILE_FLUSH_CYCLE = 3600; ///< TrafficProfiler  Flush cycle. 1챨 
+// END_OF_TRAFFIC_PROFILER
+
+// 緞 풔 
+volatile int num_events_called = 0;
+int max_bytes_written = 0;
+int current_bytes_written = 0;
+int total_bytes_written = 0;
+BYTE g_bLogLevel = 0;
+
+socket_t tcp_socket = 0;
+socket_t udp_socket = 0;
+socket_t p2p_socket = 0;
+
+LPFDWATCH main_fdw = NULL;
+
+int io_loop(LPFDWATCH fdw);
+
+int start(int argc, char** argv);
+int idle();
+void destroy();
+
+void test();
+
+enum EProfile
+{
+	PROF_EVENT,
+	PROF_CHR_UPDATE,
+	PROF_IO,
+	PROF_HEARTBEAT,
+	PROF_MAX_NUM
+};
+
+static DWORD s_dwProfiler[PROF_MAX_NUM];
+
+int g_shutdown_disconnect_pulse;
+int g_shutdown_disconnect_force_pulse;
+int g_shutdown_core_pulse;
+bool g_bShutdown = false;
+
+extern void CancelReloadSpamEvent();
+
+void ContinueOnFatalError()
+{
+#ifdef USE_STACKTRACE
+	void* array[200];
+	std::size_t size;
+	char** symbols;
+
+	size = backtrace(array, 200);
+	symbols = backtrace_symbols(array, size);
+
+	std::ostringstream oss;
+	oss << std::endl;
+	for (std::size_t i = 0; i < size; ++i)
+	{
+		oss << "  Stack> " << symbols[i] << std::endl;
+	}
+
+	free(symbols);
+
+	sys_err("FatalError on %s", oss.str().c_str());
+#else
+	sys_err("FatalError");
+#endif
+}
+
+void ShutdownOnFatalError()
+{
+	if (!g_bShutdown)
+	{
+		sys_err("ShutdownOnFatalError!!!!!!!!!!");
+		{
+			SendNotice(LC_STRING(" 치  澁臼 湄 천絳求."));
+			SendNotice(LC_STRING("10 湄  퓔,"));
+			SendNotice(LC_STRING("5 커  絿퓬 笭求."));
+		}
+
+		g_bShutdown = true;
+		g_bNoMoreClient = true;
+
+		g_shutdown_disconnect_pulse = thecore_pulse() + PASSES_PER_SEC(10);
+		g_shutdown_disconnect_force_pulse = thecore_pulse() + PASSES_PER_SEC(20);
+		g_shutdown_core_pulse = thecore_pulse() + PASSES_PER_SEC(30);
+	}
+}
+
+namespace
+{
+	struct SendDisconnectFunc
+	{
+		void operator () (LPDESC d)
+		{
+			if (d->GetCharacter())
+			{
+				if (d->GetCharacter()->GetGMLevel() == GM_PLAYER)
+					d->GetCharacter()->ChatPacket(CHAT_TYPE_COMMAND, "quit Shutdown(SendDisconnectFunc)");
+			}
+		}
+	};
+
+	struct DisconnectFunc
+	{
+		void operator () (LPDESC d)
+		{
+			if (d->GetType() == DESC_TYPE_CONNECTOR)
+				return;
+
+			if (d->IsPhase(PHASE_P2P))
+				return;
+
+			d->SetPhase(PHASE_CLOSE);
+		}
+	};
+}
+
+extern std::map<DWORD, CLoginSim*> g_sim; // first: AID
+extern std::map<DWORD, CLoginSim*> g_simByPID;
+extern std::vector<TPlayerTable> g_vec_save;
+unsigned int save_idx = 0;
+
+void heartbeat(LPHEART ht, int pulse)
+{
+	DWORD t;
+
+	t = get_dword_time();
+	num_events_called += event_process(pulse);
+	s_dwProfiler[PROF_EVENT] += (get_dword_time() - t);
+
+	t = get_dword_time();
+
+	// 1訶
+	if (!(pulse % ht->passes_per_sec))
+	{
+		if (g_bAuthServer && LC_IsBrazil() && !test_server)
+			auth_brazil_log();
+
+		if (!g_bAuthServer)
+		{
+			TPlayerCountPacket pack;
+			pack.dwCount = DESC_MANAGER::instance().GetLocalUserCount();
+			db_clientdesc->DBPacket(HEADER_GD_PLAYER_COUNT, 0, &pack, sizeof(TPlayerCountPacket));
+		}
+		else
+		{
+			DESC_MANAGER::instance().ProcessExpiredLoginKey();
+		}
+
+		{
+			int count = 0;
+			auto it = g_sim.begin();
+			while (it != g_sim.end())
+			{
+				if (!it->second->IsCheck())
+				{
+					it->second->SendLogin();
+
+					if (++count > 50)
+					{
+						sys_log(0, "FLUSH_SENT");
+						break;
+					}
+				}
+
+				it++;
+			}
+
+			if (save_idx < g_vec_save.size())
+			{
+				count = MIN(100, g_vec_save.size() - save_idx);
+
+				for (int i = 0; i < count; ++i, ++save_idx)
+					db_clientdesc->DBPacket(HEADER_GD_PLAYER_SAVE, 0, &g_vec_save[save_idx], sizeof(TPlayerTable));
+
+				sys_log(0, "SAVE_FLUSH %d", count);
+			}
+		}
+	}
+
+	//
+	// 25 PPS(Pulse per second)   
+	//
+
+	//  1.16訶
+	if (!(pulse % (passes_per_sec + 4)))
+		CHARACTER_MANAGER::instance().ProcessDelayedSave();
+
+	// 4 
+#if defined (__FreeBSD__) && defined(__FILEMONITOR__)
+	if (!(pulse % (passes_per_sec * 5)))
+	{
+		FileMonitorFreeBSD::Instance().Update(pulse);
+	}
+#endif
+
+	//  5.08訶
+	if (!(pulse % (passes_per_sec * 5 + 2)))
+	{
+		ITEM_MANAGER::instance().Update();
+		DESC_MANAGER::instance().UpdateLocalUserCount();
+
+#if defined(__MINI_GAME_RUMI__) || defined(__MINI_GAME_YUTNORI__) || defined(__MINI_GAME_CATCH_KING__)
+		CInGameEventManager::Instance().UpdateInGameEvent();
+#endif
+	}
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	if (!(pulse % (passes_per_sec * 1)))
+	{
+		CBattlePassManager::instance().CheckBattlePassTimes();
+	}
+#endif
+
+	s_dwProfiler[PROF_HEARTBEAT] += (get_dword_time() - t);
+
+	DBManager::instance().Process();
+	AccountDB::instance().Process();
+	CPVPManager::instance().Process();
+#ifdef __OFFLINE_SHOP__
+	if (!g_bAuthServer) {
+		COfflineShop::Process();
+	}
+#endif
+	if (g_bShutdown)
+	{
+		if (thecore_pulse() > g_shutdown_disconnect_pulse)
+		{
+			const DESC_MANAGER::DESC_SET& c_set_desc = DESC_MANAGER::instance().GetClientSet();
+			std::for_each(c_set_desc.begin(), c_set_desc.end(), ::SendDisconnectFunc());
+			g_shutdown_disconnect_pulse = INT_MAX;
+		}
+		else if (thecore_pulse() > g_shutdown_disconnect_force_pulse)
+		{
+			const DESC_MANAGER::DESC_SET& c_set_desc = DESC_MANAGER::instance().GetClientSet();
+			std::for_each(c_set_desc.begin(), c_set_desc.end(), ::DisconnectFunc());
+		}
+		else if (thecore_pulse() > g_shutdown_disconnect_force_pulse + PASSES_PER_SEC(5))
+		{
+			thecore_shutdown();
+		}
+	}
+}
+
+static void CleanUpForEarlyExit()
+{
+	CancelReloadSpamEvent();
+}
+
+int main(int argc, char** argv)
+{
+	//_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
+
+#ifdef DEBUG_ALLOC
+	DebugAllocator::StaticSetUp();
+#endif
+
+	/*
+	#ifndef __WIN32__
+		// <Factor> start unit tests if option is set
+		if (argc > 1)
+		{
+			if (strcmp(argv[1], "unittest") == 0)
+			{
+				::testing::InitGoogleTest(&argc, argv);
+				return RUN_ALL_TESTS();
+			}
+		}
+	#endif
+	*/
+
+	ilInit(); // DevIL Initialize
+#ifndef __WIN32__
+	mkdir("log", S_IRWXU);
+#else
+	_mkdir("log");
+#endif
+
+	SECTREE_MANAGER sectree_manager;
+	CHARACTER_MANAGER char_manager;
+	ITEM_MANAGER item_manager;
+	CShopManager shop_manager;
+	CMobManager mob_manager;
+	CMotionManager motion_manager;
+	CPartyManager party_manager;
+	CSkillManager skill_manager;
+	CPVPManager pvp_manager;
+	LZOManager lzo_manager;
+	DBManager db_manager;
+	AccountDB account_db;
+
+	LogManager log_manager;
+	CMessengerManager messenger_manager;
+	P2P_MANAGER p2p_manager;
+	CGuildManager guild_manager;
+	CGuildMarkManager mark_manager;
+	CDungeonManager dungeon_manager;
+	CRefineManager refine_manager;
+	CBanwordManager banword_manager;
+	CPrivManager priv_manager;
+	CWarMapManager war_map_manager;
+	building::CManager building_manager;
+	CTargetManager target_manager;
+	marriage::CManager marriage_manager;
+	marriage::WeddingManager wedding_manager;
+	CItemAddonManager item_addon_manager;
+	CArenaManager arena_manager;
+	COXEventManager OXEvent_manager;
+	CMonarch Monarch;
+	CHorseNameManager horsename_manager;
+	CPCBangManager pcbang_manager;
+
+	DESC_MANAGER desc_manager;
+
+	TrafficProfiler trafficProfiler;
+	CTableBySkill SkillPowerByLevel;
+	CPolymorphUtils polymorph_utils;
+	CProfiler profiler;
+	CBattleArena ba;
+	COver9RefineManager o9r;
+	SpamManager spam_mgr;
+	CThreeWayWar threeway_war;
+	CDragonLairManager dl_manager;
+#if defined(__MT_THUNDER_DUNGEON__)
+	CMTThunderDungeon mt_thunder_dungeon;
+#endif
+#if defined(__DAWNMIST_DUNGEON__)
+	CDawnMistDungeon dawnmist_dungeon;
+#endif
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	CGuildDragonLairManager guild_dragonlair_mgr;
+#endif
+#if defined(__DEFENSE_WAVE__)
+	CDefenseWaveManager dw_manager;
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	DSManager dsManager;
+#endif
+#if defined(__CUBE_RENEWAL__)
+	CCubeManager CubeManager;
+#endif
+#if defined(__INGAME_EVENT_MANAGER__)
+	CInGameEventManager ingame_event_manager;
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	CRouletteManager roulette_manager;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	CGrowthPetManager growth_pet_manager;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	CBattlePassManager battlepass_manager;
+#endif
+
+	if (!start(argc, argv))
+	{
+		CleanUpForEarlyExit();
+		return 0;
+	}
+
+#ifdef ENABLE_QUEEN_NETHIS
+	SnakeLair::CSnk SnakeLair_manager;
+#endif
+
+	quest::CQuestManager quest_manager;
+	if (!quest_manager.Initialize())
+	{
+		CleanUpForEarlyExit();
+		return 0;
+	}
+
+	messenger_manager.Initialize();
+	guild_manager.Initialize();
+	fishing::Initialize();
+	OXEvent_manager.Initialize();
+
+#if defined(__CUBE_RENEWAL__)
+	CubeManager.Initialize();
+#else
+	Cube_init();
+#endif
+
+#ifdef ENABLE_QUEEN_NETHIS
+	SnakeLair_manager.Initialize();
+#endif
+
+	Blend_Item_init();
+	ani_init();
+	PanamaLoad();
+
+	if (g_bTrafficProfileOn)
+		TrafficProfiler::instance().Initialize(TRAFFIC_PROFILE_FLUSH_CYCLE, "ProfileLog");
+
+	// if game server
+	if (!g_bAuthServer)
+	{
+	}
+
+	// Client PackageCrypt
+
+	// TODO : make it config
+	const std::string strPackageCryptInfoDir = "package/";
+	if (!desc_manager.LoadClientPackageCryptInfo(strPackageCryptInfoDir.c_str()))
+	{
+		sys_err("Failed to Load ClientPackageCryptInfo File(%s)", strPackageCryptInfoDir.c_str());
+	}
+
+#if defined (__FreeBSD__) && defined(__FILEMONITOR__)
+	PFN_FileChangeListener pPackageNotifyFunc = &(DESC_MANAGER::NotifyClientPackageFileChanged);
+	//FileMonitorFreeBSD::Instance().AddWatch(strPackageCryptInfoName, pPackageNotifyFunc);
+#endif
+
+	while (idle());
+
+	sys_log(0, "<shutdown> Starting...");
+	g_bShutdown = true;
+	g_bNoMoreClient = true;
+
+	if (g_bAuthServer)
+	{
+		int iLimit = DBManager::instance().CountQuery() / 50;
+		int i = 0;
+
+		do
+		{
+			DWORD dwCount = DBManager::instance().CountQuery();
+			sys_log(0, "Queries %u", dwCount);
+
+			if (dwCount == 0)
+				break;
+
+			usleep(500000);
+
+			if (++i >= iLimit)
+				if (dwCount == DBManager::instance().CountQuery())
+					break;
+		} while (1);
+	}
+
+#if defined(__OFFLINE_SHOP__)
+	sys_log(0, "<shutdown> Destroying COfflineShop...");
+	COfflineShop::DestroyAll();
+#endif
+
+	sys_log(0, "<shutdown> Destroying CArenaManager...");
+	arena_manager.Destroy();
+	sys_log(0, "<shutdown> Destroying COXEventManager...");
+	OXEvent_manager.Destroy();
+
+	sys_log(0, "<shutdown> Disabling signal timer...");
+	signal_timer_disable();
+
+	sys_log(0, "<shutdown> Shutting down CHARACTER_MANAGER...");
+	char_manager.GracefulShutdown();
+	sys_log(0, "<shutdown> Shutting down ITEM_MANAGER...");
+	item_manager.GracefulShutdown();
+
+	sys_log(0, "<shutdown> Flushing db_clientdesc...");
+	db_clientdesc->FlushOutput();
+	sys_log(0, "<shutdown> Flushing p2p_manager...");
+	p2p_manager.FlushOutput();
+
+	sys_log(0, "<shutdown> Destroying CShopManager...");
+	shop_manager.Destroy();
+	sys_log(0, "<shutdown> Destroying CHARACTER_MANAGER...");
+	char_manager.Destroy();
+	sys_log(0, "<shutdown> Destroying ITEM_MANAGER...");
+	item_manager.Destroy();
+	sys_log(0, "<shutdown> Destroying DESC_MANAGER...");
+	desc_manager.Destroy();
+	sys_log(0, "<shutdown> Destroying quest::CQuestManager...");
+	quest_manager.Destroy();
+	sys_log(0, "<shutdown> Destroying building::CManager...");
+	building_manager.Destroy();
+
+	sys_log(0, "<shutdown> Flushing TrafficProfiler...");
+	trafficProfiler.Flush();
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	sys_log(0, "<shutdown> Destroying CGuildDragonLairManager...");
+	guild_dragonlair_mgr.Destroy();
+#endif
+
+#if defined(__MT_THUNDER_DUNGEON__)
+	sys_log(0, "<shutdown> Destroying CMTThunderDungeon...");
+	mt_thunder_dungeon.Destroy();
+#endif
+
+	destroy();
+
+#ifdef DEBUG_ALLOC
+	DebugAllocator::StaticTearDown();
+#endif
+
+	return 1;
+}
+
+void usage()
+{
+	printf("Option list\n"
+		"-p <port>    : bind port number (port must be over 1024)\n"
+		"-l <level>   : sets log level\n"
+		"-v           : log to stdout\n"
+		"-r           : do not load regen tables\n"
+		"-t           : traffic proflie on\n");
+}
+
+int start(int argc, char** argv)
+{
+	std::string st_localeServiceName;
+
+	bool bVerbose = false;
+	char ch;
+
+	//_malloc_options = "A";
+#if defined(__FreeBSD__) && defined(DEBUG_ALLOC)
+	_malloc_message = WriteMallocMessage;
+#endif
+
+	//TCHAR tszArg[] = { "npverltI" };
+	//while ((ch = getopt(argc, argv, tszArg)) != -1)
+	while (false /*(ch = getopt(argc, argv, "npverltI")) != -1*/)
+	{
+		char* ep = NULL;
+
+		switch (ch)
+		{
+			case 'I': // IP
+				strlcpy(g_szPublicIP, argv[optind], sizeof(g_szPublicIP));
+
+				printf("IP %s\n", g_szPublicIP);
+
+				optind++;
+				optreset = 1;
+				break;
+
+#if defined(__PROXY_IP__)
+			case 'P': // Proxy
+				g_stProxyIP = argv[optind];
+
+				printf("PROXY_IP %s\n", g_stProxyIP.c_str());
+
+				optind++;
+				optreset = 1;
+				break;
+#endif
+
+			case 'p': // port
+				mother_port = static_cast<WORD>(strtol(argv[optind], &ep, 10));
+
+				if (mother_port <= 1024)
+				{
+					usage();
+					return 0;
+				}
+
+				printf("port %d\n", mother_port);
+
+				optind++;
+				optreset = 1;
+				break;
+
+			case 'l':
+			{
+				long l = strtol(argv[optind], &ep, 10);
+
+				log_set_level(l);
+
+				optind++;
+				optreset = 1;
+			}
+			break;
+
+			// LOCALE_SERVICE
+			case 'n':
+			{
+				if (optind < argc)
+				{
+					st_localeServiceName = argv[optind++];
+					optreset = 1;
+				}
+			}
+			break;
+			// END_OF_LOCALE_SERVICE
+
+			case 'v': // verbose
+				bVerbose = true;
+				break;
+
+			case 'r':
+				g_bNoRegen = true;
+				break;
+
+				// TRAFFIC_PROFILER
+			case 't':
+				g_bTrafficProfileOn = true;
+				break;
+				// END_OF_TRAFFIC_PROFILER
+		}
+	}
+
+	// LOCALE_SERVICE
+	config_init(st_localeServiceName);
+	// END_OF_LOCALE_SERVICE
+
+#ifdef __WIN32__
+	// In Windows dev mode, "verbose" option is [on] by default.
+	bVerbose = true;
+#endif
+	if (!bVerbose)
+		freopen("stdout", "a", stdout);
+
+	bool is_thecore_initialized = thecore_init(25, heartbeat);
+
+	if (!is_thecore_initialized)
+	{
+		fprintf(stderr, "Could not initialize thecore, check owner of pid, syslog\n");
+		exit(0);
+	}
+
+	if (false == CThreeWayWar::instance().LoadSetting("forkedmapindex.txt"))
+	{
+		if (false == g_bAuthServer)
+		{
+			fprintf(stderr, "Could not Load ThreeWayWar Setting file");
+			exit(0);
+		}
+	}
+
+	signal_timer_disable();
+
+	main_fdw = fdwatch_new(4096);
+
+	if ((tcp_socket = socket_tcp_bind(g_szPublicIP, mother_port)) == INVALID_SOCKET)
+	{
+		perror("socket_tcp_bind: tcp_socket");
+		return 0;
+	}
+
+#if !defined(__UDP_BLOCK__)
+	if ((udp_socket = socket_udp_bind(g_szPublicIP, mother_port)) == INVALID_SOCKET)
+	{
+		perror("socket_udp_bind: udp_socket");
+		return 0;
+	}
+#endif
+
+	// if internal ip exists, p2p socket uses internal ip, if not use public ip
+	//if ((p2p_socket = socket_tcp_bind(*g_szInternalIP ? g_szInternalIP : g_szPublicIP, p2p_port)) == INVALID_SOCKET)
+	if ((p2p_socket = socket_tcp_bind(g_szPublicIP, p2p_port)) == INVALID_SOCKET)
+	{
+		perror("socket_tcp_bind: p2p_socket");
+		return 0;
+	}
+
+	fdwatch_add_fd(main_fdw, tcp_socket, NULL, FDW_READ, false);
+#if !defined(__UDP_BLOCK__)
+	fdwatch_add_fd(main_fdw, udp_socket, NULL, FDW_READ, false);
+#endif
+	fdwatch_add_fd(main_fdw, p2p_socket, NULL, FDW_READ, false);
+
+	db_clientdesc = DESC_MANAGER::instance().CreateConnectionDesc(main_fdw, db_addr, db_port, PHASE_DBCLIENT, true);
+	if (!g_bAuthServer)
+	{
+		db_clientdesc->UpdateChannelStatus(0, true);
+	}
+
+	if (g_bAuthServer)
+	{
+		if (g_stAuthMasterIP.length() != 0)
+		{
+			fprintf(stderr, "SlaveAuth");
+			g_pkAuthMasterDesc = DESC_MANAGER::instance().CreateConnectionDesc(main_fdw, g_stAuthMasterIP.c_str(), g_wAuthMasterPort, PHASE_P2P, true);
+			P2P_MANAGER::instance().RegisterConnector(g_pkAuthMasterDesc);
+			g_pkAuthMasterDesc->SetP2P(g_stAuthMasterIP.c_str(), g_wAuthMasterPort, g_bChannel);
+
+		}
+		else
+		{
+			fprintf(stderr, "MasterAuth %d", LC_GetLocalType());
+		}
+	}
+	/* game server to teen server */
+	/*
+	else
+	{
+		extern unsigned int g_uiSpamBlockDuration;
+		extern unsigned int g_uiSpamBlockScore;
+		extern unsigned int g_uiSpamReloadCycle;
+
+		sys_log(0, "SPAM_CONFIG: duration %u score %u reload cycle %u\n",
+			g_uiSpamBlockDuration, g_uiSpamBlockScore, g_uiSpamReloadCycle);
+
+		extern void LoadSpamDB();
+		LoadSpamDB();
+	}
+	*/
+
+	signal_timer_enable(30);
+	return 1;
+}
+
+void destroy()
+{
+	sys_log(0, "<shutdown> Canceling ReloadSpamEvent...");
+	CancelReloadSpamEvent();
+
+	sys_log(0, "<shutdown> regen_free()...");
+	regen_free();
+
+	sys_log(0, "<shutdown> Closing sockets...");
+	socket_close(tcp_socket);
+#if !defined(__UDP_BLOCK__)
+	socket_close(udp_socket);
+#endif
+	socket_close(p2p_socket);
+
+#ifdef ENABLE_QUEEN_NETHIS
+	sys_log(0, "<shutdown> Destroying SnakeLair_manager.");
+#endif
+
+	sys_log(0, "<shutdown> fdwatch_delete()...");
+	fdwatch_delete(main_fdw);
+
+	sys_log(0, "<shutdown> event_destroy()...");
+	event_destroy();
+
+	sys_log(0, "<shutdown> CTextFileLoader::DestroySystem()...");
+	CTextFileLoader::DestroySystem();
+
+	sys_log(0, "<shutdown> PanamaDestroy()...");
+	PanamaDestroy();
+
+	sys_log(0, "<shutdown> thecore_destroy()...");
+	thecore_destroy();
+}
+
+int idle()
+{
+	static struct timeval pta = { 0, 0 };
+	static int process_time_count = 0;
+	struct timeval now;
+
+	if (pta.tv_sec == 0)
+		gettimeofday(&pta, (struct timezone*)0);
+
+	int passed_pulses;
+
+	if (!(passed_pulses = thecore_idle()))
+		return 0;
+
+	assert(passed_pulses > 0);
+
+	DWORD t;
+
+	while (passed_pulses--)
+	{
+		heartbeat(thecore_heart, ++thecore_heart->pulse);
+
+		// To reduce the possibility of abort() in checkpointing
+		thecore_tick();
+	}
+
+	t = get_dword_time();
+	CHARACTER_MANAGER::instance().Update(thecore_heart->pulse);
+	db_clientdesc->Update(t);
+	s_dwProfiler[PROF_CHR_UPDATE] += (get_dword_time() - t);
+
+	t = get_dword_time();
+	if (!io_loop(main_fdw)) return 0;
+	s_dwProfiler[PROF_IO] += (get_dword_time() - t);
+
+	log_rotate();
+
+	gettimeofday(&now, (struct timezone*)0);
+	++process_time_count;
+
+	if (now.tv_sec - pta.tv_sec > 0)
+	{
+		pt_log("[%3d] event %5d/%-5d idle %-4ld event %-4ld heartbeat %-4ld I/O %-4ld chrUpate %-4ld | WRITE: %-7d | PULSE: %d",
+			process_time_count,
+			num_events_called,
+			event_count(),
+			thecore_profiler[PF_IDLE],
+			s_dwProfiler[PROF_EVENT],
+			s_dwProfiler[PROF_HEARTBEAT],
+			s_dwProfiler[PROF_IO],
+			s_dwProfiler[PROF_CHR_UPDATE],
+			current_bytes_written,
+			thecore_pulse());
+
+		num_events_called = 0;
+		current_bytes_written = 0;
+
+		process_time_count = 0;
+		gettimeofday(&pta, (struct timezone*)0);
+
+		memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
+		memset(&s_dwProfiler[0], 0, sizeof(s_dwProfiler));
+	}
+
+#ifdef __WIN32__
+	if (_kbhit())
+	{
+		int c = _getch();
+		switch (c)
+		{
+			case 0x1b: // Esc
+				return 0; // shutdown
+				break;
+			default:
+				break;
+		}
+	}
+#endif
+
+	return 1;
+}
+
+int io_loop(LPFDWATCH fdw)
+{
+	LPDESC d;
+	int num_events, event_idx;
+
+	DESC_MANAGER::instance().DestroyClosed(); // PHASE_CLOSE  撻 娩.
+	DESC_MANAGER::instance().TryConnect();
+
+	if ((num_events = fdwatch(fdw, 0)) < 0)
+		return 0;
+
+	for (event_idx = 0; event_idx < num_events; ++event_idx)
+	{
+		d = (LPDESC)fdwatch_get_client_data(fdw, event_idx);
+
+		if (!d)
+		{
+			if (FDW_READ == fdwatch_check_event(fdw, tcp_socket, event_idx))
+			{
+				DESC_MANAGER::instance().AcceptDesc(fdw, tcp_socket);
+				fdwatch_clear_event(fdw, tcp_socket, event_idx);
+			}
+			else if (FDW_READ == fdwatch_check_event(fdw, p2p_socket, event_idx))
+			{
+				DESC_MANAGER::instance().AcceptP2PDesc(fdw, p2p_socket);
+				fdwatch_clear_event(fdw, p2p_socket, event_idx);
+			}
+			/*
+			else if (FDW_READ == fdwatch_check_event(fdw, udp_socket, event_idx))
+			{
+				char buf[256];
+				struct sockaddr_in cliaddr;
+				socklen_t socklen = sizeof(cliaddr);
+
+				int iBytesRead;
+
+				if ((iBytesRead = socket_udp_read(udp_socket, buf, 256, (struct sockaddr*) & cliaddr, &socklen)) > 0)
+				{
+					static CInputUDP s_inputUDP;
+
+					s_inputUDP.SetSockAddr(cliaddr);
+
+					int iBytesProceed;
+					s_inputUDP.Process(NULL, buf, iBytesRead, iBytesProceed);
+				}
+
+				fdwatch_clear_event(fdw, udp_socket, event_idx);
+			}
+			*/
+			continue;
+		}
+
+		int iRet = fdwatch_check_event(fdw, d->GetSocket(), event_idx);
+
+		switch (iRet)
+		{
+			case FDW_READ:
+				if (db_clientdesc == d)
+				{
+					int size = d->ProcessInput();
+
+					if (size)
+						sys_log(1, "DB_BYTES_READ: %d", size);
+
+					if (size < 0)
+					{
+						d->SetPhase(PHASE_CLOSE);
+					}
+				}
+				else if (d->ProcessInput() < 0)
+				{
+					d->SetPhase(PHASE_CLOSE);
+				}
+				break;
+
+			case FDW_WRITE:
+				if (db_clientdesc == d)
+				{
+					int buf_size = buffer_size(d->GetOutputBuffer());
+					int sock_buf_size = fdwatch_get_buffer_size(fdw, d->GetSocket());
+
+					int ret = d->ProcessOutput();
+
+					if (ret < 0)
+					{
+						d->SetPhase(PHASE_CLOSE);
+					}
+
+					if (buf_size)
+						sys_log(1, "DB_BYTES_WRITE: size %d sock_buf %d ret %d", buf_size, sock_buf_size, ret);
+				}
+				else if (d->ProcessOutput() < 0)
+				{
+					d->SetPhase(PHASE_CLOSE);
+				}
+				break;
+
+			case FDW_EOF:
+			{
+				d->SetPhase(PHASE_CLOSE);
+			}
+			break;
+
+			default:
+				sys_err("fdwatch_check_event returned unknown %d", iRet);
+				d->SetPhase(PHASE_CLOSE);
+				break;
+		}
+	}
+
+	return 1;
+}
diff --git a/server/metin2/Source/Server/game/src/messenger_manager.cpp b/server/metin2/Source/Server/game/src/messenger_manager.cpp
index a6dda00..22d1de6 100644
--- a/server/metin2/Source/Server/game/src/messenger_manager.cpp
+++ b/server/metin2/Source/Server/game/src/messenger_manager.cpp
@@ -1,959 +1,953 @@
-/**
-* Filename: messenger_manager.cpp
-* Author: Owsap
-**/
-
-#include "stdafx.h"
-#include "messenger_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "desc_client.h"
-#include "p2p.h"
-#include "questmanager.h"
-#include "crc32.h"
-#include "config.h"
-#include "gm.h"
-
-void CMessengerManager::Initialize()
-{
-}
-
-void CMessengerManager::Destroy()
-{
-}
-
-void CMessengerManager::P2PLogin(const std::string& c_strAccount)
-{
-	Login(c_strAccount);
-}
-
-void CMessengerManager::P2PLogout(const std::string& c_strAccount)
-{
-	Logout(c_strAccount);
-}
-
-void CMessengerManager::Login(const std::string& c_strAccount)
-{
-	if (m_set_strOnlineAccount.find(c_strAccount) != m_set_strOnlineAccount.end())
-		return;
-
-	DBManager::instance().FuncQuery(std::bind(&CMessengerManager::__LoadList, this, std::placeholders::_1),
-#if defined(__MESSENGER_DETAILS__)
-		"SELECT "
-		"`messenger_list`.`account`, UNIX_TIMESTAMP(`player`.`last_play`) AS `last_play`"
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		", `account`.`country` AS `country`"
-#endif
-		", `messenger_list`.`companion`, UNIX_TIMESTAMP(`companion_player`.`last_play`) AS `companion_last_play`"
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		", `companion_account`.`country` AS `companion_country`"
-#endif
-		" FROM `player`.`messenger_list`"
-		" LEFT JOIN (SELECT `account_id`, `name`, `last_play` FROM `player`) AS `player` ON `player`.`name` = `messenger_list`.`account`"
-		" LEFT JOIN (SELECT `id`, `country` FROM `account`.`account`) AS `account` ON `account`.`id` = `player`.`account_id`"
-		" LEFT JOIN (SELECT `account_id`, `name`, `last_play` FROM `player`) AS `companion_player` ON `companion_player`.`name` = `messenger_list`.`companion`"
-		" LEFT JOIN (SELECT `id`, `country` FROM `account`.`account`) AS `companion_account` ON `companion_account`.`id` = `companion_player`.`account_id`"
-		" WHERE `messenger_list`.`account` = '%s'", c_strAccount.c_str());
-#else
-		"SELECT `account`, `companion` FROM `messenger_list` WHERE `account` = '%s'", c_strAccount.c_str());
-#endif
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	DBManager::instance().FuncQuery(std::bind(&CMessengerManager::__LoadBlockList, this, std::placeholders::_1),
-		"SELECT `account`, `companion` FROM `messenger_block_list` WHERE `account` = '%s'", c_strAccount.c_str());
-#endif
-
-#if defined(__MESSENGER_GM__)
-	DBManager::instance().FuncQuery(std::bind(&CMessengerManager::__LoadGMList, this, std::placeholders::_1),
-#if defined(__MESSENGER_DETAILS__)
-		"SELECT '%s', `gmlist`.`mName`, UNIX_TIMESTAMP(`player`.`last_play`) AS `last_play`"
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		", `account`.`country` AS `country`"
-#endif
-		" FROM `common`.`gmlist`"
-		" LEFT JOIN (SELECT `account_id`, `name`, `last_play` FROM `player`) AS `player` ON `player`.`name` = `gmlist`.`mName`"
-		" LEFT JOIN (SELECT `id`, `country` FROM `account`.`account`) AS `account` ON `account`.`id` = `player`.`account_id`"
-		" WHERE `gmlist`.`mAuthority` != 'PLAYER'", c_strAccount.c_str());
-#else
-		"SELECT '%s', `gmlist`.`mName` FROM `common`.`gmlist` WHERE `gmlist`.`mAuthority` != 'PLAYER'", c_strAccount.c_str());
-#endif
-#endif
-
-	m_set_strOnlineAccount.emplace(c_strAccount);
-}
-
-void CMessengerManager::Logout(const std::string& c_strAccount)
-{
-	if (m_set_strOnlineAccount.find(c_strAccount) == m_set_strOnlineAccount.end())
-		return;
-
-	m_set_strOnlineAccount.erase(c_strAccount);
-
-#if defined(__MESSENGER_DETAILS__)
-	for (const RelationData& it : m_map_strInverseRelation[c_strAccount])
-		__SendLogout(it.first, c_strAccount);
-
-	for (auto& [key, vec] : m_map_strInverseRelation)
-	{
-		vec.erase(std::remove_if(vec.begin(), vec.end(),
-			[&](const RelationData& c_rData) { return c_rData.first == c_strAccount; }),
-			vec.end());
-	}
-#else
-	for (const std::string& it : m_map_strInverseRelation[c_strAccount])
-		__SendLogout(it, c_strAccount);
-
-	RelationMap::iterator it = m_map_strInverseRelation.begin();
-	while (it != m_map_strInverseRelation.end())
-	{
-		it->second.erase(c_strAccount);
-		++it;
-	}
-#endif
-	m_map_strRelation.erase(c_strAccount);
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	for (const std::string& it : m_map_strInverseBlockRelation[c_strAccount])
-		__SendBlockLogout(it, c_strAccount);
-
-	BlockRelationMap::iterator it = m_map_strInverseBlockRelation.begin();
-	while (it != m_map_strInverseBlockRelation.end())
-	{
-		it->second.erase(c_strAccount);
-		++it;
-	}
-
-	m_map_strBlockRelation.erase(c_strAccount);
-#endif
-
-#if defined(__MESSENGER_GM__)
-#if defined(__MESSENGER_DETAILS__)
-	for (const RelationData& it : m_map_strGMInverseRelation[c_strAccount])
-		__SendGMLogout(it.first, c_strAccount);
-
-	for (auto& [key, vec] : m_map_strGMInverseRelation)
-	{
-		vec.erase(std::remove_if(vec.begin(), vec.end(),
-			[&](const RelationData& c_rData) { return c_rData.first == c_strAccount; }),
-			vec.end());
-}
-#else
-	for (const std::string& it : m_map_strGMInverseRelation[c_strAccount])
-		__SendGMLogout(it, c_strAccount);
-
-	RelationMap::iterator it = m_map_strGMInverseRelation.begin();
-	while (it != m_map_strGMInverseRelation.end())
-	{
-		it->second.erase(c_strAccount);
-		++it;
-	}
-#endif
-	m_map_strGMRelation.erase(c_strAccount);
-#endif
-}
-
-void CMessengerManager::RequestToAdd(const LPCHARACTER c_lpChar, const LPCHARACTER c_lpCharTarget)
-{
-	if (c_lpChar == nullptr || c_lpCharTarget == nullptr)
-		return;
-
-	if (c_lpChar->IsPC() == false || c_lpCharTarget->IsPC() == false)
-		return;
-
-	if (quest::CQuestManager::instance().GetPCForce(c_lpChar->GetPlayerID())->IsRunning() == true)
-	{
-		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 친구 추가를 받을 수 없는 상태입니다."));
-		return;
-	}
-
-	if (quest::CQuestManager::instance().GetPCForce(c_lpCharTarget->GetPlayerID())->IsRunning() == true)
-		return;
-
-	DWORD dwCRC32CharName = GetCRC32(c_lpChar->GetName(), strlen(c_lpChar->GetName()));
-	DWORD dwCRC32CharTargetName = GetCRC32(c_lpCharTarget->GetName(), strlen(c_lpCharTarget->GetName()));
-
-	char szBuf[64] = {};
-	snprintf(szBuf, sizeof(szBuf), "%u:%u", dwCRC32CharName, dwCRC32CharTargetName);
-	DWORD dwComplex = GetCRC32(szBuf, strlen(szBuf));
-
-	m_set_dwRequestToAdd.emplace(dwComplex);
-
-	c_lpCharTarget->ChatPacket(CHAT_TYPE_COMMAND, "messenger_auth %s", c_lpChar->GetName());
-}
-
-void CMessengerManager::AuthToAdd(const std::string& c_strAccount, const std::string& c_strCompanion, bool bDeny)
-{
-	DWORD dwCRC32CharTargetName = GetCRC32(c_strCompanion.c_str(), c_strCompanion.length());
-	DWORD dwCRC32CharName = GetCRC32(c_strAccount.c_str(), c_strAccount.length());
-
-	char szBuf[64] = {};
-	snprintf(szBuf, sizeof(szBuf), "%u:%u", dwCRC32CharTargetName, dwCRC32CharName);
-	DWORD dwComplex = GetCRC32(szBuf, strlen(szBuf));
-
-	if (m_set_dwRequestToAdd.find(dwComplex) == m_set_dwRequestToAdd.end())
-	{
-		sys_log(0, "MessengerManager::AuthToAdd : request not exist %s -> %s", c_strCompanion.c_str(), c_strAccount.c_str());
-		return;
-	}
-
-	m_set_dwRequestToAdd.erase(dwComplex);
-
-	if (!bDeny)
-	{
-		AddToList(c_strCompanion, c_strAccount);
-		AddToList(c_strAccount, c_strCompanion);
-	}
-}
-
-void CMessengerManager::__AddToList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-#if !defined(__MESSENGER_DETAILS__)
-	m_map_strRelation[c_strAccount].emplace(c_strCompanion);
-	m_map_strInverseRelation[c_strCompanion].emplace(c_strAccount);
-#endif
-
-	const LPCHARACTER pkChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC pkDesc = pkChar ? pkChar->GetDesc() : nullptr;
-	if (pkChar && pkDesc)
-		pkChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<메신져> %s 님을 친구로 추가하였습니다.", c_strCompanion.c_str()));
-
-	const LPCHARACTER pkCharCompanion = CHARACTER_MANAGER::instance().FindPC(c_strCompanion.c_str());
-
-#if defined(__MESSENGER_DETAILS__)
-	CompanionData sAccountRowData{};
-	sAccountRowData.dwLastPlayTime = pkChar ? pkChar->GetLastPlay() : 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	strlcpy(sAccountRowData.szCountry, pkChar ? pkChar->GetCountry() : "", sizeof(sAccountRowData.szCountry));
-#endif
-
-	CompanionData sCompanionData{};
-	sCompanionData.dwLastPlayTime = pkCharCompanion ? pkCharCompanion->GetLastPlay() : 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	strlcpy(sCompanionData.szCountry, pkCharCompanion ? pkCharCompanion->GetCountry() : "", sizeof(sCompanionData.szCountry));
-#endif
-
-	m_map_strRelation[c_strAccount].emplace_back(c_strCompanion, sCompanionData);
-	m_map_strInverseRelation[c_strCompanion].emplace_back(c_strAccount, sCompanionData);
-#endif
-
-	if (pkCharCompanion)
-		__SendLogin(c_strAccount, c_strCompanion);
-	else
-		__SendLogout(c_strAccount, c_strCompanion);
-}
-
-void CMessengerManager::AddToList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (c_strCompanion.empty())
-		return;
-
-#if defined(__MESSENGER_DETAILS__)
-	if (std::any_of(m_map_strRelation[c_strAccount].begin(), m_map_strRelation[c_strAccount].end(),
-		[&](const RelationData& elem) { return elem.first == c_strCompanion; }))
-		return;
-#else
-	if (m_map_strRelation[c_strAccount].find(c_strCompanion) != m_map_strRelation[c_strAccount].end())
-		return;
-#endif
-
-	sys_log(0, "Messenger Add %s %s", c_strAccount.c_str(), c_strCompanion.c_str());
-	DBManager::instance().Query("INSERT INTO messenger_list%s VALUES ('%s', '%s')",
-		get_table_postfix(), c_strAccount.c_str(), c_strCompanion.c_str());
-
-	__AddToList(c_strAccount, c_strCompanion);
-
-	TPacketGGMessenger P2PPacket = {};
-	P2PPacket.bHeader = HEADER_GG_MESSENGER_ADD;
-	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
-	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
-	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
-}
-
-void CMessengerManager::__RemoveFromList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-#if defined(__MESSENGER_DETAILS__)
-	Relations& vRelation = m_map_strRelation[c_strAccount];
-	m_map_strRelation[c_strAccount].erase(std::remove_if(vRelation.begin(), vRelation.end(),
-		[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; }),
-		vRelation.end());
-	
-	Relations& vInverseRelation = m_map_strInverseRelation[c_strCompanion];
-	m_map_strInverseRelation[c_strCompanion].erase(std::remove_if(vInverseRelation.begin(), vInverseRelation.end(),
-		[&](const RelationData& data) { return data.first == c_strAccount; }),
-		vInverseRelation.end());
-#else
-	m_map_strRelation[c_strAccount].erase(c_strCompanion);
-	m_map_strInverseRelation[c_strCompanion].erase(c_strAccount);
-#endif
-
-	const LPCHARACTER c_lpChar= CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc)
-		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<메신져> %s 님을 메신저에서 삭제하였습니다.", c_strCompanion.c_str()));
-}
-
-void CMessengerManager::RemoveFromList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (c_strCompanion.empty())
-		return;
-
-	if (!IsInList(c_strAccount, c_strCompanion))
-	{
-		const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-		const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-		if (c_lpDesc)
-			c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 님은 접속되 있지 않습니다.", c_strCompanion.c_str()));
-
-		return;
-	}
-
-	char szCompanion[CHARACTER_NAME_MAX_LEN + 1] = {};
-	DBManager::instance().EscapeString(szCompanion, sizeof(szCompanion), c_strCompanion.c_str(), c_strCompanion.length());
-	DBManager::instance().Query("DELETE FROM messenger_list%s WHERE `account` = '%s' AND `companion` = '%s'",
-		get_table_postfix(), c_strAccount.c_str(), szCompanion);
-
-	__RemoveFromList(c_strAccount, c_strCompanion);
-
-	sys_log(1, "Messenger Remove %s %s", c_strAccount.c_str(), c_strCompanion.c_str());
-
-	TPacketGGMessenger P2PPacket = {};
-	P2PPacket.bHeader = HEADER_GG_MESSENGER_REMOVE;
-	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
-	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
-	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
-}
-
-void CMessengerManager::RemoveAllList(const std::string& c_strAccount)
-{
-	/* SQL Data 삭제 */
-	DBManager::instance().Query("DELETE FROM messenger_list%s WHERE account = '%s' OR companion = '%s'",
-		get_table_postfix(), c_strAccount.c_str(), c_strAccount.c_str());
-
-	/* 내가 가지고있는 리스트 삭제 */
-#if defined(__MESSENGER_DETAILS__)
-	for (const RelationData& it : m_map_strRelation[c_strAccount])
-		RemoveFromList(c_strAccount, it.first);
-#else
-	for (const std::string& it : m_map_strRelation[c_strAccount])
-		RemoveFromList(c_strAccount, it);
-#endif
-
-	/* 복사한 데이타 삭제 */
-	m_map_strRelation[c_strAccount].clear();
-}
-
-bool CMessengerManager::IsInList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (m_map_strRelation.find(c_strAccount) == m_map_strRelation.end())
-		return false;
-
-	if (m_map_strRelation[c_strAccount].empty())
-		return false;
-
-#if defined(__MESSENGER_DETAILS__)
-	return std::any_of(m_map_strRelation[c_strAccount].begin(), m_map_strRelation[c_strAccount].end(),
-		[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
-#else
-	return m_map_strRelation[c_strAccount].find(c_strCompanion) != m_map_strRelation[c_strAccount].end();
-#endif
-}
-
-bool CMessengerManager::IsFriend(const char* c_szAccount, const char* c_szName)
-{
-	if (m_map_strRelation.empty())
-		return false;
-
-#if defined(__MESSENGER_DETAILS__)
-	for (const RelationData& it : m_map_strRelation[c_szAccount])
-	{
-		if (it.first.compare(c_szName) == 0)
-			return true;
-	}
-#else
-	for (const std::string& it : m_map_strRelation[c_szAccount])
-	{
-		if (it.compare(c_szName) == 0)
-			return true;
-	}
-#endif
-
-	return false;
-}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-void CMessengerManager::__AddToBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	m_map_strBlockRelation[c_strAccount].emplace(c_strCompanion);
-	m_map_strInverseBlockRelation[c_strCompanion].emplace(c_strAccount);
-
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc)
-		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is now blocked.", c_strCompanion.c_str()));
-
-	const LPCHARACTER c_lpCharBlocked = CHARACTER_MANAGER::instance().FindPC(c_strCompanion.c_str());
-	if (c_lpCharBlocked)
-		__SendBlockLogin(c_strAccount, c_strCompanion);
-	else
-		__SendBlockLogout(c_strAccount, c_strCompanion);
-}
-
-void CMessengerManager::AddToBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (c_strCompanion.size() == 0)
-		return;
-
-	if (m_map_strBlockRelation[c_strAccount].find(c_strCompanion) != m_map_strBlockRelation[c_strAccount].end())
-		return;
-
-	DBManager::instance().Query("INSERT INTO messenger_block_list%s VALUES ('%s', '%s', NOW())",
-		get_table_postfix(), c_strAccount.c_str(), c_strCompanion.c_str());
-
-	__AddToBlockList(c_strAccount, c_strCompanion);
-
-	TPacketGGMessenger P2PPacket = {};
-	P2PPacket.bHeader = HEADER_GG_MESSENGER_BLOCK_ADD;
-	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
-	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
-	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
-}
-
-void CMessengerManager::__RemoveFromBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	m_map_strBlockRelation[c_strAccount].erase(c_strCompanion);
-	m_map_strInverseBlockRelation[c_strCompanion].erase(c_strAccount);
-
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc)
-		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is no longer blocked.", c_strCompanion.c_str()));
-}
-
-void CMessengerManager::RemoveFromBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (c_strCompanion.size() == 0)
-		return;
-
-	char szCompanion[CHARACTER_NAME_MAX_LEN + 1] = {};
-	DBManager::instance().EscapeString(szCompanion, sizeof(szCompanion), c_strCompanion.c_str(), c_strCompanion.length());
-	DBManager::instance().Query("DELETE FROM messenger_block_list%s WHERE `account` = '%s' AND `companion` = '%s'",
-		get_table_postfix(), c_strAccount.c_str(), szCompanion);
-
-	__RemoveFromBlockList(c_strAccount, c_strCompanion);
-
-	TPacketGGMessenger P2PPacket = {};
-	P2PPacket.bHeader = HEADER_GG_MESSENGER_BLOCK_REMOVE;
-	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
-	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
-	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
-}
-
-void CMessengerManager::RemoveAllBlockList(const std::string& c_strAccount)
-{
-	/* SQL Data 삭제 */
-	DBManager::instance().Query("DELETE FROM messenger_list%s WHERE account = '%s' OR companion = '%s'",
-		get_table_postfix(), c_strAccount.c_str(), c_strAccount.c_str());
-
-	/* 내가 가지고있는 리스트 삭제 */
-	for (const std::string& it : m_map_strBlockRelation[c_strAccount])
-		RemoveFromBlockList(c_strAccount, it);
-
-	/* 복사한 데이타 삭제 */
-	m_map_strBlockRelation[c_strAccount].clear();
-}
-
-bool CMessengerManager::IsBlocked(const char* c_szAccount, const char* c_szName)
-{
-	if (m_map_strBlockRelation.empty())
-		return false;
-
-	for (const std::string& it : m_map_strBlockRelation[c_szAccount])
-	{
-		if (it.compare(c_szName) == 0)
-			return true;
-	}
-
-	return false;
-}
-#endif
-
-void CMessengerManager::__SendList(const std::string& c_strAccount)
-{
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	if (c_lpChar == nullptr)
-		return;
-
-	const LPDESC c_lpDesc = c_lpChar->GetDesc();
-	if (c_lpDesc == nullptr)
-		return;
-
-	if (m_map_strRelation.find(c_strAccount) == m_map_strRelation.end())
-		return;
-
-	if (m_map_strRelation[c_strAccount].empty())
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>(128 * 1024);
-#if defined(__MESSENGER_DETAILS__)
-	for (const RelationData& it : m_map_strRelation[c_strAccount])
-#else
-	for (const Relations::value_type& it : m_map_strRelation[c_strAccount])
-#endif
-	{
-		TPacketGCMessengerList ListPacket = {};
-#if defined(__MESSENGER_DETAILS__)
-		strlcpy(ListPacket.szName, it.first.c_str(), sizeof(ListPacket.szName));
-		if (m_set_strOnlineAccount.find(it.first) != m_set_strOnlineAccount.end())
-#else
-		strlcpy(ListPacket.szName, it.c_str(), sizeof(ListPacket.szName));
-		if (m_set_strOnlineAccount.find(it) != m_set_strOnlineAccount.end())
-#endif
-		{
-			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
-#if defined(__MESSENGER_DETAILS__)
-			ListPacket.dwLastPlayTime = 0;
-#endif
-		}
-		else
-		{
-			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
-#if defined(__MESSENGER_DETAILS__)
-			ListPacket.dwLastPlayTime = it.second.dwLastPlayTime;
-#endif
-		}
-#if defined(__MULTI_LANGUAGE_SYSTEM__) && defined(__MESSENGER_DETAILS__)
-		strlcpy(ListPacket.szCountry, it.second.szCountry, sizeof(ListPacket.szCountry));
-#endif
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_LIST, std::move(TempBuffer));
-}
-
-void CMessengerManager::__SendLogin(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc == nullptr)
-		return;
-
-	if (c_lpDesc->GetCharacter() == nullptr)
-		return;
-
-	if (c_lpChar->GetGMLevel() == GM_PLAYER && gm_get_level(c_strCompanion.c_str()) != GM_PLAYER)
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
-		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
-#if defined(__MESSENGER_DETAILS__)
-		const Relations& vRelations = m_map_strRelation[c_strAccount];
-		auto it = std::find_if(vRelations.begin(), vRelations.end(),
-			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
-		if (it != vRelations.end())
-		{
-			const CompanionData& c_rCompanionData = it->second;
-			ListPacket.dwLastPlayTime = 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
-#endif
-		}
-		else
-		{
-			ListPacket.dwLastPlayTime = 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, "", sizeof(ListPacket.szCountry));
-#endif
-		}
-#endif
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_LOGIN, std::move(TempBuffer));
-}
-
-void CMessengerManager::__SendLogout(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (!c_strCompanion.size())
-		return;
-
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc == nullptr)
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
-		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
-#if defined(__MESSENGER_DETAILS__)
-		const Relations& vRelations = m_map_strRelation[c_strAccount];
-		auto it = std::find_if(vRelations.begin(), vRelations.end(),
-			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
-		if (it != vRelations.end())
-		{
-			const CompanionData& c_rCompanionData = it->second;
-			ListPacket.dwLastPlayTime = c_rCompanionData.dwLastPlayTime;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
-#endif
-		}
-		else
-		{
-			ListPacket.dwLastPlayTime = 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, "", sizeof(ListPacket.szCountry));
-#endif
-		}
-#endif
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_LOGOUT, std::move(TempBuffer));
-}
-
-void CMessengerManager::__LoadList(SQLMsg* pMsg)
-{
-	if (pMsg == nullptr)
-		return;
-
-	if (pMsg->Get() == nullptr)
-		return;
-
-	if (pMsg->Get()->uiNumRows == 0)
-		return;
-
-	sys_log(1, "Messenger::LoadList");
-
-	std::string strAccount;
-	for (UINT uiRow = 0; uiRow < pMsg->Get()->uiNumRows; ++uiRow)
-	{
-		MYSQL_ROW cRow = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		if (cRow[LIST_ROW_ACCOUNT] && cRow[LIST_ROW_COMPANION])
-		{
-			if (strAccount.length() == 0)
-				strAccount = cRow[LIST_ROW_ACCOUNT];
-
-#if defined(__MESSENGER_DETAILS__)
-			CompanionData sAccountRowData{};
-			sAccountRowData.dwLastPlayTime = static_cast<DWORD>(cRow[LIST_ROW_ACCOUNT_LAST_PLAY] ? atol(cRow[LIST_ROW_ACCOUNT_LAST_PLAY]) : 0);
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(sAccountRowData.szCountry, cRow[LIST_ROW_ACCOUNT_LANGUAGE] ? cRow[LIST_ROW_ACCOUNT_LANGUAGE] : NULL, sizeof(sAccountRowData.szCountry));
-#endif
-
-			CompanionData sCompanionRowData{};
-			sCompanionRowData.dwLastPlayTime = static_cast<DWORD>(cRow[LIST_ROW_COMPANION_LAST_PLAY] ? atol(cRow[LIST_ROW_COMPANION_LAST_PLAY]) : 0);
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(sCompanionRowData.szCountry, cRow[LIST_ROW_COMPANION_LANGUAGE] ? cRow[LIST_ROW_COMPANION_LANGUAGE] : NULL, sizeof(sCompanionRowData.szCountry));
-#endif
-
-			m_map_strRelation[cRow[LIST_ROW_ACCOUNT]].emplace_back(cRow[LIST_ROW_COMPANION], sCompanionRowData);
-			m_map_strInverseRelation[cRow[LIST_ROW_COMPANION]].emplace_back(cRow[LIST_ROW_ACCOUNT], sAccountRowData);
-#else
-			m_map_strRelation[cRow[LIST_ROW_ACCOUNT]].emplace(cRow[LIST_ROW_COMPANION]);
-			m_map_strInverseRelation[cRow[LIST_ROW_COMPANION]].emplace(cRow[LIST_ROW_ACCOUNT]);
-#endif
-		}
-	}
-
-	__SendList(strAccount);
-#if defined(__MESSENGER_DETAILS__)
-	for (const RelationData& it : m_map_strInverseRelation[strAccount])
-		__SendLogin(it.first, strAccount);
-#else
-	for (const std::string& it : m_map_strInverseRelation[strAccount])
-		__SendLogin(it, strAccount);
-#endif
-}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-void CMessengerManager::__SendBlockList(const std::string& c_strAccount)
-{
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	if (c_lpChar == nullptr)
-		return;
-
-	const LPDESC c_lpDesc = c_lpChar->GetDesc();
-	if (c_lpDesc == nullptr)
-		return;
-
-	if (m_map_strBlockRelation.find(c_strAccount) == m_map_strBlockRelation.end())
-		return;
-
-	if (m_map_strBlockRelation[c_strAccount].empty())
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>(128 * 1024);
-	for (const std::string& it : m_map_strBlockRelation[c_strAccount])
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, it.c_str(), sizeof(ListPacket.szName));
-		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_BLOCK_LIST, std::move(TempBuffer));
-}
-
-void CMessengerManager::__SendBlockLogin(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc == nullptr)
-		return;
-
-	if (c_lpDesc->GetCharacter() == nullptr)
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
-		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_BLOCK_LOGIN, std::move(TempBuffer));
-}
-
-void CMessengerManager::__SendBlockLogout(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (!c_strCompanion.size())
-		return;
-
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc == nullptr)
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
-		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT, std::move(TempBuffer));
-}
-
-void CMessengerManager::__LoadBlockList(SQLMsg* pMsg)
-{
-	if (pMsg == nullptr)
-		return;
-
-	if (pMsg->Get() == nullptr)
-		return;
-
-	if (pMsg->Get()->uiNumRows == 0)
-		return;
-
-	sys_log(1, "Messenger::LoadBlockList");
-
-	std::string strAccount;
-	for (UINT uiRow = 0; uiRow < pMsg->Get()->uiNumRows; ++uiRow)
-	{
-		MYSQL_ROW cRow = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		if (cRow[BLOCK_LIST_ACCOUNT] && cRow[BLOCK_LIST_COMPANION])
-		{
-			if (strAccount.length() == 0)
-				strAccount = cRow[BLOCK_LIST_ACCOUNT];
-
-			m_map_strBlockRelation[cRow[BLOCK_LIST_ACCOUNT]].emplace(cRow[BLOCK_LIST_COMPANION]);
-			m_map_strInverseBlockRelation[cRow[BLOCK_LIST_COMPANION]].emplace(cRow[BLOCK_LIST_ACCOUNT]);
-		}
-	}
-
-	__SendBlockList(strAccount);
-	for (const std::string& it : m_map_strInverseBlockRelation[strAccount])
-		__SendBlockLogin(it, strAccount);
-}
-#endif
-
-#if defined(__MESSENGER_GM__)
-void CMessengerManager::__SendGMList(const std::string& c_strAccount)
-{
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	if (c_lpChar == nullptr)
-		return;
-
-	const LPDESC c_lpDesc = c_lpChar->GetDesc();
-	if (c_lpDesc == nullptr)
-		return;
-
-	if (m_map_strGMRelation.find(c_strAccount) == m_map_strGMRelation.end())
-		return;
-
-	if (m_map_strGMRelation[c_strAccount].empty())
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>(128 * 1024);
-	for (const RelationData& it : m_map_strGMRelation[c_strAccount])
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, it.first.c_str(), sizeof(ListPacket.szName));
-		if (m_set_strOnlineAccount.find(it.first) != m_set_strOnlineAccount.end())
-		{
-			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
-#if defined(__MESSENGER_DETAILS__)
-			ListPacket.dwLastPlayTime = 0;
-#endif
-		}
-		else
-		{
-			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
-#if defined(__MESSENGER_DETAILS__)
-			ListPacket.dwLastPlayTime = it.second.dwLastPlayTime;
-#endif
-		}
-#if defined(__MULTI_LANGUAGE_SYSTEM__) && defined(__MESSENGER_DETAILS__)
-		strlcpy(ListPacket.szCountry, it.second.szCountry, sizeof(ListPacket.szCountry));
-#endif
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_GM_LIST, std::move(TempBuffer));
-}
-
-void CMessengerManager::__SendGMLogin(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc == nullptr)
-		return;
-
-	if (c_lpDesc->GetCharacter() == nullptr)
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
-		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
-#if defined(__MESSENGER_DETAILS__)
-		const Relations& vRelations = m_map_strGMRelation[c_strAccount];
-		auto it = std::find_if(vRelations.begin(), vRelations.end(),
-			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
-		if (it != vRelations.end())
-		{
-			const CompanionData& c_rCompanionData = it->second;
-			ListPacket.dwLastPlayTime = 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
-#endif
-		}
-		else
-		{
-			ListPacket.dwLastPlayTime = 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, NULL, sizeof(ListPacket.szCountry));
-#endif
-		}
-#endif
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_GM_LOGIN, std::move(TempBuffer));
-}
-
-void CMessengerManager::__SendGMLogout(const std::string& c_strAccount, const std::string& c_strCompanion)
-{
-	if (!c_strCompanion.size())
-		return;
-
-	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
-	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
-	if (c_lpDesc == nullptr)
-		return;
-
-	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
-	{
-		TPacketGCMessengerList ListPacket = {};
-		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
-		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
-#if defined(__MESSENGER_DETAILS__)
-		const Relations& vRelations = m_map_strGMRelation[c_strAccount];
-		auto it = std::find_if(vRelations.begin(), vRelations.end(),
-			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
-		if (it != vRelations.end())
-		{
-			const CompanionData& c_rCompanionData = it->second;
-			ListPacket.dwLastPlayTime = c_rCompanionData.dwLastPlayTime;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
-#endif
-		}
-		else
-		{
-			ListPacket.dwLastPlayTime = 0;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(ListPacket.szCountry, NULL, sizeof(ListPacket.szCountry));
-#endif
-		}
-#endif
-		TempBuffer->write(&ListPacket, sizeof(ListPacket));
-	}
-	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_GM_LOGOUT, std::move(TempBuffer));
-}
-
-void CMessengerManager::__LoadGMList(SQLMsg* pMsg)
-{
-	if (pMsg == nullptr)
-		return;
-
-	if (pMsg->Get() == nullptr)
-		return;
-
-	if (pMsg->Get()->uiNumRows == 0)
-		return;
-
-	sys_log(1, "Messenger::LoadGMList");
-
-	std::string strAccount;
-	for (UINT uiRow = 0; uiRow < pMsg->Get()->uiNumRows; ++uiRow)
-	{
-		MYSQL_ROW cRow = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		if (cRow[GM_LIST_ROW_ACCOUNT] && cRow[GM_LIST_ROW_COMPANION])
-		{
-			if (strAccount.length() == 0)
-				strAccount = cRow[GM_LIST_ROW_ACCOUNT];
-
-#if defined(__MESSENGER_DETAILS__)
-			CompanionData sCompanion{};
-			sCompanion.dwLastPlayTime = static_cast<DWORD>(cRow[GM_LIST_ROW_COMPANION_LAST_PLAY] ? atol(cRow[GM_LIST_ROW_COMPANION_LAST_PLAY]) : 0);
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			strlcpy(sCompanion.szCountry, cRow[GM_LIST_ROW_COMPANION_LANGUAGE] ? cRow[GM_LIST_ROW_COMPANION_LANGUAGE] : "", sizeof(sCompanion.szCountry));
-#endif
-			m_map_strGMRelation[cRow[GM_LIST_ROW_ACCOUNT]].emplace_back(cRow[GM_LIST_ROW_COMPANION], sCompanion);
-			m_map_strGMInverseRelation[cRow[GM_LIST_ROW_COMPANION]].emplace_back(cRow[GM_LIST_ROW_ACCOUNT], sCompanion);
-#else
-			m_map_strGMRelation[cRow[GM_LIST_ROW_ACCOUNT]].emplace(cRow[GM_LIST_ROW_COMPANION]);
-			m_map_strGMInverseRelation[cRow[GM_LIST_ROW_COMPANION]].emplace(cRow[GM_LIST_ROW_ACCOUNT]);
-#endif
-		}
-	}
-
-	__SendGMList(strAccount);
-#if defined(__MESSENGER_DETAILS__)
-	for (const RelationData& it : m_map_strGMInverseRelation[strAccount])
-		__SendGMLogin(it.first, strAccount);
-#else
-	for (const std::string& it : m_map_strGMInverseRelation[strAccount])
-		__SendGMLogin(it, strAccount);
-#endif
-}
-#endif
-
-void CMessengerManager::__Process(const LPDESC c_lpDesc, const BYTE c_bSubHeader, std::unique_ptr<TEMP_BUFFER> pTempBuffer)
-{
-	if (c_lpDesc == nullptr || pTempBuffer.get() == nullptr)
-		return;
-
-	TPacketGCMessenger Packet = {};
-	Packet.bHeader = HEADER_GC_MESSENGER;
-	Packet.bSubHeader = c_bSubHeader;
-	Packet.wSize = sizeof(Packet) + pTempBuffer->size();
-	if (pTempBuffer->size())
-	{
-		c_lpDesc->BufferedPacket(&Packet, sizeof(Packet));
-		c_lpDesc->Packet(pTempBuffer->read_peek(), pTempBuffer->size());
-	}
-}
+/**
+* Filename: messenger_manager.cpp
+* Author: Owsap
+**/
+
+#include "stdafx.h"
+#include "messenger_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "desc_client.h"
+#include "p2p.h"
+#include "questmanager.h"
+#include "crc32.h"
+#include "config.h"
+#include "gm.h"
+
+void CMessengerManager::Initialize()
+{
+}
+
+void CMessengerManager::Destroy()
+{
+}
+
+void CMessengerManager::P2PLogin(const std::string& c_strAccount)
+{
+	Login(c_strAccount);
+}
+
+void CMessengerManager::P2PLogout(const std::string& c_strAccount)
+{
+	Logout(c_strAccount);
+}
+
+void CMessengerManager::Login(const std::string& c_strAccount)
+{
+	if (m_set_strOnlineAccount.find(c_strAccount) != m_set_strOnlineAccount.end())
+		return;
+
+	DBManager::instance().FuncQuery(std::bind(&CMessengerManager::__LoadList, this, std::placeholders::_1),
+#if defined(__MESSENGER_DETAILS__)
+		"SELECT "
+		"`messenger_list`.`account`, UNIX_TIMESTAMP(`player`.`last_play`) AS `last_play`"
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		", `account`.`country` AS `country`"
+#endif
+		", `messenger_list`.`companion`, UNIX_TIMESTAMP(`companion_player`.`last_play`) AS `companion_last_play`"
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		", `companion_account`.`country` AS `companion_country`"
+#endif
+		" FROM `player`.`messenger_list`"
+		" LEFT JOIN (SELECT `account_id`, `name`, `last_play` FROM `player`) AS `player` ON `player`.`name` = `messenger_list`.`account`"
+		" LEFT JOIN (SELECT `id`, `country` FROM `account`.`account`) AS `account` ON `account`.`id` = `player`.`account_id`"
+		" LEFT JOIN (SELECT `account_id`, `name`, `last_play` FROM `player`) AS `companion_player` ON `companion_player`.`name` = `messenger_list`.`companion`"
+		" LEFT JOIN (SELECT `id`, `country` FROM `account`.`account`) AS `companion_account` ON `companion_account`.`id` = `companion_player`.`account_id`"
+		" WHERE `messenger_list`.`account` = '%s'", c_strAccount.c_str());
+#else
+		"SELECT `account`, `companion` FROM `messenger_list` WHERE `account` = '%s'", c_strAccount.c_str());
+#endif
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	DBManager::instance().FuncQuery(std::bind(&CMessengerManager::__LoadBlockList, this, std::placeholders::_1),
+		"SELECT `account`, `companion` FROM `messenger_block_list` WHERE `account` = '%s'", c_strAccount.c_str());
+#endif
+
+#if defined(__MESSENGER_GM__)
+	DBManager::instance().FuncQuery(std::bind(&CMessengerManager::__LoadGMList, this, std::placeholders::_1),
+#if defined(__MESSENGER_DETAILS__)
+		"SELECT '%s', `gmlist`.`mName`, UNIX_TIMESTAMP(`player`.`last_play`) AS `last_play`"
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		", `account`.`country` AS `country`"
+#endif
+		" FROM `common`.`gmlist`"
+		" LEFT JOIN (SELECT `account_id`, `name`, `last_play` FROM `player`) AS `player` ON `player`.`name` = `gmlist`.`mName`"
+		" LEFT JOIN (SELECT `id`, `country` FROM `account`.`account`) AS `account` ON `account`.`id` = `player`.`account_id`"
+		" WHERE `gmlist`.`mAuthority` != 'PLAYER'", c_strAccount.c_str());
+#else
+		"SELECT '%s', `gmlist`.`mName` FROM `common`.`gmlist` WHERE `gmlist`.`mAuthority` != 'PLAYER'", c_strAccount.c_str());
+#endif
+#endif
+
+	m_set_strOnlineAccount.emplace(c_strAccount);
+}
+
+void CMessengerManager::Logout(const std::string& c_strAccount)
+{
+	if (m_set_strOnlineAccount.find(c_strAccount) == m_set_strOnlineAccount.end())
+		return;
+
+	m_set_strOnlineAccount.erase(c_strAccount);
+
+#if defined(__MESSENGER_DETAILS__)
+	for (const RelationData& it : m_map_strInverseRelation[c_strAccount])
+		__SendLogout(it.first, c_strAccount);
+
+	for (auto& [key, vec] : m_map_strInverseRelation)
+	{
+		vec.erase(std::remove_if(vec.begin(), vec.end(),
+			[&](const RelationData& c_rData) { return c_rData.first == c_strAccount; }),
+			vec.end());
+	}
+#else
+	for (const std::string& it : m_map_strInverseRelation[c_strAccount])
+		__SendLogout(it, c_strAccount);
+
+	RelationMap::iterator it = m_map_strInverseRelation.begin();
+	while (it != m_map_strInverseRelation.end())
+	{
+		it->second.erase(c_strAccount);
+		++it;
+	}
+#endif
+	m_map_strRelation.erase(c_strAccount);
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	for (const std::string& it : m_map_strInverseBlockRelation[c_strAccount])
+		__SendBlockLogout(it, c_strAccount);
+
+	BlockRelationMap::iterator it = m_map_strInverseBlockRelation.begin();
+	while (it != m_map_strInverseBlockRelation.end())
+	{
+		it->second.erase(c_strAccount);
+		++it;
+	}
+
+	m_map_strBlockRelation.erase(c_strAccount);
+#endif
+
+#if defined(__MESSENGER_GM__)
+#if defined(__MESSENGER_DETAILS__)
+	for (const RelationData& it : m_map_strGMInverseRelation[c_strAccount])
+		__SendGMLogout(it.first, c_strAccount);
+
+	for (auto& [key, vec] : m_map_strGMInverseRelation)
+	{
+		vec.erase(std::remove_if(vec.begin(), vec.end(),
+			[&](const RelationData& c_rData) { return c_rData.first == c_strAccount; }),
+			vec.end());
+}
+#else
+	for (const std::string& it : m_map_strGMInverseRelation[c_strAccount])
+		__SendGMLogout(it, c_strAccount);
+
+	RelationMap::iterator it = m_map_strGMInverseRelation.begin();
+	while (it != m_map_strGMInverseRelation.end())
+	{
+		it->second.erase(c_strAccount);
+		++it;
+	}
+#endif
+	m_map_strGMRelation.erase(c_strAccount);
+#endif
+}
+
+void CMessengerManager::RequestToAdd(const LPCHARACTER c_lpChar, const LPCHARACTER c_lpCharTarget)
+{
+	if (c_lpChar == nullptr || c_lpCharTarget == nullptr)
+		return;
+
+	if (c_lpChar->IsPC() == false || c_lpCharTarget->IsPC() == false)
+		return;
+
+	if (quest::CQuestManager::instance().GetPCForce(c_lpChar->GetPlayerID())->IsRunning() == true)
+	{
+		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 친 煞    都求."));
+		return;
+	}
+
+	if (quest::CQuestManager::instance().GetPCForce(c_lpCharTarget->GetPlayerID())->IsRunning() == true)
+		return;
+
+	DWORD dwCRC32CharName = GetCRC32(c_lpChar->GetName(), strlen(c_lpChar->GetName()));
+	DWORD dwCRC32CharTargetName = GetCRC32(c_lpCharTarget->GetName(), strlen(c_lpCharTarget->GetName()));
+
+	char szBuf[64] = {};
+	snprintf(szBuf, sizeof(szBuf), "%u:%u", dwCRC32CharName, dwCRC32CharTargetName);
+	DWORD dwComplex = GetCRC32(szBuf, strlen(szBuf));
+
+	m_set_dwRequestToAdd.emplace(dwComplex);
+
+	c_lpCharTarget->ChatPacket(CHAT_TYPE_COMMAND, "messenger_auth %s", c_lpChar->GetName());
+}
+
+void CMessengerManager::AuthToAdd(const std::string& c_strAccount, const std::string& c_strCompanion, bool bDeny)
+{
+	DWORD dwCRC32CharTargetName = GetCRC32(c_strCompanion.c_str(), c_strCompanion.length());
+	DWORD dwCRC32CharName = GetCRC32(c_strAccount.c_str(), c_strAccount.length());
+
+	char szBuf[64] = {};
+	snprintf(szBuf, sizeof(szBuf), "%u:%u", dwCRC32CharTargetName, dwCRC32CharName);
+	DWORD dwComplex = GetCRC32(szBuf, strlen(szBuf));
+
+	if (m_set_dwRequestToAdd.find(dwComplex) == m_set_dwRequestToAdd.end())
+	{
+		sys_log(0, "MessengerManager::AuthToAdd : request not exist %s -> %s", c_strCompanion.c_str(), c_strAccount.c_str());
+		return;
+	}
+
+	m_set_dwRequestToAdd.erase(dwComplex);
+
+	if (!bDeny)
+	{
+		AddToList(c_strCompanion, c_strAccount);
+		AddToList(c_strAccount, c_strCompanion);
+	}
+}
+
+void CMessengerManager::__AddToList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+#if !defined(__MESSENGER_DETAILS__)
+	m_map_strRelation[c_strAccount].emplace(c_strCompanion);
+	m_map_strInverseRelation[c_strCompanion].emplace(c_strAccount);
+#endif
+
+	const LPCHARACTER pkChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC pkDesc = pkChar ? pkChar->GetDesc() : nullptr;
+	if (pkChar && pkDesc)
+		pkChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<聘> %s  친 煞臼求.", c_strCompanion.c_str()));
+
+	const LPCHARACTER pkCharCompanion = CHARACTER_MANAGER::instance().FindPC(c_strCompanion.c_str());
+
+#if defined(__MESSENGER_DETAILS__)
+	CompanionData sAccountRowData{};
+	sAccountRowData.dwLastPlayTime = pkChar ? pkChar->GetLastPlay() : 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	strlcpy(sAccountRowData.szCountry, pkChar ? pkChar->GetCountry() : "", sizeof(sAccountRowData.szCountry));
+#endif
+
+	CompanionData sCompanionData{};
+	sCompanionData.dwLastPlayTime = pkCharCompanion ? pkCharCompanion->GetLastPlay() : 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	strlcpy(sCompanionData.szCountry, pkCharCompanion ? pkCharCompanion->GetCountry() : "", sizeof(sCompanionData.szCountry));
+#endif
+
+	m_map_strRelation[c_strAccount].emplace_back(c_strCompanion, sCompanionData);
+	m_map_strInverseRelation[c_strCompanion].emplace_back(c_strAccount, sCompanionData);
+#endif
+
+	if (pkCharCompanion)
+		__SendLogin(c_strAccount, c_strCompanion);
+	else
+		__SendLogout(c_strAccount, c_strCompanion);
+}
+
+void CMessengerManager::AddToList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (c_strCompanion.empty())
+		return;
+
+#if defined(__MESSENGER_DETAILS__)
+	if (std::any_of(m_map_strRelation[c_strAccount].begin(), m_map_strRelation[c_strAccount].end(),
+		[&](const RelationData& elem) { return elem.first == c_strCompanion; }))
+		return;
+#else
+	if (m_map_strRelation[c_strAccount].find(c_strCompanion) != m_map_strRelation[c_strAccount].end())
+		return;
+#endif
+
+	sys_log(0, "Messenger Add %s %s", c_strAccount.c_str(), c_strCompanion.c_str());
+	DBManager::instance().Query("INSERT INTO messenger_list%s VALUES ('%s', '%s')",
+		get_table_postfix(), c_strAccount.c_str(), c_strCompanion.c_str());
+
+	__AddToList(c_strAccount, c_strCompanion);
+
+	TPacketGGMessenger P2PPacket = {};
+	P2PPacket.bHeader = HEADER_GG_MESSENGER_ADD;
+	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
+	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
+	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
+}
+
+void CMessengerManager::__RemoveFromList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+#if defined(__MESSENGER_DETAILS__)
+	Relations& vRelation = m_map_strRelation[c_strAccount];
+	m_map_strRelation[c_strAccount].erase(std::remove_if(vRelation.begin(), vRelation.end(),
+		[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; }),
+		vRelation.end());
+	
+	Relations& vInverseRelation = m_map_strInverseRelation[c_strCompanion];
+	m_map_strInverseRelation[c_strCompanion].erase(std::remove_if(vInverseRelation.begin(), vInverseRelation.end(),
+		[&](const RelationData& data) { return data.first == c_strAccount; }),
+		vInverseRelation.end());
+#else
+	m_map_strRelation[c_strAccount].erase(c_strCompanion);
+	m_map_strInverseRelation[c_strCompanion].erase(c_strAccount);
+#endif
+
+	const LPCHARACTER c_lpChar= CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc)
+		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<聘> %s  聘 臼求.", c_strCompanion.c_str()));
+}
+
+void CMessengerManager::RemoveFromList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (c_strCompanion.empty())
+		return;
+
+	// Make removal idempotent: even if the friend entry is already gone from DB or in-memory maps,
+	// do a best-effort cleanup and broadcast, instead of treating it as an error.
+	char szAccount[CHARACTER_NAME_MAX_LEN + 1] = {};
+	char szCompanion[CHARACTER_NAME_MAX_LEN + 1] = {};
+	DBManager::instance().EscapeString(szAccount, sizeof(szAccount), c_strAccount.c_str(), c_strAccount.length());
+	DBManager::instance().EscapeString(szCompanion, sizeof(szCompanion), c_strCompanion.c_str(), c_strCompanion.length());
+	DBManager::instance().Query("DELETE FROM messenger_list%s WHERE `account` = '%s' AND `companion` = '%s'",
+		get_table_postfix(), szAccount, szCompanion);
+
+	__RemoveFromList(c_strAccount, c_strCompanion);
+
+	sys_log(1, "Messenger Remove %s %s", c_strAccount.c_str(), c_strCompanion.c_str());
+
+	TPacketGGMessenger P2PPacket = {};
+	P2PPacket.bHeader = HEADER_GG_MESSENGER_REMOVE;
+	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
+	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
+	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
+}
+
+void CMessengerManager::RemoveAllList(const std::string& c_strAccount)
+{
+	/* SQL Data  */
+	DBManager::instance().Query("DELETE FROM messenger_list%s WHERE account = '%s' OR companion = '%s'",
+		get_table_postfix(), c_strAccount.c_str(), c_strAccount.c_str());
+
+	/*  獵 트  */
+#if defined(__MESSENGER_DETAILS__)
+	for (const RelationData& it : m_map_strRelation[c_strAccount])
+		RemoveFromList(c_strAccount, it.first);
+#else
+	for (const std::string& it : m_map_strRelation[c_strAccount])
+		RemoveFromList(c_strAccount, it);
+#endif
+
+	/*  타  */
+	m_map_strRelation[c_strAccount].clear();
+}
+
+bool CMessengerManager::IsInList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (m_map_strRelation.find(c_strAccount) == m_map_strRelation.end())
+		return false;
+
+	if (m_map_strRelation[c_strAccount].empty())
+		return false;
+
+#if defined(__MESSENGER_DETAILS__)
+	return std::any_of(m_map_strRelation[c_strAccount].begin(), m_map_strRelation[c_strAccount].end(),
+		[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
+#else
+	return m_map_strRelation[c_strAccount].find(c_strCompanion) != m_map_strRelation[c_strAccount].end();
+#endif
+}
+
+bool CMessengerManager::IsFriend(const char* c_szAccount, const char* c_szName)
+{
+	if (m_map_strRelation.empty())
+		return false;
+
+#if defined(__MESSENGER_DETAILS__)
+	for (const RelationData& it : m_map_strRelation[c_szAccount])
+	{
+		if (it.first.compare(c_szName) == 0)
+			return true;
+	}
+#else
+	for (const std::string& it : m_map_strRelation[c_szAccount])
+	{
+		if (it.compare(c_szName) == 0)
+			return true;
+	}
+#endif
+
+	return false;
+}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+void CMessengerManager::__AddToBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	m_map_strBlockRelation[c_strAccount].emplace(c_strCompanion);
+	m_map_strInverseBlockRelation[c_strCompanion].emplace(c_strAccount);
+
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc)
+		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is now blocked.", c_strCompanion.c_str()));
+
+	const LPCHARACTER c_lpCharBlocked = CHARACTER_MANAGER::instance().FindPC(c_strCompanion.c_str());
+	if (c_lpCharBlocked)
+		__SendBlockLogin(c_strAccount, c_strCompanion);
+	else
+		__SendBlockLogout(c_strAccount, c_strCompanion);
+}
+
+void CMessengerManager::AddToBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (c_strCompanion.size() == 0)
+		return;
+
+	if (m_map_strBlockRelation[c_strAccount].find(c_strCompanion) != m_map_strBlockRelation[c_strAccount].end())
+		return;
+
+	DBManager::instance().Query("INSERT INTO messenger_block_list%s VALUES ('%s', '%s', NOW())",
+		get_table_postfix(), c_strAccount.c_str(), c_strCompanion.c_str());
+
+	__AddToBlockList(c_strAccount, c_strCompanion);
+
+	TPacketGGMessenger P2PPacket = {};
+	P2PPacket.bHeader = HEADER_GG_MESSENGER_BLOCK_ADD;
+	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
+	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
+	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
+}
+
+void CMessengerManager::__RemoveFromBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	m_map_strBlockRelation[c_strAccount].erase(c_strCompanion);
+	m_map_strInverseBlockRelation[c_strCompanion].erase(c_strAccount);
+
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc)
+		c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is no longer blocked.", c_strCompanion.c_str()));
+}
+
+void CMessengerManager::RemoveFromBlockList(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (c_strCompanion.size() == 0)
+		return;
+
+	char szCompanion[CHARACTER_NAME_MAX_LEN + 1] = {};
+	DBManager::instance().EscapeString(szCompanion, sizeof(szCompanion), c_strCompanion.c_str(), c_strCompanion.length());
+	DBManager::instance().Query("DELETE FROM messenger_block_list%s WHERE `account` = '%s' AND `companion` = '%s'",
+		get_table_postfix(), c_strAccount.c_str(), szCompanion);
+
+	__RemoveFromBlockList(c_strAccount, c_strCompanion);
+
+	TPacketGGMessenger P2PPacket = {};
+	P2PPacket.bHeader = HEADER_GG_MESSENGER_BLOCK_REMOVE;
+	strlcpy(P2PPacket.szAccount, c_strAccount.c_str(), sizeof(P2PPacket.szAccount));
+	strlcpy(P2PPacket.szCompanion, c_strCompanion.c_str(), sizeof(P2PPacket.szCompanion));
+	P2P_MANAGER::instance().Send(&P2PPacket, sizeof(TPacketGGMessenger));
+}
+
+void CMessengerManager::RemoveAllBlockList(const std::string& c_strAccount)
+{
+	/* SQL Data  */
+	DBManager::instance().Query("DELETE FROM messenger_list%s WHERE account = '%s' OR companion = '%s'",
+		get_table_postfix(), c_strAccount.c_str(), c_strAccount.c_str());
+
+	/*  獵 트  */
+	for (const std::string& it : m_map_strBlockRelation[c_strAccount])
+		RemoveFromBlockList(c_strAccount, it);
+
+	/*  타  */
+	m_map_strBlockRelation[c_strAccount].clear();
+}
+
+bool CMessengerManager::IsBlocked(const char* c_szAccount, const char* c_szName)
+{
+	if (m_map_strBlockRelation.empty())
+		return false;
+
+	for (const std::string& it : m_map_strBlockRelation[c_szAccount])
+	{
+		if (it.compare(c_szName) == 0)
+			return true;
+	}
+
+	return false;
+}
+#endif
+
+void CMessengerManager::__SendList(const std::string& c_strAccount)
+{
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	if (c_lpChar == nullptr)
+		return;
+
+	const LPDESC c_lpDesc = c_lpChar->GetDesc();
+	if (c_lpDesc == nullptr)
+		return;
+
+	if (m_map_strRelation.find(c_strAccount) == m_map_strRelation.end())
+		return;
+
+	if (m_map_strRelation[c_strAccount].empty())
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>(128 * 1024);
+#if defined(__MESSENGER_DETAILS__)
+	for (const RelationData& it : m_map_strRelation[c_strAccount])
+#else
+	for (const Relations::value_type& it : m_map_strRelation[c_strAccount])
+#endif
+	{
+		TPacketGCMessengerList ListPacket = {};
+#if defined(__MESSENGER_DETAILS__)
+		strlcpy(ListPacket.szName, it.first.c_str(), sizeof(ListPacket.szName));
+		if (m_set_strOnlineAccount.find(it.first) != m_set_strOnlineAccount.end())
+#else
+		strlcpy(ListPacket.szName, it.c_str(), sizeof(ListPacket.szName));
+		if (m_set_strOnlineAccount.find(it) != m_set_strOnlineAccount.end())
+#endif
+		{
+			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
+#if defined(__MESSENGER_DETAILS__)
+			ListPacket.dwLastPlayTime = 0;
+#endif
+		}
+		else
+		{
+			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
+#if defined(__MESSENGER_DETAILS__)
+			ListPacket.dwLastPlayTime = it.second.dwLastPlayTime;
+#endif
+		}
+#if defined(__MULTI_LANGUAGE_SYSTEM__) && defined(__MESSENGER_DETAILS__)
+		strlcpy(ListPacket.szCountry, it.second.szCountry, sizeof(ListPacket.szCountry));
+#endif
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_LIST, std::move(TempBuffer));
+}
+
+void CMessengerManager::__SendLogin(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc == nullptr)
+		return;
+
+	if (c_lpDesc->GetCharacter() == nullptr)
+		return;
+
+	if (c_lpChar->GetGMLevel() == GM_PLAYER && gm_get_level(c_strCompanion.c_str()) != GM_PLAYER)
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
+		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
+#if defined(__MESSENGER_DETAILS__)
+		const Relations& vRelations = m_map_strRelation[c_strAccount];
+		auto it = std::find_if(vRelations.begin(), vRelations.end(),
+			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
+		if (it != vRelations.end())
+		{
+			const CompanionData& c_rCompanionData = it->second;
+			ListPacket.dwLastPlayTime = 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
+#endif
+		}
+		else
+		{
+			ListPacket.dwLastPlayTime = 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, "", sizeof(ListPacket.szCountry));
+#endif
+		}
+#endif
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_LOGIN, std::move(TempBuffer));
+}
+
+void CMessengerManager::__SendLogout(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (!c_strCompanion.size())
+		return;
+
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc == nullptr)
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
+		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
+#if defined(__MESSENGER_DETAILS__)
+		const Relations& vRelations = m_map_strRelation[c_strAccount];
+		auto it = std::find_if(vRelations.begin(), vRelations.end(),
+			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
+		if (it != vRelations.end())
+		{
+			const CompanionData& c_rCompanionData = it->second;
+			ListPacket.dwLastPlayTime = c_rCompanionData.dwLastPlayTime;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
+#endif
+		}
+		else
+		{
+			ListPacket.dwLastPlayTime = 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, "", sizeof(ListPacket.szCountry));
+#endif
+		}
+#endif
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_LOGOUT, std::move(TempBuffer));
+}
+
+void CMessengerManager::__LoadList(SQLMsg* pMsg)
+{
+	if (pMsg == nullptr)
+		return;
+
+	if (pMsg->Get() == nullptr)
+		return;
+
+	if (pMsg->Get()->uiNumRows == 0)
+		return;
+
+	sys_log(1, "Messenger::LoadList");
+
+	std::string strAccount;
+	for (UINT uiRow = 0; uiRow < pMsg->Get()->uiNumRows; ++uiRow)
+	{
+		MYSQL_ROW cRow = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		if (cRow[LIST_ROW_ACCOUNT] && cRow[LIST_ROW_COMPANION])
+		{
+			if (strAccount.length() == 0)
+				strAccount = cRow[LIST_ROW_ACCOUNT];
+
+#if defined(__MESSENGER_DETAILS__)
+			CompanionData sAccountRowData{};
+			sAccountRowData.dwLastPlayTime = static_cast<DWORD>(cRow[LIST_ROW_ACCOUNT_LAST_PLAY] ? atol(cRow[LIST_ROW_ACCOUNT_LAST_PLAY]) : 0);
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(sAccountRowData.szCountry, cRow[LIST_ROW_ACCOUNT_LANGUAGE] ? cRow[LIST_ROW_ACCOUNT_LANGUAGE] : NULL, sizeof(sAccountRowData.szCountry));
+#endif
+
+			CompanionData sCompanionRowData{};
+			sCompanionRowData.dwLastPlayTime = static_cast<DWORD>(cRow[LIST_ROW_COMPANION_LAST_PLAY] ? atol(cRow[LIST_ROW_COMPANION_LAST_PLAY]) : 0);
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(sCompanionRowData.szCountry, cRow[LIST_ROW_COMPANION_LANGUAGE] ? cRow[LIST_ROW_COMPANION_LANGUAGE] : NULL, sizeof(sCompanionRowData.szCountry));
+#endif
+
+			m_map_strRelation[cRow[LIST_ROW_ACCOUNT]].emplace_back(cRow[LIST_ROW_COMPANION], sCompanionRowData);
+			m_map_strInverseRelation[cRow[LIST_ROW_COMPANION]].emplace_back(cRow[LIST_ROW_ACCOUNT], sAccountRowData);
+#else
+			m_map_strRelation[cRow[LIST_ROW_ACCOUNT]].emplace(cRow[LIST_ROW_COMPANION]);
+			m_map_strInverseRelation[cRow[LIST_ROW_COMPANION]].emplace(cRow[LIST_ROW_ACCOUNT]);
+#endif
+		}
+	}
+
+	__SendList(strAccount);
+#if defined(__MESSENGER_DETAILS__)
+	for (const RelationData& it : m_map_strInverseRelation[strAccount])
+		__SendLogin(it.first, strAccount);
+#else
+	for (const std::string& it : m_map_strInverseRelation[strAccount])
+		__SendLogin(it, strAccount);
+#endif
+}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+void CMessengerManager::__SendBlockList(const std::string& c_strAccount)
+{
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	if (c_lpChar == nullptr)
+		return;
+
+	const LPDESC c_lpDesc = c_lpChar->GetDesc();
+	if (c_lpDesc == nullptr)
+		return;
+
+	if (m_map_strBlockRelation.find(c_strAccount) == m_map_strBlockRelation.end())
+		return;
+
+	if (m_map_strBlockRelation[c_strAccount].empty())
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>(128 * 1024);
+	for (const std::string& it : m_map_strBlockRelation[c_strAccount])
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, it.c_str(), sizeof(ListPacket.szName));
+		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_BLOCK_LIST, std::move(TempBuffer));
+}
+
+void CMessengerManager::__SendBlockLogin(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc == nullptr)
+		return;
+
+	if (c_lpDesc->GetCharacter() == nullptr)
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
+		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_BLOCK_LOGIN, std::move(TempBuffer));
+}
+
+void CMessengerManager::__SendBlockLogout(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (!c_strCompanion.size())
+		return;
+
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc == nullptr)
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
+		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT, std::move(TempBuffer));
+}
+
+void CMessengerManager::__LoadBlockList(SQLMsg* pMsg)
+{
+	if (pMsg == nullptr)
+		return;
+
+	if (pMsg->Get() == nullptr)
+		return;
+
+	if (pMsg->Get()->uiNumRows == 0)
+		return;
+
+	sys_log(1, "Messenger::LoadBlockList");
+
+	std::string strAccount;
+	for (UINT uiRow = 0; uiRow < pMsg->Get()->uiNumRows; ++uiRow)
+	{
+		MYSQL_ROW cRow = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		if (cRow[BLOCK_LIST_ACCOUNT] && cRow[BLOCK_LIST_COMPANION])
+		{
+			if (strAccount.length() == 0)
+				strAccount = cRow[BLOCK_LIST_ACCOUNT];
+
+			m_map_strBlockRelation[cRow[BLOCK_LIST_ACCOUNT]].emplace(cRow[BLOCK_LIST_COMPANION]);
+			m_map_strInverseBlockRelation[cRow[BLOCK_LIST_COMPANION]].emplace(cRow[BLOCK_LIST_ACCOUNT]);
+		}
+	}
+
+	__SendBlockList(strAccount);
+	for (const std::string& it : m_map_strInverseBlockRelation[strAccount])
+		__SendBlockLogin(it, strAccount);
+}
+#endif
+
+#if defined(__MESSENGER_GM__)
+void CMessengerManager::__SendGMList(const std::string& c_strAccount)
+{
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	if (c_lpChar == nullptr)
+		return;
+
+	const LPDESC c_lpDesc = c_lpChar->GetDesc();
+	if (c_lpDesc == nullptr)
+		return;
+
+	if (m_map_strGMRelation.find(c_strAccount) == m_map_strGMRelation.end())
+		return;
+
+	if (m_map_strGMRelation[c_strAccount].empty())
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>(128 * 1024);
+	for (const RelationData& it : m_map_strGMRelation[c_strAccount])
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, it.first.c_str(), sizeof(ListPacket.szName));
+		if (m_set_strOnlineAccount.find(it.first) != m_set_strOnlineAccount.end())
+		{
+			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
+#if defined(__MESSENGER_DETAILS__)
+			ListPacket.dwLastPlayTime = 0;
+#endif
+		}
+		else
+		{
+			ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
+#if defined(__MESSENGER_DETAILS__)
+			ListPacket.dwLastPlayTime = it.second.dwLastPlayTime;
+#endif
+		}
+#if defined(__MULTI_LANGUAGE_SYSTEM__) && defined(__MESSENGER_DETAILS__)
+		strlcpy(ListPacket.szCountry, it.second.szCountry, sizeof(ListPacket.szCountry));
+#endif
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_GM_LIST, std::move(TempBuffer));
+}
+
+void CMessengerManager::__SendGMLogin(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc == nullptr)
+		return;
+
+	if (c_lpDesc->GetCharacter() == nullptr)
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
+		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_ONLINE;
+#if defined(__MESSENGER_DETAILS__)
+		const Relations& vRelations = m_map_strGMRelation[c_strAccount];
+		auto it = std::find_if(vRelations.begin(), vRelations.end(),
+			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
+		if (it != vRelations.end())
+		{
+			const CompanionData& c_rCompanionData = it->second;
+			ListPacket.dwLastPlayTime = 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
+#endif
+		}
+		else
+		{
+			ListPacket.dwLastPlayTime = 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, NULL, sizeof(ListPacket.szCountry));
+#endif
+		}
+#endif
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_GM_LOGIN, std::move(TempBuffer));
+}
+
+void CMessengerManager::__SendGMLogout(const std::string& c_strAccount, const std::string& c_strCompanion)
+{
+	if (!c_strCompanion.size())
+		return;
+
+	const LPCHARACTER c_lpChar = CHARACTER_MANAGER::instance().FindPC(c_strAccount.c_str());
+	const LPDESC c_lpDesc = c_lpChar ? c_lpChar->GetDesc() : nullptr;
+	if (c_lpDesc == nullptr)
+		return;
+
+	std::unique_ptr<TEMP_BUFFER> TempBuffer = std::make_unique<TEMP_BUFFER>();
+	{
+		TPacketGCMessengerList ListPacket = {};
+		strlcpy(ListPacket.szName, c_strCompanion.c_str(), sizeof(ListPacket.szName));
+		ListPacket.bConnected = MESSENGER_CONNECTED_STATE_OFFLINE;
+#if defined(__MESSENGER_DETAILS__)
+		const Relations& vRelations = m_map_strGMRelation[c_strAccount];
+		auto it = std::find_if(vRelations.begin(), vRelations.end(),
+			[&](const RelationData& c_rData) { return c_rData.first == c_strCompanion; });
+		if (it != vRelations.end())
+		{
+			const CompanionData& c_rCompanionData = it->second;
+			ListPacket.dwLastPlayTime = c_rCompanionData.dwLastPlayTime;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, c_rCompanionData.szCountry, sizeof(ListPacket.szCountry));
+#endif
+		}
+		else
+		{
+			ListPacket.dwLastPlayTime = 0;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(ListPacket.szCountry, NULL, sizeof(ListPacket.szCountry));
+#endif
+		}
+#endif
+		TempBuffer->write(&ListPacket, sizeof(ListPacket));
+	}
+	__Process(c_lpDesc, MESSENGER_SUBHEADER_GC_GM_LOGOUT, std::move(TempBuffer));
+}
+
+void CMessengerManager::__LoadGMList(SQLMsg* pMsg)
+{
+	if (pMsg == nullptr)
+		return;
+
+	if (pMsg->Get() == nullptr)
+		return;
+
+	if (pMsg->Get()->uiNumRows == 0)
+		return;
+
+	sys_log(1, "Messenger::LoadGMList");
+
+	std::string strAccount;
+	for (UINT uiRow = 0; uiRow < pMsg->Get()->uiNumRows; ++uiRow)
+	{
+		MYSQL_ROW cRow = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		if (cRow[GM_LIST_ROW_ACCOUNT] && cRow[GM_LIST_ROW_COMPANION])
+		{
+			if (strAccount.length() == 0)
+				strAccount = cRow[GM_LIST_ROW_ACCOUNT];
+
+#if defined(__MESSENGER_DETAILS__)
+			CompanionData sCompanion{};
+			sCompanion.dwLastPlayTime = static_cast<DWORD>(cRow[GM_LIST_ROW_COMPANION_LAST_PLAY] ? atol(cRow[GM_LIST_ROW_COMPANION_LAST_PLAY]) : 0);
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			strlcpy(sCompanion.szCountry, cRow[GM_LIST_ROW_COMPANION_LANGUAGE] ? cRow[GM_LIST_ROW_COMPANION_LANGUAGE] : "", sizeof(sCompanion.szCountry));
+#endif
+			m_map_strGMRelation[cRow[GM_LIST_ROW_ACCOUNT]].emplace_back(cRow[GM_LIST_ROW_COMPANION], sCompanion);
+			m_map_strGMInverseRelation[cRow[GM_LIST_ROW_COMPANION]].emplace_back(cRow[GM_LIST_ROW_ACCOUNT], sCompanion);
+#else
+			m_map_strGMRelation[cRow[GM_LIST_ROW_ACCOUNT]].emplace(cRow[GM_LIST_ROW_COMPANION]);
+			m_map_strGMInverseRelation[cRow[GM_LIST_ROW_COMPANION]].emplace(cRow[GM_LIST_ROW_ACCOUNT]);
+#endif
+		}
+	}
+
+	__SendGMList(strAccount);
+#if defined(__MESSENGER_DETAILS__)
+	for (const RelationData& it : m_map_strGMInverseRelation[strAccount])
+		__SendGMLogin(it.first, strAccount);
+#else
+	for (const std::string& it : m_map_strGMInverseRelation[strAccount])
+		__SendGMLogin(it, strAccount);
+#endif
+}
+#endif
+
+void CMessengerManager::__Process(const LPDESC c_lpDesc, const BYTE c_bSubHeader, std::unique_ptr<TEMP_BUFFER> pTempBuffer)
+{
+	if (c_lpDesc == nullptr || pTempBuffer.get() == nullptr)
+		return;
+
+	TPacketGCMessenger Packet = {};
+	Packet.bHeader = HEADER_GC_MESSENGER;
+	Packet.bSubHeader = c_bSubHeader;
+	Packet.wSize = sizeof(Packet) + pTempBuffer->size();
+	if (pTempBuffer->size())
+	{
+		c_lpDesc->BufferedPacket(&Packet, sizeof(Packet));
+		c_lpDesc->Packet(pTempBuffer->read_peek(), pTempBuffer->size());
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/minigame_catchking.cpp b/server/metin2/Source/Server/game/src/minigame_catchking.cpp
index 5d52b6b..311bfda 100644
--- a/server/metin2/Source/Server/game/src/minigame_catchking.cpp
+++ b/server/metin2/Source/Server/game/src/minigame_catchking.cpp
@@ -1,678 +1,681 @@
-#include "stdafx.h"
-
-#if defined(__MINI_GAME_CATCH_KING__)
-#include "minigame_catchking.h"
-
-#include "char.h"
-#include "desc.h"
-#include "char_manager.h"
-#include "desc_manager.h"
-#include "sectree_manager.h"
-#include "questmanager.h"
-#include "config.h"
-#include "db.h"
-#include "unique_item.h"
-
-CMiniGameCatchKing::CMiniGameCatchKing() {}
-CMiniGameCatchKing::~CMiniGameCatchKing() {}
-
-int CMiniGameCatchKing::Process(LPCHARACTER pkChar, const char* c_pszData, size_t uiBytes)
-{
-	const TPacketCGMiniGameCatchKing* pkData = reinterpret_cast<const TPacketCGMiniGameCatchKing*>(c_pszData);
-	if (uiBytes < sizeof(TPacketCGMiniGameCatchKing))
-		return -1;
-
-	uiBytes -= sizeof(TPacketCGMiniGameCatchKing);
-	switch (pkData->bSubHeader)
-	{
-		case CATCHKING_CG_START:
-			StartGame(pkChar, pkData->bSubArgument);
-			return 0;
-
-		case CATCHKING_CG_CLICK_HAND:
-			DeckCardClick(pkChar);
-			return 0;
-
-		case CATCHKING_CG_CLICK_CARD:
-			FieldCardClick(pkChar, pkData->bSubArgument);
-			return 0;
-
-		case CATCHKING_CG_REWARD:
-			GetReward(pkChar);
-			return 0;
-
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-		case CATCHKING_CG_REQUEST_QUEST_FLAG:
-			RequestQuestFlag(pkChar, CATCHKING_GC_SET_QUEST_FLAG);
-			break;
-#endif
-
-		default:
-			sys_err("CMiniGameCatchKing::Process : Unknown SubHeader %d : %s", pkData->bSubHeader, pkChar->GetName());
-			break;
-	}
-
-	return 0;
-}
-
-/* static */ bool CMiniGameCatchKing::IsActiveEvent()
-{
-	if (quest::CQuestManager::instance().GetEventFlag("mini_game_catchking"))
-		return true;
-
-	return false;
-}
-
-/* static */ void CMiniGameCatchKing::SpawnEventNPC(bool bSpawn)
-{
-	CharacterVectorInteractor vChar;
-	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(20506, vChar))
-	{
-		std::for_each(vChar.begin(), vChar.end(), [](LPCHARACTER ch) { M2_DESTROY_CHARACTER(ch); });
-	}
-
-	if (bSpawn)
-	{
-		std::map<long, std::pair<long, long>> vMap
-		{
-			{ MAP_A1, { 608, 623 } },
-			{ MAP_B1, { 596, 614 } },
-			{ MAP_C1, { 350, 738 } },
-		};
-
-		auto it = vMap.begin();
-		for (; it != vMap.end(); ++it)
-		{
-			if (!map_allow_find(it->first))
-				continue;
-
-			const LPSECTREE_MAP c_lpSectree = SECTREE_MANAGER::instance().GetMap(it->first);
-			if (c_lpSectree == nullptr)
-				continue;
-
-			CHARACTER_MANAGER::instance().SpawnMob(20506, it->first,
-				c_lpSectree->m_setting.iBaseX + it->second.first * 100,
-				c_lpSectree->m_setting.iBaseY + it->second.second * 100,
-				0, false, 90, true);
-		}
-	}
-}
-
-/* static */ void CMiniGameCatchKing::StartGame(LPCHARACTER pkChar, BYTE bSetCount)
-{
-	if (pkChar == NULL)
-		return;
-
-	if (!pkChar->GetDesc())
-		return;
-
-	if (pkChar->MiniGameCatchKingGetGameStatus() == true)
-		return;
-
-	if (!IsActiveEvent())
-		return;
-
-	if (bSetCount < 1 || bSetCount > 5)
-		return;
-
-	if (pkChar->GetGold() < (30000 * bSetCount))
-	{
-		pkChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Catch the King] You don't have a complete King Deck or you have insufficient Yang."));
-		return;
-	}
-
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-	const WORD wPackCount = pkChar->GetQuestFlag("minigame_catchking.pack_count");
-	if (wPackCount < bSetCount)
-		return;
-
-	pkChar->SetQuestFlag("minigame_catchking.pack_count", wPackCount - bSetCount);
-#else
-	if (pkChar->CountSpecifyItem(ITEM_VNUM_CATCH_KING_PACK) < bSetCount)
-		return;
-
-	pkChar->RemoveSpecifyItem(ITEM_VNUM_CATCH_KING_PACK, bSetCount);
-#endif
-	pkChar->PointChange(POINT_GOLD, -(30000 * bSetCount));
-
-	std::vector<TCatchKingCard> vFieldCards;
-
-	std::srand(unsigned(std::time(0)));
-
-	for (int i = 0; i < 25; i++)
-	{
-		if (i >= 0 && i < 7)
-			vFieldCards.push_back(TCatchKingCard(1, false));
-		else if (i >= 7 && i < 11)
-			vFieldCards.push_back(TCatchKingCard(2, false));
-		else if (i >= 11 && i < 16)
-			vFieldCards.push_back(TCatchKingCard(3, false));
-		else if (i >= 16 && i < 21)
-			vFieldCards.push_back(TCatchKingCard(4, false));
-		else if (i >= 21 && i < 24)
-			vFieldCards.push_back(TCatchKingCard(5, false));
-		else if (i >= 24)
-			vFieldCards.push_back(TCatchKingCard(6, false)); // 6 = K
-	}
-
-	//std::random_shuffle(m_vecFieldCards.begin(), m_vecFieldCards.end());
-
-	std::random_device rd;
-	std::mt19937 g(rd());
-	std::shuffle(vFieldCards.begin(), vFieldCards.end(), g);
-
-	pkChar->MiniGameCatchKingSetFieldCards(vFieldCards);
-
-	pkChar->MiniGameCatchKingSetBetNumber(bSetCount);
-	pkChar->MiniGameCatchKingSetHandCardLeft(12);
-	pkChar->MiniGameCatchKingSetGameStatus(true);
-
-	DWORD dwBigScore = GetMyScore(pkChar);
-
-	TPacketGCMiniGameCatchKing packet;
-	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
-	packet.bSubHeader = CATCHKING_GC_START;
-
-	packet.wSize = sizeof(packet) + sizeof(dwBigScore);
-
-	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
-	pkChar->GetDesc()->Packet(&dwBigScore, sizeof(DWORD));
-}
-
-/* static */ void CMiniGameCatchKing::DeckCardClick(LPCHARACTER pkChar)
-{
-	if (pkChar == NULL)
-		return;
-
-	if (!pkChar->GetDesc())
-		return;
-
-	if (!IsActiveEvent())
-		return;
-
-	if (pkChar->MiniGameCatchKingGetGameStatus() == false)
-		return;
-
-	if (pkChar->MiniGameCatchKingGetHandCard())
-		return;
-
-	BYTE bCardLeft = pkChar->MiniGameCatchKingGetHandCardLeft();
-
-	if (bCardLeft)
-	{
-		if (bCardLeft <= 12 && bCardLeft > 7)
-			pkChar->MiniGameCatchKingSetHandCard(1);
-		else if (bCardLeft <= 7 && bCardLeft > 5)
-			pkChar->MiniGameCatchKingSetHandCard(2);
-		else if (bCardLeft <= 5 && bCardLeft > 3)
-			pkChar->MiniGameCatchKingSetHandCard(3);
-		else if (bCardLeft == 3)
-			pkChar->MiniGameCatchKingSetHandCard(4);
-		else if (bCardLeft == 2)
-			pkChar->MiniGameCatchKingSetHandCard(5);
-		else if (bCardLeft == 1)
-			pkChar->MiniGameCatchKingSetHandCard(6);
-	}
-	else
-		return;
-
-	BYTE bCardInHand = pkChar->MiniGameCatchKingGetHandCard();
-
-	if (!bCardInHand)
-		return;
-
-	pkChar->MiniGameCatchKingSetHandCardLeft(bCardLeft - 1);
-
-	TPacketGCMiniGameCatchKing packet;
-	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
-	packet.bSubHeader = CATCHKING_GC_SET_CARD;
-
-	packet.wSize = sizeof(packet) + sizeof(bCardInHand);
-
-	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
-	pkChar->GetDesc()->Packet(&bCardInHand, sizeof(BYTE));
-}
-
-/* static */ void CMiniGameCatchKing::FieldCardClick(LPCHARACTER pkChar, BYTE bFieldPos)
-{
-	if (pkChar == NULL)
-		return;
-
-	if (!pkChar->GetDesc())
-		return;
-
-	if (!IsActiveEvent())
-		return;
-
-	if (pkChar->MiniGameCatchKingGetGameStatus() == false)
-		return;
-
-	if (bFieldPos < 0 || bFieldPos > 24)
-		return;
-
-	BYTE bHandCard = pkChar->MiniGameCatchKingGetHandCard();
-	TCatchKingCard filedCard = pkChar->m_vecCatchKingFieldCards[bFieldPos];
-
-	if (!bHandCard)
-		return;
-
-	if (filedCard.bIsExposed == true)
-		return;
-
-	DWORD dwPoints = 0;
-	bool bDestroyCard = false;
-	bool bKeepFieldCard = false;
-	bool bGetReward = false;
-
-	if (bHandCard < 5)
-	{
-		if (bHandCard < filedCard.bIndex)
-		{
-			dwPoints = 0;
-			bDestroyCard = true;
-			bKeepFieldCard = false;
-		}
-		else if (bHandCard == filedCard.bIndex)
-		{
-			dwPoints = filedCard.bIndex * 10;
-			bDestroyCard = true;
-			bKeepFieldCard = true;
-		}
-		else
-		{
-			dwPoints = filedCard.bIndex * 10;
-			bDestroyCard = false;
-			bKeepFieldCard = true;
-		}
-	}
-
-	int checkPos[8];
-	checkPos[0] = bFieldPos - 5;
-	checkPos[1] = bFieldPos + 5;
-	checkPos[2] = (bFieldPos % 10 == 4 || bFieldPos % 10 == 9) ? -1 : (bFieldPos + 1);
-	checkPos[3] = (bFieldPos % 10 == 0 || bFieldPos % 10 == 5) ? -1 : (bFieldPos - 1);
-	checkPos[4] = (bFieldPos % 10 == 4 || bFieldPos % 10 == 9) ? -1 : (bFieldPos - 5 + 1);
-	checkPos[5] = (bFieldPos % 10 == 4 || bFieldPos % 10 == 9) ? -1 : (bFieldPos + 5 + 1);
-	checkPos[6] = (bFieldPos % 10 == 0 || bFieldPos % 10 == 5) ? -1 : (bFieldPos - 5 - 1);
-	checkPos[7] = (bFieldPos % 10 == 0 || bFieldPos % 10 == 5) ? -1 : (bFieldPos + 5 - 1);
-
-	bool isFiveNearby = false;
-
-	for (int i = 0; i < 25; i++)
-	{
-		if (isFiveNearby)
-			break;
-
-		for (int j = 0; j < sizeof(checkPos) / sizeof(checkPos[0]); j++)
-		{
-			if (checkPos[j] < 0 || checkPos[j] >= 25)
-				continue;
-
-			if (i == checkPos[j] && pkChar->m_vecCatchKingFieldCards[i].bIndex == 5)
-			{
-				isFiveNearby = true;
-				break;
-			}
-		}
-	}
-
-	if (bHandCard == 5)
-	{
-		if (isFiveNearby)
-		{
-			dwPoints = 0;
-			bDestroyCard = true;
-			bKeepFieldCard = (bHandCard >= filedCard.bIndex) ? true : false;
-		}
-		else
-		{
-			dwPoints = (bHandCard >= filedCard.bIndex) ? filedCard.bIndex * 10 : 0;
-			bDestroyCard = (bHandCard > filedCard.bIndex) ? false : true;
-			bKeepFieldCard = (bHandCard >= filedCard.bIndex) ? true : false;
-		}
-	}
-
-	if (bHandCard == 6)
-	{
-		dwPoints = (bHandCard == filedCard.bIndex) ? 100 : 0;
-		bDestroyCard = true;
-		bKeepFieldCard = (bHandCard == filedCard.bIndex) ? true : false;
-	}
-
-	if (bKeepFieldCard)
-	{
-		pkChar->m_vecCatchKingFieldCards[bFieldPos].bIsExposed = true;
-	}
-
-	int checkRowPos[4];
-	checkRowPos[0] = 5 * (bFieldPos / 5);
-	checkRowPos[1] = 4 + (5 * (bFieldPos / 5));
-	checkRowPos[2] = bFieldPos - (5 * (bFieldPos / 5));
-	checkRowPos[3] = bFieldPos + 20 - (5 * (bFieldPos / 5));
-
-	bool isHorizontalRow = true;
-	bool isVerticalRow = true;
-
-	for (int row = checkRowPos[0]; row <= checkRowPos[1]; row += 1)
-	{
-		if (!pkChar->m_vecCatchKingFieldCards[row].bIsExposed)
-		{
-			isHorizontalRow = false;
-			break;
-		}
-	}
-
-	for (int col = checkRowPos[2]; col <= checkRowPos[3]; col += 5)
-	{
-		if (!pkChar->m_vecCatchKingFieldCards[col].bIsExposed)
-		{
-			isVerticalRow = false;
-			break;
-		}
-	}
-
-	dwPoints += isHorizontalRow ? 10 : 0;
-	dwPoints += isVerticalRow ? 10 : 0;
-
-	if (dwPoints)
-	{
-		pkChar->MiniGameCatchKingSetScore(pkChar->MiniGameCatchKingGetScore() + dwPoints);
-	}
-
-	bool isTheEnd = false;
-
-	if (bDestroyCard)
-	{
-		bGetReward = (bHandCard == 6 && pkChar->MiniGameCatchKingGetScore() >= 10) ? true : false;
-		isTheEnd = (bHandCard == 6) ? true : false;
-		pkChar->MiniGameCatchKingSetHandCard(0);
-	}
-
-	BYTE bRowType = 0;
-	if (isHorizontalRow && !isVerticalRow)
-	{
-		bRowType = 1;
-	}
-	else if (!isHorizontalRow && isVerticalRow)
-	{
-		bRowType = 2;
-	}
-	else if (isHorizontalRow && isVerticalRow)
-	{
-		bRowType = 3;
-	}
-
-	TPacketGCMiniGameCatchKing packet;
-	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
-	packet.bSubHeader = CATCHKING_GC_RESULT_FIELD;
-
-	TPacketGCMiniGameCatchKingResult packetSecond;
-	packetSecond.dwPoints = pkChar->MiniGameCatchKingGetScore();
-	packetSecond.bRowType = bRowType;
-	packetSecond.bCardPos = bFieldPos;
-	packetSecond.bCardValue = filedCard.bIndex;
-	packetSecond.bKeepFieldCard = bKeepFieldCard;
-	packetSecond.bDestroyHandCard = bDestroyCard;
-	packetSecond.bGetReward = bGetReward;
-	packetSecond.bIsFiveNearBy = isFiveNearby;
-
-	packet.wSize = sizeof(packet) + sizeof(packetSecond);
-
-	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
-	pkChar->GetDesc()->Packet(&packetSecond, sizeof(TPacketGCMiniGameCatchKingResult));
-
-	if (isTheEnd)
-	{
-		for (int i = 0; i < 25; i++)
-		{
-			if (!pkChar->m_vecCatchKingFieldCards[i].bIsExposed)
-			{
-				TPacketGCMiniGameCatchKing packet;
-				packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
-				packet.bSubHeader = CATCHKING_GC_SET_END_CARD;
-
-				TPacketGCMiniGameCatchKingSetEndCard packetSecond;
-				packetSecond.bCardPos = i;
-				packetSecond.bCardValue = pkChar->m_vecCatchKingFieldCards[i].bIndex;
-
-				packet.wSize = sizeof(packet) + sizeof(packetSecond);
-
-				pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
-				pkChar->GetDesc()->Packet(&packetSecond, sizeof(TPacketGCMiniGameCatchKingSetEndCard));
-			}
-		}
-	}
-}
-
-/* static */ void CMiniGameCatchKing::GetReward(LPCHARACTER pkChar)
-{
-	if (pkChar == NULL)
-		return;
-
-	if (!pkChar->GetDesc())
-		return;
-
-	if (!IsActiveEvent())
-		return;
-
-	if (pkChar->MiniGameCatchKingGetGameStatus() == false)
-		return;
-
-	if (pkChar->MiniGameCatchKingGetHandCard())
-		return;
-
-	if (pkChar->MiniGameCatchKingGetHandCardLeft())
-		return;
-
-	DWORD dwRewardVnum = 0;
-	BYTE bReturnCode = 0;
-	DWORD dwScore = pkChar->MiniGameCatchKingGetScore();
-
-	if (dwScore >= 10 && dwScore < 400)
-		dwRewardVnum = 50930;
-	else if (dwScore >= 400 && dwScore < 550)
-		dwRewardVnum = 50929;
-	else if (dwScore >= 550)
-		dwRewardVnum = 50928;
-
-	RegisterScore(pkChar, dwScore);
-
-	if (dwRewardVnum)
-	{
-		pkChar->MiniGameCatchKingSetScore(0);
-		pkChar->AutoGiveItem(dwRewardVnum, pkChar->MiniGameCatchKingGetBetNumber());
-		pkChar->MiniGameCatchKingSetBetNumber(0);
-		pkChar->MiniGameCatchKingSetGameStatus(false);
-		pkChar->m_vecCatchKingFieldCards.clear();
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		pkChar->UpdateExtBattlePassMissionProgress(COMPLETE_MINIGAME, 1, 2);
-#endif
-		bReturnCode = 0;
-	}
-	else
-	{
-		bReturnCode = 1;
-	}
-
-	TPacketGCMiniGameCatchKing packet;
-	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
-	packet.bSubHeader = CATCHKING_GC_REWARD;
-
-	packet.wSize = sizeof(packet) + sizeof(bReturnCode);
-
-	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
-	pkChar->GetDesc()->Packet(&bReturnCode, sizeof(BYTE));
-}
-
-/* static */ void CMiniGameCatchKing::RegisterScore(LPCHARACTER pkChar, DWORD dwScore)
-{
-	if (pkChar == NULL)
-		return;
-
-	if (!pkChar->GetDesc())
-		return;
-
-	char querySelect[256];
-
-	snprintf(querySelect, sizeof(querySelect),
-		"SELECT max_score FROM log.catck_king_event WHERE name = '%s' LIMIT 1;", pkChar->GetName());
-
-	std::unique_ptr<SQLMsg> pSelectMsg(DBManager::instance().DirectQuery(querySelect));
-	SQLResult* resSelect = pSelectMsg->Get();
-
-	if (resSelect && resSelect->uiNumRows > 0)
-	{
-		DWORD maxScore;
-		MYSQL_ROW row = mysql_fetch_row(resSelect->pSQLResult);
-		str_to_number(maxScore, row[0]);
-
-		if (dwScore > maxScore)
-			DBManager::instance().DirectQuery("UPDATE log.catck_king_event SET max_score = %d, total_score = total_score + %d WHERE name = '%s';", dwScore, dwScore, pkChar->GetName());
-		else
-			DBManager::instance().DirectQuery("UPDATE log.catck_king_event SET total_score = total_score + %d WHERE name = '%s';", dwScore, pkChar->GetName());
-	}
-	else
-	{
-		DBManager::instance().DirectQuery("REPLACE INTO log.catck_king_event (name, empire, max_score, total_score) VALUES ('%s', %d, %d, %d);",
-			pkChar->GetName(), pkChar->GetEmpire(), dwScore, dwScore);
-	}
-}
-
-/* static */ int CMiniGameCatchKing::GetScore(lua_State* L, bool isTotal)
-{
-	DWORD index = 1;
-	lua_newtable(L);
-
-	char querySelect[256];
-
-	if (isTotal)
-	{
-		snprintf(querySelect, sizeof(querySelect),
-			"SELECT name, empire, total_score FROM log.catck_king_event ORDER BY total_score DESC LIMIT 10;");
-	}
-	else
-	{
-		snprintf(querySelect, sizeof(querySelect),
-			"SELECT name, empire, max_score FROM log.catck_king_event ORDER BY max_score DESC LIMIT 10;");
-	}
-
-	std::unique_ptr<SQLMsg> pSelectMsg(DBManager::instance().DirectQuery(querySelect));
-	SQLResult* resSelect = pSelectMsg->Get();
-
-	if (resSelect && resSelect->uiNumRows > 0)
-	{
-		for (uint i = 0; i < resSelect->uiNumRows; i++)
-		{
-			MYSQL_ROW row = mysql_fetch_row(resSelect->pSQLResult);
-			BYTE bEmpire;
-			DWORD dwScore;
-
-			str_to_number(bEmpire, row[1]);
-			str_to_number(dwScore, row[2]);
-
-			lua_newtable(L);
-
-			lua_pushstring(L, row[0]);
-			lua_rawseti(L, -2, 1);
-
-			lua_pushnumber(L, bEmpire);
-			lua_rawseti(L, -2, 2);
-
-			lua_pushnumber(L, dwScore);
-			lua_rawseti(L, -2, 3);
-
-			lua_rawseti(L, -2, index++);
-		}
-	}
-
-	return 0;
-}
-
-/* static */ int CMiniGameCatchKing::GetMyScore(LPCHARACTER pkChar, bool isTotal)
-{
-	if (pkChar == NULL)
-		return 0;
-
-	if (!pkChar->GetDesc())
-		return 0;
-
-	char querySelect[256];
-
-	if (isTotal)
-		snprintf(querySelect, sizeof(querySelect), "SELECT total_score FROM log.catck_king_event WHERE name = '%s' LIMIT 1;", pkChar->GetName());
-	else
-		snprintf(querySelect, sizeof(querySelect), "SELECT max_score FROM log.catck_king_event WHERE name = '%s' LIMIT 1;", pkChar->GetName());
-
-	std::unique_ptr<SQLMsg> pSelectMsg(DBManager::instance().DirectQuery(querySelect));
-	SQLResult* resSelect = pSelectMsg->Get();
-
-	if (resSelect && resSelect->uiNumRows > 0)
-	{
-		DWORD dwScore = 0;
-		MYSQL_ROW row = mysql_fetch_row(resSelect->pSQLResult);
-
-		str_to_number(dwScore, row[0]);
-
-		return dwScore;
-	}
-
-	return 0;
-}
-
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-/* static */ bool CMiniGameCatchKing::UpdateQuestFlag(LPCHARACTER pChar)
-{
-	if (!IsActiveEvent())
-		return false;
-
-	const WORD wPieceCount = pChar->GetQuestFlag("minigame_catchking.piece_count");
-	const WORD wPackCount = pChar->GetQuestFlag("minigame_catchking.pack_count");
-
-	if (wPackCount >= CATCH_KING_PACK_COUNT_MAX)
-	{
-		RequestQuestFlag(pChar, CATCHKING_GC_NO_MORE_GAIN);
-		return false;
-	}
-
-	if (wPieceCount + 1 >= CATCH_KING_PIECE_COUNT_MAX)
-	{
-		pChar->SetQuestFlag("minigame_catchking.piece_count", 0);
-		pChar->SetQuestFlag("minigame_catchking.pack_count", wPackCount + 1);
-
-		RequestQuestFlag(pChar, CATCHKING_GC_SET_CARD_FLAG);
-	}
-	else
-	{
-		pChar->SetQuestFlag("minigame_catchking.piece_count", wPieceCount + 1);
-
-		RequestQuestFlag(pChar, CATCHKING_GC_SET_CARD_PIECE_FLAG);
-	}
-
-	return true;
-}
-
-/* static */ void CMiniGameCatchKing::RequestQuestFlag(LPCHARACTER pChar, BYTE bSubHeader)
-{
-	const LPDESC pkDesc = pChar->GetDesc();
-	if (pkDesc == nullptr)
-	{
-		sys_err("CMiniGameCatchKing::RequestQuestFlag - Null DESC! (ch: %s) (%d)",
-			pChar->GetName(), bSubHeader);
-		return;
-	}
-
-	const WORD wPieceCount = pChar->GetQuestFlag("minigame_catchking.piece_count");
-	const WORD wPackCount = pChar->GetQuestFlag("minigame_catchking.pack_count");
-
-	TPacketGCMiniGameCatchKing Packet;
-	Packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
-	Packet.bSubHeader = bSubHeader;
-
-	TPacketGCMiniGameCatchKingQuestFlag QuestFlagPacket(wPieceCount, wPackCount);
-	Packet.wSize = sizeof(Packet) + sizeof(QuestFlagPacket);
-
-	pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameCatchKing));
-	pkDesc->Packet(&QuestFlagPacket, sizeof(TPacketGCMiniGameCatchKingQuestFlag));
-}
-#endif
-#endif
+#include "stdafx.h"
+
+#if defined(__MINI_GAME_CATCH_KING__)
+#include "minigame_catchking.h"
+
+#include "char.h"
+#include "desc.h"
+#include "char_manager.h"
+#include "desc_manager.h"
+#include "sectree_manager.h"
+#include "questmanager.h"
+#include "config.h"
+#include "db.h"
+#include "unique_item.h"
+
+CMiniGameCatchKing::CMiniGameCatchKing() {}
+CMiniGameCatchKing::~CMiniGameCatchKing() {}
+
+int CMiniGameCatchKing::Process(LPCHARACTER pkChar, const char* c_pszData, size_t uiBytes)
+{
+	const TPacketCGMiniGameCatchKing* pkData = reinterpret_cast<const TPacketCGMiniGameCatchKing*>(c_pszData);
+	if (uiBytes < sizeof(TPacketCGMiniGameCatchKing))
+		return -1;
+
+	uiBytes -= sizeof(TPacketCGMiniGameCatchKing);
+	switch (pkData->bSubHeader)
+	{
+		case CATCHKING_CG_START:
+			StartGame(pkChar, pkData->bSubArgument);
+			return 0;
+
+		case CATCHKING_CG_CLICK_HAND:
+			DeckCardClick(pkChar);
+			return 0;
+
+		case CATCHKING_CG_CLICK_CARD:
+			FieldCardClick(pkChar, pkData->bSubArgument);
+			return 0;
+
+		case CATCHKING_CG_REWARD:
+			GetReward(pkChar);
+			return 0;
+
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+		case CATCHKING_CG_REQUEST_QUEST_FLAG:
+			RequestQuestFlag(pkChar, CATCHKING_GC_SET_QUEST_FLAG);
+			break;
+#endif
+
+		default:
+			sys_err("CMiniGameCatchKing::Process : Unknown SubHeader %d : %s", pkData->bSubHeader, pkChar->GetName());
+			break;
+	}
+
+	return 0;
+}
+
+/* static */ bool CMiniGameCatchKing::IsActiveEvent()
+{
+	if (quest::CQuestManager::instance().GetEventFlag("mini_game_catchking"))
+		return true;
+
+	return false;
+}
+
+/* static */ void CMiniGameCatchKing::SpawnEventNPC(bool bSpawn)
+{
+	CharacterVectorInteractor vChar;
+	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(20506, vChar))
+	{
+		std::for_each(vChar.begin(), vChar.end(), [](LPCHARACTER ch) { M2_DESTROY_CHARACTER(ch); });
+	}
+
+	if (bSpawn)
+	{
+		std::map<long, std::pair<long, long>> vMap
+		{
+			{ MAP_A1, { 608, 623 } },
+			{ MAP_B1, { 596, 614 } },
+			{ MAP_C1, { 350, 738 } },
+		};
+
+		auto it = vMap.begin();
+		for (; it != vMap.end(); ++it)
+		{
+			if (!map_allow_find(it->first))
+				continue;
+
+			const LPSECTREE_MAP c_lpSectree = SECTREE_MANAGER::instance().GetMap(it->first);
+			if (c_lpSectree == nullptr)
+				continue;
+
+			CHARACTER_MANAGER::instance().SpawnMob(20506, it->first,
+				c_lpSectree->m_setting.iBaseX + it->second.first * 100,
+				c_lpSectree->m_setting.iBaseY + it->second.second * 100,
+				0, false, 90, true);
+		}
+	}
+}
+
+/* static */ void CMiniGameCatchKing::StartGame(LPCHARACTER pkChar, BYTE bSetCount)
+{
+	if (pkChar == NULL)
+		return;
+
+	if (!pkChar->GetDesc())
+		return;
+
+	if (pkChar->MiniGameCatchKingGetGameStatus() == true)
+		return;
+
+	if (!IsActiveEvent())
+		return;
+
+	if (bSetCount < 1 || bSetCount > 5)
+		return;
+
+	if (pkChar->GetGold() < (30000 * bSetCount))
+	{
+		pkChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Catch the King] You don't have a complete King Deck or you have insufficient Yang."));
+		return;
+	}
+
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+	const WORD wPackCount = pkChar->GetQuestFlag("minigame_catchking.pack_count");
+	if (wPackCount < bSetCount)
+		return;
+
+	pkChar->SetQuestFlag("minigame_catchking.pack_count", wPackCount - bSetCount);
+#else
+	if (pkChar->CountSpecifyItem(ITEM_VNUM_CATCH_KING_PACK) < bSetCount)
+		return;
+
+	pkChar->RemoveSpecifyItem(ITEM_VNUM_CATCH_KING_PACK, bSetCount);
+#endif
+	pkChar->PointChange(POINT_GOLD, -(30000 * bSetCount));
+
+	std::vector<TCatchKingCard> vFieldCards;
+
+	std::srand(unsigned(std::time(0)));
+
+	for (int i = 0; i < 25; i++)
+	{
+		if (i >= 0 && i < 7)
+			vFieldCards.push_back(TCatchKingCard(1, false));
+		else if (i >= 7 && i < 11)
+			vFieldCards.push_back(TCatchKingCard(2, false));
+		else if (i >= 11 && i < 16)
+			vFieldCards.push_back(TCatchKingCard(3, false));
+		else if (i >= 16 && i < 21)
+			vFieldCards.push_back(TCatchKingCard(4, false));
+		else if (i >= 21 && i < 24)
+			vFieldCards.push_back(TCatchKingCard(5, false));
+		else if (i >= 24)
+			vFieldCards.push_back(TCatchKingCard(6, false)); // 6 = K
+	}
+
+	//std::random_shuffle(m_vecFieldCards.begin(), m_vecFieldCards.end());
+
+	std::random_device rd;
+	std::mt19937 g(rd());
+	std::shuffle(vFieldCards.begin(), vFieldCards.end(), g);
+
+	pkChar->MiniGameCatchKingSetFieldCards(vFieldCards);
+
+	pkChar->MiniGameCatchKingSetBetNumber(bSetCount);
+	pkChar->MiniGameCatchKingSetHandCardLeft(12);
+	pkChar->MiniGameCatchKingSetGameStatus(true);
+
+	DWORD dwBigScore = GetMyScore(pkChar);
+
+	TPacketGCMiniGameCatchKing packet;
+	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
+	packet.bSubHeader = CATCHKING_GC_START;
+
+	packet.wSize = sizeof(packet) + sizeof(dwBigScore);
+
+	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
+	pkChar->GetDesc()->Packet(&dwBigScore, sizeof(DWORD));
+}
+
+/* static */ void CMiniGameCatchKing::DeckCardClick(LPCHARACTER pkChar)
+{
+	if (pkChar == NULL)
+		return;
+
+	if (!pkChar->GetDesc())
+		return;
+
+	if (!IsActiveEvent())
+		return;
+
+	if (pkChar->MiniGameCatchKingGetGameStatus() == false)
+		return;
+
+	if (pkChar->MiniGameCatchKingGetHandCard())
+		return;
+
+	BYTE bCardLeft = pkChar->MiniGameCatchKingGetHandCardLeft();
+
+	if (bCardLeft)
+	{
+		if (bCardLeft <= 12 && bCardLeft > 7)
+			pkChar->MiniGameCatchKingSetHandCard(1);
+		else if (bCardLeft <= 7 && bCardLeft > 5)
+			pkChar->MiniGameCatchKingSetHandCard(2);
+		else if (bCardLeft <= 5 && bCardLeft > 3)
+			pkChar->MiniGameCatchKingSetHandCard(3);
+		else if (bCardLeft == 3)
+			pkChar->MiniGameCatchKingSetHandCard(4);
+		else if (bCardLeft == 2)
+			pkChar->MiniGameCatchKingSetHandCard(5);
+		else if (bCardLeft == 1)
+			pkChar->MiniGameCatchKingSetHandCard(6);
+	}
+	else
+		return;
+
+	BYTE bCardInHand = pkChar->MiniGameCatchKingGetHandCard();
+
+	if (!bCardInHand)
+		return;
+
+	pkChar->MiniGameCatchKingSetHandCardLeft(bCardLeft - 1);
+
+	TPacketGCMiniGameCatchKing packet;
+	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
+	packet.bSubHeader = CATCHKING_GC_SET_CARD;
+
+	packet.wSize = sizeof(packet) + sizeof(bCardInHand);
+
+	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
+	pkChar->GetDesc()->Packet(&bCardInHand, sizeof(BYTE));
+}
+
+/* static */ void CMiniGameCatchKing::FieldCardClick(LPCHARACTER pkChar, BYTE bFieldPos)
+{
+	if (pkChar == NULL)
+		return;
+
+	if (!pkChar->GetDesc())
+		return;
+
+	if (!IsActiveEvent())
+		return;
+
+	if (pkChar->MiniGameCatchKingGetGameStatus() == false)
+		return;
+
+	if (bFieldPos < 0 || bFieldPos > 24)
+		return;
+
+	BYTE bHandCard = pkChar->MiniGameCatchKingGetHandCard();
+	TCatchKingCard filedCard = pkChar->m_vecCatchKingFieldCards[bFieldPos];
+
+	if (!bHandCard)
+		return;
+
+	if (filedCard.bIsExposed == true)
+		return;
+
+	DWORD dwPoints = 0;
+	bool bDestroyCard = false;
+	bool bKeepFieldCard = false;
+	bool bGetReward = false;
+
+	if (bHandCard < 5)
+	{
+		if (bHandCard < filedCard.bIndex)
+		{
+			dwPoints = 0;
+			bDestroyCard = true;
+			bKeepFieldCard = false;
+		}
+		else if (bHandCard == filedCard.bIndex)
+		{
+			dwPoints = filedCard.bIndex * 10;
+			bDestroyCard = true;
+			bKeepFieldCard = true;
+		}
+		else
+		{
+			dwPoints = filedCard.bIndex * 10;
+			bDestroyCard = false;
+			bKeepFieldCard = true;
+		}
+	}
+
+	int checkPos[8];
+	checkPos[0] = bFieldPos - 5;
+	checkPos[1] = bFieldPos + 5;
+	checkPos[2] = (bFieldPos % 10 == 4 || bFieldPos % 10 == 9) ? -1 : (bFieldPos + 1);
+	checkPos[3] = (bFieldPos % 10 == 0 || bFieldPos % 10 == 5) ? -1 : (bFieldPos - 1);
+	checkPos[4] = (bFieldPos % 10 == 4 || bFieldPos % 10 == 9) ? -1 : (bFieldPos - 5 + 1);
+	checkPos[5] = (bFieldPos % 10 == 4 || bFieldPos % 10 == 9) ? -1 : (bFieldPos + 5 + 1);
+	checkPos[6] = (bFieldPos % 10 == 0 || bFieldPos % 10 == 5) ? -1 : (bFieldPos - 5 - 1);
+	checkPos[7] = (bFieldPos % 10 == 0 || bFieldPos % 10 == 5) ? -1 : (bFieldPos + 5 - 1);
+
+	bool isFiveNearby = false;
+
+	for (int i = 0; i < 25; i++)
+	{
+		if (isFiveNearby)
+			break;
+
+		for (int j = 0; j < sizeof(checkPos) / sizeof(checkPos[0]); j++)
+		{
+			if (checkPos[j] < 0 || checkPos[j] >= 25)
+				continue;
+
+			if (i == checkPos[j] && pkChar->m_vecCatchKingFieldCards[i].bIndex == 5)
+			{
+				isFiveNearby = true;
+				break;
+			}
+		}
+	}
+
+	if (bHandCard == 5)
+	{
+		if (isFiveNearby)
+		{
+			dwPoints = 0;
+			bDestroyCard = true;
+			bKeepFieldCard = (bHandCard >= filedCard.bIndex) ? true : false;
+		}
+		else
+		{
+			dwPoints = (bHandCard >= filedCard.bIndex) ? filedCard.bIndex * 10 : 0;
+			bDestroyCard = (bHandCard > filedCard.bIndex) ? false : true;
+			bKeepFieldCard = (bHandCard >= filedCard.bIndex) ? true : false;
+		}
+	}
+
+	if (bHandCard == 6)
+	{
+		dwPoints = (bHandCard == filedCard.bIndex) ? 100 : 0;
+		bDestroyCard = true;
+		bKeepFieldCard = (bHandCard == filedCard.bIndex) ? true : false;
+	}
+
+	if (bKeepFieldCard)
+	{
+		pkChar->m_vecCatchKingFieldCards[bFieldPos].bIsExposed = true;
+	}
+
+	int checkRowPos[4];
+	checkRowPos[0] = 5 * (bFieldPos / 5);
+	checkRowPos[1] = 4 + (5 * (bFieldPos / 5));
+	checkRowPos[2] = bFieldPos - (5 * (bFieldPos / 5));
+	checkRowPos[3] = bFieldPos + 20 - (5 * (bFieldPos / 5));
+
+	bool isHorizontalRow = true;
+	bool isVerticalRow = true;
+
+	for (int row = checkRowPos[0]; row <= checkRowPos[1]; row += 1)
+	{
+		if (!pkChar->m_vecCatchKingFieldCards[row].bIsExposed)
+		{
+			isHorizontalRow = false;
+			break;
+		}
+	}
+
+	for (int col = checkRowPos[2]; col <= checkRowPos[3]; col += 5)
+	{
+		if (!pkChar->m_vecCatchKingFieldCards[col].bIsExposed)
+		{
+			isVerticalRow = false;
+			break;
+		}
+	}
+
+	dwPoints += isHorizontalRow ? 10 : 0;
+	dwPoints += isVerticalRow ? 10 : 0;
+
+	if (dwPoints)
+	{
+		pkChar->MiniGameCatchKingSetScore(pkChar->MiniGameCatchKingGetScore() + dwPoints);
+	}
+
+	bool isTheEnd = false;
+
+	if (bDestroyCard)
+	{
+		bGetReward = (bHandCard == 6 && pkChar->MiniGameCatchKingGetScore() >= 10) ? true : false;
+		isTheEnd = (bHandCard == 6) ? true : false;
+		pkChar->MiniGameCatchKingSetHandCard(0);
+	}
+
+	BYTE bRowType = 0;
+	if (isHorizontalRow && !isVerticalRow)
+	{
+		bRowType = 1;
+	}
+	else if (!isHorizontalRow && isVerticalRow)
+	{
+		bRowType = 2;
+	}
+	else if (isHorizontalRow && isVerticalRow)
+	{
+		bRowType = 3;
+	}
+
+	TPacketGCMiniGameCatchKing packet;
+	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
+	packet.bSubHeader = CATCHKING_GC_RESULT_FIELD;
+
+	TPacketGCMiniGameCatchKingResult packetSecond;
+	packetSecond.dwPoints = pkChar->MiniGameCatchKingGetScore();
+	packetSecond.bRowType = bRowType;
+	packetSecond.bCardPos = bFieldPos;
+	packetSecond.bCardValue = filedCard.bIndex;
+	packetSecond.bKeepFieldCard = bKeepFieldCard;
+	packetSecond.bDestroyHandCard = bDestroyCard;
+	packetSecond.bGetReward = bGetReward;
+	packetSecond.bIsFiveNearBy = isFiveNearby;
+
+	packet.wSize = sizeof(packet) + sizeof(packetSecond);
+
+	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
+	pkChar->GetDesc()->Packet(&packetSecond, sizeof(TPacketGCMiniGameCatchKingResult));
+
+	if (isTheEnd)
+	{
+		for (int i = 0; i < 25; i++)
+		{
+			if (!pkChar->m_vecCatchKingFieldCards[i].bIsExposed)
+			{
+				TPacketGCMiniGameCatchKing packet;
+				packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
+				packet.bSubHeader = CATCHKING_GC_SET_END_CARD;
+
+				TPacketGCMiniGameCatchKingSetEndCard packetSecond;
+				packetSecond.bCardPos = i;
+				packetSecond.bCardValue = pkChar->m_vecCatchKingFieldCards[i].bIndex;
+
+				packet.wSize = sizeof(packet) + sizeof(packetSecond);
+
+				pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
+				pkChar->GetDesc()->Packet(&packetSecond, sizeof(TPacketGCMiniGameCatchKingSetEndCard));
+			}
+		}
+	}
+}
+
+/* static */ void CMiniGameCatchKing::GetReward(LPCHARACTER pkChar)
+{
+	if (pkChar == NULL)
+		return;
+
+	if (!pkChar->GetDesc())
+		return;
+
+	if (!IsActiveEvent())
+		return;
+
+	if (pkChar->MiniGameCatchKingGetGameStatus() == false)
+		return;
+
+	if (pkChar->MiniGameCatchKingGetHandCard())
+		return;
+
+	if (pkChar->MiniGameCatchKingGetHandCardLeft())
+		return;
+
+	DWORD dwRewardVnum = 0;
+	BYTE bReturnCode = 0;
+	DWORD dwScore = pkChar->MiniGameCatchKingGetScore();
+
+	if (dwScore >= 10 && dwScore < 400)
+		dwRewardVnum = 50930;
+	else if (dwScore >= 400 && dwScore < 550)
+		dwRewardVnum = 50929;
+	else if (dwScore >= 550)
+		dwRewardVnum = 50928;
+
+	RegisterScore(pkChar, dwScore);
+
+	if (dwRewardVnum)
+	{
+		pkChar->MiniGameCatchKingSetScore(0);
+		pkChar->AutoGiveItem(dwRewardVnum, pkChar->MiniGameCatchKingGetBetNumber());
+		pkChar->MiniGameCatchKingSetBetNumber(0);
+		pkChar->MiniGameCatchKingSetGameStatus(false);
+		pkChar->m_vecCatchKingFieldCards.clear();
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		pkChar->UpdateExtBattlePassMissionProgress(COMPLETE_MINIGAME, 1, 2);
+#endif
+		bReturnCode = 0;
+	}
+	else
+	{
+		bReturnCode = 1;
+	}
+
+	TPacketGCMiniGameCatchKing packet;
+	packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
+	packet.bSubHeader = CATCHKING_GC_REWARD;
+
+	packet.wSize = sizeof(packet) + sizeof(bReturnCode);
+
+	pkChar->GetDesc()->BufferedPacket(&packet, sizeof(TPacketGCMiniGameCatchKing));
+	pkChar->GetDesc()->Packet(&bReturnCode, sizeof(BYTE));
+}
+
+/* static */ void CMiniGameCatchKing::RegisterScore(LPCHARACTER pkChar, DWORD dwScore)
+{
+	if (pkChar == NULL)
+		return;
+
+	if (!pkChar->GetDesc())
+		return;
+
+	char szNameEsc[(CHARACTER_NAME_MAX_LEN + 1) * 2 + 1];
+	DBManager::instance().EscapeString(szNameEsc, sizeof(szNameEsc), pkChar->GetName(), strlen(pkChar->GetName()));
+
+	char querySelect[256];
+
+	snprintf(querySelect, sizeof(querySelect),
+		"SELECT max_score FROM log.catck_king_event WHERE name = '%s' LIMIT 1;", szNameEsc);
+
+	std::unique_ptr<SQLMsg> pSelectMsg(DBManager::instance().DirectQuery(querySelect));
+	SQLResult* resSelect = pSelectMsg->Get();
+
+	if (resSelect && resSelect->uiNumRows > 0)
+	{
+		DWORD maxScore;
+		MYSQL_ROW row = mysql_fetch_row(resSelect->pSQLResult);
+		str_to_number(maxScore, row[0]);
+
+		if (dwScore > maxScore)
+			DBManager::instance().DirectQuery("UPDATE log.catck_king_event SET max_score = %d, total_score = total_score + %d WHERE name = '%s';", dwScore, dwScore, szNameEsc);
+		else
+			DBManager::instance().DirectQuery("UPDATE log.catck_king_event SET total_score = total_score + %d WHERE name = '%s';", dwScore, szNameEsc);
+	}
+	else
+	{
+		DBManager::instance().DirectQuery("REPLACE INTO log.catck_king_event (name, empire, max_score, total_score) VALUES ('%s', %d, %d, %d);",
+			szNameEsc, pkChar->GetEmpire(), dwScore, dwScore);
+	}
+}
+
+/* static */ int CMiniGameCatchKing::GetScore(lua_State* L, bool isTotal)
+{
+	DWORD index = 1;
+	lua_newtable(L);
+
+	char querySelect[256];
+
+	if (isTotal)
+	{
+		snprintf(querySelect, sizeof(querySelect),
+			"SELECT name, empire, total_score FROM log.catck_king_event ORDER BY total_score DESC LIMIT 10;");
+	}
+	else
+	{
+		snprintf(querySelect, sizeof(querySelect),
+			"SELECT name, empire, max_score FROM log.catck_king_event ORDER BY max_score DESC LIMIT 10;");
+	}
+
+	std::unique_ptr<SQLMsg> pSelectMsg(DBManager::instance().DirectQuery(querySelect));
+	SQLResult* resSelect = pSelectMsg->Get();
+
+	if (resSelect && resSelect->uiNumRows > 0)
+	{
+		for (uint i = 0; i < resSelect->uiNumRows; i++)
+		{
+			MYSQL_ROW row = mysql_fetch_row(resSelect->pSQLResult);
+			BYTE bEmpire;
+			DWORD dwScore;
+
+			str_to_number(bEmpire, row[1]);
+			str_to_number(dwScore, row[2]);
+
+			lua_newtable(L);
+
+			lua_pushstring(L, row[0]);
+			lua_rawseti(L, -2, 1);
+
+			lua_pushnumber(L, bEmpire);
+			lua_rawseti(L, -2, 2);
+
+			lua_pushnumber(L, dwScore);
+			lua_rawseti(L, -2, 3);
+
+			lua_rawseti(L, -2, index++);
+		}
+	}
+
+	return 0;
+}
+
+/* static */ int CMiniGameCatchKing::GetMyScore(LPCHARACTER pkChar, bool isTotal)
+{
+	if (pkChar == NULL)
+		return 0;
+
+	if (!pkChar->GetDesc())
+		return 0;
+
+	char querySelect[256];
+
+	if (isTotal)
+		snprintf(querySelect, sizeof(querySelect), "SELECT total_score FROM log.catck_king_event WHERE name = '%s' LIMIT 1;", pkChar->GetName());
+	else
+		snprintf(querySelect, sizeof(querySelect), "SELECT max_score FROM log.catck_king_event WHERE name = '%s' LIMIT 1;", pkChar->GetName());
+
+	std::unique_ptr<SQLMsg> pSelectMsg(DBManager::instance().DirectQuery(querySelect));
+	SQLResult* resSelect = pSelectMsg->Get();
+
+	if (resSelect && resSelect->uiNumRows > 0)
+	{
+		DWORD dwScore = 0;
+		MYSQL_ROW row = mysql_fetch_row(resSelect->pSQLResult);
+
+		str_to_number(dwScore, row[0]);
+
+		return dwScore;
+	}
+
+	return 0;
+}
+
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+/* static */ bool CMiniGameCatchKing::UpdateQuestFlag(LPCHARACTER pChar)
+{
+	if (!IsActiveEvent())
+		return false;
+
+	const WORD wPieceCount = pChar->GetQuestFlag("minigame_catchking.piece_count");
+	const WORD wPackCount = pChar->GetQuestFlag("minigame_catchking.pack_count");
+
+	if (wPackCount >= CATCH_KING_PACK_COUNT_MAX)
+	{
+		RequestQuestFlag(pChar, CATCHKING_GC_NO_MORE_GAIN);
+		return false;
+	}
+
+	if (wPieceCount + 1 >= CATCH_KING_PIECE_COUNT_MAX)
+	{
+		pChar->SetQuestFlag("minigame_catchking.piece_count", 0);
+		pChar->SetQuestFlag("minigame_catchking.pack_count", wPackCount + 1);
+
+		RequestQuestFlag(pChar, CATCHKING_GC_SET_CARD_FLAG);
+	}
+	else
+	{
+		pChar->SetQuestFlag("minigame_catchking.piece_count", wPieceCount + 1);
+
+		RequestQuestFlag(pChar, CATCHKING_GC_SET_CARD_PIECE_FLAG);
+	}
+
+	return true;
+}
+
+/* static */ void CMiniGameCatchKing::RequestQuestFlag(LPCHARACTER pChar, BYTE bSubHeader)
+{
+	const LPDESC pkDesc = pChar->GetDesc();
+	if (pkDesc == nullptr)
+	{
+		sys_err("CMiniGameCatchKing::RequestQuestFlag - Null DESC! (ch: %s) (%d)",
+			pChar->GetName(), bSubHeader);
+		return;
+	}
+
+	const WORD wPieceCount = pChar->GetQuestFlag("minigame_catchking.piece_count");
+	const WORD wPackCount = pChar->GetQuestFlag("minigame_catchking.pack_count");
+
+	TPacketGCMiniGameCatchKing Packet;
+	Packet.bHeader = HEADER_GC_MINI_GAME_CATCH_KING;
+	Packet.bSubHeader = bSubHeader;
+
+	TPacketGCMiniGameCatchKingQuestFlag QuestFlagPacket(wPieceCount, wPackCount);
+	Packet.wSize = sizeof(Packet) + sizeof(QuestFlagPacket);
+
+	pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameCatchKing));
+	pkDesc->Packet(&QuestFlagPacket, sizeof(TPacketGCMiniGameCatchKingQuestFlag));
+}
+#endif
+#endif
diff --git a/server/metin2/Source/Server/game/src/minigame_roulette.cpp b/server/metin2/Source/Server/game/src/minigame_roulette.cpp
index d857b19..06efa9e 100644
--- a/server/metin2/Source/Server/game/src/minigame_roulette.cpp
+++ b/server/metin2/Source/Server/game/src/minigame_roulette.cpp
@@ -1,775 +1,818 @@
-/**
-* Filename: minigame_roulette.cpp
-* Author: Owsap
-* Description: Mini-Game Roulette (Late Summer Event)
-**/
-
-#include "stdafx.h"
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-#include "minigame_roulette.h"
-
-#include "char.h"
-#include "item.h"
-#include "desc.h"
-#include "char_manager.h"
-#include "questmanager.h"
-#include "sectree_manager.h"
-#include "config.h"
-#include "utils.h"
-#include "db.h"
-#include "log.h"
-
-#if defined(__MAILBOX__)
-#	include "MailBox.h"
-#endif
-
-static const char* gs_szQuestFlag_SoulCount = "minigame_roulette.souls";
-static const char* gs_szQuestFlag_UsedSoulCount = "minigame_roulette.used_souls";
-static const char* gs_szQuestFlag_SpecialExpireTime = "minigame_roulette.ritual_expire_time";
-
-EVENTINFO(MiniGameRouletteEventInfo)
-{
-	CMiniGameRoulette* pMiniGameRoulette;
-	MiniGameRouletteEventInfo()
-		: pMiniGameRoulette(NULL)
-	{}
-};
-
-EVENTFUNC(MiniGameSpecialRouletteEvent)
-{
-	MiniGameRouletteEventInfo* pEventInfo = dynamic_cast<MiniGameRouletteEventInfo*>(event->info);
-	if (pEventInfo == NULL)
-	{
-		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null pointer.");
-		return 0;
-	}
-
-	CMiniGameRoulette* pMiniGameRoulette = pEventInfo->pMiniGameRoulette;
-	if (pMiniGameRoulette == NULL)
-	{
-		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null instance.");
-		return 0;
-	}
-
-	LPCHARACTER pChar = pMiniGameRoulette->GetCharacter();
-	if (pChar == NULL)
-	{
-		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null CHARACTER (pc).");
-		return 0;
-	}
-
-	LPCHARACTER pNPC = pMiniGameRoulette->GetRouletteCharacter();
-	if (pNPC == NULL)
-	{
-		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null CHARACTER (npc).");
-		return 0;
-	}
-
-	if (pChar->GetQuestNPC() != pNPC)
-	{
-		sys_err("MiniGameSpecialRouletteEvent: <Factor> Quest NPC != Roulette Character");
-		return 0;
-	}
-
-	pNPC->ViewReencode();
-	return 0;
-}
-
-bool CRouletteManager::ReadRouletteTableFile(const char* c_pszFileName)
-{
-	m_MapperMap.clear();
-	m_ItemMap.clear();
-
-	CTextFileLoader TextFileLoader;
-	if (!TextFileLoader.Load(c_pszFileName))
-		return false;
-
-	if (!__LoadRouletteMapper(TextFileLoader))
-		return false;
-
-	if (!__LoadRouletteItem(TextFileLoader))
-		return false;
-
-	return true;
-}
-
-bool CRouletteManager::__LoadRouletteMapper(CTextFileLoader& TextFileLoader)
-{
-	if (!TextFileLoader.SetChildNode("roulettemapper"))
-	{
-		sys_err("ReadRouletteTableFile : Cannot find `RouletteMapper` node.");
-		return false;
-	}
-
-	TTokenVector* pToken = NULL;
-	for (BYTE bRowIndex = 1; bRowIndex < 256; ++bRowIndex)
-	{
-		if (!TextFileLoader.GetTokenVector(std::to_string(bRowIndex), &pToken))
-			break;
-
-		if (pToken == NULL || pToken->size() < 4)
-		{
-			sys_err("ReadRouletteTableFile : Invalid token vector at row %u", bRowIndex);
-			continue;
-		}
-
-		TMapper Mapper;
-		Mapper.strGroupName = pToken->at(0);
-		std::transform(Mapper.strGroupName.begin(), Mapper.strGroupName.end(), Mapper.strGroupName.begin(), ::tolower);
-
-		if (!str_to_number(Mapper.bType, pToken->at(1).c_str()) ||
-			!str_to_number(Mapper.iPrice, pToken->at(2).c_str()) ||
-			!str_to_number(Mapper.iSoulCount, pToken->at(3).c_str()))
-		{
-			sys_err("ReadRouletteTableFile : Error parsing values at row %u", bRowIndex);
-			continue;
-		}
-
-		m_MapperMap.insert(std::make_pair(bRowIndex, Mapper));
-	}
-
-	if (m_MapperMap.empty())
-	{
-		sys_err("ReadRouletteTableFile : Empty `RouletteMapper`");
-		TextFileLoader.SetParentNode();
-		return false;
-	}
-
-	TextFileLoader.SetParentNode();
-	return true;
-}
-
-bool CRouletteManager::__LoadRouletteItem(CTextFileLoader& TextFileLoader)
-{
-	if (!TextFileLoader.SetChildNode("rouletteitem"))
-	{
-		sys_err("ReadRouletteTableFile : Cannot find `RouletteItem` node.");
-		return false;
-	}
-
-	TTokenVector* pToken = NULL;
-	for (const TMapperMap::value_type& it : m_MapperMap)
-	{
-		const BYTE bMappperIndex = it.first;
-		const TMapper& Mappper = it.second;
-
-		if (!TextFileLoader.SetChildNode(Mappper.strGroupName.c_str()))
-		{
-			sys_err("ReadRouletteTableFile : Cannot find `%s` node in group `RouletteItem`.", Mappper.strGroupName.c_str());
-			return false;
-		}
-
-		for (BYTE bRowIndex = 1; bRowIndex <= ROULETTE_ITEM_MAX; ++bRowIndex)
-		{
-			if (!TextFileLoader.GetTokenVector(std::to_string(bRowIndex), &pToken))
-				break;
-
-			if (pToken == NULL || pToken->size() < 3)
-			{
-				sys_err("ReadRouletteTableFile : Invalid token vector at row %u in group `%s`",
-					bRowIndex, Mappper.strGroupName.c_str());
-				continue;
-			}
-
-			TItem Item;
-			if (!str_to_number(Item.dwVnum, pToken->at(0).c_str()) ||
-				!str_to_number(Item.bCount, pToken->at(1).c_str()) ||
-				!str_to_number(Item.dwWeight, pToken->at(2).c_str()))
-			{
-				sys_err("ReadRouletteTableFile : Error parsing values at row %u in group `%s`",
-					bRowIndex, Mappper.strGroupName.c_str());
-				continue;
-			}
-
-			m_ItemMap[bMappperIndex].push_back(Item);
-		}
-
-		TextFileLoader.SetParentNode();
-	}
-
-	if (m_ItemMap.empty())
-	{
-		sys_err("ReadRouletteTableFile : Empty `RouletteItem`");
-		TextFileLoader.SetParentNode();
-		return false;
-	}
-
-	TextFileLoader.SetParentNode();
-	return true;
-}
-
-BYTE CRouletteManager::GetRandomMapperIndex(BYTE bType) const
-{
-	TMapperMap MapperFilter;
-	for (const TMapperMap::value_type& it : m_MapperMap)
-	{
-		const TMapper& Mapper = it.second;
-		if (Mapper.bType == bType)
-			MapperFilter.insert(std::make_pair(it.first, Mapper));
-	}
-
-	if (MapperFilter.empty())
-	{
-		sys_err("CRouletteManager::GetRandomMapper(bType=%u): Cannot find any Mappers!", bType);
-		return 0;
-	}
-
-	return number(MapperFilter.begin()->first, MapperFilter.rbegin()->first);
-}
-
-const CRouletteManager::TMapper* CRouletteManager::GetMapper(BYTE bRowIndex) const
-{
-	TMapperMap::const_iterator it = m_MapperMap.find(bRowIndex);
-	if (it != m_MapperMap.end())
-		return &(it->second);
-
-	return NULL;
-}
-
-BYTE CRouletteManager::GetRandomItemIndex(BYTE bMapperIndex) const
-{
-	TItemMap::const_iterator it = m_ItemMap.find(bMapperIndex);
-	if (it == m_ItemMap.end() || it->second.empty())
-		return ROULETTE_ITEM_MAX;
-
-	const std::vector<TItem>& vItem = it->second;
-
-	DWORD dwTotalWeight = 0;
-	for (const TItem& Item : vItem)
-		dwTotalWeight += Item.dwWeight;
-
-	DWORD dwRandomWeight = number(1, dwTotalWeight);
-	for (size_t i = 0; i < vItem.size(); ++i)
-	{
-		if (dwRandomWeight <= vItem[i].dwWeight)
-			return static_cast<BYTE>(i);
-
-		dwRandomWeight -= vItem[i].dwWeight;
-	}
-
-	return ROULETTE_ITEM_MAX;
-}
-
-const CRouletteManager::TItem* CRouletteManager::GetItem(BYTE bMapperIndex, BYTE bRowIndex) const
-{
-	TItemMap::const_iterator it = m_ItemMap.find(bMapperIndex);
-	if (it != m_ItemMap.end())
-	{
-		const std::vector<TItem>& Item = it->second;
-		if (bRowIndex < Item.size())
-			return &(Item[bRowIndex]);
-	}
-	return NULL;
-}
-
-const CRouletteManager::TItemVec* CRouletteManager::GetItemVec(BYTE bMapperIndex) const
-{
-	TItemMap::const_iterator it = m_ItemMap.find(bMapperIndex);
-	if (it != m_ItemMap.end())
-		return &(it->second);
-	return NULL;
-}
-
-////////////////////////////////////////////////////////////////////
-
-CMiniGameRoulette::CMiniGameRoulette(LPCHARACTER pNPC, LPCHARACTER pChar, BYTE bType) :
-	m_pNPC(pNPC), m_pChar(pChar), m_bType(bType), m_bIsSpinning(false), m_bSpinCount(0), m_pSpecialRouletteEvent(NULL)
-{
-	Initialize();
-}
-
-CMiniGameRoulette::~CMiniGameRoulette()
-{
-	Destroy();
-}
-
-/* static */ bool CMiniGameRoulette::IsActiveEvent()
-{
-	if (quest::CQuestManager::instance().GetEventFlag("e_late_summer"))
-		return true;
-
-	return false;
-}
-
-/* static */ bool CMiniGameRoulette::IsSpecialRoulette(LPCHARACTER pChar)
-{
-	if (pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime) > get_global_time())
-		return true;
-
-	return false;
-}
-
-/* static */ void CMiniGameRoulette::SpawnEventNPC(bool bSpawn)
-{
-	CharacterVectorInteractor vChar;
-	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(EVENT_NPC, vChar))
-	{
-		std::for_each(vChar.begin(), vChar.end(),
-			[](LPCHARACTER pChar) { M2_DESTROY_CHARACTER(pChar); });
-	}
-
-	if (bSpawn)
-	{
-		struct pixel_pos { long xPos, yPos; int iDir; };
-		std::unordered_map<long, pixel_pos> mSpawnPoint
-		{
-			{ MAP_A1, { 658, 534, 1 } },
-			{ MAP_B1, { 602, 698, 4 } },
-			{ MAP_C1, { 363, 702, 5 } },
-			{ MAP_CAPEDRAGONHEAD, { 510, 1197, 1 } },
-#if defined(__CONQUEROR_LEVEL__)
-			{ MAP_EASTPLAIN_01, { 553, 672, 1 } },
-#endif
-		};
-
-		for (const auto& it : mSpawnPoint)
-		{
-			long lMapIndex = it.first;
-			const auto& pos = it.second;
-
-			if (!map_allow_find(lMapIndex))
-				continue;
-
-			const LPSECTREE_MAP pSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
-			if (pSectreeMap == NULL)
-				continue;
-
-			long xPos = pSectreeMap->m_setting.iBaseX + pos.xPos * 100;
-			long yPos = pSectreeMap->m_setting.iBaseY + pos.yPos * 100;
-
-			CHARACTER_MANAGER::Instance().SpawnMob(EVENT_NPC, lMapIndex,
-				xPos, yPos, 0, false, pos.iDir == 0 ? -1 : (pos.iDir - 1) * 45);
-		}
-	}
-}
-
-struct SLateSummerEvent
-{
-	SLateSummerEvent(LPCHARACTER pChar) : m_pChar(pChar) {}
-	bool UpdateAffect(LPAFFECT pAffect, int iMaxLimit)
-	{
-		if (pAffect == NULL)
-			return false;
-
-		if (pAffect->lApplyValue >= iMaxLimit - 1)
-		{
-			m_pChar->RemoveAffect(pAffect);
-			m_pChar->SetQuestFlag(gs_szQuestFlag_SoulCount, m_pChar->GetQuestFlag(gs_szQuestFlag_SoulCount) + iMaxLimit);
-			m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have collected the maximum number of souls. Visit the Altar of Blood and carry out the ritual!"));
-		}
-		else
-		{
-			pAffect->bUpdate = true;
-			++pAffect->lApplyValue;
-			return true;
-		}
-
-		return false;
-	}
-
-	LPCHARACTER m_pChar;
-};
-
-/* static */ void CMiniGameRoulette::UpdateQuestFlag(LPCHARACTER pChar)
-{
-	SLateSummerEvent LateSummerEvent(pChar);
-
-	LPAFFECT pAffect = pChar->FindAffect(AFFECT_LATE_SUMMER_EVENT_BUFF);
-	if (!LateSummerEvent.UpdateAffect(pAffect, BUFF_SOUL_COUNT))
-	{
-		pAffect = pChar->FindAffect(AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF);
-		LateSummerEvent.UpdateAffect(pAffect, PREMIUM_BUFF_SOUL_COUNT);
-	}
-
-	if (pAffect && pAffect->bUpdate)
-		SendAffectAddPacket(pChar->GetDesc(), pAffect);
-
-	if (pChar->GetQuestFlag(gs_szQuestFlag_SoulCount) < INT_MAX)
-		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have captured a soul."));
-}
-
-/* static */ void CMiniGameRoulette::GetScoreTable(lua_State* L)
-{
-	DWORD dwIndex = 1;
-	lua_newtable(L);
-
-	char szQuery[2048 + 1];
-	int iLen = 0;
-
-	iLen += sprintf(szQuery + iLen, "SELECT `player`.`name`, `score` FROM `minigame_roulette%s` ", get_table_postfix());
-	iLen += sprintf(szQuery + iLen,
-		"LEFT JOIN (SELECT `id`, `name` AS `name` FROM `player%s`) AS `player` ON `player`.`id` = `minigame_roulette%s`.`pid` ",
-		get_table_postfix(), get_table_postfix());
-	iLen += sprintf(szQuery + iLen, "ORDER BY `score` DESC LIMIT 10");
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	const SQLResult* pRes = pMsg->Get();
-	if (pRes && pRes->uiNumRows > 0)
-	{
-		MYSQL_ROW RowData;
-		while ((RowData = mysql_fetch_row(pRes->pSQLResult)))
-		{
-			if (RowData[0][0] == '[') // GM
-				continue;
-
-			DWORD dwScore;
-			str_to_number(dwScore, RowData[1]);
-
-			if (dwScore == 0)
-				continue;
-
-			lua_newtable(L);
-
-			// Name
-			lua_pushstring(L, RowData[0]);
-			lua_rawseti(L, -2, 1);
-
-			// Score
-			lua_pushnumber(L, dwScore);
-			lua_rawseti(L, -2, 2);
-
-			lua_rawseti(L, -2, dwIndex++);
-		}
-	}
-}
-
-/* static */ DWORD CMiniGameRoulette::GetMyScoreValue(lua_State* L, DWORD dwPID)
-{
-	char szQuery[2048 + 1];
-	int iLen = 0;
-
-	iLen += sprintf(szQuery + iLen,
-		"SELECT `score` FROM `minigame_roulette%s` WHERE `pid` = %u ", get_table_postfix(), dwPID);
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	const SQLResult* pRes = pMsg->Get();
-	if (pRes && pRes->uiNumRows > 0)
-	{
-		MYSQL_ROW RowData = mysql_fetch_row(pRes->pSQLResult);
-
-		DWORD dwScore;
-		str_to_number(dwScore, RowData[0]);
-
-		return dwScore;
-	}
-
-	return 0;
-}
-
-/* static */ void CMiniGameRoulette::Open(LPCHARACTER pNPC, LPCHARACTER pChar, BYTE bType)
-{
-	if (pNPC == NULL)
-	{
-		sys_err("CMiniGameRoulette::Open(pNPC=%p, pChar=%p, bType=%d): NULL CHAR %s",
-			get_pointer(pNPC), get_pointer(pChar), pChar->GetName());
-		return;
-	}
-
-	int iDist = DISTANCE_APPROX(pChar->GetX() - pNPC->GetX(), pChar->GetY() - pNPC->GetY());
-	if (iDist >= WINDOW_OPENER_MAX_DISTANCE)
-		return;
-
-	if (IsActiveEvent() == false)
-		return;
-
-	if (pChar->GetMiniGameRoulette())
-		return;
-
-	CMiniGameRoulette* pMiniGameRoulette = M2_NEW CMiniGameRoulette(pNPC, pChar, bType);
-	if (pMiniGameRoulette == NULL)
-		return;
-
-	pMiniGameRoulette->SendPacket(ROULETTE_GC_OPEN);
-	pChar->SetMiniGameRoulette(pMiniGameRoulette);
-}
-
-void CMiniGameRoulette::Initialize()
-{
-	const BYTE bMapperIndex = m_pChar->GetMiniGameRoulette_RewardMapperNum();
-
-	m_bMapperIndex = bMapperIndex != 0 ? bMapperIndex : CRouletteManager::Instance().GetRandomMapperIndex(m_bType);
-	m_pChar->SetMiniGameRoulette_RewardMapperNum(m_bMapperIndex);
-
-	m_bItemIndex = ROULETTE_ITEM_MAX;
-
-	const CRouletteManager::TMapper* pMapper = CRouletteManager::Instance().GetMapper(m_bMapperIndex);
-	if (pMapper == NULL)
-	{
-		CloseError("CMiniGameRoulette::Initialize(): Failed to find TMapper for bMapperNum: %d", m_bMapperIndex);
-		return;
-	}
-
-	m_iPrice = pMapper->iPrice;
-	m_iSoulCount = pMapper->iSoulCount;
-
-	if (m_bType == TYPE_SPECIAL)
-	{
-		int iSpecialRouletteTime = m_pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime);
-		if (iSpecialRouletteTime > get_global_time())
-		{
-			MiniGameRouletteEventInfo* pSpecialRouletteEvent = AllocEventInfo<MiniGameRouletteEventInfo>();
-			pSpecialRouletteEvent->pMiniGameRoulette = this;
-			SetSpecialRouletteEvent(event_create(MiniGameSpecialRouletteEvent, pSpecialRouletteEvent, PASSES_PER_SEC(iSpecialRouletteTime - get_global_time())));
-		}
-	}
-}
-
-void CMiniGameRoulette::Destroy()
-{
-	if (m_bIsSpinning)
-		Recover();
-
-	m_bType = TYPE_NORMAL;
-	m_bMapperIndex = 0;
-	m_bItemIndex = ROULETTE_ITEM_MAX;
-	m_iPrice = 0;
-	m_iSoulCount = 0;
-
-	m_pChar = NULL;
-	m_pNPC = NULL;
-
-	m_bIsSpinning = false;
-	m_bSpinCount = 0;
-
-	SetSpecialRouletteEvent(NULL);
-}
-
-void CMiniGameRoulette::Start()
-{
-	if (m_bIsSpinning)
-		return;
-
-	if (m_bType == TYPE_SPECIAL)
-	{
-		if (get_global_time() > m_pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime))
-		{
-			m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Ritual of Blood is over. Try again another time."));
-			Close(true); // NOTE : Force close window if the ritual of blood if over.
-			return;
-		}
-	}
-
-	// NOTE : Always check if there is any available position, all rewards are size 1.
-	const int iEmptyPos = m_pChar->GetEmptyInventory(1);
-	if (iEmptyPos == -1)
-	{
-		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Ritual of Blood] You don't have enough space in your inventory."));
-		return;
-	}
-
-	if (m_pChar->GetGold() < m_iPrice)
-	{
-		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Ritual of Blood] You don't have enough Yang."));
-		return;
-	}
-
-	int iSoulCount = m_pChar->GetQuestFlag(gs_szQuestFlag_SoulCount);
-	int iUsedSoulCount = m_pChar->GetQuestFlag(gs_szQuestFlag_UsedSoulCount);
-
-	if (iSoulCount < m_iSoulCount)
-	{
-		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Ritual of Blood] You don't have enough souls."));
-		return;
-	}
-
-	m_bItemIndex = CRouletteManager::Instance().GetRandomItemIndex(m_bMapperIndex);
-	if (m_bItemIndex == ROULETTE_ITEM_MAX)
-	{
-		CloseError("CMiniGameRoulette::Start: Failed to get item index for mapper index: %d", m_bMapperIndex);
-		return;
-	}
-
-	m_pChar->PointChange(POINT_GOLD, -m_iPrice);
-	m_pChar->SetQuestFlag(gs_szQuestFlag_SoulCount, iSoulCount - m_iSoulCount);
-	m_pChar->SetQuestFlag(gs_szQuestFlag_UsedSoulCount, iUsedSoulCount + m_iSoulCount);
-
-	m_bIsSpinning = true;
-	m_bSpinCount += 1;
-
-	SendPacket(ROULETTE_GC_START);
-}
-
-void CMiniGameRoulette::Request()
-{
-	SendPacket(ROULETTE_GC_REQUEST);
-}
-
-void CMiniGameRoulette::End()
-{
-	if (!m_bIsSpinning)
-		return;
-
-	int iUsedSoulCount = m_pChar->GetQuestFlag(gs_szQuestFlag_UsedSoulCount);
-	if (iUsedSoulCount >= SOUL_MAX_NUM)
-	{
-		if (m_pNPC == m_pChar->GetQuestNPC())
-		{
-			TPacketGCSpecialEffect p;
-			p.bHeader = HEADER_GC_SEPCIAL_EFFECT;
-			p.bEffectNum = SE_SPECIAL_ROULETTE;
-			p.dwVID = m_pNPC->GetVID();
-			m_pChar->GetDesc()->Packet(&p, sizeof(p));
-		}
-
-		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Ritual of Blood has started. Buy special items to get better rewards."));
-		m_pChar->SetQuestFlag(gs_szQuestFlag_SpecialExpireTime, get_global_time() + (test_server ? 60 : SPECIAL_ROULETTE_EXPIRE_TIME));
-		m_pChar->SetQuestFlag(gs_szQuestFlag_UsedSoulCount, 0);
-	}
-
-	const CRouletteManager::TItem* pItemData = CRouletteManager::Instance().GetItem(m_bMapperIndex, m_bItemIndex);
-	if (pItemData == NULL)
-	{
-		CloseError("CMiniGameRoulette::Start: Failed to get item index for mapper index: %d", m_bMapperIndex);
-		return;
-	}
-
-	if (m_pChar->AutoGiveItem(pItemData->dwVnum, pItemData->bCount, -1, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, true /* isHighLight */
-#endif
-#if defined(__NEW_USER_CARE__)
-		, false /* bSystemDrop */
-#endif
-	) == NULL)
-	{
-#if defined(__MAILBOX__)
-		CMailBox::SendGMMail(m_pChar->GetName(),
-			LC_STRING("Reward for Ritual of Blood"),
-			"",
-			pItemData->dwVnum, pItemData->bCount);
-
-		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Insufficient space in your inventory. The reward will be sent to your mailbox."));
-#else
-		sys_log(0, "ROULETTE ITEM: Cannot find empty position for item %u (ch : %s)", pItemData->dwVnum, m_pChar->GetName());
-
-		char szQuery[2048 + 1];
-		snprintf(szQuery, sizeof(szQuery), "INSERT INTO `item_award%s` (`login`, `vnum`, `count`, `given_time`) VALUES('%s', %u, %u, NOW())",
-			get_table_postfix(), m_pChar->GetDesc()->GetAccountTable().login, pItemData->dwVnum, pItemData->bCount);
-
-		DBManager::instance().DirectQuery(szQuery);
-#endif
-	}
-
-	m_bItemIndex = ROULETTE_ITEM_MAX;
-	m_bIsSpinning = false;
-
-	UpdateMyScore(m_pChar->GetPlayerID());
-}
-
-void CMiniGameRoulette::Close(bool bForce)
-{
-	if (bForce)
-		SendPacket(ROULETTE_GC_CLOSE);
-
-	if (m_pChar)
-		m_pChar->SetMiniGameRoulette(NULL);
-}
-
-void CMiniGameRoulette::CloseError(const char* format, ...)
-{
-	char buf[255 + 1];
-	va_list args;
-
-	va_start(args, format);
-	vsnprintf(buf, sizeof(buf), format, args);
-	va_end(args);
-
-	sys_err(buf);
-
-	Close(true);
-}
-
-void CMiniGameRoulette::Recover()
-{
-	if (m_bIsSpinning == false)
-		return;
-
-	const CRouletteManager::TItem* pItemData = CRouletteManager::Instance().GetItem(m_bMapperIndex, m_bItemIndex);
-	if (pItemData == NULL)
-	{
-		sys_err("CMiniGameRoulette::Recover : Item Data (%u) NULL (ch : %s)",
-			m_bMapperIndex, m_pChar->GetName());
-		return;
-	}
-
-#if defined(__MAILBOX__)
-	CMailBox::SendGMMail(m_pChar->GetName(), LC_STRING("Reward for Ritual of Blood"), "", pItemData->dwVnum, pItemData->bCount);
-#else
-	char szQuery[2048 + 1];
-	snprintf(szQuery, sizeof(szQuery), "INSERT INTO `item_award%s` (`login`, `vnum`, `count`, `given_time`) VALUES('%s', %u, %u, NOW())",
-		get_table_postfix(), m_pChar->GetDesc()->GetAccountTable().login, pItemData->dwVnum, pItemData->bCount);
-
-	DBManager::instance().DirectQuery(szQuery);
-#endif
-}
-
-void CMiniGameRoulette::SendPacket(BYTE bSubHeader)
-{
-	if (m_pChar == NULL)
-		return;
-
-	LPDESC pDesc = m_pChar->GetDesc();
-	if (pDesc == NULL)
-		return;
-
-	TPacketGCMiniGameRoulette MiniGameRoulette;
-	MiniGameRoulette.bHeader = HEADER_GC_MINI_GAME_ROULETTE;
-	MiniGameRoulette.bSubHeader = bSubHeader;
-	MiniGameRoulette.bResult = m_bItemIndex;
-	if (m_bType == TYPE_SPECIAL)
-		MiniGameRoulette.dwExpireTime = m_pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime);
-	else
-		MiniGameRoulette.dwExpireTime = 0;
-
-	switch (bSubHeader)
-	{
-		case ROULETTE_GC_OPEN:
-		{
-			const CRouletteManager::TItemVec* pItemVec = CRouletteManager::Instance().GetItemVec(m_bMapperIndex);
-			if (pItemVec == NULL)
-			{
-				CloseError("CMiniGameRoulette::Initialize: pItemVec == NULL! (ch : %s)", m_pChar->GetName());
-				return;
-			}
-
-			for (size_t i = 0; i < pItemVec->size(); i++)
-			{
-				MiniGameRoulette.ItemData[i].dwVnum = (*pItemVec)[i].dwVnum;
-				MiniGameRoulette.ItemData[i].bCount = (*pItemVec)[i].bCount;
-			}
-		}
-		break;
-
-		case ROULETTE_GC_START:
-		case ROULETTE_GC_REQUEST:
-		case ROULETTE_GC_END:
-		case ROULETTE_GC_CLOSE:
-			break;
-
-		default:
-			sys_log(0, "CMiniGameRoulette::SendPacket(bSubHeader=%u): Unknown SubHeader! (ch : %s)",
-				bSubHeader, m_pChar->GetName());
-			break;
-	}
-
-	pDesc->Packet(&MiniGameRoulette, sizeof(MiniGameRoulette));
-}
-
-void CMiniGameRoulette::SetSpecialRouletteEvent(LPEVENT pEvent)
-{
-	if (m_pSpecialRouletteEvent != NULL)
-		event_cancel(&m_pSpecialRouletteEvent);
-
-	m_pSpecialRouletteEvent = pEvent;
-}
-
-void CMiniGameRoulette::UpdateMyScore(DWORD dwPID)
-{
-	char szQuery[2048 + 1];
-	int iLen = sprintf(szQuery, "INSERT INTO `minigame_roulette%s` (`pid`, `score`, `last_play`) ", get_table_postfix());
-	iLen += sprintf(szQuery + iLen, "VALUES (%u, %u, FROM_UNIXTIME(%d)) ", dwPID, m_iSoulCount, std::time(nullptr));
-	iLen += sprintf(szQuery + iLen, "ON DUPLICATE KEY UPDATE `score` = `score` + %d", m_iSoulCount);
-	DBManager::instance().DirectQuery(szQuery);
-}
-#endif // __SUMMER_EVENT_ROULETTE__
+#include <cstdarg>
+
+static bool SafeAppendQuery(char* buf, size_t cap, size_t& len, const char* fmt, ...)
+{
+	if (!buf || cap == 0 || len >= cap)
+		return false;
+	va_list ap;
+	va_start(ap, fmt);
+	int n = vsnprintf(buf + len, cap - len, fmt, ap);
+	va_end(ap);
+	if (n < 0)
+		return false;
+	if ((size_t)n >= cap - len)
+		return false;
+	len += (size_t)n;
+	return true;
+}
+/**
+* Filename: minigame_roulette.cpp
+* Author: Owsap
+* Description: Mini-Game Roulette (Late Summer Event)
+**/
+
+#include "stdafx.h"
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+#include "minigame_roulette.h"
+
+#include "char.h"
+#include "item.h"
+#include "desc.h"
+#include "char_manager.h"
+#include "questmanager.h"
+#include "sectree_manager.h"
+#include "config.h"
+#include "utils.h"
+#include "db.h"
+#include "log.h"
+#include <cstdarg>
+
+// Safe query builder: prevents buffer overflows when composing SQL.
+static bool SafeAppendQuery(char* buf, size_t bufSize, int& len, const char* fmt, ...)
+{
+	if (!buf || bufSize == 0 || len < 0 || (size_t)len >= bufSize)
+		return false;
+	va_list args;
+	va_start(args, fmt);
+	const int written = vsnprintf(buf + len, bufSize - (size_t)len, fmt, args);
+	va_end(args);
+	if (written < 0)
+		return false;
+	if ((size_t)written >= bufSize - (size_t)len)
+		return false;
+	len += written;
+	return true;
+}
+
+#if defined(__MAILBOX__)
+#	include "MailBox.h"
+#endif
+
+static const char* gs_szQuestFlag_SoulCount = "minigame_roulette.souls";
+static const char* gs_szQuestFlag_UsedSoulCount = "minigame_roulette.used_souls";
+static const char* gs_szQuestFlag_SpecialExpireTime = "minigame_roulette.ritual_expire_time";
+
+EVENTINFO(MiniGameRouletteEventInfo)
+{
+	CMiniGameRoulette* pMiniGameRoulette;
+	MiniGameRouletteEventInfo()
+		: pMiniGameRoulette(NULL)
+	{}
+};
+
+EVENTFUNC(MiniGameSpecialRouletteEvent)
+{
+	MiniGameRouletteEventInfo* pEventInfo = dynamic_cast<MiniGameRouletteEventInfo*>(event->info);
+	if (pEventInfo == NULL)
+	{
+		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null pointer.");
+		return 0;
+	}
+
+	CMiniGameRoulette* pMiniGameRoulette = pEventInfo->pMiniGameRoulette;
+	if (pMiniGameRoulette == NULL)
+	{
+		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null instance.");
+		return 0;
+	}
+
+	LPCHARACTER pChar = pMiniGameRoulette->GetCharacter();
+	if (pChar == NULL)
+	{
+		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null CHARACTER (pc).");
+		return 0;
+	}
+
+	LPCHARACTER pNPC = pMiniGameRoulette->GetRouletteCharacter();
+	if (pNPC == NULL)
+	{
+		sys_err("MiniGameSpecialRouletteEvent: <Factor> Null CHARACTER (npc).");
+		return 0;
+	}
+
+	if (pChar->GetQuestNPC() != pNPC)
+	{
+		sys_err("MiniGameSpecialRouletteEvent: <Factor> Quest NPC != Roulette Character");
+		return 0;
+	}
+
+	pNPC->ViewReencode();
+	return 0;
+}
+
+bool CRouletteManager::ReadRouletteTableFile(const char* c_pszFileName)
+{
+	m_MapperMap.clear();
+	m_ItemMap.clear();
+
+	CTextFileLoader TextFileLoader;
+	if (!TextFileLoader.Load(c_pszFileName))
+		return false;
+
+	if (!__LoadRouletteMapper(TextFileLoader))
+		return false;
+
+	if (!__LoadRouletteItem(TextFileLoader))
+		return false;
+
+	return true;
+}
+
+bool CRouletteManager::__LoadRouletteMapper(CTextFileLoader& TextFileLoader)
+{
+	if (!TextFileLoader.SetChildNode("roulettemapper"))
+	{
+		sys_err("ReadRouletteTableFile : Cannot find `RouletteMapper` node.");
+		return false;
+	}
+
+	TTokenVector* pToken = NULL;
+	for (BYTE bRowIndex = 1; bRowIndex < 256; ++bRowIndex)
+	{
+		if (!TextFileLoader.GetTokenVector(std::to_string(bRowIndex), &pToken))
+			break;
+
+		if (pToken == NULL || pToken->size() < 4)
+		{
+			sys_err("ReadRouletteTableFile : Invalid token vector at row %u", bRowIndex);
+			continue;
+		}
+
+		TMapper Mapper;
+		Mapper.strGroupName = pToken->at(0);
+		std::transform(Mapper.strGroupName.begin(), Mapper.strGroupName.end(), Mapper.strGroupName.begin(), ::tolower);
+
+		if (!str_to_number(Mapper.bType, pToken->at(1).c_str()) ||
+			!str_to_number(Mapper.iPrice, pToken->at(2).c_str()) ||
+			!str_to_number(Mapper.iSoulCount, pToken->at(3).c_str()))
+		{
+			sys_err("ReadRouletteTableFile : Error parsing values at row %u", bRowIndex);
+			continue;
+		}
+
+		m_MapperMap.insert(std::make_pair(bRowIndex, Mapper));
+	}
+
+	if (m_MapperMap.empty())
+	{
+		sys_err("ReadRouletteTableFile : Empty `RouletteMapper`");
+		TextFileLoader.SetParentNode();
+		return false;
+	}
+
+	TextFileLoader.SetParentNode();
+	return true;
+}
+
+bool CRouletteManager::__LoadRouletteItem(CTextFileLoader& TextFileLoader)
+{
+	if (!TextFileLoader.SetChildNode("rouletteitem"))
+	{
+		sys_err("ReadRouletteTableFile : Cannot find `RouletteItem` node.");
+		return false;
+	}
+
+	TTokenVector* pToken = NULL;
+	for (const TMapperMap::value_type& it : m_MapperMap)
+	{
+		const BYTE bMappperIndex = it.first;
+		const TMapper& Mappper = it.second;
+
+		if (!TextFileLoader.SetChildNode(Mappper.strGroupName.c_str()))
+		{
+			sys_err("ReadRouletteTableFile : Cannot find `%s` node in group `RouletteItem`.", Mappper.strGroupName.c_str());
+			return false;
+		}
+
+		for (BYTE bRowIndex = 1; bRowIndex <= ROULETTE_ITEM_MAX; ++bRowIndex)
+		{
+			if (!TextFileLoader.GetTokenVector(std::to_string(bRowIndex), &pToken))
+				break;
+
+			if (pToken == NULL || pToken->size() < 3)
+			{
+				sys_err("ReadRouletteTableFile : Invalid token vector at row %u in group `%s`",
+					bRowIndex, Mappper.strGroupName.c_str());
+				continue;
+			}
+
+			TItem Item;
+			if (!str_to_number(Item.dwVnum, pToken->at(0).c_str()) ||
+				!str_to_number(Item.bCount, pToken->at(1).c_str()) ||
+				!str_to_number(Item.dwWeight, pToken->at(2).c_str()))
+			{
+				sys_err("ReadRouletteTableFile : Error parsing values at row %u in group `%s`",
+					bRowIndex, Mappper.strGroupName.c_str());
+				continue;
+			}
+
+			m_ItemMap[bMappperIndex].push_back(Item);
+		}
+
+		TextFileLoader.SetParentNode();
+	}
+
+	if (m_ItemMap.empty())
+	{
+		sys_err("ReadRouletteTableFile : Empty `RouletteItem`");
+		TextFileLoader.SetParentNode();
+		return false;
+	}
+
+	TextFileLoader.SetParentNode();
+	return true;
+}
+
+BYTE CRouletteManager::GetRandomMapperIndex(BYTE bType) const
+{
+	TMapperMap MapperFilter;
+	for (const TMapperMap::value_type& it : m_MapperMap)
+	{
+		const TMapper& Mapper = it.second;
+		if (Mapper.bType == bType)
+			MapperFilter.insert(std::make_pair(it.first, Mapper));
+	}
+
+	if (MapperFilter.empty())
+	{
+		sys_err("CRouletteManager::GetRandomMapper(bType=%u): Cannot find any Mappers!", bType);
+		return 0;
+	}
+
+	return number(MapperFilter.begin()->first, MapperFilter.rbegin()->first);
+}
+
+const CRouletteManager::TMapper* CRouletteManager::GetMapper(BYTE bRowIndex) const
+{
+	TMapperMap::const_iterator it = m_MapperMap.find(bRowIndex);
+	if (it != m_MapperMap.end())
+		return &(it->second);
+
+	return NULL;
+}
+
+BYTE CRouletteManager::GetRandomItemIndex(BYTE bMapperIndex) const
+{
+	TItemMap::const_iterator it = m_ItemMap.find(bMapperIndex);
+	if (it == m_ItemMap.end() || it->second.empty())
+		return ROULETTE_ITEM_MAX;
+
+	const std::vector<TItem>& vItem = it->second;
+
+	DWORD dwTotalWeight = 0;
+	for (const TItem& Item : vItem)
+		dwTotalWeight += Item.dwWeight;
+
+	DWORD dwRandomWeight = number(1, dwTotalWeight);
+	for (size_t i = 0; i < vItem.size(); ++i)
+	{
+		if (dwRandomWeight <= vItem[i].dwWeight)
+			return static_cast<BYTE>(i);
+
+		dwRandomWeight -= vItem[i].dwWeight;
+	}
+
+	return ROULETTE_ITEM_MAX;
+}
+
+const CRouletteManager::TItem* CRouletteManager::GetItem(BYTE bMapperIndex, BYTE bRowIndex) const
+{
+	TItemMap::const_iterator it = m_ItemMap.find(bMapperIndex);
+	if (it != m_ItemMap.end())
+	{
+		const std::vector<TItem>& Item = it->second;
+		if (bRowIndex < Item.size())
+			return &(Item[bRowIndex]);
+	}
+	return NULL;
+}
+
+const CRouletteManager::TItemVec* CRouletteManager::GetItemVec(BYTE bMapperIndex) const
+{
+	TItemMap::const_iterator it = m_ItemMap.find(bMapperIndex);
+	if (it != m_ItemMap.end())
+		return &(it->second);
+	return NULL;
+}
+
+////////////////////////////////////////////////////////////////////
+
+CMiniGameRoulette::CMiniGameRoulette(LPCHARACTER pNPC, LPCHARACTER pChar, BYTE bType) :
+	m_pNPC(pNPC), m_pChar(pChar), m_bType(bType), m_bIsSpinning(false), m_bSpinCount(0), m_pSpecialRouletteEvent(NULL)
+{
+	Initialize();
+}
+
+CMiniGameRoulette::~CMiniGameRoulette()
+{
+	Destroy();
+}
+
+/* static */ bool CMiniGameRoulette::IsActiveEvent()
+{
+	if (quest::CQuestManager::instance().GetEventFlag("e_late_summer"))
+		return true;
+
+	return false;
+}
+
+/* static */ bool CMiniGameRoulette::IsSpecialRoulette(LPCHARACTER pChar)
+{
+	if (pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime) > get_global_time())
+		return true;
+
+	return false;
+}
+
+/* static */ void CMiniGameRoulette::SpawnEventNPC(bool bSpawn)
+{
+	CharacterVectorInteractor vChar;
+	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(EVENT_NPC, vChar))
+	{
+		std::for_each(vChar.begin(), vChar.end(),
+			[](LPCHARACTER pChar) { M2_DESTROY_CHARACTER(pChar); });
+	}
+
+	if (bSpawn)
+	{
+		struct pixel_pos { long xPos, yPos; int iDir; };
+		std::unordered_map<long, pixel_pos> mSpawnPoint
+		{
+			{ MAP_A1, { 658, 534, 1 } },
+			{ MAP_B1, { 602, 698, 4 } },
+			{ MAP_C1, { 363, 702, 5 } },
+			{ MAP_CAPEDRAGONHEAD, { 510, 1197, 1 } },
+#if defined(__CONQUEROR_LEVEL__)
+			{ MAP_EASTPLAIN_01, { 553, 672, 1 } },
+#endif
+		};
+
+		for (const auto& it : mSpawnPoint)
+		{
+			long lMapIndex = it.first;
+			const auto& pos = it.second;
+
+			if (!map_allow_find(lMapIndex))
+				continue;
+
+			const LPSECTREE_MAP pSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
+			if (pSectreeMap == NULL)
+				continue;
+
+			long xPos = pSectreeMap->m_setting.iBaseX + pos.xPos * 100;
+			long yPos = pSectreeMap->m_setting.iBaseY + pos.yPos * 100;
+
+			CHARACTER_MANAGER::Instance().SpawnMob(EVENT_NPC, lMapIndex,
+				xPos, yPos, 0, false, pos.iDir == 0 ? -1 : (pos.iDir - 1) * 45);
+		}
+	}
+}
+
+struct SLateSummerEvent
+{
+	SLateSummerEvent(LPCHARACTER pChar) : m_pChar(pChar) {}
+	bool UpdateAffect(LPAFFECT pAffect, int iMaxLimit)
+	{
+		if (pAffect == NULL)
+			return false;
+
+		if (pAffect->lApplyValue >= iMaxLimit - 1)
+		{
+			m_pChar->RemoveAffect(pAffect);
+			m_pChar->SetQuestFlag(gs_szQuestFlag_SoulCount, m_pChar->GetQuestFlag(gs_szQuestFlag_SoulCount) + iMaxLimit);
+			m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have collected the maximum number of souls. Visit the Altar of Blood and carry out the ritual!"));
+		}
+		else
+		{
+			pAffect->bUpdate = true;
+			++pAffect->lApplyValue;
+			return true;
+		}
+
+		return false;
+	}
+
+	LPCHARACTER m_pChar;
+};
+
+/* static */ void CMiniGameRoulette::UpdateQuestFlag(LPCHARACTER pChar)
+{
+	SLateSummerEvent LateSummerEvent(pChar);
+
+	LPAFFECT pAffect = pChar->FindAffect(AFFECT_LATE_SUMMER_EVENT_BUFF);
+	if (!LateSummerEvent.UpdateAffect(pAffect, BUFF_SOUL_COUNT))
+	{
+		pAffect = pChar->FindAffect(AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF);
+		LateSummerEvent.UpdateAffect(pAffect, PREMIUM_BUFF_SOUL_COUNT);
+	}
+
+	if (pAffect && pAffect->bUpdate)
+		SendAffectAddPacket(pChar->GetDesc(), pAffect);
+
+	if (pChar->GetQuestFlag(gs_szQuestFlag_SoulCount) < INT_MAX)
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have captured a soul."));
+}
+
+/* static */ void CMiniGameRoulette::GetScoreTable(lua_State* L)
+{
+	DWORD dwIndex = 1;
+	lua_newtable(L);
+
+	char szQuery[2048 + 1];
+	int iLen = 0;
+
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "SELECT `player`.`name`, `score` FROM `minigame_roulette%s` ", get_table_postfix()))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen,
+		"LEFT JOIN (SELECT `id`, `name` AS `name` FROM `player%s`) AS `player` ON `player`.`id` = `minigame_roulette%s`.`pid` ",
+		get_table_postfix(), get_table_postfix()))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "ORDER BY `score` DESC LIMIT 10"))
+		return;
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	const SQLResult* pRes = pMsg->Get();
+	if (pRes && pRes->uiNumRows > 0)
+	{
+		MYSQL_ROW RowData;
+		while ((RowData = mysql_fetch_row(pRes->pSQLResult)))
+		{
+			if (RowData[0][0] == '[') // GM
+				continue;
+
+			DWORD dwScore;
+			str_to_number(dwScore, RowData[1]);
+
+			if (dwScore == 0)
+				continue;
+
+			lua_newtable(L);
+
+			// Name
+			lua_pushstring(L, RowData[0]);
+			lua_rawseti(L, -2, 1);
+
+			// Score
+			lua_pushnumber(L, dwScore);
+			lua_rawseti(L, -2, 2);
+
+			lua_rawseti(L, -2, dwIndex++);
+		}
+	}
+}
+
+/* static */ DWORD CMiniGameRoulette::GetMyScoreValue(lua_State* L, DWORD dwPID)
+{
+	char szQuery[2048 + 1];
+	int iLen = 0;
+
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen,
+		"SELECT `score` FROM `minigame_roulette%s` WHERE `pid` = %u ", get_table_postfix(), dwPID))
+		return 0;
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	const SQLResult* pRes = pMsg->Get();
+	if (pRes && pRes->uiNumRows > 0)
+	{
+		MYSQL_ROW RowData = mysql_fetch_row(pRes->pSQLResult);
+
+		DWORD dwScore;
+		str_to_number(dwScore, RowData[0]);
+
+		return dwScore;
+	}
+
+	return 0;
+}
+
+/* static */ void CMiniGameRoulette::Open(LPCHARACTER pNPC, LPCHARACTER pChar, BYTE bType)
+{
+	if (pNPC == NULL)
+	{
+		sys_err("CMiniGameRoulette::Open(pNPC=%p, pChar=%p, bType=%d): NULL CHAR %s",
+			get_pointer(pNPC), get_pointer(pChar), pChar->GetName());
+		return;
+	}
+
+	int iDist = DISTANCE_APPROX(pChar->GetX() - pNPC->GetX(), pChar->GetY() - pNPC->GetY());
+	if (iDist >= WINDOW_OPENER_MAX_DISTANCE)
+		return;
+
+	if (IsActiveEvent() == false)
+		return;
+
+	if (pChar->GetMiniGameRoulette())
+		return;
+
+	CMiniGameRoulette* pMiniGameRoulette = M2_NEW CMiniGameRoulette(pNPC, pChar, bType);
+	if (pMiniGameRoulette == NULL)
+		return;
+
+	pMiniGameRoulette->SendPacket(ROULETTE_GC_OPEN);
+	pChar->SetMiniGameRoulette(pMiniGameRoulette);
+}
+
+void CMiniGameRoulette::Initialize()
+{
+	const BYTE bMapperIndex = m_pChar->GetMiniGameRoulette_RewardMapperNum();
+
+	m_bMapperIndex = bMapperIndex != 0 ? bMapperIndex : CRouletteManager::Instance().GetRandomMapperIndex(m_bType);
+	m_pChar->SetMiniGameRoulette_RewardMapperNum(m_bMapperIndex);
+
+	m_bItemIndex = ROULETTE_ITEM_MAX;
+
+	const CRouletteManager::TMapper* pMapper = CRouletteManager::Instance().GetMapper(m_bMapperIndex);
+	if (pMapper == NULL)
+	{
+		CloseError("CMiniGameRoulette::Initialize(): Failed to find TMapper for bMapperNum: %d", m_bMapperIndex);
+		return;
+	}
+
+	m_iPrice = pMapper->iPrice;
+	m_iSoulCount = pMapper->iSoulCount;
+
+	if (m_bType == TYPE_SPECIAL)
+	{
+		int iSpecialRouletteTime = m_pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime);
+		if (iSpecialRouletteTime > get_global_time())
+		{
+			MiniGameRouletteEventInfo* pSpecialRouletteEvent = AllocEventInfo<MiniGameRouletteEventInfo>();
+			pSpecialRouletteEvent->pMiniGameRoulette = this;
+			SetSpecialRouletteEvent(event_create(MiniGameSpecialRouletteEvent, pSpecialRouletteEvent, PASSES_PER_SEC(iSpecialRouletteTime - get_global_time())));
+		}
+	}
+}
+
+void CMiniGameRoulette::Destroy()
+{
+	if (m_bIsSpinning)
+		Recover();
+
+	m_bType = TYPE_NORMAL;
+	m_bMapperIndex = 0;
+	m_bItemIndex = ROULETTE_ITEM_MAX;
+	m_iPrice = 0;
+	m_iSoulCount = 0;
+
+	m_pChar = NULL;
+	m_pNPC = NULL;
+
+	m_bIsSpinning = false;
+	m_bSpinCount = 0;
+
+	SetSpecialRouletteEvent(NULL);
+}
+
+void CMiniGameRoulette::Start()
+{
+	if (m_bIsSpinning)
+		return;
+
+	if (m_bType == TYPE_SPECIAL)
+	{
+		if (get_global_time() > m_pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime))
+		{
+			m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Ritual of Blood is over. Try again another time."));
+			Close(true); // NOTE : Force close window if the ritual of blood if over.
+			return;
+		}
+	}
+
+	// NOTE : Always check if there is any available position, all rewards are size 1.
+	const int iEmptyPos = m_pChar->GetEmptyInventory(1);
+	if (iEmptyPos == -1)
+	{
+		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Ritual of Blood] You don't have enough space in your inventory."));
+		return;
+	}
+
+	if (m_pChar->GetGold() < m_iPrice)
+	{
+		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Ritual of Blood] You don't have enough Yang."));
+		return;
+	}
+
+	int iSoulCount = m_pChar->GetQuestFlag(gs_szQuestFlag_SoulCount);
+	int iUsedSoulCount = m_pChar->GetQuestFlag(gs_szQuestFlag_UsedSoulCount);
+
+	if (iSoulCount < m_iSoulCount)
+	{
+		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Ritual of Blood] You don't have enough souls."));
+		return;
+	}
+
+	m_bItemIndex = CRouletteManager::Instance().GetRandomItemIndex(m_bMapperIndex);
+	if (m_bItemIndex == ROULETTE_ITEM_MAX)
+	{
+		CloseError("CMiniGameRoulette::Start: Failed to get item index for mapper index: %d", m_bMapperIndex);
+		return;
+	}
+
+	m_pChar->PointChange(POINT_GOLD, -m_iPrice);
+	m_pChar->SetQuestFlag(gs_szQuestFlag_SoulCount, iSoulCount - m_iSoulCount);
+	m_pChar->SetQuestFlag(gs_szQuestFlag_UsedSoulCount, iUsedSoulCount + m_iSoulCount);
+
+	m_bIsSpinning = true;
+	m_bSpinCount += 1;
+
+	SendPacket(ROULETTE_GC_START);
+}
+
+void CMiniGameRoulette::Request()
+{
+	SendPacket(ROULETTE_GC_REQUEST);
+}
+
+void CMiniGameRoulette::End()
+{
+	if (!m_bIsSpinning)
+		return;
+
+	int iUsedSoulCount = m_pChar->GetQuestFlag(gs_szQuestFlag_UsedSoulCount);
+	if (iUsedSoulCount >= SOUL_MAX_NUM)
+	{
+		if (m_pNPC == m_pChar->GetQuestNPC())
+		{
+			TPacketGCSpecialEffect p;
+			p.bHeader = HEADER_GC_SEPCIAL_EFFECT;
+			p.bEffectNum = SE_SPECIAL_ROULETTE;
+			p.dwVID = m_pNPC->GetVID();
+			m_pChar->GetDesc()->Packet(&p, sizeof(p));
+		}
+
+		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Ritual of Blood has started. Buy special items to get better rewards."));
+		m_pChar->SetQuestFlag(gs_szQuestFlag_SpecialExpireTime, get_global_time() + (test_server ? 60 : SPECIAL_ROULETTE_EXPIRE_TIME));
+		m_pChar->SetQuestFlag(gs_szQuestFlag_UsedSoulCount, 0);
+	}
+
+	const CRouletteManager::TItem* pItemData = CRouletteManager::Instance().GetItem(m_bMapperIndex, m_bItemIndex);
+	if (pItemData == NULL)
+	{
+		CloseError("CMiniGameRoulette::Start: Failed to get item index for mapper index: %d", m_bMapperIndex);
+		return;
+	}
+
+	if (m_pChar->AutoGiveItem(pItemData->dwVnum, pItemData->bCount, -1, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, true /* isHighLight */
+#endif
+#if defined(__NEW_USER_CARE__)
+		, false /* bSystemDrop */
+#endif
+	) == NULL)
+	{
+#if defined(__MAILBOX__)
+		CMailBox::SendGMMail(m_pChar->GetName(),
+			LC_STRING("Reward for Ritual of Blood"),
+			"",
+			pItemData->dwVnum, pItemData->bCount);
+
+		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Insufficient space in your inventory. The reward will be sent to your mailbox."));
+#else
+		sys_log(0, "ROULETTE ITEM: Cannot find empty position for item %u (ch : %s)", pItemData->dwVnum, m_pChar->GetName());
+
+		char szQuery[2048 + 1];
+		snprintf(szQuery, sizeof(szQuery), "INSERT INTO `item_award%s` (`login`, `vnum`, `count`, `given_time`) VALUES('%s', %u, %u, NOW())",
+			get_table_postfix(), m_pChar->GetDesc()->GetAccountTable().login, pItemData->dwVnum, pItemData->bCount);
+
+		DBManager::instance().DirectQuery(szQuery);
+#endif
+	}
+
+	m_bItemIndex = ROULETTE_ITEM_MAX;
+	m_bIsSpinning = false;
+
+	UpdateMyScore(m_pChar->GetPlayerID());
+}
+
+void CMiniGameRoulette::Close(bool bForce)
+{
+	if (bForce)
+		SendPacket(ROULETTE_GC_CLOSE);
+
+	if (m_pChar)
+		m_pChar->SetMiniGameRoulette(NULL);
+}
+
+void CMiniGameRoulette::CloseError(const char* format, ...)
+{
+	char buf[255 + 1];
+	va_list args;
+
+	va_start(args, format);
+	vsnprintf(buf, sizeof(buf), format, args);
+	va_end(args);
+
+	sys_err(buf);
+
+	Close(true);
+}
+
+void CMiniGameRoulette::Recover()
+{
+	if (m_bIsSpinning == false)
+		return;
+
+	const CRouletteManager::TItem* pItemData = CRouletteManager::Instance().GetItem(m_bMapperIndex, m_bItemIndex);
+	if (pItemData == NULL)
+	{
+		sys_err("CMiniGameRoulette::Recover : Item Data (%u) NULL (ch : %s)",
+			m_bMapperIndex, m_pChar->GetName());
+		return;
+	}
+
+#if defined(__MAILBOX__)
+	CMailBox::SendGMMail(m_pChar->GetName(), LC_STRING("Reward for Ritual of Blood"), "", pItemData->dwVnum, pItemData->bCount);
+#else
+	char szQuery[2048 + 1];
+	snprintf(szQuery, sizeof(szQuery), "INSERT INTO `item_award%s` (`login`, `vnum`, `count`, `given_time`) VALUES('%s', %u, %u, NOW())",
+		get_table_postfix(), m_pChar->GetDesc()->GetAccountTable().login, pItemData->dwVnum, pItemData->bCount);
+
+	DBManager::instance().DirectQuery(szQuery);
+#endif
+}
+
+void CMiniGameRoulette::SendPacket(BYTE bSubHeader)
+{
+	if (m_pChar == NULL)
+		return;
+
+	LPDESC pDesc = m_pChar->GetDesc();
+	if (pDesc == NULL)
+		return;
+
+	TPacketGCMiniGameRoulette MiniGameRoulette;
+	MiniGameRoulette.bHeader = HEADER_GC_MINI_GAME_ROULETTE;
+	MiniGameRoulette.bSubHeader = bSubHeader;
+	MiniGameRoulette.bResult = m_bItemIndex;
+	if (m_bType == TYPE_SPECIAL)
+		MiniGameRoulette.dwExpireTime = m_pChar->GetQuestFlag(gs_szQuestFlag_SpecialExpireTime);
+	else
+		MiniGameRoulette.dwExpireTime = 0;
+
+	switch (bSubHeader)
+	{
+		case ROULETTE_GC_OPEN:
+		{
+			const CRouletteManager::TItemVec* pItemVec = CRouletteManager::Instance().GetItemVec(m_bMapperIndex);
+			if (pItemVec == NULL)
+			{
+				CloseError("CMiniGameRoulette::Initialize: pItemVec == NULL! (ch : %s)", m_pChar->GetName());
+				return;
+			}
+
+			for (size_t i = 0; i < pItemVec->size(); i++)
+			{
+				MiniGameRoulette.ItemData[i].dwVnum = (*pItemVec)[i].dwVnum;
+				MiniGameRoulette.ItemData[i].bCount = (*pItemVec)[i].bCount;
+			}
+		}
+		break;
+
+		case ROULETTE_GC_START:
+		case ROULETTE_GC_REQUEST:
+		case ROULETTE_GC_END:
+		case ROULETTE_GC_CLOSE:
+			break;
+
+		default:
+			sys_log(0, "CMiniGameRoulette::SendPacket(bSubHeader=%u): Unknown SubHeader! (ch : %s)",
+				bSubHeader, m_pChar->GetName());
+			break;
+	}
+
+	pDesc->Packet(&MiniGameRoulette, sizeof(MiniGameRoulette));
+}
+
+void CMiniGameRoulette::SetSpecialRouletteEvent(LPEVENT pEvent)
+{
+	if (m_pSpecialRouletteEvent != NULL)
+		event_cancel(&m_pSpecialRouletteEvent);
+
+	m_pSpecialRouletteEvent = pEvent;
+}
+
+void CMiniGameRoulette::UpdateMyScore(DWORD dwPID)
+{
+	char szQuery[2048 + 1];
+	int iLen = 0;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "INSERT INTO `minigame_roulette%s` (`pid`, `score`, `last_play`) ", get_table_postfix()))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "VALUES (%u, %u, FROM_UNIXTIME(%d)) ", dwPID, m_iSoulCount, std::time(nullptr)))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "ON DUPLICATE KEY UPDATE `score` = `score` + %d", m_iSoulCount))
+		return;
+	DBManager::instance().DirectQuery(szQuery);
+}
+#endif // __SUMMER_EVENT_ROULETTE__
diff --git a/server/metin2/Source/Server/game/src/minigame_rumi.cpp b/server/metin2/Source/Server/game/src/minigame_rumi.cpp
index d518289..391614b 100644
--- a/server/metin2/Source/Server/game/src/minigame_rumi.cpp
+++ b/server/metin2/Source/Server/game/src/minigame_rumi.cpp
@@ -1,787 +1,841 @@
-/**
-* Filename: minigame_rumi.cpp
-* Author: Owsap
-**/
-
-#include "stdafx.h"
-
-#if defined(__MINI_GAME_RUMI__)
-#include "minigame_rumi.h"
-
-#include "char.h"
-#include "desc.h"
-#include "db.h"
-#include "config.h"
-#include "char_manager.h"
-#include "sectree_manager.h"
-#include "questmanager.h"
-
-CMiniGameRumi::CMiniGameRumi(LPCHARACTER pChar) : m_pChar(pChar)
-{
-	m_vecDeck.clear();
-	m_mapHand.clear();
-	m_vecGrave.clear();
-
-	m_bState = RUMI_STATE_PLAY;
-	m_bCardCount = 0;
-	m_wScore = 0;
-
-	SendPacket(RUMI_GC_SUBHEADER_START);
-
-	__ShuffleDeck();
-}
-
-CMiniGameRumi::~CMiniGameRumi()
-{
-	m_vecDeck.clear();
-	m_mapHand.clear();
-	m_vecGrave.clear();
-
-	m_bState = RUMI_STATE_NONE;
-	m_bCardCount = 0;
-	m_wScore = 0;
-
-	SendPacket(RUMI_GC_SUBHEADER_END);
-}
-
-BYTE CMiniGameRumi::GetDeckCount() const
-{
-	return static_cast<BYTE>(m_vecDeck.size());
-}
-
-INT CMiniGameRumi::GetEmptyHandPosition() const
-{
-	INT iHandPosition = __GetEmptyHandPosition();
-	if (iHandPosition == -1)
-		return -1;
-
-	return iHandPosition;
-}
-
-void CMiniGameRumi::ClickDeckCard()
-{
-	if (m_vecDeck.empty())
-		return;
-
-	if (m_bCardCount >= RUMI_HAND_CARD_INDEX_MAX)
-		return;
-
-	// Find the first available position in hand.
-	INT iHandPosition = __GetEmptyHandPosition();
-	if (iHandPosition == -1)
-		return;
-
-	static std::mt19937 rng(std::random_device{}());
-	std::uniform_int_distribution<std::size_t> dist(0, m_vecDeck.size() - 1);
-	std::size_t nIndex = dist(rng);
-
-	// Get the selected card. <color, number>
-	PairedCard Card = m_vecDeck[nIndex];
-
-	// Add the card to the hand.
-	m_mapHand[iHandPosition] = Card;
-
-	{
-		TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
-		MoveCardPacket.bSrcPos = RUMI_DECK_CARD;
-
-		MoveCardPacket.bDstPos = RUMI_HAND_CARD;
-		MoveCardPacket.bDstIndex = iHandPosition;
-		MoveCardPacket.bDstColor = Card.first;
-		MoveCardPacket.bDstNumber = Card.second;
-
-		SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
-	}
-
-	// Remove the card from the deck.
-	m_vecDeck.erase(m_vecDeck.begin() + nIndex);
-	m_bCardCount += 1;
-}
-
-void CMiniGameRumi::ClickHandCard(BOOL bUseCard, BYTE bIndex)
-{
-	if (m_bCardCount <= 0 || m_mapHand.empty())
-		return;
-
-	if (bUseCard)
-	{
-		HandMap::iterator it = m_mapHand.find(bIndex);
-		if (it != m_mapHand.end())
-		{
-			// Find the first available position in the field.
-			INT iFieldPosition = __GetEmptyFieldPosition();
-			if (iFieldPosition == -1)
-				return;
-
-			// Add the card to the field.
-			m_mapField[iFieldPosition] = it->second;
-
-			// Server Process
-			{
-				TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
-
-				MoveCardPacket.bSrcPos = RUMI_HAND_CARD;
-				MoveCardPacket.bSrcIndex = bIndex;
-				MoveCardPacket.bSrcColor = it->second.first;
-				MoveCardPacket.bSrcNumber = it->second.second;
-
-				MoveCardPacket.bDstPos = RUMI_FIELD_CARD;
-				MoveCardPacket.bDstIndex = iFieldPosition;
-				MoveCardPacket.bDstColor = it->second.first;
-				MoveCardPacket.bDstNumber = it->second.second;
-
-				SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
-			}
-
-			// Remove the card from the players hand.
-			m_mapHand.erase(it);
-
-			// Check if the field cards combine.
-			if (m_mapField.size() == RUMI_FIELD_CARD_INDEX_MAX)
-			{
-				if (__CheckCombination())
-				{
-					m_bCardCount -= 3;
-				}
-				else
-				{
-					// Add the cards back to the hand.
-					for (BYTE bIndex = 0; bIndex < RUMI_FIELD_CARD_INDEX_MAX; ++bIndex)
-					{
-						ClickFieldCard(bIndex);
-					}
-				}
-			}
-		}
-	}
-	else if (bUseCard == false)
-	{
-		HandMap::iterator it = m_mapHand.find(bIndex);
-		if (it != m_mapHand.end())
-		{
-			// Add the card to the grave.
-			m_vecGrave.emplace_back(it->second);
-
-			// Server Process
-			{
-				TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
-
-				MoveCardPacket.bSrcPos = RUMI_HAND_CARD;
-				MoveCardPacket.bSrcIndex = bIndex;
-				MoveCardPacket.bSrcColor = it->second.first;
-				MoveCardPacket.bSrcNumber = it->second.second;
-
-				MoveCardPacket.bDstPos = RUMI_NONE_POS;
-
-				SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
-			}
-
-			// Remove the card from the players hand.
-			m_mapHand.erase(it);
-			m_bCardCount -= 1;
-		}
-		else if (m_mapField.find(bIndex) != m_mapField.end())
-		{
-			m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot discard cards when you have already selected some."));
-			return;
-		}
-		else
-		{
-			// card already in grave?
-		}
-	}
-}
-
-void CMiniGameRumi::ClickFieldCard(BYTE bIndex)
-{
-	if (m_mapField.empty())
-		return;
-
-	FieldMap::iterator it = m_mapField.find(bIndex);
-	if (it != m_mapField.end())
-	{
-		// Find the first available position in hand.
-		INT iHandPosition = __GetEmptyHandPosition();
-		if (iHandPosition == -1)
-			return;
-
-		// Add the card back to the hand.
-		m_mapHand[iHandPosition] = it->second;
-
-		// Update
-		{
-			TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
-
-			MoveCardPacket.bSrcPos = RUMI_FIELD_CARD;
-			MoveCardPacket.bSrcIndex = bIndex;
-			MoveCardPacket.bSrcColor = it->second.first;
-			MoveCardPacket.bSrcNumber = it->second.second;
-
-			MoveCardPacket.bDstPos = RUMI_HAND_CARD;
-			MoveCardPacket.bDstIndex = iHandPosition;
-			MoveCardPacket.bDstColor = it->second.first;
-			MoveCardPacket.bDstNumber = it->second.second;
-
-			SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
-		}
-
-		// Remove the card from the field.
-		m_mapField.erase(it);
-	}
-}
-
-void CMiniGameRumi::Reward()
-{
-	if (m_bState != RUMI_STATE_PLAY)
-		return;
-
-	int iMiniGameOkeyNormal = quest::CQuestManager::instance().GetEventFlag("mini_game_okey_normal");
-
-	DWORD dwRewardVnum = 0;
-	if (m_wScore >= RUMI_MID_TOTAL_SCORE)
-	{
-		dwRewardVnum = (iMiniGameOkeyNormal > 0) ? RUMI_NORMAL_HIGH_REWARD : RUMI_HIGH_REWARD;
-	}
-	else if (m_wScore >= RUMI_LOW_TOTAL_SCORE && m_wScore < RUMI_MID_TOTAL_SCORE)
-	{
-		dwRewardVnum = (iMiniGameOkeyNormal > 0) ? RUMI_NORMAL_MID_REWARD : RUMI_MID_REWARD;
-	}
-	else if (m_wScore >= 0 && m_wScore < RUMI_LOW_TOTAL_SCORE)
-	{
-		dwRewardVnum = (iMiniGameOkeyNormal > 0) ? RUMI_NORMAL_LOW_REWARD : RUMI_LOW_REWARD;
-	}
-
-	const TItemTable* pkTable = ITEM_MANAGER::instance().GetTable(dwRewardVnum);
-	if (!pkTable)
-	{
-		sys_err("CMiniGameRumi::Reward - Failed to get item table. (ch: %s) (%d)",
-			m_pChar->GetName(), dwRewardVnum);
-		return;
-	}
-
-	bool bEnoughInventoryForItem = m_pChar->GetEmptyInventory(pkTable->bSize) != -1;
-	if (!bEnoughInventoryForItem)
-	{
-		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only receive your prize once you have made space in your inventory."));
-		return;
-	}
-
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	m_pChar->AutoGiveItem(dwRewardVnum, 1, -1, true, true);
-#else
-	m_pChar->AutoGiveItem(dwRewardVnum, 1, -1, true);
-#endif
-
-	UpdateMyScore(m_pChar->GetPlayerID());
-
-	m_pChar->SetMiniGameRumi(nullptr);
-}
-
-void CMiniGameRumi::UpdateMyScore(DWORD dwPID)
-{
-	char szQuery[2048 + 1];
-	int iLen = sprintf(szQuery, "INSERT INTO `minigame_rumi%s` (`pid`, `best_score`, `total_score`, `last_play`) ", get_table_postfix());
-	iLen += sprintf(szQuery + iLen, "VALUES (%u, %u, %u, FROM_UNIXTIME(%d)) ", dwPID, m_wScore, m_wScore, std::time(nullptr));
-	iLen += sprintf(szQuery + iLen, "ON DUPLICATE KEY UPDATE ");
-	iLen += sprintf(szQuery + iLen, "`total_score` = `total_score` + %d, ", m_wScore);
-	iLen += sprintf(szQuery + iLen, "`best_score` = if (%d > `best_score`, %d, `best_score`) ", m_wScore, m_wScore);
-	DBManager::instance().DirectQuery(szQuery);
-}
-
-void CMiniGameRumi::SendPacket(BYTE bSubHeader, void* pvData)
-{
-	if (m_pChar == nullptr)
-		return;
-
-	const LPDESC pkDesc = m_pChar->GetDesc();
-	if (pkDesc == nullptr)
-	{
-		sys_err("CMiniGameRumi::SendPacket - Null DESC! (ch: %s) (%d)",
-			m_pChar->GetName(), bSubHeader);
-		return;
-	}
-
-	TPacketGCMiniGameRumi Packet;
-	Packet.bHeader = HEADER_GC_MINI_GAME_RUMI;
-	Packet.bSubHeader = bSubHeader;
-
-	const std::unordered_set<BYTE> EmptyData
-	{
-		RUMI_GC_SUBHEADER_END,
-		RUMI_GC_SUBHEADER_START,
-	};
-
-	if (pvData == nullptr && EmptyData.find(bSubHeader) == EmptyData.end())
-	{
-		sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null Data! Character: %s",
-			bSubHeader, m_pChar->GetName());
-		return;
-	}
-
-	switch (bSubHeader)
-	{
-		case RUMI_GC_SUBHEADER_END:
-		case RUMI_GC_SUBHEADER_START:
-		{
-			Packet.wSize = sizeof(Packet);
-			pkDesc->Packet(&Packet, sizeof(TPacketGCMiniGameRumi));
-		}
-		break;
-
-		case RUMI_GC_SUBHEADER_SET_DECK:
-		{
-			const TPacketGCMiniGameRumiSetDeck* pkData = static_cast<TPacketGCMiniGameRumiSetDeck*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null SetDeckPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameRumiSetDeck SetDeckPacket(pkData->bDeckCount);
-			Packet.wSize = sizeof(Packet) + sizeof(SetDeckPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
-			pkDesc->Packet(&SetDeckPacket, sizeof(TPacketGCMiniGameRumiSetDeck));
-		}
-		break;
-
-		case RUMI_GC_SUBHEADER_MOVE_CARD:
-		{
-			const TPacketGCMiniGameRumiMoveCard* pkData = static_cast<TPacketGCMiniGameRumiMoveCard*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null MoveCardPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameRumiMoveCard MoveCardPacket;
-			MoveCardPacket.bSrcPos = pkData->bSrcPos;
-			MoveCardPacket.bSrcIndex = pkData->bSrcIndex;
-			MoveCardPacket.bSrcColor = pkData->bSrcColor;
-			MoveCardPacket.bSrcNumber = pkData->bSrcNumber;
-			MoveCardPacket.bDstPos = pkData->bDstPos;
-			MoveCardPacket.bDstIndex = pkData->bDstIndex;
-			MoveCardPacket.bDstColor = pkData->bDstColor;
-			MoveCardPacket.bDstNumber = pkData->bDstNumber;
-
-			Packet.wSize = sizeof(Packet) + sizeof(MoveCardPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
-			pkDesc->Packet(&MoveCardPacket, sizeof(TPacketGCMiniGameRumiMoveCard));
-		}
-		break;
-
-		case RUMI_GC_SUBHEADER_SET_SCORE:
-		{
-			const TPacketGCMiniGameRumiSetScore* pkData = static_cast<TPacketGCMiniGameRumiSetScore*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null SetScorePacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameRumiSetScore SetScorePacket(pkData->wScore, pkData->wTotalScore);
-			Packet.wSize = sizeof(Packet) + sizeof(SetScorePacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
-			pkDesc->Packet(&SetScorePacket, sizeof(TPacketGCMiniGameRumiSetScore));
-		}
-		break;
-	}
-}
-
-void CMiniGameRumi::__ShuffleDeck()
-{
-	std::array<BYTE, RUMI_CARD_COLOR_MAX> aCardColor = { RUMI_RED_CARD, RUMI_BLUE_CARD, RUMI_YELLOW_CARD };
-	for (BYTE bColor : aCardColor)
-	{
-		for (BYTE bCardNumber = 1; bCardNumber <= RUMI_CARD_NUMBER_END; bCardNumber++)
-		{
-			m_vecDeck.emplace_back(bColor, bCardNumber);
-		}
-	}
-
-	static std::mt19937 rng(std::random_device{}());
-	std::shuffle(m_vecDeck.begin(), m_vecDeck.end(), rng);
-
-	TPacketGCMiniGameRumiSetDeck SetDeckPacket(static_cast<BYTE>(m_vecDeck.size()));
-	SendPacket(RUMI_GC_SUBHEADER_SET_DECK, &SetDeckPacket);
-}
-
-static bool __ContainsNumbers(const std::vector<BYTE>& rkNumVec, const std::vector<BYTE>& rkSearchNumVec)
-{
-	return std::all_of(rkSearchNumVec.begin(), rkSearchNumVec.end(),
-		[&](BYTE bNumber)
-		{
-			return std::find(rkNumVec.begin(), rkNumVec.end(), bNumber) != rkNumVec.end();
-		});
-}
-
-bool CMiniGameRumi::__CheckCombination()
-{
-	if (m_mapField.empty())
-		return false;
-
-	if (m_mapField.size() < RUMI_FIELD_CARD_INDEX_MAX)
-		return false;
-
-	std::vector<BYTE> vCardColor, vCardNumber;
-	for (const auto& it : m_mapField)
-	{
-		PairedCard Card = it.second;
-		vCardColor.push_back(Card.first);
-		vCardNumber.push_back(Card.second);
-	}
-
-	WORD wScore = 0;
-
-	const bool bSameNumber = std::all_of(vCardNumber.cbegin() + 1, vCardNumber.cend(),
-		[&](BYTE bNumber) { return bNumber == vCardNumber.front(); });
-
-	if (bSameNumber)
-	{
-		const BYTE bCardNumber = vCardNumber.front();
-		wScore = (bCardNumber * 10) + 10;
-	}
-	else
-	{
-		const bool bSameCardColors = std::all_of(vCardColor.cbegin() + 1, vCardColor.cend(),
-			[&](BYTE bColor) { return bColor == vCardColor.front(); });
-
-		for (BYTE bCardNumber = 1; bCardNumber <= 6; ++bCardNumber)
-		{
-			std::vector<BYTE> vSearchNumber
-			{
-				static_cast<BYTE>(bCardNumber),
-				static_cast<BYTE>(bCardNumber + 1),
-				static_cast<BYTE>(bCardNumber + 2)
-			};
-
-			if (__ContainsNumbers(vCardNumber, vSearchNumber))
-			{
-				wScore = (bCardNumber * 10);
-				break;
-			}
-		}
-
-		if (wScore > 0 && bSameCardColors)
-			wScore += 40;
-	}
-
-	if (wScore > 0)
-	{
-		m_mapField.clear();
-		m_wScore += wScore;
-
-		TPacketGCMiniGameRumiSetScore SetScorePacket(wScore, m_wScore);
-		SendPacket(RUMI_GC_SUBHEADER_SET_SCORE, &SetScorePacket);
-
-		return true;
-	}
-
-	return false;
-}
-
-INT CMiniGameRumi::__GetEmptyHandPosition() const
-{
-	if (m_mapHand.size() < RUMI_HAND_CARD_INDEX_MAX)
-	{
-		INT bPosition = 0;
-		while (m_mapHand.count(bPosition) > 0)
-			bPosition++;
-
-		return bPosition;
-	}
-	return -1;
-}
-
-INT CMiniGameRumi::__GetEmptyFieldPosition() const
-{
-	if (m_mapField.size() < RUMI_FIELD_CARD_INDEX_MAX)
-	{
-		INT bPosition = 0;
-		while (m_mapField.count(bPosition) > 0)
-			bPosition++;
-
-		return bPosition;
-	}
-	return -1;
-}
-
-/* static */ void CMiniGameRumi::StartGame(LPCHARACTER pChar)
-{
-	if (!IsActiveEvent())
-	{
-		EndGame(pChar);
-		return;
-	}
-
-	if (pChar->GetMiniGameRumi())
-		return;
-
-	if (pChar->GetGold() < RUMI_START_GOLD)
-	{
-		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang."));
-		return;
-	}
-
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-	const WORD wCardCount = pChar->GetQuestFlag("minigame_rumi.card_count");
-	if (wCardCount == 0)
-		return;
-
-	pChar->SetQuestFlag("minigame_rumi.card_count", wCardCount - 1);
-#else
-	if (pChar->CountSpecifyItem(ITEM_VNUM_RUMI_CARD_PACK))
-		return;
-
-	pChar->RemoveSpecifyItem(ITEM_VNUM_RUMI_CARD_PACK, 1);
-#endif
-	pChar->PointChange(POINT_GOLD, -RUMI_START_GOLD, true);
-
-	pChar->SetMiniGameRumi(new CMiniGameRumi(pChar));
-	pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Your game of okey has started!"));
-}
-
-/* static */ void CMiniGameRumi::EndGame(LPCHARACTER pChar)
-{
-	CMiniGameRumi* pMiniGameRumi = pChar->GetMiniGameRumi();
-	if (pMiniGameRumi)
-		pMiniGameRumi->Reward();
-}
-
-/* static */ void CMiniGameRumi::Analyze(LPCHARACTER pChar, BYTE bSubHeader, BOOL bUseCard, BYTE bIndex)
-{
-	CMiniGameRumi* pMiniGameRumi = pChar->GetMiniGameRumi();
-	if (pMiniGameRumi == nullptr)
-	{
-		sys_err("CMiniGameRumi::Analyze - Null MiniGameRumi! (ch: %s) (%d)",
-			pChar->GetName(), bSubHeader);
-		return;
-	}
-
-	switch (bSubHeader)
-	{
-		case RUMI_CG_SUBHEADER_DECK_CARD_CLICK:
-		{
-			if (pMiniGameRumi->GetDeckCount() == 0)
-			{
-				pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot draw any more cards."));
-				return;
-			}
-
-			if (pMiniGameRumi->GetEmptyHandPosition() == -1)
-			{
-				pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot draw any more cards when you have already selected some."));
-				return;
-			}
-
-#if defined(__RUMI_DEALER__)
-			for (BYTE bIndex = 0; bIndex < RUMI_HAND_CARD_INDEX_MAX; ++bIndex)
-				pMiniGameRumi->ClickDeckCard();
-#else
-			pMiniGameRumi->ClickDeckCard();
-#endif
-		}
-		break;
-
-		case RUMI_CG_SUBHEADER_HAND_CARD_CLICK:
-			pMiniGameRumi->ClickHandCard(bUseCard, bIndex);
-			break;
-
-		case RUMI_CG_SUBHEADER_FIELD_CARD_CLICK:
-			pMiniGameRumi->ClickFieldCard(bIndex);
-			break;
-
-		default:
-			sys_err("CMiniGameRumi::Analyze - Unknown SubHeader (ch: %s) (%d)",
-				pChar->GetName(), bSubHeader);
-			break;
-	}
-}
-
-/* static */ bool CMiniGameRumi::IsActiveEvent()
-{
-	if (quest::CQuestManager::instance().GetEventFlag("mini_game_okey"))
-		return true;
-
-	if (quest::CQuestManager::instance().GetEventFlag("mini_game_okey_normal"))
-		return true;
-
-	return false;
-}
-
-/* static */ void CMiniGameRumi::SpawnEventNPC(bool bSpawn)
-{
-	CharacterVectorInteractor vChar;
-	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(RUMI_TABLE, vChar))
-	{
-		std::for_each(vChar.begin(), vChar.end(),
-			[](LPCHARACTER pChar) { M2_DESTROY_CHARACTER(pChar); });
-	}
-
-	if (bSpawn)
-	{
-		std::unordered_map<long, std::pair<long, long>> mSpawnPoint
-		{
-			{ MAP_A1, { 607, 619 } },
-			{ MAP_B1, { 595, 613 } },
-			{ MAP_C1, { 353, 741 } },
-		};
-
-		for (const auto& it : mSpawnPoint)
-		{
-			long lMapIndex = it.first;
-			const auto& rkPos = it.second;
-
-			if (!map_allow_find(lMapIndex))
-				continue;
-
-			const LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
-			if (pkSectreeMap == nullptr)
-				continue;
-
-			long xPos = pkSectreeMap->m_setting.iBaseX + rkPos.first * 100;
-			long yPos = pkSectreeMap->m_setting.iBaseY + rkPos.second * 100;
-
-			CHARACTER_MANAGER::instance().SpawnMob(RUMI_TABLE, lMapIndex,
-				xPos, yPos, 0, false, 90, true);
-		}
-	}
-}
-
-/* static */ void CMiniGameRumi::RequestQuestFlag(LPCHARACTER pChar, BYTE bSubHeader)
-{
-	const LPDESC pkDesc = pChar->GetDesc();
-	if (pkDesc == nullptr)
-	{
-		sys_err("CMiniGameRumi::RequestQuestFlag - Null DESC! (ch: %s) (%d)",
-			pChar->GetName(), bSubHeader);
-		return;
-	}
-
-	const WORD wCardPieceCount = pChar->GetQuestFlag("minigame_rumi.card_piece_count");
-	const WORD wCardCount = pChar->GetQuestFlag("minigame_rumi.card_count");
-
-	TPacketGCMiniGameRumi Packet;
-	Packet.bHeader = HEADER_GC_MINI_GAME_RUMI;
-	Packet.bSubHeader = bSubHeader;
-
-	TPacketGCMiniGameRumiQuestFlag QuestFlagPacket(wCardPieceCount, wCardCount);
-	Packet.wSize = sizeof(Packet) + sizeof(QuestFlagPacket);
-
-	pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
-	pkDesc->Packet(&QuestFlagPacket, sizeof(TPacketGCMiniGameRumiQuestFlag));
-}
-
-/* static */ bool CMiniGameRumi::UpdateQuestFlag(LPCHARACTER pChar)
-{
-	if (!IsActiveEvent())
-		return false;
-
-	const WORD wCardPieceCount = pChar->GetQuestFlag("minigame_rumi.card_piece_count");
-	const WORD wCardCount = pChar->GetQuestFlag("minigame_rumi.card_count");
-
-	if (wCardCount >= RUMI_CARD_COUNT_MAX)
-	{
-		RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_NO_MORE_GAIN);
-		return false;
-	}
-
-	if (wCardPieceCount + 1 >= RUMI_CARD_PIECE_COUNT_MAX)
-	{
-		pChar->SetQuestFlag("minigame_rumi.card_piece_count", 0);
-		pChar->SetQuestFlag("minigame_rumi.card_count", wCardCount + 1);
-
-		RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_CARD_FLAG);
-	}
-	else
-	{
-		pChar->SetQuestFlag("minigame_rumi.card_piece_count", wCardPieceCount + 1);
-
-		RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG);
-	}
-
-	return true;
-}
-
-/* static */ void CMiniGameRumi::GetScoreTable(lua_State* L, bool bTotal)
-{
-	DWORD dwIndex = 1;
-	lua_newtable(L);
-
-	char szQuery[2048 + 1];
-	int iLen = 0;
-
-	iLen += sprintf(szQuery + iLen, "SELECT ");
-	iLen += sprintf(szQuery + iLen, "`player`.`name`, ");
-	iLen += bTotal ? sprintf(szQuery + iLen, "`total_score` ") : sprintf(szQuery + iLen, "`best_score` ");
-	iLen += sprintf(szQuery + iLen, "FROM `minigame_rumi` ");
-	iLen += sprintf(szQuery + iLen, "LEFT JOIN (SELECT `id`, `name` AS `name` FROM `player`) AS `player` ON `player`.`id` = `minigame_rumi`.`pid` ");
-	iLen += bTotal ? sprintf(szQuery + iLen, "ORDER BY `total_score` DESC ") : sprintf(szQuery + iLen, "ORDER BY `best_score` DESC ");
-	iLen += sprintf(szQuery + iLen, "LIMIT 10 ");
-
-	if (iLen >= sizeof(szQuery))
-		return;
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	SQLResult* pRes = pMsg->Get();
-	if (pRes && pRes->uiNumRows > 0)
-	{
-		MYSQL_ROW RowData;
-		while ((RowData = mysql_fetch_row(pRes->pSQLResult)))
-		{
-			if (RowData[0] == NULL || RowData[1] == NULL)
-				continue;
-
-			if (RowData[0][0] == '[') // GM
-				continue;
-
-			DWORD dwScore = 0;
-			str_to_number(dwScore, RowData[1]);
-
-			if (dwScore == 0)
-				continue;
-
-			lua_newtable(L);
-
-			// Name
-			lua_pushstring(L, RowData[0]);
-			lua_rawseti(L, -2, 1);
-
-			// Score
-			lua_pushnumber(L, dwScore);
-			lua_rawseti(L, -2, 2);
-
-			lua_rawseti(L, -2, dwIndex++);
-		}
-	}
-}
-
-/* static */ DWORD CMiniGameRumi::GetMyScoreValue(lua_State* L, DWORD dwPID, bool bTotal)
-{
-	char szQuery[2048 + 1];
-	int iLen = 0;
-
-	iLen += sprintf(szQuery + iLen, "SELECT ");
-	iLen += bTotal ? sprintf(szQuery + iLen, "`total_score` ") : sprintf(szQuery + iLen, "`best_score` ");
-	iLen += sprintf(szQuery + iLen, "FROM `minigame_rumi` WHERE `pid` = %u ", dwPID);
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	const SQLResult* pkRes = pMsg->Get();
-	if (pkRes && pkRes->uiNumRows > 0)
-	{
-		MYSQL_ROW RowData = mysql_fetch_row(pkRes->pSQLResult);
-
-		DWORD dwScore;
-		str_to_number(dwScore, RowData[0]);
-
-		return dwScore;
-	}
-
-	return 0;
-}
-#endif // __MINI_GAME_RUMI__
+#include <cstdarg>
+
+static bool SafeAppendQuery(char* buf, size_t cap, size_t& len, const char* fmt, ...)
+{
+	if (!buf || cap == 0 || len >= cap)
+		return false;
+	va_list ap;
+	va_start(ap, fmt);
+	int n = vsnprintf(buf + len, cap - len, fmt, ap);
+	va_end(ap);
+	if (n < 0)
+		return false;
+	if ((size_t)n >= cap - len)
+	{
+		// would overflow/truncate; abort building query
+		return false;
+	}
+	len += (size_t)n;
+	return true;
+}
+/**
+* Filename: minigame_rumi.cpp
+* Author: Owsap
+**/
+
+#include "stdafx.h"
+
+#if defined(__MINI_GAME_RUMI__)
+#include "minigame_rumi.h"
+
+#include "char.h"
+#include "desc.h"
+#include "db.h"
+#include "config.h"
+#include "char_manager.h"
+#include "sectree_manager.h"
+#include "questmanager.h"
+#include <cstdarg>
+
+// Safe query builder: prevents buffer overflows when composing SQL.
+static bool SafeAppendQuery(char* buf, size_t bufSize, int& len, const char* fmt, ...)
+{
+	if (!buf || bufSize == 0 || len < 0 || (size_t)len >= bufSize)
+		return false;
+	va_list args;
+	va_start(args, fmt);
+	const int written = vsnprintf(buf + len, bufSize - (size_t)len, fmt, args);
+	va_end(args);
+	if (written < 0)
+		return false;
+	if ((size_t)written >= bufSize - (size_t)len)
+		return false;
+	len += written;
+	return true;
+}
+
+CMiniGameRumi::CMiniGameRumi(LPCHARACTER pChar) : m_pChar(pChar)
+{
+	m_vecDeck.clear();
+	m_mapHand.clear();
+	m_vecGrave.clear();
+
+	m_bState = RUMI_STATE_PLAY;
+	m_bCardCount = 0;
+	m_wScore = 0;
+
+	SendPacket(RUMI_GC_SUBHEADER_START);
+
+	__ShuffleDeck();
+}
+
+CMiniGameRumi::~CMiniGameRumi()
+{
+	m_vecDeck.clear();
+	m_mapHand.clear();
+	m_vecGrave.clear();
+
+	m_bState = RUMI_STATE_NONE;
+	m_bCardCount = 0;
+	m_wScore = 0;
+
+	SendPacket(RUMI_GC_SUBHEADER_END);
+}
+
+BYTE CMiniGameRumi::GetDeckCount() const
+{
+	return static_cast<BYTE>(m_vecDeck.size());
+}
+
+INT CMiniGameRumi::GetEmptyHandPosition() const
+{
+	INT iHandPosition = __GetEmptyHandPosition();
+	if (iHandPosition == -1)
+		return -1;
+
+	return iHandPosition;
+}
+
+void CMiniGameRumi::ClickDeckCard()
+{
+	if (m_vecDeck.empty())
+		return;
+
+	if (m_bCardCount >= RUMI_HAND_CARD_INDEX_MAX)
+		return;
+
+	// Find the first available position in hand.
+	INT iHandPosition = __GetEmptyHandPosition();
+	if (iHandPosition == -1)
+		return;
+
+	static std::mt19937 rng(std::random_device{}());
+	std::uniform_int_distribution<std::size_t> dist(0, m_vecDeck.size() - 1);
+	std::size_t nIndex = dist(rng);
+
+	// Get the selected card. <color, number>
+	PairedCard Card = m_vecDeck[nIndex];
+
+	// Add the card to the hand.
+	m_mapHand[iHandPosition] = Card;
+
+	{
+		TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
+		MoveCardPacket.bSrcPos = RUMI_DECK_CARD;
+
+		MoveCardPacket.bDstPos = RUMI_HAND_CARD;
+		MoveCardPacket.bDstIndex = iHandPosition;
+		MoveCardPacket.bDstColor = Card.first;
+		MoveCardPacket.bDstNumber = Card.second;
+
+		SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
+	}
+
+	// Remove the card from the deck.
+	m_vecDeck.erase(m_vecDeck.begin() + nIndex);
+	m_bCardCount += 1;
+}
+
+void CMiniGameRumi::ClickHandCard(BOOL bUseCard, BYTE bIndex)
+{
+	if (m_bCardCount <= 0 || m_mapHand.empty())
+		return;
+
+	if (bUseCard)
+	{
+		HandMap::iterator it = m_mapHand.find(bIndex);
+		if (it != m_mapHand.end())
+		{
+			// Find the first available position in the field.
+			INT iFieldPosition = __GetEmptyFieldPosition();
+			if (iFieldPosition == -1)
+				return;
+
+			// Add the card to the field.
+			m_mapField[iFieldPosition] = it->second;
+
+			// Server Process
+			{
+				TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
+
+				MoveCardPacket.bSrcPos = RUMI_HAND_CARD;
+				MoveCardPacket.bSrcIndex = bIndex;
+				MoveCardPacket.bSrcColor = it->second.first;
+				MoveCardPacket.bSrcNumber = it->second.second;
+
+				MoveCardPacket.bDstPos = RUMI_FIELD_CARD;
+				MoveCardPacket.bDstIndex = iFieldPosition;
+				MoveCardPacket.bDstColor = it->second.first;
+				MoveCardPacket.bDstNumber = it->second.second;
+
+				SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
+			}
+
+			// Remove the card from the players hand.
+			m_mapHand.erase(it);
+
+			// Check if the field cards combine.
+			if (m_mapField.size() == RUMI_FIELD_CARD_INDEX_MAX)
+			{
+				if (__CheckCombination())
+				{
+					m_bCardCount -= 3;
+				}
+				else
+				{
+					// Add the cards back to the hand.
+					for (BYTE bIndex = 0; bIndex < RUMI_FIELD_CARD_INDEX_MAX; ++bIndex)
+					{
+						ClickFieldCard(bIndex);
+					}
+				}
+			}
+		}
+	}
+	else if (bUseCard == false)
+	{
+		HandMap::iterator it = m_mapHand.find(bIndex);
+		if (it != m_mapHand.end())
+		{
+			// Add the card to the grave.
+			m_vecGrave.emplace_back(it->second);
+
+			// Server Process
+			{
+				TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
+
+				MoveCardPacket.bSrcPos = RUMI_HAND_CARD;
+				MoveCardPacket.bSrcIndex = bIndex;
+				MoveCardPacket.bSrcColor = it->second.first;
+				MoveCardPacket.bSrcNumber = it->second.second;
+
+				MoveCardPacket.bDstPos = RUMI_NONE_POS;
+
+				SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
+			}
+
+			// Remove the card from the players hand.
+			m_mapHand.erase(it);
+			m_bCardCount -= 1;
+		}
+		else if (m_mapField.find(bIndex) != m_mapField.end())
+		{
+			m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot discard cards when you have already selected some."));
+			return;
+		}
+		else
+		{
+			// card already in grave?
+		}
+	}
+}
+
+void CMiniGameRumi::ClickFieldCard(BYTE bIndex)
+{
+	if (m_mapField.empty())
+		return;
+
+	FieldMap::iterator it = m_mapField.find(bIndex);
+	if (it != m_mapField.end())
+	{
+		// Find the first available position in hand.
+		INT iHandPosition = __GetEmptyHandPosition();
+		if (iHandPosition == -1)
+			return;
+
+		// Add the card back to the hand.
+		m_mapHand[iHandPosition] = it->second;
+
+		// Update
+		{
+			TPacketGCMiniGameRumiMoveCard MoveCardPacket = {};
+
+			MoveCardPacket.bSrcPos = RUMI_FIELD_CARD;
+			MoveCardPacket.bSrcIndex = bIndex;
+			MoveCardPacket.bSrcColor = it->second.first;
+			MoveCardPacket.bSrcNumber = it->second.second;
+
+			MoveCardPacket.bDstPos = RUMI_HAND_CARD;
+			MoveCardPacket.bDstIndex = iHandPosition;
+			MoveCardPacket.bDstColor = it->second.first;
+			MoveCardPacket.bDstNumber = it->second.second;
+
+			SendPacket(RUMI_GC_SUBHEADER_MOVE_CARD, &MoveCardPacket);
+		}
+
+		// Remove the card from the field.
+		m_mapField.erase(it);
+	}
+}
+
+void CMiniGameRumi::Reward()
+{
+	if (m_bState != RUMI_STATE_PLAY)
+		return;
+
+	int iMiniGameOkeyNormal = quest::CQuestManager::instance().GetEventFlag("mini_game_okey_normal");
+
+	DWORD dwRewardVnum = 0;
+	if (m_wScore >= RUMI_MID_TOTAL_SCORE)
+	{
+		dwRewardVnum = (iMiniGameOkeyNormal > 0) ? RUMI_NORMAL_HIGH_REWARD : RUMI_HIGH_REWARD;
+	}
+	else if (m_wScore >= RUMI_LOW_TOTAL_SCORE && m_wScore < RUMI_MID_TOTAL_SCORE)
+	{
+		dwRewardVnum = (iMiniGameOkeyNormal > 0) ? RUMI_NORMAL_MID_REWARD : RUMI_MID_REWARD;
+	}
+	else if (m_wScore >= 0 && m_wScore < RUMI_LOW_TOTAL_SCORE)
+	{
+		dwRewardVnum = (iMiniGameOkeyNormal > 0) ? RUMI_NORMAL_LOW_REWARD : RUMI_LOW_REWARD;
+	}
+
+	const TItemTable* pkTable = ITEM_MANAGER::instance().GetTable(dwRewardVnum);
+	if (!pkTable)
+	{
+		sys_err("CMiniGameRumi::Reward - Failed to get item table. (ch: %s) (%d)",
+			m_pChar->GetName(), dwRewardVnum);
+		return;
+	}
+
+	bool bEnoughInventoryForItem = m_pChar->GetEmptyInventory(pkTable->bSize) != -1;
+	if (!bEnoughInventoryForItem)
+	{
+		m_pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only receive your prize once you have made space in your inventory."));
+		return;
+	}
+
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	m_pChar->AutoGiveItem(dwRewardVnum, 1, -1, true, true);
+#else
+	m_pChar->AutoGiveItem(dwRewardVnum, 1, -1, true);
+#endif
+
+	UpdateMyScore(m_pChar->GetPlayerID());
+
+	m_pChar->SetMiniGameRumi(nullptr);
+}
+
+void CMiniGameRumi::UpdateMyScore(DWORD dwPID)
+{
+	char szQuery[2048 + 1];
+	int iLen = 0;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "INSERT INTO `minigame_rumi%s` (`pid`, `best_score`, `total_score`, `last_play`) ", get_table_postfix()))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "VALUES (%u, %u, %u, FROM_UNIXTIME(%d)) ", dwPID, m_wScore, m_wScore, std::time(nullptr)))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "ON DUPLICATE KEY UPDATE "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "`total_score` = `total_score` + %d, ", m_wScore))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "`best_score` = if (%d > `best_score`, %d, `best_score`) ", m_wScore, m_wScore))
+		return;
+	DBManager::instance().DirectQuery(szQuery);
+}
+
+void CMiniGameRumi::SendPacket(BYTE bSubHeader, void* pvData)
+{
+	if (m_pChar == nullptr)
+		return;
+
+	const LPDESC pkDesc = m_pChar->GetDesc();
+	if (pkDesc == nullptr)
+	{
+		sys_err("CMiniGameRumi::SendPacket - Null DESC! (ch: %s) (%d)",
+			m_pChar->GetName(), bSubHeader);
+		return;
+	}
+
+	TPacketGCMiniGameRumi Packet;
+	Packet.bHeader = HEADER_GC_MINI_GAME_RUMI;
+	Packet.bSubHeader = bSubHeader;
+
+	const std::unordered_set<BYTE> EmptyData
+	{
+		RUMI_GC_SUBHEADER_END,
+		RUMI_GC_SUBHEADER_START,
+	};
+
+	if (pvData == nullptr && EmptyData.find(bSubHeader) == EmptyData.end())
+	{
+		sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null Data! Character: %s",
+			bSubHeader, m_pChar->GetName());
+		return;
+	}
+
+	switch (bSubHeader)
+	{
+		case RUMI_GC_SUBHEADER_END:
+		case RUMI_GC_SUBHEADER_START:
+		{
+			Packet.wSize = sizeof(Packet);
+			pkDesc->Packet(&Packet, sizeof(TPacketGCMiniGameRumi));
+		}
+		break;
+
+		case RUMI_GC_SUBHEADER_SET_DECK:
+		{
+			const TPacketGCMiniGameRumiSetDeck* pkData = static_cast<TPacketGCMiniGameRumiSetDeck*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null SetDeckPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameRumiSetDeck SetDeckPacket(pkData->bDeckCount);
+			Packet.wSize = sizeof(Packet) + sizeof(SetDeckPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
+			pkDesc->Packet(&SetDeckPacket, sizeof(TPacketGCMiniGameRumiSetDeck));
+		}
+		break;
+
+		case RUMI_GC_SUBHEADER_MOVE_CARD:
+		{
+			const TPacketGCMiniGameRumiMoveCard* pkData = static_cast<TPacketGCMiniGameRumiMoveCard*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null MoveCardPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameRumiMoveCard MoveCardPacket;
+			MoveCardPacket.bSrcPos = pkData->bSrcPos;
+			MoveCardPacket.bSrcIndex = pkData->bSrcIndex;
+			MoveCardPacket.bSrcColor = pkData->bSrcColor;
+			MoveCardPacket.bSrcNumber = pkData->bSrcNumber;
+			MoveCardPacket.bDstPos = pkData->bDstPos;
+			MoveCardPacket.bDstIndex = pkData->bDstIndex;
+			MoveCardPacket.bDstColor = pkData->bDstColor;
+			MoveCardPacket.bDstNumber = pkData->bDstNumber;
+
+			Packet.wSize = sizeof(Packet) + sizeof(MoveCardPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
+			pkDesc->Packet(&MoveCardPacket, sizeof(TPacketGCMiniGameRumiMoveCard));
+		}
+		break;
+
+		case RUMI_GC_SUBHEADER_SET_SCORE:
+		{
+			const TPacketGCMiniGameRumiSetScore* pkData = static_cast<TPacketGCMiniGameRumiSetScore*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameRumi::SendPacket(bSubHeader=%u) Null SetScorePacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameRumiSetScore SetScorePacket(pkData->wScore, pkData->wTotalScore);
+			Packet.wSize = sizeof(Packet) + sizeof(SetScorePacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
+			pkDesc->Packet(&SetScorePacket, sizeof(TPacketGCMiniGameRumiSetScore));
+		}
+		break;
+	}
+}
+
+void CMiniGameRumi::__ShuffleDeck()
+{
+	std::array<BYTE, RUMI_CARD_COLOR_MAX> aCardColor = { RUMI_RED_CARD, RUMI_BLUE_CARD, RUMI_YELLOW_CARD };
+	for (BYTE bColor : aCardColor)
+	{
+		for (BYTE bCardNumber = 1; bCardNumber <= RUMI_CARD_NUMBER_END; bCardNumber++)
+		{
+			m_vecDeck.emplace_back(bColor, bCardNumber);
+		}
+	}
+
+	static std::mt19937 rng(std::random_device{}());
+	std::shuffle(m_vecDeck.begin(), m_vecDeck.end(), rng);
+
+	TPacketGCMiniGameRumiSetDeck SetDeckPacket(static_cast<BYTE>(m_vecDeck.size()));
+	SendPacket(RUMI_GC_SUBHEADER_SET_DECK, &SetDeckPacket);
+}
+
+static bool __ContainsNumbers(const std::vector<BYTE>& rkNumVec, const std::vector<BYTE>& rkSearchNumVec)
+{
+	return std::all_of(rkSearchNumVec.begin(), rkSearchNumVec.end(),
+		[&](BYTE bNumber)
+		{
+			return std::find(rkNumVec.begin(), rkNumVec.end(), bNumber) != rkNumVec.end();
+		});
+}
+
+bool CMiniGameRumi::__CheckCombination()
+{
+	if (m_mapField.empty())
+		return false;
+
+	if (m_mapField.size() < RUMI_FIELD_CARD_INDEX_MAX)
+		return false;
+
+	std::vector<BYTE> vCardColor, vCardNumber;
+	for (const auto& it : m_mapField)
+	{
+		PairedCard Card = it.second;
+		vCardColor.push_back(Card.first);
+		vCardNumber.push_back(Card.second);
+	}
+
+	WORD wScore = 0;
+
+	const bool bSameNumber = std::all_of(vCardNumber.cbegin() + 1, vCardNumber.cend(),
+		[&](BYTE bNumber) { return bNumber == vCardNumber.front(); });
+
+	if (bSameNumber)
+	{
+		const BYTE bCardNumber = vCardNumber.front();
+		wScore = (bCardNumber * 10) + 10;
+	}
+	else
+	{
+		const bool bSameCardColors = std::all_of(vCardColor.cbegin() + 1, vCardColor.cend(),
+			[&](BYTE bColor) { return bColor == vCardColor.front(); });
+
+		for (BYTE bCardNumber = 1; bCardNumber <= 6; ++bCardNumber)
+		{
+			std::vector<BYTE> vSearchNumber
+			{
+				static_cast<BYTE>(bCardNumber),
+				static_cast<BYTE>(bCardNumber + 1),
+				static_cast<BYTE>(bCardNumber + 2)
+			};
+
+			if (__ContainsNumbers(vCardNumber, vSearchNumber))
+			{
+				wScore = (bCardNumber * 10);
+				break;
+			}
+		}
+
+		if (wScore > 0 && bSameCardColors)
+			wScore += 40;
+	}
+
+	if (wScore > 0)
+	{
+		m_mapField.clear();
+		m_wScore += wScore;
+
+		TPacketGCMiniGameRumiSetScore SetScorePacket(wScore, m_wScore);
+		SendPacket(RUMI_GC_SUBHEADER_SET_SCORE, &SetScorePacket);
+
+		return true;
+	}
+
+	return false;
+}
+
+INT CMiniGameRumi::__GetEmptyHandPosition() const
+{
+	if (m_mapHand.size() < RUMI_HAND_CARD_INDEX_MAX)
+	{
+		INT bPosition = 0;
+		while (m_mapHand.count(bPosition) > 0)
+			bPosition++;
+
+		return bPosition;
+	}
+	return -1;
+}
+
+INT CMiniGameRumi::__GetEmptyFieldPosition() const
+{
+	if (m_mapField.size() < RUMI_FIELD_CARD_INDEX_MAX)
+	{
+		INT bPosition = 0;
+		while (m_mapField.count(bPosition) > 0)
+			bPosition++;
+
+		return bPosition;
+	}
+	return -1;
+}
+
+/* static */ void CMiniGameRumi::StartGame(LPCHARACTER pChar)
+{
+	if (!IsActiveEvent())
+	{
+		EndGame(pChar);
+		return;
+	}
+
+	if (pChar->GetMiniGameRumi())
+		return;
+
+	if (pChar->GetGold() < RUMI_START_GOLD)
+	{
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang."));
+		return;
+	}
+
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+	const WORD wCardCount = pChar->GetQuestFlag("minigame_rumi.card_count");
+	if (wCardCount == 0)
+		return;
+
+	pChar->SetQuestFlag("minigame_rumi.card_count", wCardCount - 1);
+#else
+	if (pChar->CountSpecifyItem(ITEM_VNUM_RUMI_CARD_PACK))
+		return;
+
+	pChar->RemoveSpecifyItem(ITEM_VNUM_RUMI_CARD_PACK, 1);
+#endif
+	pChar->PointChange(POINT_GOLD, -RUMI_START_GOLD, true);
+
+	pChar->SetMiniGameRumi(new CMiniGameRumi(pChar));
+	pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Your game of okey has started!"));
+}
+
+/* static */ void CMiniGameRumi::EndGame(LPCHARACTER pChar)
+{
+	CMiniGameRumi* pMiniGameRumi = pChar->GetMiniGameRumi();
+	if (pMiniGameRumi)
+		pMiniGameRumi->Reward();
+}
+
+/* static */ void CMiniGameRumi::Analyze(LPCHARACTER pChar, BYTE bSubHeader, BOOL bUseCard, BYTE bIndex)
+{
+	CMiniGameRumi* pMiniGameRumi = pChar->GetMiniGameRumi();
+	if (pMiniGameRumi == nullptr)
+	{
+		sys_err("CMiniGameRumi::Analyze - Null MiniGameRumi! (ch: %s) (%d)",
+			pChar->GetName(), bSubHeader);
+		return;
+	}
+
+	switch (bSubHeader)
+	{
+		case RUMI_CG_SUBHEADER_DECK_CARD_CLICK:
+		{
+			if (pMiniGameRumi->GetDeckCount() == 0)
+			{
+				pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot draw any more cards."));
+				return;
+			}
+
+			if (pMiniGameRumi->GetEmptyHandPosition() == -1)
+			{
+				pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot draw any more cards when you have already selected some."));
+				return;
+			}
+
+#if defined(__RUMI_DEALER__)
+			for (BYTE bIndex = 0; bIndex < RUMI_HAND_CARD_INDEX_MAX; ++bIndex)
+				pMiniGameRumi->ClickDeckCard();
+#else
+			pMiniGameRumi->ClickDeckCard();
+#endif
+		}
+		break;
+
+		case RUMI_CG_SUBHEADER_HAND_CARD_CLICK:
+			pMiniGameRumi->ClickHandCard(bUseCard, bIndex);
+			break;
+
+		case RUMI_CG_SUBHEADER_FIELD_CARD_CLICK:
+			pMiniGameRumi->ClickFieldCard(bIndex);
+			break;
+
+		default:
+			sys_err("CMiniGameRumi::Analyze - Unknown SubHeader (ch: %s) (%d)",
+				pChar->GetName(), bSubHeader);
+			break;
+	}
+}
+
+/* static */ bool CMiniGameRumi::IsActiveEvent()
+{
+	if (quest::CQuestManager::instance().GetEventFlag("mini_game_okey"))
+		return true;
+
+	if (quest::CQuestManager::instance().GetEventFlag("mini_game_okey_normal"))
+		return true;
+
+	return false;
+}
+
+/* static */ void CMiniGameRumi::SpawnEventNPC(bool bSpawn)
+{
+	CharacterVectorInteractor vChar;
+	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(RUMI_TABLE, vChar))
+	{
+		std::for_each(vChar.begin(), vChar.end(),
+			[](LPCHARACTER pChar) { M2_DESTROY_CHARACTER(pChar); });
+	}
+
+	if (bSpawn)
+	{
+		std::unordered_map<long, std::pair<long, long>> mSpawnPoint
+		{
+			{ MAP_A1, { 607, 619 } },
+			{ MAP_B1, { 595, 613 } },
+			{ MAP_C1, { 353, 741 } },
+		};
+
+		for (const auto& it : mSpawnPoint)
+		{
+			long lMapIndex = it.first;
+			const auto& rkPos = it.second;
+
+			if (!map_allow_find(lMapIndex))
+				continue;
+
+			const LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
+			if (pkSectreeMap == nullptr)
+				continue;
+
+			long xPos = pkSectreeMap->m_setting.iBaseX + rkPos.first * 100;
+			long yPos = pkSectreeMap->m_setting.iBaseY + rkPos.second * 100;
+
+			CHARACTER_MANAGER::instance().SpawnMob(RUMI_TABLE, lMapIndex,
+				xPos, yPos, 0, false, 90, true);
+		}
+	}
+}
+
+/* static */ void CMiniGameRumi::RequestQuestFlag(LPCHARACTER pChar, BYTE bSubHeader)
+{
+	const LPDESC pkDesc = pChar->GetDesc();
+	if (pkDesc == nullptr)
+	{
+		sys_err("CMiniGameRumi::RequestQuestFlag - Null DESC! (ch: %s) (%d)",
+			pChar->GetName(), bSubHeader);
+		return;
+	}
+
+	const WORD wCardPieceCount = pChar->GetQuestFlag("minigame_rumi.card_piece_count");
+	const WORD wCardCount = pChar->GetQuestFlag("minigame_rumi.card_count");
+
+	TPacketGCMiniGameRumi Packet;
+	Packet.bHeader = HEADER_GC_MINI_GAME_RUMI;
+	Packet.bSubHeader = bSubHeader;
+
+	TPacketGCMiniGameRumiQuestFlag QuestFlagPacket(wCardPieceCount, wCardCount);
+	Packet.wSize = sizeof(Packet) + sizeof(QuestFlagPacket);
+
+	pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameRumi));
+	pkDesc->Packet(&QuestFlagPacket, sizeof(TPacketGCMiniGameRumiQuestFlag));
+}
+
+/* static */ bool CMiniGameRumi::UpdateQuestFlag(LPCHARACTER pChar)
+{
+	if (!IsActiveEvent())
+		return false;
+
+	const WORD wCardPieceCount = pChar->GetQuestFlag("minigame_rumi.card_piece_count");
+	const WORD wCardCount = pChar->GetQuestFlag("minigame_rumi.card_count");
+
+	if (wCardCount >= RUMI_CARD_COUNT_MAX)
+	{
+		RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_NO_MORE_GAIN);
+		return false;
+	}
+
+	if (wCardPieceCount + 1 >= RUMI_CARD_PIECE_COUNT_MAX)
+	{
+		pChar->SetQuestFlag("minigame_rumi.card_piece_count", 0);
+		pChar->SetQuestFlag("minigame_rumi.card_count", wCardCount + 1);
+
+		RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_CARD_FLAG);
+	}
+	else
+	{
+		pChar->SetQuestFlag("minigame_rumi.card_piece_count", wCardPieceCount + 1);
+
+		RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG);
+	}
+
+	return true;
+}
+
+/* static */ void CMiniGameRumi::GetScoreTable(lua_State* L, bool bTotal)
+{
+	DWORD dwIndex = 1;
+	lua_newtable(L);
+
+	char szQuery[2048 + 1];
+	int iLen = 0;
+
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "SELECT "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "`player`.`name`, "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, bTotal ? "`total_score` " : "`best_score` "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "FROM `minigame_rumi` "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "LEFT JOIN (SELECT `id`, `name` AS `name` FROM `player`) AS `player` ON `player`.`id` = `minigame_rumi`.`pid` "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, bTotal ? "ORDER BY `total_score` DESC " : "ORDER BY `best_score` DESC "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "LIMIT 10 "))
+		return;
+
+	if (iLen >= sizeof(szQuery))
+		return;
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	SQLResult* pRes = pMsg->Get();
+	if (pRes && pRes->uiNumRows > 0)
+	{
+		MYSQL_ROW RowData;
+		while ((RowData = mysql_fetch_row(pRes->pSQLResult)))
+		{
+			if (RowData[0] == NULL || RowData[1] == NULL)
+				continue;
+
+			if (RowData[0][0] == '[') // GM
+				continue;
+
+			DWORD dwScore = 0;
+			str_to_number(dwScore, RowData[1]);
+
+			if (dwScore == 0)
+				continue;
+
+			lua_newtable(L);
+
+			// Name
+			lua_pushstring(L, RowData[0]);
+			lua_rawseti(L, -2, 1);
+
+			// Score
+			lua_pushnumber(L, dwScore);
+			lua_rawseti(L, -2, 2);
+
+			lua_rawseti(L, -2, dwIndex++);
+		}
+	}
+}
+
+/* static */ DWORD CMiniGameRumi::GetMyScoreValue(lua_State* L, DWORD dwPID, bool bTotal)
+{
+	char szQuery[2048 + 1];
+	int iLen = 0;
+
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "SELECT "))
+		return 0;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, bTotal ? "`total_score` " : "`best_score` "))
+		return 0;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "FROM `minigame_rumi` WHERE `pid` = %u ", dwPID))
+		return 0;
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	const SQLResult* pkRes = pMsg->Get();
+	if (pkRes && pkRes->uiNumRows > 0)
+	{
+		MYSQL_ROW RowData = mysql_fetch_row(pkRes->pSQLResult);
+
+		DWORD dwScore;
+		str_to_number(dwScore, RowData[0]);
+
+		return dwScore;
+	}
+
+	return 0;
+}
+#endif // __MINI_GAME_RUMI__
diff --git a/server/metin2/Source/Server/game/src/minigame_yutnori.cpp b/server/metin2/Source/Server/game/src/minigame_yutnori.cpp
index eeedc91..0208964 100644
--- a/server/metin2/Source/Server/game/src/minigame_yutnori.cpp
+++ b/server/metin2/Source/Server/game/src/minigame_yutnori.cpp
@@ -1,1114 +1,1165 @@
-/**
-* Filename: minigame_yutnori.cpp
-* Author: Owsap
-**/
-
-#include "stdafx.h"
-
-#if defined(__MINI_GAME_YUTNORI__)
-#include "minigame_yutnori.h"
-
-#include "char.h"
-#include "desc.h"
-#include "char_manager.h"
-#include "questmanager.h"
-#include "sectree_manager.h"
-#include "unique_item.h"
-#include "db.h"
-#include "config.h"
-
-CMiniGameYutnori::CMiniGameYutnori(LPCHARACTER pChar) : m_pChar(pChar)
-{
-	m_bFirstThrow = true;
-	m_bReThrow = false;
-
-	m_wScore = YUTNORI_INIT_SCORE;
-	m_bRemainCount = YUTNORI_INIT_REMAIN_COUNT;
-	m_bRecvReward = false;
-	m_bYutProb = YUTNORI_YUTSEM1;
-
-	m_bPC = true;
-
-	m_bPCYut = 0;
-	memset(&m_bPCUnitPos, 0, sizeof(m_bPCUnitPos));
-	memset(&m_bPCUnitLastPos, 0, sizeof(m_bPCUnitLastPos));
-
-	m_bCOMYut = 0;
-	memset(&m_bCOMUnitPos, 0, sizeof(m_bCOMUnitPos));
-	memset(&m_bCOMUnitLastPos, 0, sizeof(m_bCOMUnitLastPos));
-	m_bComNextUnitIndex = false;
-
-	SendPacket(YUTNORI_GC_SUBHEADER_START);
-}
-
-CMiniGameYutnori::~CMiniGameYutnori()
-{
-	m_bFirstThrow = false;
-	m_bReThrow = false;
-
-	m_wScore = 0;
-	m_bRemainCount = 0;
-	m_bRecvReward = false;
-	m_bYutProb = 0;
-
-	m_bPC = false;
-
-	m_bPCYut = 0;
-	memset(&m_bPCUnitPos, 0, sizeof(m_bPCUnitPos));
-	memset(&m_bPCUnitLastPos, 0, sizeof(m_bPCUnitLastPos));
-
-	m_bCOMYut = 0;
-	memset(&m_bCOMUnitPos, 0, sizeof(m_bCOMUnitPos));
-	memset(&m_bCOMUnitLastPos, 0, sizeof(m_bCOMUnitLastPos));
-	m_bComNextUnitIndex = false;
-
-	SendPacket(YUTNORI_GC_SUBHEADER_STOP);
-}
-
-void CMiniGameYutnori::Giveup()
-{
-	m_pChar->SetMiniGameYutnori(nullptr);
-}
-
-void CMiniGameYutnori::SetProb(BYTE bProbIndex)
-{
-	if (bProbIndex >= YUTNORI_YUTSEM_MAX)
-		return;
-
-	m_bYutProb = bProbIndex;
-
-	TPacketGCMiniGameYutnoriSetProb SetProbPacket(bProbIndex);
-	SendPacket(YUTNORI_GC_SUBHEADER_SET_PROB, &SetProbPacket);
-}
-
-void CMiniGameYutnori::Throw(bool bPC)
-{
-	if (bPC && !m_bPC)
-		return;
-
-	if (!bPC && m_bPC)
-		return;
-
-	if (m_bFirstThrow)
-	{
-		BYTE bRandomYut = __GetRandomYut(false, true);
-
-		TPacketGCMiniGameYutnoriThrow ThrowPacket(bPC, bRandomYut);
-		SendPacket(YUTNORI_GC_SUBHEADER_THROW, &ThrowPacket);
-
-		if (bPC)
-		{
-			m_bPC = false;
-			m_bPCYut = bRandomYut;
-
-			__PushNextTurn(false, YUTNORI_BEFORE_TURN_SELECT);
-		}
-		else
-		{
-			m_bFirstThrow = false;
-			m_bPC = (m_bPCYut < bRandomYut);
-
-			__PushNextTurn(m_bPC, YUTNORI_AFTER_TURN_SELECT);
-		}
-	}
-	else
-	{
-		bool bReThrow = m_bReThrow;
-
-		if (m_bReThrow)
-			m_bReThrow = false;
-
-		if (bPC && !bReThrow)
-		{
-			__UpdateScore(false, false);
-			__UpdateRemainCount();
-		}
-
-		bool bExcludeYutSem6 = __IsExcludeYutSem6(bPC);
-		BYTE bRandomYut = __GetRandomYut(bReThrow, bExcludeYutSem6, bPC ? m_bYutProb : YUTNORI_YUTSEM_MAX);
-
-		// Avoid getting the same Yut again.
-		BYTE bLastYut = bPC ? m_bPCYut : m_bCOMYut;
-		while (bRandomYut == bLastYut)
-		{
-			bRandomYut = __GetRandomYut(bReThrow, bExcludeYutSem6, bPC ? m_bYutProb : YUTNORI_YUTSEM_MAX);
-		}
-
-		TPacketGCMiniGameYutnoriThrow ThrowPacket(bPC, bRandomYut);
-		SendPacket(YUTNORI_GC_SUBHEADER_THROW, &ThrowPacket);
-
-		if (bRandomYut == YUTNORI_YUTSEM6)
-		{
-			bool bCanMove = __CanMove(bPC);
-
-			m_bPC = bPC ? bCanMove : !bCanMove;
-
-			if (bPC)
-				m_bPCYut = bRandomYut;
-			else
-				m_bCOMYut = bRandomYut;
-
-			__PushNextTurn(bPC ? bCanMove : !bCanMove, bCanMove ? YUTNORI_STATE_MOVE : YUTNORI_STATE_THROW);
-		}
-		else
-		{
-			m_bPC = bPC;
-
-			if (bPC)
-				m_bPCYut = bRandomYut;
-			else
-				m_bCOMYut = bRandomYut;
-
-			__PushNextTurn(bPC, YUTNORI_STATE_MOVE);
-		}
-	}
-}
-
-void CMiniGameYutnori::CharClick(BYTE bUnitIndex)
-{
-	if (!m_bPC)
-		return;
-
-	if (bUnitIndex >= YUTNORI_PLAYER_MAX)
-		return;
-
-	BYTE bStartIndex = m_bPCUnitPos[bUnitIndex];
-	BYTE bDestIndex = bStartIndex;
-	BYTE bLastIndex = m_bPCUnitLastPos[bUnitIndex];
-
-	if (bStartIndex == YUTNORI_GOAL_AREA)
-		return;
-
-	__GetDestPos(m_bPCYut, &bStartIndex, &bDestIndex, &bLastIndex);
-
-	TPacketGCMiniGameYutnoriAvailableArea AvailableAreaPacket(bUnitIndex, bDestIndex);
-	SendPacket(YUTNORI_GC_SUBHEADER_AVAILABLE_AREA, &AvailableAreaPacket);
-}
-
-void CMiniGameYutnori::Move(BYTE bUnitIndex)
-{
-	if (!m_bPC)
-		return;
-
-	if (bUnitIndex >= YUTNORI_PLAYER_MAX)
-		return;
-
-	BYTE bStartIndex = m_bPCUnitPos[bUnitIndex];
-	BYTE bDestIndex = bStartIndex;
-	BYTE bLastIndex = m_bPCUnitLastPos[bUnitIndex];
-
-	if (bStartIndex == YUTNORI_GOAL_AREA)
-		return;
-
-	__GetDestPos(m_bPCYut, &bStartIndex, &bDestIndex, &bLastIndex);
-
-	bool bIsCatch = false;
-	{
-		for (BYTE bUnitIdx = 0; bUnitIdx < YUTNORI_PLAYER_MAX; ++bUnitIdx)
-		{
-			if (m_bCOMUnitPos[bUnitIdx] == bDestIndex && bDestIndex != 0 && bDestIndex != YUTNORI_GOAL_AREA)
-			{
-				__UpdateScore(true, false);
-
-				m_bCOMUnitPos[bUnitIdx] = 0;
-				m_bCOMUnitLastPos[bUnitIdx] = 0;
-
-				TPacketGCMiniGameYutnoriPushCatchYut PushCatchYutPacket(false, bUnitIdx);
-				SendPacket(YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT, &PushCatchYutPacket);
-
-				bIsCatch = true;
-			}
-		}
-	}
-
-	TPacketGCMiniGameYutnoriMove MovePacket(true, bUnitIndex, bIsCatch, bStartIndex, bDestIndex);
-	SendPacket(YUTNORI_GC_SUBHEADER_MOVE, &MovePacket);
-
-	if (__IsDouble(m_bPCUnitPos))
-	{
-		if (bDestIndex == YUTNORI_GOAL_AREA)
-			__UpdateScore(true, true);
-
-		for (BYTE bUnitIndx = 0; bUnitIndx < YUTNORI_PLAYER_MAX; ++bUnitIndx)
-		{
-			m_bPCUnitPos[bUnitIndx] = bDestIndex;
-			m_bPCUnitLastPos[bUnitIndx] = bLastIndex;
-		}
-	}
-	else
-	{
-		if (bDestIndex == YUTNORI_GOAL_AREA)
-			__UpdateScore(true, false);
-
-		m_bPCUnitPos[bUnitIndex] = bDestIndex;
-		m_bPCUnitLastPos[bUnitIndex] = bLastIndex;
-	}
-
-	if (__IsGoalArea(m_bPCUnitPos))
-	{
-		m_bRecvReward = true;
-		__PushNextTurn(true, YUTNORI_STATE_END);
-	}
-	else
-	{
-		if (m_bRemainCount == 0 || m_wScore == 0)
-		{
-			if (m_wScore == 0)
-				m_bRecvReward = false;
-			else
-				m_bRecvReward = true;
-
-			__PushNextTurn(false, YUTNORI_STATE_END);
-		}
-		else
-		{
-			if (m_bPCYut == YUTNORI_YUTSEM4 || m_bPCYut == YUTNORI_YUTSEM5)
-			{
-				m_bReThrow = true;
-				__PushNextTurn(true, YUTNORI_STATE_RE_THROW);
-			}
-			else
-			{
-				m_bPC = false;
-				__PushNextTurn(false, YUTNORI_STATE_THROW);
-			}
-		}
-	}
-}
-
-void CMiniGameYutnori::RequestComAction()
-{
-	if (m_bPC)
-		return;
-
-	BYTE bUnitIndex = __GetComUnitIndex();
-	if (bUnitIndex == YUTNORI_PLAYER_MAX)
-		return;
-
-	m_bComNextUnitIndex = bUnitIndex ? 0 : 1;
-
-	BYTE bStartIndex = m_bCOMUnitPos[bUnitIndex];
-	BYTE bDestIndex = bStartIndex;
-	BYTE bLastIndex = m_bCOMUnitLastPos[bUnitIndex];
-
-	if (bStartIndex == YUTNORI_GOAL_AREA)
-		return;
-
-	__GetDestPos(m_bCOMYut, &bStartIndex, &bDestIndex, &bLastIndex);
-
-	bool bIsCatch = false;
-	{
-		for (BYTE bUnitIdx = 0; bUnitIdx < YUTNORI_PLAYER_MAX; ++bUnitIdx)
-		{
-			if (m_bPCUnitPos[bUnitIdx] == bDestIndex && bDestIndex != 0 && bDestIndex != YUTNORI_GOAL_AREA)
-			{
-				__UpdateScore(false, false);
-
-				m_bPCUnitPos[bUnitIdx] = 0;
-				m_bPCUnitLastPos[bUnitIdx] = 0;
-
-				TPacketGCMiniGameYutnoriPushCatchYut PushCatchYutPacket(true, bUnitIdx);
-				SendPacket(YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT, &PushCatchYutPacket);
-
-				bIsCatch = true;
-			}
-		}
-	}
-
-	TPacketGCMiniGameYutnoriMove MovePacket(false, bUnitIndex, bIsCatch, bStartIndex, bDestIndex);
-	SendPacket(YUTNORI_GC_SUBHEADER_MOVE, &MovePacket);
-
-	if (__IsDouble(m_bCOMUnitPos))
-	{
-		if (bDestIndex == YUTNORI_GOAL_AREA)
-			__UpdateScore(false, true);
-
-		for (BYTE bUnitIndx = 0; bUnitIndx < YUTNORI_PLAYER_MAX; ++bUnitIndx)
-		{
-			m_bCOMUnitPos[bUnitIndx] = bDestIndex;
-			m_bCOMUnitLastPos[bUnitIndx] = bLastIndex;
-		}
-	}
-	else
-	{
-		if (bDestIndex == YUTNORI_GOAL_AREA)
-			__UpdateScore(false, false);
-
-		m_bCOMUnitPos[bUnitIndex] = bDestIndex;
-		m_bCOMUnitLastPos[bUnitIndex] = bLastIndex;
-	}
-
-	if (__IsGoalArea(m_bCOMUnitPos))
-	{
-		m_bRecvReward = true;
-		__PushNextTurn(false, YUTNORI_STATE_END);
-	}
-	else
-	{
-		if (m_bCOMYut == YUTNORI_YUTSEM4 || m_bCOMYut == YUTNORI_YUTSEM5)
-		{
-			m_bReThrow = true;
-			__PushNextTurn(false, YUTNORI_STATE_RE_THROW);
-		}
-		else
-		{
-			m_bPC = true;
-			__PushNextTurn(true, YUTNORI_STATE_THROW);
-		}
-	}
-}
-
-void CMiniGameYutnori::Reward()
-{
-	if (!m_bRecvReward)
-		return;
-
-	m_bRecvReward = false;
-
-	const WORD wScore = m_wScore;
-	if (wScore < YUTNORI_LOW_TOTAL_SCORE)
-	{
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		m_pChar->AutoGiveItem(YUTNORI_LOW_REWARD, 1, -1, true, true);
-#else
-		m_pChar->AutoGiveItem(YUTNORI_LOW_REWARD, 1, -1, true);
-#endif
-	}
-	else if (wScore >= YUTNORI_LOW_TOTAL_SCORE && wScore < YUTNORI_MID_TOTAL_SCORE)
-	{
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		m_pChar->AutoGiveItem(YUTNORI_MID_REWARD, 1, -1, true, true);
-#else
-		m_pChar->AutoGiveItem(YUTNORI_MID_REWARD, 1, -1, true);
-#endif
-	}
-	else if (wScore >= YUTNORI_MID_TOTAL_SCORE)
-	{
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		m_pChar->AutoGiveItem(YUTNORI_HIGH_REWARD, 1, -1, true, true);
-#else
-		m_pChar->AutoGiveItem(YUTNORI_HIGH_REWARD, 1, -1, true);
-#endif
-	}
-
-	__UpdateMyScore(m_pChar->GetPlayerID());
-
-	m_pChar->SetMiniGameYutnori(nullptr);
-}
-
-void CMiniGameYutnori::__UpdateScore(bool bIncrease, bool bIsDouble)
-{
-	if (bIncrease)
-	{
-		if (bIsDouble)
-			m_wScore = MAX(0, m_wScore + (YUTNORI_IN_DE_CREASE_SCORE * 2));
-		else
-			m_wScore = MAX(0, m_wScore + YUTNORI_IN_DE_CREASE_SCORE);
-	}
-	else
-	{
-		if (bIsDouble)
-			m_wScore = MAX(0, m_wScore - (YUTNORI_IN_DE_CREASE_SCORE * 2));
-		else
-			m_wScore = MAX(0, m_wScore - YUTNORI_IN_DE_CREASE_SCORE);
-	}
-
-	TPacketGCMiniGameYutnoriSetScore SetScorePacket(m_wScore);
-	SendPacket(YUTNORI_GC_SUBHEADER_SET_SCORE, &SetScorePacket);
-}
-
-void CMiniGameYutnori::__UpdateRemainCount()
-{
-	m_bRemainCount = MAX(0, m_bRemainCount - 1);
-
-	TPacketGCMiniGameYutnoriSetRemainCount SetRemainCountPacket(m_bRemainCount);
-	SendPacket(YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT, &SetRemainCountPacket);
-}
-
-bool CMiniGameYutnori::__IsGoalArea(BYTE* pbUnitPos)
-{
-	bool bIsGoalArea = false;
-	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
-	{
-		if (pbUnitPos[bUnitIndex] == pbUnitPos[(bUnitIndex + 1) % YUTNORI_PLAYER_MAX] &&
-			pbUnitPos[bUnitIndex] == YUTNORI_GOAL_AREA)
-		{
-			bIsGoalArea = true;
-			break;
-		}
-	}
-
-	return bIsGoalArea;
-}
-
-bool CMiniGameYutnori::__IsDouble(BYTE* pbUnitPos)
-{
-	bool bIsDouble = false;
-	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
-	{
-		if (pbUnitPos[bUnitIndex] == pbUnitPos[(bUnitIndex + 1) % YUTNORI_PLAYER_MAX] &&
-			pbUnitPos[bUnitIndex] != 0 && pbUnitPos[bUnitIndex] != YUTNORI_GOAL_AREA)
-		{
-			bIsDouble = true;
-			break;
-		}
-	}
-
-	return bIsDouble;
-}
-
-bool CMiniGameYutnori::__CanMove(bool bPC)
-{
-	const BYTE* pUnit = bPC ? m_bPCUnitPos : m_bCOMUnitPos;
-	bool bCanMove = true;
-
-	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
-	{
-		if (pUnit[bUnitIndex] == 0 || pUnit[bUnitIndex] == 11)
-		{
-			bCanMove = false;
-			break;
-		}
-	}
-
-	return bCanMove;
-}
-
-bool CMiniGameYutnori::__IsExcludeYutSem6(bool bPC)
-{
-	const BYTE* pUnit = bPC ? m_bPCUnitPos : m_bCOMUnitPos;
-	bool bExcludeYutSem6 = false;
-
-	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
-	{
-		if (pUnit[bUnitIndex] == YUTNORI_GOAL_AREA || pUnit[bUnitIndex] == YUTNORI_GOAL_AREA - 1)
-		{
-			bExcludeYutSem6 = true;
-			break;
-		}
-	}
-
-	return bExcludeYutSem6;
-}
-
-BYTE CMiniGameYutnori::__GetComUnitIndex()
-{
-	BYTE bStartIndexUnit1 = m_bCOMUnitPos[0];
-	BYTE bStartIndexUnit2 = m_bCOMUnitPos[1];
-
-	BYTE bDestIndexUnit1 = bStartIndexUnit1;
-	BYTE bDestIndexUnit2 = bStartIndexUnit2;
-
-	BYTE bLastIndexUnit1 = m_bCOMUnitLastPos[0];
-	BYTE bLastIndexUnit2 = m_bCOMUnitLastPos[1];
-
-	// Check if both units are in the goal area.
-	if (bStartIndexUnit1 == YUTNORI_GOAL_AREA && bStartIndexUnit2 == YUTNORI_GOAL_AREA)
-		return YUTNORI_PLAYER_MAX;
-
-	// Check if both units start at the same position.
-	if (bStartIndexUnit1 == bStartIndexUnit2)
-		return 0;
-
-	// Check conditions for excluding units based on YUTNORI_YUTSEM6.
-	bool bExcludeUnit1 = (m_bCOMYut == YUTNORI_YUTSEM6 && bStartIndexUnit1 == 0) || (bStartIndexUnit1 == YUTNORI_GOAL_AREA);
-	bool bExcludeUnit2 = (m_bCOMYut == YUTNORI_YUTSEM6 && bStartIndexUnit2 == 0) || (bStartIndexUnit2 == YUTNORI_GOAL_AREA);
-
-	// Determine the destination indices for each unit.
-	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
-	{
-		BYTE& bStartIndex = (bUnitIndex == 0) ? bStartIndexUnit1 : bStartIndexUnit2;
-		BYTE& bDestIndex = (bUnitIndex == 0) ? bDestIndexUnit1 : bDestIndexUnit2;
-		BYTE& bLastIndex = (bUnitIndex == 0) ? bLastIndexUnit1 : bLastIndexUnit2;
-
-		__GetDestPos(m_bCOMYut, &bStartIndex, &bDestIndex, &bLastIndex);
-	}
-
-	// Check if each unit catches any PC unit.
-	bool bCatchUnit1 = (bDestIndexUnit1 == m_bPCUnitPos[0] || bDestIndexUnit1 == m_bPCUnitPos[1]);
-	bool bCatchUnit2 = (bDestIndexUnit2 == m_bPCUnitPos[0] || bDestIndexUnit2 == m_bPCUnitPos[1]);
-
-	// Determine the computer's next unit index based on the conditions.
-	if (bCatchUnit1 && !bExcludeUnit1)
-		return 0;
-
-	if (bCatchUnit2 && !bExcludeUnit2)
-		return 1;
-
-	if (m_bComNextUnitIndex == 0 && bExcludeUnit1 && !bExcludeUnit2)
-		return 1;
-
-	if (m_bComNextUnitIndex == 1 && !bExcludeUnit1 && bExcludeUnit2)
-		return 0;
-
-	if (bExcludeUnit1 && bExcludeUnit2)
-		return YUTNORI_PLAYER_MAX;
-
-	return m_bComNextUnitIndex;
-}
-
-BYTE CMiniGameYutnori::__GetRandomYut(BYTE bReThrow, BYTE bExcludeYutSem6, BYTE bYutProb)
-{
-	std::vector<BYTE> vYutIndexes;
-	for (BYTE bYutIndex = YUTNORI_YUTSEM1; bYutIndex < YUTNORI_YUTSEM_MAX; ++bYutIndex)
-	{
-		// Avoid getting YUTSEM4 or YUTSEM5 if it's a re-throw.
-		if (bReThrow && (bYutIndex == YUTNORI_YUTSEM4 || bYutIndex == YUTNORI_YUTSEM5))
-			continue;
-
-		if (bExcludeYutSem6 && bYutIndex == YUTNORI_YUTSEM6)
-			continue;
-
-		// Add an additional chance for the selected Yut.
-		if (bYutIndex == bYutProb)
-			vYutIndexes.push_back(bYutIndex);
-
-		vYutIndexes.push_back(bYutIndex);
-	}
-
-	BYTE bRandomIndex = number(0, vYutIndexes.size() - 1);
-	return vYutIndexes[bRandomIndex];
-}
-
-void CMiniGameYutnori::__GetDestPos(BYTE bMoveCount, BYTE* bStartIndex, BYTE* bDestIndex, BYTE* bLastIndex)
-{
-	if (*bStartIndex == 0 || *bDestIndex == 0 || *bLastIndex == 0)
-		*bStartIndex = YUTNORI_GOAL_AREA;
-
-	*bDestIndex = *bStartIndex;
-
-	BYTE bNextIndex = *bDestIndex;
-	BYTE bPrevIndex = *bDestIndex;
-
-	if (bMoveCount == YUTNORI_YUTSEM6)
-	{
-		if (*bDestIndex == 20 || *bDestIndex == 21)
-			*bDestIndex = 1;
-		else if (*bDestIndex == 26 || *bDestIndex == 5)
-			*bDestIndex = 6;
-		else if (*bDestIndex == 28 || *bDestIndex == 24)
-			*bDestIndex = 23;
-		else if (*bDestIndex == 23)
-			*bDestIndex = (*bDestIndex == 23 && *bLastIndex == 27) ? 27 : 22;
-		else if (*bDestIndex == 16)
-			*bDestIndex = (*bDestIndex == 16 || *bLastIndex == 29) ? 29 : 17;
-		else
-			*bDestIndex = (*bDestIndex <= 20) ? *bDestIndex + 1 : *bDestIndex - 1;
-	}
-	else
-	{
-		for (BYTE bIndex = 0; bIndex < bMoveCount + 1; ++bIndex)
-		{
-			if (*bDestIndex == 1)
-			{
-				bPrevIndex = *bDestIndex;
-				*bDestIndex = (bNextIndex == 1) ? 21 : 20;
-				*bLastIndex = bPrevIndex;
-				continue;
-			}
-			else if (*bDestIndex == 6)
-			{
-				bPrevIndex = *bDestIndex;
-				*bDestIndex = (bNextIndex == 6) ? 26 : 5;
-				*bLastIndex = bPrevIndex;
-				continue;
-			}
-			else if (*bDestIndex == 23)
-			{
-				bPrevIndex = *bDestIndex;
-				*bDestIndex = (bNextIndex == 23 || *bLastIndex == 22) ? 24 : 28;
-				*bLastIndex = bPrevIndex;
-				continue;
-			}
-			else if (*bDestIndex == 27)
-			{
-				bPrevIndex = *bDestIndex;
-				*bDestIndex = 23;
-				*bLastIndex = bPrevIndex;
-				continue;
-			}
-			else if (*bDestIndex == 29)
-			{
-				bPrevIndex = *bDestIndex;
-				*bDestIndex = 16;
-				*bLastIndex = bPrevIndex;
-				continue;
-			}
-			else if (*bDestIndex == 25 || *bDestIndex == 12)
-			{
-				bPrevIndex = *bDestIndex;
-				*bDestIndex = 11;
-				*bLastIndex = bPrevIndex;
-				break;
-			}
-			else
-			{
-				bPrevIndex = *bDestIndex;
-				*bDestIndex = (*bDestIndex <= 20) ? *bDestIndex - 1 : *bDestIndex + 1;
-				*bLastIndex = bPrevIndex;
-				continue;
-			}
-		}
-	}
-}
-
-void CMiniGameYutnori::__PushNextTurn(bool bPC, BYTE bState)
-{
-	TPacketGCMiniGameYutnoriPushNextTurn PushNextTurnPacket(bPC, bState);
-	SendPacket(YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN, &PushNextTurnPacket);
-}
-
-void CMiniGameYutnori::SendPacket(BYTE bSubHeader, void* pvData)
-{
-	if (m_pChar == nullptr)
-		return;
-
-	const LPDESC pkDesc = m_pChar->GetDesc();
-	if (pkDesc == nullptr)
-	{
-		sys_err("CMiniGameYutnori::SendPacket - Null DESC! (ch: %s) (%d)",
-			m_pChar->GetName(), bSubHeader);
-		return;
-	}
-
-	TPacketGCMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_GC_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = bSubHeader;
-
-	const std::unordered_set<BYTE> EmptyData
-	{
-		YUTNORI_GC_SUBHEADER_START,
-		YUTNORI_GC_SUBHEADER_STOP,
-	};
-
-	if (pvData == nullptr && EmptyData.find(bSubHeader) == EmptyData.end())
-	{
-		sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null Data! Character: %s",
-			bSubHeader, m_pChar->GetName());
-		return;
-	}
-
-	switch (bSubHeader)
-	{
-		case YUTNORI_GC_SUBHEADER_START:
-		case YUTNORI_GC_SUBHEADER_STOP:
-		{
-			Packet.wSize = sizeof(Packet);
-			pkDesc->Packet(&Packet, sizeof(TPacketGCMiniGameYutnori));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_SET_PROB:
-		{
-			const TPacketGCMiniGameYutnoriSetProb* pkData = static_cast<TPacketGCMiniGameYutnoriSetProb*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null SetProbPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriSetProb SetProbPacket(pkData->bProbIndex);
-			Packet.wSize = sizeof(Packet) + sizeof(SetProbPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&SetProbPacket, sizeof(TPacketGCMiniGameYutnoriSetProb));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_THROW:
-		{
-			const TPacketGCMiniGameYutnoriThrow* pkData = static_cast<TPacketGCMiniGameYutnoriThrow*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null ThrowYutPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriThrow ThrowPacket(pkData->bPC, pkData->bYut);
-			Packet.wSize = sizeof(Packet) + sizeof(ThrowPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&ThrowPacket, sizeof(TPacketGCMiniGameYutnoriThrow));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_MOVE:
-		{
-			const TPacketGCMiniGameYutnoriMove* pkData = static_cast<TPacketGCMiniGameYutnoriMove*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null MoveYutPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriMove MovePacket(pkData->bPC, pkData->bUnitIndex, pkData->bIsCatch, pkData->bStartIndex, pkData->bDestIndex);
-			Packet.wSize = sizeof(Packet) + sizeof(MovePacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&MovePacket, sizeof(TPacketGCMiniGameYutnoriMove));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_AVAILABLE_AREA:
-		{
-			const TPacketGCMiniGameYutnoriAvailableArea* pkData = static_cast<TPacketGCMiniGameYutnoriAvailableArea*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null AvailAreaPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriAvailableArea AvailAreaPacket(pkData->bPlayerIndex, pkData->bAvailableIndex);
-			Packet.wSize = sizeof(Packet) + sizeof(AvailAreaPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&AvailAreaPacket, sizeof(TPacketGCMiniGameYutnoriAvailableArea));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT:
-		{
-			const TPacketGCMiniGameYutnoriPushCatchYut* pkData = static_cast<TPacketGCMiniGameYutnoriPushCatchYut*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null PushCatchYutPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriPushCatchYut PushCatchYutPacket(pkData->bPC, pkData->bUnitIndex);
-			Packet.wSize = sizeof(Packet) + sizeof(PushCatchYutPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&PushCatchYutPacket, sizeof(TPacketGCMiniGameYutnoriPushCatchYut));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_SET_SCORE:
-		{
-			const TPacketGCMiniGameYutnoriSetScore* pkData = static_cast<TPacketGCMiniGameYutnoriSetScore*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null SetScorePacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriSetScore SetScorePacket(pkData->wScore);
-			Packet.wSize = sizeof(Packet) + sizeof(SetScorePacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&SetScorePacket, sizeof(TPacketGCMiniGameYutnoriSetScore));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT:
-		{
-			const TPacketGCMiniGameYutnoriSetRemainCount* pkData = static_cast<TPacketGCMiniGameYutnoriSetRemainCount*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null SetRemainCountPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriSetRemainCount SetRemainCountPacket(pkData->bRemainCount);
-			Packet.wSize = sizeof(Packet) + sizeof(SetRemainCountPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&SetRemainCountPacket, sizeof(TPacketGCMiniGameYutnoriSetRemainCount));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN:
-		{
-			const TPacketGCMiniGameYutnoriPushNextTurn* pkData = static_cast<TPacketGCMiniGameYutnoriPushNextTurn*>(pvData);
-			if (pkData == nullptr)
-			{
-				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null PushNextTurnPacket! Character: %s",
-					bSubHeader, m_pChar->GetName());
-				return;
-			}
-
-			TPacketGCMiniGameYutnoriPushNextTurn PushNextTurnPacket(pkData->bPC, pkData->bState);
-			Packet.wSize = sizeof(Packet) + sizeof(PushNextTurnPacket);
-
-			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-			pkDesc->Packet(&PushNextTurnPacket, sizeof(TPacketGCMiniGameYutnoriPushNextTurn));
-		}
-		break;
-	}
-}
-
-void CMiniGameYutnori::__UpdateMyScore(DWORD dwPID)
-{
-	char szQuery[2048 + 1];
-	int iLen = sprintf(szQuery, "INSERT INTO `player`.`minigame_yutnori` (`pid`, `best_score`, `total_score`, `last_play`) ");
-	iLen += sprintf(szQuery + iLen, "VALUES (%u, %u, %u, FROM_UNIXTIME(%d)) ", dwPID, m_wScore, m_wScore, std::time(nullptr));
-	iLen += sprintf(szQuery + iLen, "ON DUPLICATE KEY UPDATE ");
-	iLen += sprintf(szQuery + iLen, "`total_score` = `total_score` + %d,", m_wScore);
-	iLen += sprintf(szQuery + iLen, "`best_score` = if (%d > `best_score`, %d, `best_score`) ", m_wScore, m_wScore);
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-}
-
-//////////////////////////////////////////////////////////////////////////
-
-/* static */ void CMiniGameYutnori::Create(LPCHARACTER pChar)
-{
-	if (!IsActiveEvent())
-	{
-		Destroy(pChar);
-		return;
-	}
-
-	if (pChar->GetMiniGameYutnori())
-		return;
-
-	if (pChar->GetGold() < YUTNORI_START_GOLD)
-		return;
-
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-	const WORD wYutBoardCount = pChar->GetQuestFlag("minigame_yutnori.board_count");
-	if (wYutBoardCount == 0)
-		return;
-
-	pChar->SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount - 1);
-#else
-	if (pChar->CountSpecifyItem(ITEM_VNUM_YUT_BOARD))
-		return;
-
-	pChar->RemoveSpecifyItem(ITEM_VNUM_YUT_BOARD, 1);
-#endif
-	pChar->PointChange(POINT_GOLD, -YUTNORI_START_GOLD, true);
-
-	pChar->SetMiniGameYutnori(new CMiniGameYutnori(pChar));
-}
-
-/* static */ void CMiniGameYutnori::Destroy(LPCHARACTER pChar)
-{
-	pChar->SetMiniGameYutnori(nullptr);
-}
-
-/* static */ void CMiniGameYutnori::Analyze(LPCHARACTER pChar, BYTE bSubHeader, BYTE bArgument)
-{
-	CMiniGameYutnori* pMiniGameYutnori = pChar->GetMiniGameYutnori();
-	if (pMiniGameYutnori == nullptr)
-	{
-		sys_err("CMiniGameYutnori::Analyze - Null MiniGameYutnori! (ch: %s) (%d)",
-			pChar->GetName(), bSubHeader);
-		return;
-	}
-
-	switch (bSubHeader)
-	{
-		case YUTNORI_CG_SUBHEADER_SET_PROB:
-			pMiniGameYutnori->SetProb(bArgument);
-			break;
-
-		case YUTNORI_CG_SUBHEADER_CLICK_CHAR:
-			pMiniGameYutnori->CharClick(bArgument);
-			break;
-
-		case YUTNORI_CG_SUBHEADER_THROW:
-			pMiniGameYutnori->Throw(bArgument);
-			break;
-
-		case YUTNORI_CG_SUBHEADER_MOVE:
-			pMiniGameYutnori->Move(bArgument);
-			break;
-
-		case YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION:
-			pMiniGameYutnori->RequestComAction();
-			break;
-
-		case YUTNORI_CG_SUBHEADER_REWARD:
-			pMiniGameYutnori->Reward();
-			break;
-
-		default:
-			sys_err("CMiniGameYutnori::Analyze - Unknown SubHeader (ch: %s) (%d)",
-				pChar->GetName(), bSubHeader);
-			break;
-	}
-}
-
-/* static */ bool CMiniGameYutnori::IsActiveEvent()
-{
-	if (quest::CQuestManager::instance().GetEventFlag("mini_game_yutnori"))
-		return true;
-
-	return false;
-}
-
-/* static */ void CMiniGameYutnori::SpawnEventNPC(bool bSpawn)
-{
-	CharacterVectorInteractor vChar;
-	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(YUTNORI_TABLE, vChar))
-	{
-		std::for_each(vChar.begin(), vChar.end(),
-			[](LPCHARACTER pChar) { M2_DESTROY_CHARACTER(pChar); });
-	}
-
-	if (bSpawn)
-	{
-		std::unordered_map<long, std::pair<long, long>> mSpawnPoint
-		{
-			{ MAP_A1, { 608, 614 } },
-			{ MAP_B1, { 596, 608 } },
-			{ MAP_C1, { 358, 748 } },
-		};
-
-		for (const auto& it : mSpawnPoint)
-		{
-			long lMapIndex = it.first;
-			const auto& rkPos = it.second;
-
-			if (!map_allow_find(lMapIndex))
-				continue;
-
-			const LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
-			if (pkSectreeMap == nullptr)
-				continue;
-
-			long xPos = pkSectreeMap->m_setting.iBaseX + rkPos.first * 100;
-			long yPos = pkSectreeMap->m_setting.iBaseY + rkPos.second * 100;
-
-			CHARACTER_MANAGER::instance().SpawnMob(YUTNORI_TABLE, lMapIndex,
-				xPos, yPos, 0, false, 90, true);
-		}
-	}
-}
-
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-/* static */ void CMiniGameYutnori::RequestQuestFlag(LPCHARACTER pChar, BYTE bSubHeader)
-{
-	const LPDESC pDesc = pChar->GetDesc();
-	if (pDesc == nullptr)
-	{
-		sys_err("CMiniGameYutnori::RequestQuestFlag - Null DESC! (ch: %s) (%d)",
-			pChar->GetName(), bSubHeader);
-		return;
-	}
-
-	const WORD wYutPieceCount = pChar->GetQuestFlag("minigame_yutnori.piece_count");
-	const WORD wYutBoardCount = pChar->GetQuestFlag("minigame_yutnori.board_count");
-
-	TPacketGCMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_GC_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = bSubHeader;
-
-	TPacketGCMiniGameYutnoriQuestFlag QuestFlagPacket(wYutPieceCount, wYutBoardCount);
-	Packet.wSize = sizeof(Packet) + sizeof(QuestFlagPacket);
-
-	pDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
-	pDesc->Packet(&QuestFlagPacket, sizeof(TPacketGCMiniGameYutnoriQuestFlag));
-}
-
-/* static */ bool CMiniGameYutnori::UpdateQuestFlag(LPCHARACTER pChar)
-{
-	if (!IsActiveEvent())
-		return false;
-
-	const WORD wYutPieceCount = pChar->GetQuestFlag("minigame_yutnori.piece_count");
-	const WORD wYutBoardCount = pChar->GetQuestFlag("minigame_yutnori.board_count");
-
-	if (wYutBoardCount >= YUTNORI_BOARD_COUNT_MAX)
-	{
-		RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_NO_MORE_GAIN);
-		return false;
-	}
-
-	if (wYutPieceCount + 1 >= YUTNORI_PIECE_COUNT_MAX)
-	{
-		pChar->SetQuestFlag("minigame_yutnori.piece_count", 0);
-		pChar->SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount + 1);
-
-		RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG);
-	}
-	else
-	{
-		pChar->SetQuestFlag("minigame_yutnori.piece_count", wYutPieceCount + 1);
-
-		RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG);
-	}
-
-	return true;
-}
-#endif
-
-/* static */ void CMiniGameYutnori::GetScoreTable(lua_State* L, bool bTotal)
-{
-	DWORD dwIndex = 1;
-	lua_newtable(L);
-
-	char szQuery[2048 + 1];
-	int iLen = 0;
-
-	iLen += sprintf(szQuery + iLen, "SELECT ");
-	iLen += sprintf(szQuery + iLen, " `player`.`name`, ");
-	iLen += bTotal ? sprintf(szQuery + iLen, "`total_score` ") : sprintf(szQuery + iLen, "`best_score` ");
-	iLen += sprintf(szQuery + iLen, "FROM `minigame_yutnori` ");
-	iLen += sprintf(szQuery + iLen, "LEFT JOIN (SELECT `id`, `name` AS `name` FROM `player`) AS `player` ON `player`.`id` = `minigame_yutnori`.`pid` ");
-	iLen += bTotal ? sprintf(szQuery + iLen, "ORDER BY `total_score` DESC ") : sprintf(szQuery + iLen, "ORDER BY `best_score` DESC ");
-	iLen += sprintf(szQuery + iLen, "LIMIT 10 ");
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	const SQLResult* pkRes = pMsg->Get();
-	if (pkRes && pkRes->uiNumRows > 0)
-	{
-		MYSQL_ROW RowData;
-		while ((RowData = mysql_fetch_row(pkRes->pSQLResult)))
-		{
-			if (RowData[0][0] == '[') // GM
-				continue;
-
-			DWORD dwScore;
-			str_to_number(dwScore, RowData[1]);
-
-			if (dwScore == 0)
-				continue;
-
-			lua_newtable(L);
-
-			// Name
-			lua_pushstring(L, RowData[0]);
-			lua_rawseti(L, -2, 1);
-
-			// Score
-			lua_pushnumber(L, dwScore);
-			lua_rawseti(L, -2, 2);
-
-			lua_rawseti(L, -2, dwIndex++);
-		}
-	}
-}
-
-/* static */ DWORD CMiniGameYutnori::GetMyScoreValue(lua_State* L, DWORD dwPID, bool bTotal)
-{
-	char szQuery[2048 + 1];
-	int iLen = 0;
-
-	iLen += sprintf(szQuery + iLen, "SELECT");
-	iLen += bTotal ? sprintf(szQuery + iLen, "`total_score` ") : sprintf(szQuery + iLen, "`best_score` ");
-	iLen += sprintf(szQuery + iLen, "FROM `minigame_yutnori` WHERE `pid` = %u", dwPID);
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
-	const SQLResult* pkRes = pMsg->Get();
-	if (pkRes && pkRes->uiNumRows > 0)
-	{
-		MYSQL_ROW RowData = mysql_fetch_row(pkRes->pSQLResult);
-
-		DWORD dwScore;
-		str_to_number(dwScore, RowData[0]);
-
-		return dwScore;
-	}
-
-	return 0;
-}
-
-#endif // __MINI_GAME_YUTNORI__
+#include <cstdarg>
+
+static bool SafeAppendQuery(char* buf, size_t cap, size_t& len, const char* fmt, ...)
+{
+	if (!buf || cap == 0 || len >= cap)
+		return false;
+	va_list ap;
+	va_start(ap, fmt);
+	int n = vsnprintf(buf + len, cap - len, fmt, ap);
+	va_end(ap);
+	if (n < 0)
+		return false;
+	if ((size_t)n >= cap - len)
+		return false;
+	len += (size_t)n;
+	return true;
+}
+/**
+* Filename: minigame_yutnori.cpp
+* Author: Owsap
+**/
+
+#include "stdafx.h"
+
+#if defined(__MINI_GAME_YUTNORI__)
+#include "minigame_yutnori.h"
+
+#include "char.h"
+#include "desc.h"
+#include "char_manager.h"
+#include "questmanager.h"
+#include "sectree_manager.h"
+#include "unique_item.h"
+#include "db.h"
+#include "config.h"
+#include <cstdarg>
+
+// Safe query builder: prevents buffer overflows when composing SQL.
+static bool SafeAppendQuery(char* buf, size_t bufSize, int& len, const char* fmt, ...)
+{
+	if (!buf || bufSize == 0 || len < 0 || (size_t)len >= bufSize)
+		return false;
+	va_list args;
+	va_start(args, fmt);
+	const int written = vsnprintf(buf + len, bufSize - (size_t)len, fmt, args);
+	va_end(args);
+	if (written < 0)
+		return false;
+	if ((size_t)written >= bufSize - (size_t)len)
+		return false;
+	len += written;
+	return true;
+}
+
+CMiniGameYutnori::CMiniGameYutnori(LPCHARACTER pChar) : m_pChar(pChar)
+{
+	m_bFirstThrow = true;
+	m_bReThrow = false;
+
+	m_wScore = YUTNORI_INIT_SCORE;
+	m_bRemainCount = YUTNORI_INIT_REMAIN_COUNT;
+	m_bRecvReward = false;
+	m_bYutProb = YUTNORI_YUTSEM1;
+
+	m_bPC = true;
+
+	m_bPCYut = 0;
+	memset(&m_bPCUnitPos, 0, sizeof(m_bPCUnitPos));
+	memset(&m_bPCUnitLastPos, 0, sizeof(m_bPCUnitLastPos));
+
+	m_bCOMYut = 0;
+	memset(&m_bCOMUnitPos, 0, sizeof(m_bCOMUnitPos));
+	memset(&m_bCOMUnitLastPos, 0, sizeof(m_bCOMUnitLastPos));
+	m_bComNextUnitIndex = false;
+
+	SendPacket(YUTNORI_GC_SUBHEADER_START);
+}
+
+CMiniGameYutnori::~CMiniGameYutnori()
+{
+	m_bFirstThrow = false;
+	m_bReThrow = false;
+
+	m_wScore = 0;
+	m_bRemainCount = 0;
+	m_bRecvReward = false;
+	m_bYutProb = 0;
+
+	m_bPC = false;
+
+	m_bPCYut = 0;
+	memset(&m_bPCUnitPos, 0, sizeof(m_bPCUnitPos));
+	memset(&m_bPCUnitLastPos, 0, sizeof(m_bPCUnitLastPos));
+
+	m_bCOMYut = 0;
+	memset(&m_bCOMUnitPos, 0, sizeof(m_bCOMUnitPos));
+	memset(&m_bCOMUnitLastPos, 0, sizeof(m_bCOMUnitLastPos));
+	m_bComNextUnitIndex = false;
+
+	SendPacket(YUTNORI_GC_SUBHEADER_STOP);
+}
+
+void CMiniGameYutnori::Giveup()
+{
+	m_pChar->SetMiniGameYutnori(nullptr);
+}
+
+void CMiniGameYutnori::SetProb(BYTE bProbIndex)
+{
+	if (bProbIndex >= YUTNORI_YUTSEM_MAX)
+		return;
+
+	m_bYutProb = bProbIndex;
+
+	TPacketGCMiniGameYutnoriSetProb SetProbPacket(bProbIndex);
+	SendPacket(YUTNORI_GC_SUBHEADER_SET_PROB, &SetProbPacket);
+}
+
+void CMiniGameYutnori::Throw(bool bPC)
+{
+	if (bPC && !m_bPC)
+		return;
+
+	if (!bPC && m_bPC)
+		return;
+
+	if (m_bFirstThrow)
+	{
+		BYTE bRandomYut = __GetRandomYut(false, true);
+
+		TPacketGCMiniGameYutnoriThrow ThrowPacket(bPC, bRandomYut);
+		SendPacket(YUTNORI_GC_SUBHEADER_THROW, &ThrowPacket);
+
+		if (bPC)
+		{
+			m_bPC = false;
+			m_bPCYut = bRandomYut;
+
+			__PushNextTurn(false, YUTNORI_BEFORE_TURN_SELECT);
+		}
+		else
+		{
+			m_bFirstThrow = false;
+			m_bPC = (m_bPCYut < bRandomYut);
+
+			__PushNextTurn(m_bPC, YUTNORI_AFTER_TURN_SELECT);
+		}
+	}
+	else
+	{
+		bool bReThrow = m_bReThrow;
+
+		if (m_bReThrow)
+			m_bReThrow = false;
+
+		if (bPC && !bReThrow)
+		{
+			__UpdateScore(false, false);
+			__UpdateRemainCount();
+		}
+
+		bool bExcludeYutSem6 = __IsExcludeYutSem6(bPC);
+		BYTE bRandomYut = __GetRandomYut(bReThrow, bExcludeYutSem6, bPC ? m_bYutProb : YUTNORI_YUTSEM_MAX);
+
+		// Avoid getting the same Yut again.
+		BYTE bLastYut = bPC ? m_bPCYut : m_bCOMYut;
+		while (bRandomYut == bLastYut)
+		{
+			bRandomYut = __GetRandomYut(bReThrow, bExcludeYutSem6, bPC ? m_bYutProb : YUTNORI_YUTSEM_MAX);
+		}
+
+		TPacketGCMiniGameYutnoriThrow ThrowPacket(bPC, bRandomYut);
+		SendPacket(YUTNORI_GC_SUBHEADER_THROW, &ThrowPacket);
+
+		if (bRandomYut == YUTNORI_YUTSEM6)
+		{
+			bool bCanMove = __CanMove(bPC);
+
+			m_bPC = bPC ? bCanMove : !bCanMove;
+
+			if (bPC)
+				m_bPCYut = bRandomYut;
+			else
+				m_bCOMYut = bRandomYut;
+
+			__PushNextTurn(bPC ? bCanMove : !bCanMove, bCanMove ? YUTNORI_STATE_MOVE : YUTNORI_STATE_THROW);
+		}
+		else
+		{
+			m_bPC = bPC;
+
+			if (bPC)
+				m_bPCYut = bRandomYut;
+			else
+				m_bCOMYut = bRandomYut;
+
+			__PushNextTurn(bPC, YUTNORI_STATE_MOVE);
+		}
+	}
+}
+
+void CMiniGameYutnori::CharClick(BYTE bUnitIndex)
+{
+	if (!m_bPC)
+		return;
+
+	if (bUnitIndex >= YUTNORI_PLAYER_MAX)
+		return;
+
+	BYTE bStartIndex = m_bPCUnitPos[bUnitIndex];
+	BYTE bDestIndex = bStartIndex;
+	BYTE bLastIndex = m_bPCUnitLastPos[bUnitIndex];
+
+	if (bStartIndex == YUTNORI_GOAL_AREA)
+		return;
+
+	__GetDestPos(m_bPCYut, &bStartIndex, &bDestIndex, &bLastIndex);
+
+	TPacketGCMiniGameYutnoriAvailableArea AvailableAreaPacket(bUnitIndex, bDestIndex);
+	SendPacket(YUTNORI_GC_SUBHEADER_AVAILABLE_AREA, &AvailableAreaPacket);
+}
+
+void CMiniGameYutnori::Move(BYTE bUnitIndex)
+{
+	if (!m_bPC)
+		return;
+
+	if (bUnitIndex >= YUTNORI_PLAYER_MAX)
+		return;
+
+	BYTE bStartIndex = m_bPCUnitPos[bUnitIndex];
+	BYTE bDestIndex = bStartIndex;
+	BYTE bLastIndex = m_bPCUnitLastPos[bUnitIndex];
+
+	if (bStartIndex == YUTNORI_GOAL_AREA)
+		return;
+
+	__GetDestPos(m_bPCYut, &bStartIndex, &bDestIndex, &bLastIndex);
+
+	bool bIsCatch = false;
+	{
+		for (BYTE bUnitIdx = 0; bUnitIdx < YUTNORI_PLAYER_MAX; ++bUnitIdx)
+		{
+			if (m_bCOMUnitPos[bUnitIdx] == bDestIndex && bDestIndex != 0 && bDestIndex != YUTNORI_GOAL_AREA)
+			{
+				__UpdateScore(true, false);
+
+				m_bCOMUnitPos[bUnitIdx] = 0;
+				m_bCOMUnitLastPos[bUnitIdx] = 0;
+
+				TPacketGCMiniGameYutnoriPushCatchYut PushCatchYutPacket(false, bUnitIdx);
+				SendPacket(YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT, &PushCatchYutPacket);
+
+				bIsCatch = true;
+			}
+		}
+	}
+
+	TPacketGCMiniGameYutnoriMove MovePacket(true, bUnitIndex, bIsCatch, bStartIndex, bDestIndex);
+	SendPacket(YUTNORI_GC_SUBHEADER_MOVE, &MovePacket);
+
+	if (__IsDouble(m_bPCUnitPos))
+	{
+		if (bDestIndex == YUTNORI_GOAL_AREA)
+			__UpdateScore(true, true);
+
+		for (BYTE bUnitIndx = 0; bUnitIndx < YUTNORI_PLAYER_MAX; ++bUnitIndx)
+		{
+			m_bPCUnitPos[bUnitIndx] = bDestIndex;
+			m_bPCUnitLastPos[bUnitIndx] = bLastIndex;
+		}
+	}
+	else
+	{
+		if (bDestIndex == YUTNORI_GOAL_AREA)
+			__UpdateScore(true, false);
+
+		m_bPCUnitPos[bUnitIndex] = bDestIndex;
+		m_bPCUnitLastPos[bUnitIndex] = bLastIndex;
+	}
+
+	if (__IsGoalArea(m_bPCUnitPos))
+	{
+		m_bRecvReward = true;
+		__PushNextTurn(true, YUTNORI_STATE_END);
+	}
+	else
+	{
+		if (m_bRemainCount == 0 || m_wScore == 0)
+		{
+			if (m_wScore == 0)
+				m_bRecvReward = false;
+			else
+				m_bRecvReward = true;
+
+			__PushNextTurn(false, YUTNORI_STATE_END);
+		}
+		else
+		{
+			if (m_bPCYut == YUTNORI_YUTSEM4 || m_bPCYut == YUTNORI_YUTSEM5)
+			{
+				m_bReThrow = true;
+				__PushNextTurn(true, YUTNORI_STATE_RE_THROW);
+			}
+			else
+			{
+				m_bPC = false;
+				__PushNextTurn(false, YUTNORI_STATE_THROW);
+			}
+		}
+	}
+}
+
+void CMiniGameYutnori::RequestComAction()
+{
+	if (m_bPC)
+		return;
+
+	BYTE bUnitIndex = __GetComUnitIndex();
+	if (bUnitIndex == YUTNORI_PLAYER_MAX)
+		return;
+
+	m_bComNextUnitIndex = bUnitIndex ? 0 : 1;
+
+	BYTE bStartIndex = m_bCOMUnitPos[bUnitIndex];
+	BYTE bDestIndex = bStartIndex;
+	BYTE bLastIndex = m_bCOMUnitLastPos[bUnitIndex];
+
+	if (bStartIndex == YUTNORI_GOAL_AREA)
+		return;
+
+	__GetDestPos(m_bCOMYut, &bStartIndex, &bDestIndex, &bLastIndex);
+
+	bool bIsCatch = false;
+	{
+		for (BYTE bUnitIdx = 0; bUnitIdx < YUTNORI_PLAYER_MAX; ++bUnitIdx)
+		{
+			if (m_bPCUnitPos[bUnitIdx] == bDestIndex && bDestIndex != 0 && bDestIndex != YUTNORI_GOAL_AREA)
+			{
+				__UpdateScore(false, false);
+
+				m_bPCUnitPos[bUnitIdx] = 0;
+				m_bPCUnitLastPos[bUnitIdx] = 0;
+
+				TPacketGCMiniGameYutnoriPushCatchYut PushCatchYutPacket(true, bUnitIdx);
+				SendPacket(YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT, &PushCatchYutPacket);
+
+				bIsCatch = true;
+			}
+		}
+	}
+
+	TPacketGCMiniGameYutnoriMove MovePacket(false, bUnitIndex, bIsCatch, bStartIndex, bDestIndex);
+	SendPacket(YUTNORI_GC_SUBHEADER_MOVE, &MovePacket);
+
+	if (__IsDouble(m_bCOMUnitPos))
+	{
+		if (bDestIndex == YUTNORI_GOAL_AREA)
+			__UpdateScore(false, true);
+
+		for (BYTE bUnitIndx = 0; bUnitIndx < YUTNORI_PLAYER_MAX; ++bUnitIndx)
+		{
+			m_bCOMUnitPos[bUnitIndx] = bDestIndex;
+			m_bCOMUnitLastPos[bUnitIndx] = bLastIndex;
+		}
+	}
+	else
+	{
+		if (bDestIndex == YUTNORI_GOAL_AREA)
+			__UpdateScore(false, false);
+
+		m_bCOMUnitPos[bUnitIndex] = bDestIndex;
+		m_bCOMUnitLastPos[bUnitIndex] = bLastIndex;
+	}
+
+	if (__IsGoalArea(m_bCOMUnitPos))
+	{
+		m_bRecvReward = true;
+		__PushNextTurn(false, YUTNORI_STATE_END);
+	}
+	else
+	{
+		if (m_bCOMYut == YUTNORI_YUTSEM4 || m_bCOMYut == YUTNORI_YUTSEM5)
+		{
+			m_bReThrow = true;
+			__PushNextTurn(false, YUTNORI_STATE_RE_THROW);
+		}
+		else
+		{
+			m_bPC = true;
+			__PushNextTurn(true, YUTNORI_STATE_THROW);
+		}
+	}
+}
+
+void CMiniGameYutnori::Reward()
+{
+	if (!m_bRecvReward)
+		return;
+
+	m_bRecvReward = false;
+
+	const WORD wScore = m_wScore;
+	if (wScore < YUTNORI_LOW_TOTAL_SCORE)
+	{
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		m_pChar->AutoGiveItem(YUTNORI_LOW_REWARD, 1, -1, true, true);
+#else
+		m_pChar->AutoGiveItem(YUTNORI_LOW_REWARD, 1, -1, true);
+#endif
+	}
+	else if (wScore >= YUTNORI_LOW_TOTAL_SCORE && wScore < YUTNORI_MID_TOTAL_SCORE)
+	{
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		m_pChar->AutoGiveItem(YUTNORI_MID_REWARD, 1, -1, true, true);
+#else
+		m_pChar->AutoGiveItem(YUTNORI_MID_REWARD, 1, -1, true);
+#endif
+	}
+	else if (wScore >= YUTNORI_MID_TOTAL_SCORE)
+	{
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		m_pChar->AutoGiveItem(YUTNORI_HIGH_REWARD, 1, -1, true, true);
+#else
+		m_pChar->AutoGiveItem(YUTNORI_HIGH_REWARD, 1, -1, true);
+#endif
+	}
+
+	__UpdateMyScore(m_pChar->GetPlayerID());
+
+	m_pChar->SetMiniGameYutnori(nullptr);
+}
+
+void CMiniGameYutnori::__UpdateScore(bool bIncrease, bool bIsDouble)
+{
+	if (bIncrease)
+	{
+		if (bIsDouble)
+			m_wScore = MAX(0, m_wScore + (YUTNORI_IN_DE_CREASE_SCORE * 2));
+		else
+			m_wScore = MAX(0, m_wScore + YUTNORI_IN_DE_CREASE_SCORE);
+	}
+	else
+	{
+		if (bIsDouble)
+			m_wScore = MAX(0, m_wScore - (YUTNORI_IN_DE_CREASE_SCORE * 2));
+		else
+			m_wScore = MAX(0, m_wScore - YUTNORI_IN_DE_CREASE_SCORE);
+	}
+
+	TPacketGCMiniGameYutnoriSetScore SetScorePacket(m_wScore);
+	SendPacket(YUTNORI_GC_SUBHEADER_SET_SCORE, &SetScorePacket);
+}
+
+void CMiniGameYutnori::__UpdateRemainCount()
+{
+	m_bRemainCount = MAX(0, m_bRemainCount - 1);
+
+	TPacketGCMiniGameYutnoriSetRemainCount SetRemainCountPacket(m_bRemainCount);
+	SendPacket(YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT, &SetRemainCountPacket);
+}
+
+bool CMiniGameYutnori::__IsGoalArea(BYTE* pbUnitPos)
+{
+	bool bIsGoalArea = false;
+	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
+	{
+		if (pbUnitPos[bUnitIndex] == pbUnitPos[(bUnitIndex + 1) % YUTNORI_PLAYER_MAX] &&
+			pbUnitPos[bUnitIndex] == YUTNORI_GOAL_AREA)
+		{
+			bIsGoalArea = true;
+			break;
+		}
+	}
+
+	return bIsGoalArea;
+}
+
+bool CMiniGameYutnori::__IsDouble(BYTE* pbUnitPos)
+{
+	bool bIsDouble = false;
+	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
+	{
+		if (pbUnitPos[bUnitIndex] == pbUnitPos[(bUnitIndex + 1) % YUTNORI_PLAYER_MAX] &&
+			pbUnitPos[bUnitIndex] != 0 && pbUnitPos[bUnitIndex] != YUTNORI_GOAL_AREA)
+		{
+			bIsDouble = true;
+			break;
+		}
+	}
+
+	return bIsDouble;
+}
+
+bool CMiniGameYutnori::__CanMove(bool bPC)
+{
+	const BYTE* pUnit = bPC ? m_bPCUnitPos : m_bCOMUnitPos;
+	bool bCanMove = true;
+
+	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
+	{
+		if (pUnit[bUnitIndex] == 0 || pUnit[bUnitIndex] == 11)
+		{
+			bCanMove = false;
+			break;
+		}
+	}
+
+	return bCanMove;
+}
+
+bool CMiniGameYutnori::__IsExcludeYutSem6(bool bPC)
+{
+	const BYTE* pUnit = bPC ? m_bPCUnitPos : m_bCOMUnitPos;
+	bool bExcludeYutSem6 = false;
+
+	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
+	{
+		if (pUnit[bUnitIndex] == YUTNORI_GOAL_AREA || pUnit[bUnitIndex] == YUTNORI_GOAL_AREA - 1)
+		{
+			bExcludeYutSem6 = true;
+			break;
+		}
+	}
+
+	return bExcludeYutSem6;
+}
+
+BYTE CMiniGameYutnori::__GetComUnitIndex()
+{
+	BYTE bStartIndexUnit1 = m_bCOMUnitPos[0];
+	BYTE bStartIndexUnit2 = m_bCOMUnitPos[1];
+
+	BYTE bDestIndexUnit1 = bStartIndexUnit1;
+	BYTE bDestIndexUnit2 = bStartIndexUnit2;
+
+	BYTE bLastIndexUnit1 = m_bCOMUnitLastPos[0];
+	BYTE bLastIndexUnit2 = m_bCOMUnitLastPos[1];
+
+	// Check if both units are in the goal area.
+	if (bStartIndexUnit1 == YUTNORI_GOAL_AREA && bStartIndexUnit2 == YUTNORI_GOAL_AREA)
+		return YUTNORI_PLAYER_MAX;
+
+	// Check if both units start at the same position.
+	if (bStartIndexUnit1 == bStartIndexUnit2)
+		return 0;
+
+	// Check conditions for excluding units based on YUTNORI_YUTSEM6.
+	bool bExcludeUnit1 = (m_bCOMYut == YUTNORI_YUTSEM6 && bStartIndexUnit1 == 0) || (bStartIndexUnit1 == YUTNORI_GOAL_AREA);
+	bool bExcludeUnit2 = (m_bCOMYut == YUTNORI_YUTSEM6 && bStartIndexUnit2 == 0) || (bStartIndexUnit2 == YUTNORI_GOAL_AREA);
+
+	// Determine the destination indices for each unit.
+	for (BYTE bUnitIndex = 0; bUnitIndex < YUTNORI_PLAYER_MAX; ++bUnitIndex)
+	{
+		BYTE& bStartIndex = (bUnitIndex == 0) ? bStartIndexUnit1 : bStartIndexUnit2;
+		BYTE& bDestIndex = (bUnitIndex == 0) ? bDestIndexUnit1 : bDestIndexUnit2;
+		BYTE& bLastIndex = (bUnitIndex == 0) ? bLastIndexUnit1 : bLastIndexUnit2;
+
+		__GetDestPos(m_bCOMYut, &bStartIndex, &bDestIndex, &bLastIndex);
+	}
+
+	// Check if each unit catches any PC unit.
+	bool bCatchUnit1 = (bDestIndexUnit1 == m_bPCUnitPos[0] || bDestIndexUnit1 == m_bPCUnitPos[1]);
+	bool bCatchUnit2 = (bDestIndexUnit2 == m_bPCUnitPos[0] || bDestIndexUnit2 == m_bPCUnitPos[1]);
+
+	// Determine the computer's next unit index based on the conditions.
+	if (bCatchUnit1 && !bExcludeUnit1)
+		return 0;
+
+	if (bCatchUnit2 && !bExcludeUnit2)
+		return 1;
+
+	if (m_bComNextUnitIndex == 0 && bExcludeUnit1 && !bExcludeUnit2)
+		return 1;
+
+	if (m_bComNextUnitIndex == 1 && !bExcludeUnit1 && bExcludeUnit2)
+		return 0;
+
+	if (bExcludeUnit1 && bExcludeUnit2)
+		return YUTNORI_PLAYER_MAX;
+
+	return m_bComNextUnitIndex;
+}
+
+BYTE CMiniGameYutnori::__GetRandomYut(BYTE bReThrow, BYTE bExcludeYutSem6, BYTE bYutProb)
+{
+	std::vector<BYTE> vYutIndexes;
+	for (BYTE bYutIndex = YUTNORI_YUTSEM1; bYutIndex < YUTNORI_YUTSEM_MAX; ++bYutIndex)
+	{
+		// Avoid getting YUTSEM4 or YUTSEM5 if it's a re-throw.
+		if (bReThrow && (bYutIndex == YUTNORI_YUTSEM4 || bYutIndex == YUTNORI_YUTSEM5))
+			continue;
+
+		if (bExcludeYutSem6 && bYutIndex == YUTNORI_YUTSEM6)
+			continue;
+
+		// Add an additional chance for the selected Yut.
+		if (bYutIndex == bYutProb)
+			vYutIndexes.push_back(bYutIndex);
+
+		vYutIndexes.push_back(bYutIndex);
+	}
+
+	BYTE bRandomIndex = number(0, vYutIndexes.size() - 1);
+	return vYutIndexes[bRandomIndex];
+}
+
+void CMiniGameYutnori::__GetDestPos(BYTE bMoveCount, BYTE* bStartIndex, BYTE* bDestIndex, BYTE* bLastIndex)
+{
+	if (*bStartIndex == 0 || *bDestIndex == 0 || *bLastIndex == 0)
+		*bStartIndex = YUTNORI_GOAL_AREA;
+
+	*bDestIndex = *bStartIndex;
+
+	BYTE bNextIndex = *bDestIndex;
+	BYTE bPrevIndex = *bDestIndex;
+
+	if (bMoveCount == YUTNORI_YUTSEM6)
+	{
+		if (*bDestIndex == 20 || *bDestIndex == 21)
+			*bDestIndex = 1;
+		else if (*bDestIndex == 26 || *bDestIndex == 5)
+			*bDestIndex = 6;
+		else if (*bDestIndex == 28 || *bDestIndex == 24)
+			*bDestIndex = 23;
+		else if (*bDestIndex == 23)
+			*bDestIndex = (*bDestIndex == 23 && *bLastIndex == 27) ? 27 : 22;
+		else if (*bDestIndex == 16)
+			*bDestIndex = (*bDestIndex == 16 || *bLastIndex == 29) ? 29 : 17;
+		else
+			*bDestIndex = (*bDestIndex <= 20) ? *bDestIndex + 1 : *bDestIndex - 1;
+	}
+	else
+	{
+		for (BYTE bIndex = 0; bIndex < bMoveCount + 1; ++bIndex)
+		{
+			if (*bDestIndex == 1)
+			{
+				bPrevIndex = *bDestIndex;
+				*bDestIndex = (bNextIndex == 1) ? 21 : 20;
+				*bLastIndex = bPrevIndex;
+				continue;
+			}
+			else if (*bDestIndex == 6)
+			{
+				bPrevIndex = *bDestIndex;
+				*bDestIndex = (bNextIndex == 6) ? 26 : 5;
+				*bLastIndex = bPrevIndex;
+				continue;
+			}
+			else if (*bDestIndex == 23)
+			{
+				bPrevIndex = *bDestIndex;
+				*bDestIndex = (bNextIndex == 23 || *bLastIndex == 22) ? 24 : 28;
+				*bLastIndex = bPrevIndex;
+				continue;
+			}
+			else if (*bDestIndex == 27)
+			{
+				bPrevIndex = *bDestIndex;
+				*bDestIndex = 23;
+				*bLastIndex = bPrevIndex;
+				continue;
+			}
+			else if (*bDestIndex == 29)
+			{
+				bPrevIndex = *bDestIndex;
+				*bDestIndex = 16;
+				*bLastIndex = bPrevIndex;
+				continue;
+			}
+			else if (*bDestIndex == 25 || *bDestIndex == 12)
+			{
+				bPrevIndex = *bDestIndex;
+				*bDestIndex = 11;
+				*bLastIndex = bPrevIndex;
+				break;
+			}
+			else
+			{
+				bPrevIndex = *bDestIndex;
+				*bDestIndex = (*bDestIndex <= 20) ? *bDestIndex - 1 : *bDestIndex + 1;
+				*bLastIndex = bPrevIndex;
+				continue;
+			}
+		}
+	}
+}
+
+void CMiniGameYutnori::__PushNextTurn(bool bPC, BYTE bState)
+{
+	TPacketGCMiniGameYutnoriPushNextTurn PushNextTurnPacket(bPC, bState);
+	SendPacket(YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN, &PushNextTurnPacket);
+}
+
+void CMiniGameYutnori::SendPacket(BYTE bSubHeader, void* pvData)
+{
+	if (m_pChar == nullptr)
+		return;
+
+	const LPDESC pkDesc = m_pChar->GetDesc();
+	if (pkDesc == nullptr)
+	{
+		sys_err("CMiniGameYutnori::SendPacket - Null DESC! (ch: %s) (%d)",
+			m_pChar->GetName(), bSubHeader);
+		return;
+	}
+
+	TPacketGCMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_GC_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = bSubHeader;
+
+	const std::unordered_set<BYTE> EmptyData
+	{
+		YUTNORI_GC_SUBHEADER_START,
+		YUTNORI_GC_SUBHEADER_STOP,
+	};
+
+	if (pvData == nullptr && EmptyData.find(bSubHeader) == EmptyData.end())
+	{
+		sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null Data! Character: %s",
+			bSubHeader, m_pChar->GetName());
+		return;
+	}
+
+	switch (bSubHeader)
+	{
+		case YUTNORI_GC_SUBHEADER_START:
+		case YUTNORI_GC_SUBHEADER_STOP:
+		{
+			Packet.wSize = sizeof(Packet);
+			pkDesc->Packet(&Packet, sizeof(TPacketGCMiniGameYutnori));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_SET_PROB:
+		{
+			const TPacketGCMiniGameYutnoriSetProb* pkData = static_cast<TPacketGCMiniGameYutnoriSetProb*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null SetProbPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriSetProb SetProbPacket(pkData->bProbIndex);
+			Packet.wSize = sizeof(Packet) + sizeof(SetProbPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&SetProbPacket, sizeof(TPacketGCMiniGameYutnoriSetProb));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_THROW:
+		{
+			const TPacketGCMiniGameYutnoriThrow* pkData = static_cast<TPacketGCMiniGameYutnoriThrow*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null ThrowYutPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriThrow ThrowPacket(pkData->bPC, pkData->bYut);
+			Packet.wSize = sizeof(Packet) + sizeof(ThrowPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&ThrowPacket, sizeof(TPacketGCMiniGameYutnoriThrow));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_MOVE:
+		{
+			const TPacketGCMiniGameYutnoriMove* pkData = static_cast<TPacketGCMiniGameYutnoriMove*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null MoveYutPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriMove MovePacket(pkData->bPC, pkData->bUnitIndex, pkData->bIsCatch, pkData->bStartIndex, pkData->bDestIndex);
+			Packet.wSize = sizeof(Packet) + sizeof(MovePacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&MovePacket, sizeof(TPacketGCMiniGameYutnoriMove));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_AVAILABLE_AREA:
+		{
+			const TPacketGCMiniGameYutnoriAvailableArea* pkData = static_cast<TPacketGCMiniGameYutnoriAvailableArea*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null AvailAreaPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriAvailableArea AvailAreaPacket(pkData->bPlayerIndex, pkData->bAvailableIndex);
+			Packet.wSize = sizeof(Packet) + sizeof(AvailAreaPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&AvailAreaPacket, sizeof(TPacketGCMiniGameYutnoriAvailableArea));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT:
+		{
+			const TPacketGCMiniGameYutnoriPushCatchYut* pkData = static_cast<TPacketGCMiniGameYutnoriPushCatchYut*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null PushCatchYutPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriPushCatchYut PushCatchYutPacket(pkData->bPC, pkData->bUnitIndex);
+			Packet.wSize = sizeof(Packet) + sizeof(PushCatchYutPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&PushCatchYutPacket, sizeof(TPacketGCMiniGameYutnoriPushCatchYut));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_SET_SCORE:
+		{
+			const TPacketGCMiniGameYutnoriSetScore* pkData = static_cast<TPacketGCMiniGameYutnoriSetScore*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null SetScorePacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriSetScore SetScorePacket(pkData->wScore);
+			Packet.wSize = sizeof(Packet) + sizeof(SetScorePacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&SetScorePacket, sizeof(TPacketGCMiniGameYutnoriSetScore));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT:
+		{
+			const TPacketGCMiniGameYutnoriSetRemainCount* pkData = static_cast<TPacketGCMiniGameYutnoriSetRemainCount*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null SetRemainCountPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriSetRemainCount SetRemainCountPacket(pkData->bRemainCount);
+			Packet.wSize = sizeof(Packet) + sizeof(SetRemainCountPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&SetRemainCountPacket, sizeof(TPacketGCMiniGameYutnoriSetRemainCount));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN:
+		{
+			const TPacketGCMiniGameYutnoriPushNextTurn* pkData = static_cast<TPacketGCMiniGameYutnoriPushNextTurn*>(pvData);
+			if (pkData == nullptr)
+			{
+				sys_err("CMiniGameYutnori::SendPacket(bSubHeader=%u) Null PushNextTurnPacket! Character: %s",
+					bSubHeader, m_pChar->GetName());
+				return;
+			}
+
+			TPacketGCMiniGameYutnoriPushNextTurn PushNextTurnPacket(pkData->bPC, pkData->bState);
+			Packet.wSize = sizeof(Packet) + sizeof(PushNextTurnPacket);
+
+			pkDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+			pkDesc->Packet(&PushNextTurnPacket, sizeof(TPacketGCMiniGameYutnoriPushNextTurn));
+		}
+		break;
+	}
+}
+
+void CMiniGameYutnori::__UpdateMyScore(DWORD dwPID)
+{
+	char szQuery[2048 + 1];
+	int iLen = 0;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "INSERT INTO `player`.`minigame_yutnori` (`pid`, `best_score`, `total_score`, `last_play`) "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "VALUES (%u, %u, %u, FROM_UNIXTIME(%d)) ", dwPID, m_wScore, m_wScore, std::time(nullptr)))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "ON DUPLICATE KEY UPDATE "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "`total_score` = `total_score` + %d,", m_wScore))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "`best_score` = if (%d > `best_score`, %d, `best_score`) ", m_wScore, m_wScore))
+		return;
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+}
+
+//////////////////////////////////////////////////////////////////////////
+
+/* static */ void CMiniGameYutnori::Create(LPCHARACTER pChar)
+{
+	if (!IsActiveEvent())
+	{
+		Destroy(pChar);
+		return;
+	}
+
+	if (pChar->GetMiniGameYutnori())
+		return;
+
+	if (pChar->GetGold() < YUTNORI_START_GOLD)
+		return;
+
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+	const WORD wYutBoardCount = pChar->GetQuestFlag("minigame_yutnori.board_count");
+	if (wYutBoardCount == 0)
+		return;
+
+	pChar->SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount - 1);
+#else
+	if (pChar->CountSpecifyItem(ITEM_VNUM_YUT_BOARD))
+		return;
+
+	pChar->RemoveSpecifyItem(ITEM_VNUM_YUT_BOARD, 1);
+#endif
+	pChar->PointChange(POINT_GOLD, -YUTNORI_START_GOLD, true);
+
+	pChar->SetMiniGameYutnori(new CMiniGameYutnori(pChar));
+}
+
+/* static */ void CMiniGameYutnori::Destroy(LPCHARACTER pChar)
+{
+	pChar->SetMiniGameYutnori(nullptr);
+}
+
+/* static */ void CMiniGameYutnori::Analyze(LPCHARACTER pChar, BYTE bSubHeader, BYTE bArgument)
+{
+	CMiniGameYutnori* pMiniGameYutnori = pChar->GetMiniGameYutnori();
+	if (pMiniGameYutnori == nullptr)
+	{
+		sys_err("CMiniGameYutnori::Analyze - Null MiniGameYutnori! (ch: %s) (%d)",
+			pChar->GetName(), bSubHeader);
+		return;
+	}
+
+	switch (bSubHeader)
+	{
+		case YUTNORI_CG_SUBHEADER_SET_PROB:
+			pMiniGameYutnori->SetProb(bArgument);
+			break;
+
+		case YUTNORI_CG_SUBHEADER_CLICK_CHAR:
+			pMiniGameYutnori->CharClick(bArgument);
+			break;
+
+		case YUTNORI_CG_SUBHEADER_THROW:
+			pMiniGameYutnori->Throw(bArgument);
+			break;
+
+		case YUTNORI_CG_SUBHEADER_MOVE:
+			pMiniGameYutnori->Move(bArgument);
+			break;
+
+		case YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION:
+			pMiniGameYutnori->RequestComAction();
+			break;
+
+		case YUTNORI_CG_SUBHEADER_REWARD:
+			pMiniGameYutnori->Reward();
+			break;
+
+		default:
+			sys_err("CMiniGameYutnori::Analyze - Unknown SubHeader (ch: %s) (%d)",
+				pChar->GetName(), bSubHeader);
+			break;
+	}
+}
+
+/* static */ bool CMiniGameYutnori::IsActiveEvent()
+{
+	if (quest::CQuestManager::instance().GetEventFlag("mini_game_yutnori"))
+		return true;
+
+	return false;
+}
+
+/* static */ void CMiniGameYutnori::SpawnEventNPC(bool bSpawn)
+{
+	CharacterVectorInteractor vChar;
+	if (CHARACTER_MANAGER::instance().GetCharactersByRaceNum(YUTNORI_TABLE, vChar))
+	{
+		std::for_each(vChar.begin(), vChar.end(),
+			[](LPCHARACTER pChar) { M2_DESTROY_CHARACTER(pChar); });
+	}
+
+	if (bSpawn)
+	{
+		std::unordered_map<long, std::pair<long, long>> mSpawnPoint
+		{
+			{ MAP_A1, { 608, 614 } },
+			{ MAP_B1, { 596, 608 } },
+			{ MAP_C1, { 358, 748 } },
+		};
+
+		for (const auto& it : mSpawnPoint)
+		{
+			long lMapIndex = it.first;
+			const auto& rkPos = it.second;
+
+			if (!map_allow_find(lMapIndex))
+				continue;
+
+			const LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
+			if (pkSectreeMap == nullptr)
+				continue;
+
+			long xPos = pkSectreeMap->m_setting.iBaseX + rkPos.first * 100;
+			long yPos = pkSectreeMap->m_setting.iBaseY + rkPos.second * 100;
+
+			CHARACTER_MANAGER::instance().SpawnMob(YUTNORI_TABLE, lMapIndex,
+				xPos, yPos, 0, false, 90, true);
+		}
+	}
+}
+
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+/* static */ void CMiniGameYutnori::RequestQuestFlag(LPCHARACTER pChar, BYTE bSubHeader)
+{
+	const LPDESC pDesc = pChar->GetDesc();
+	if (pDesc == nullptr)
+	{
+		sys_err("CMiniGameYutnori::RequestQuestFlag - Null DESC! (ch: %s) (%d)",
+			pChar->GetName(), bSubHeader);
+		return;
+	}
+
+	const WORD wYutPieceCount = pChar->GetQuestFlag("minigame_yutnori.piece_count");
+	const WORD wYutBoardCount = pChar->GetQuestFlag("minigame_yutnori.board_count");
+
+	TPacketGCMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_GC_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = bSubHeader;
+
+	TPacketGCMiniGameYutnoriQuestFlag QuestFlagPacket(wYutPieceCount, wYutBoardCount);
+	Packet.wSize = sizeof(Packet) + sizeof(QuestFlagPacket);
+
+	pDesc->BufferedPacket(&Packet, sizeof(TPacketGCMiniGameYutnori));
+	pDesc->Packet(&QuestFlagPacket, sizeof(TPacketGCMiniGameYutnoriQuestFlag));
+}
+
+/* static */ bool CMiniGameYutnori::UpdateQuestFlag(LPCHARACTER pChar)
+{
+	if (!IsActiveEvent())
+		return false;
+
+	const WORD wYutPieceCount = pChar->GetQuestFlag("minigame_yutnori.piece_count");
+	const WORD wYutBoardCount = pChar->GetQuestFlag("minigame_yutnori.board_count");
+
+	if (wYutBoardCount >= YUTNORI_BOARD_COUNT_MAX)
+	{
+		RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_NO_MORE_GAIN);
+		return false;
+	}
+
+	if (wYutPieceCount + 1 >= YUTNORI_PIECE_COUNT_MAX)
+	{
+		pChar->SetQuestFlag("minigame_yutnori.piece_count", 0);
+		pChar->SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount + 1);
+
+		RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG);
+	}
+	else
+	{
+		pChar->SetQuestFlag("minigame_yutnori.piece_count", wYutPieceCount + 1);
+
+		RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG);
+	}
+
+	return true;
+}
+#endif
+
+/* static */ void CMiniGameYutnori::GetScoreTable(lua_State* L, bool bTotal)
+{
+	DWORD dwIndex = 1;
+	lua_newtable(L);
+
+	char szQuery[2048 + 1];
+	int iLen = 0;
+
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "SELECT "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, " `player`.`name`, "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, bTotal ? "`total_score` " : "`best_score` "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "FROM `minigame_yutnori` "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "LEFT JOIN (SELECT `id`, `name` AS `name` FROM `player`) AS `player` ON `player`.`id` = `minigame_yutnori`.`pid` "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, bTotal ? "ORDER BY `total_score` DESC " : "ORDER BY `best_score` DESC "))
+		return;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "LIMIT 10 "))
+		return;
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	const SQLResult* pkRes = pMsg->Get();
+	if (pkRes && pkRes->uiNumRows > 0)
+	{
+		MYSQL_ROW RowData;
+		while ((RowData = mysql_fetch_row(pkRes->pSQLResult)))
+		{
+			if (RowData[0][0] == '[') // GM
+				continue;
+
+			DWORD dwScore;
+			str_to_number(dwScore, RowData[1]);
+
+			if (dwScore == 0)
+				continue;
+
+			lua_newtable(L);
+
+			// Name
+			lua_pushstring(L, RowData[0]);
+			lua_rawseti(L, -2, 1);
+
+			// Score
+			lua_pushnumber(L, dwScore);
+			lua_rawseti(L, -2, 2);
+
+			lua_rawseti(L, -2, dwIndex++);
+		}
+	}
+}
+
+/* static */ DWORD CMiniGameYutnori::GetMyScoreValue(lua_State* L, DWORD dwPID, bool bTotal)
+{
+	char szQuery[2048 + 1];
+	int iLen = 0;
+
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "SELECT"))
+		return 0;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, bTotal ? "`total_score` " : "`best_score` "))
+		return 0;
+	if (!SafeAppendQuery(szQuery, sizeof(szQuery), iLen, "FROM `minigame_yutnori` WHERE `pid` = %u", dwPID))
+		return 0;
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery(szQuery));
+	const SQLResult* pkRes = pMsg->Get();
+	if (pkRes && pkRes->uiNumRows > 0)
+	{
+		MYSQL_ROW RowData = mysql_fetch_row(pkRes->pSQLResult);
+
+		DWORD dwScore;
+		str_to_number(dwScore, RowData[0]);
+
+		return dwScore;
+	}
+
+	return 0;
+}
+
+#endif // __MINI_GAME_YUTNORI__
diff --git a/server/metin2/Source/Server/game/src/packet.h b/server/metin2/Source/Server/game/src/packet.h
index c54b11a..9598935 100644
--- a/server/metin2/Source/Server/game/src/packet.h
+++ b/server/metin2/Source/Server/game/src/packet.h
@@ -1,4479 +1,4479 @@
-#ifndef __INC_PACKET_H__
-#define __INC_PACKET_H__
-
-enum CG_HEADERS
-{
-	HEADER_CG_LOGIN = 1,
-	HEADER_CG_ATTACK = 2,
-	HEADER_CG_CHAT = 3,
-	HEADER_CG_CHARACTER_CREATE = 4,
-	HEADER_CG_CHARACTER_DELETE = 5,
-	HEADER_CG_CHARACTER_SELECT = 6,
-	HEADER_CG_MOVE = 7,
-	HEADER_CG_SYNC_POSITION = 8,
-	//HEADER_CG_DIRECT_ENTER = 9,
-	HEADER_CG_ENTERGAME = 10,
-
-	HEADER_CG_ITEM_USE = 11,
-	HEADER_CG_ITEM_DROP = 12,
-	HEADER_CG_ITEM_MOVE = 13,
-	//HEADER_CG_UNUSED = 14,
-	HEADER_CG_ITEM_PICKUP = 15,
-
-	HEADER_CG_QUICKSLOT_ADD = 16,
-	HEADER_CG_QUICKSLOT_DEL = 17,
-	HEADER_CG_QUICKSLOT_SWAP = 18,
-	HEADER_CG_WHISPER = 19,
-	HEADER_CG_ITEM_DROP2 = 20,
-#if defined(__NEW_DROP_DIALOG__)
-	HEADER_CG_ITEM_DESTROY = 21,
-#endif
-
-	//HEADER_CG_UNUSED = 22,
-	//HEADER_CG_UNUSED = 23,
-	//HEADER_CG_UNUSED = 24,
-	//HEADER_CG_UNUSED = 25,
-
-	HEADER_CG_ON_CLICK = 26,
-	HEADER_CG_EXCHANGE = 27,
-	HEADER_CG_CHARACTER_POSITION = 28,
-	HEADER_CG_SCRIPT_ANSWER = 29,
-	HEADER_CG_QUEST_INPUT_STRING = 30,
-	HEADER_CG_QUEST_CONFIRM = 31,
-#if defined(__OX_RENEWAL__)
-	HEADER_CG_QUEST_INPUT_LONG_STRING = 32,
-#endif
-#if defined(__OFFLINE_SHOP__)
-	HEADER_CG_OFFLINE_SHOP = 33,
-#endif
-	//HEADER_CG_UNUSED = 34,
-
-#ifdef __GROWTH_PET_SYSTEM__
-	HEADER_CG_PET_HATCH = 35,
-	HEADER_CG_PET_WINDOW_TYPE = 36,
-	HEADER_CG_PET_WINDOW = 37,
-	HEADER_CG_PET_NAME_CHANGE = 38,
-	HEADER_CG_PET_FEED = 39,
-	HEADER_CG_PET_DETERMINE = 40,
-	HEADER_CG_PET_ATTR_CHANGE = 41,
-	HEADER_CG_PET_REVIVE = 42,
-	HEADER_CG_PET_LEARN_SKILL = 43,
-	HEADER_CG_PET_SKILL_UPGRADE = 44,
-	HEADER_CG_PET_DELETE_SKILL = 45,
-	HEADER_CG_PET_DELETE_ALL_SKILL = 46,
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	HEADER_CG_EXTEND_INVEN = 47,
-#endif
-	//HEADER_CG_UNUSED = 48,
-	//HEADER_CG_UNUSED = 49,
-
-	HEADER_CG_SHOP = 50,
-	HEADER_CG_FLY_TARGETING = 51,
-	HEADER_CG_USE_SKILL = 52,
-	HEADER_CG_ADD_FLY_TARGETING = 53,
-	HEADER_CG_SHOOT = 54,
-	HEADER_CG_MYSHOP = 55,
-#if defined(__MYSHOP_DECO__)
-	HEADER_CG_MYSHOP_DECO_STATE = 56,
-	HEADER_CG_MYSHOP_DECO_ADD = 57,
-#endif
-	//HEADER_CG_UNUSED = 58,
-
-#if defined(__SEND_TARGET_INFO__)
-	HEADER_CG_TARGET_INFO = 59,
-#endif
-	HEADER_CG_ITEM_USE_TO_ITEM = 60,
-	HEADER_CG_TARGET = 61,
-
-	//HEADER_CG_UNUSED = 62,
-	//HEADER_CG_UNUSED = 63,
-	HEADER_CG_TEXT = 64, // @ 로 시작되면 텍스트를 파싱한다.
-	HEADER_CG_WARP = 65,
-	HEADER_CG_SCRIPT_BUTTON = 66,
-	HEADER_CG_MESSENGER = 67,
-	//HEADER_CG_UNUSED = 68,
-
-	HEADER_CG_MALL_CHECKOUT = 69,
-	HEADER_CG_SAFEBOX_CHECKIN = 70, // 아이템을 창고에 넣는다.
-	HEADER_CG_SAFEBOX_CHECKOUT = 71, // 아이템을 창고로 부터 빼온다.
-
-	HEADER_CG_PARTY_INVITE = 72,
-	HEADER_CG_PARTY_INVITE_ANSWER = 73,
-	HEADER_CG_PARTY_REMOVE = 74,
-	HEADER_CG_PARTY_SET_STATE = 75,
-	HEADER_CG_PARTY_USE_SKILL = 76,
-	HEADER_CG_SAFEBOX_ITEM_MOVE = 77,
-	HEADER_CG_PARTY_PARAMETER = 78,
-	//HEADER_CG_UNUSED = 79,
-
-	HEADER_CG_GUILD = 80,
-	HEADER_CG_ANSWER_MAKE_GUILD = 81,
-	HEADER_CG_FISHING = 82,
-	HEADER_CG_ITEM_GIVE = 83,
-#ifdef __SHOP_SEARCH__
-	HEADER_CG_SHOP_SEARCH_BY_NAME = 84,
-	HEADER_CG_SHOP_SEARCH_BY_OPTION = 85,
-	HEADER_CG_SHOP_SEARCH_BUY = 86,
-	HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE = 87,
-	HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO = 88,
-#endif
-	HEADER_CG_EMPIRE = 90,
-	//HEADER_CG_UNUSED = 91,
-	//HEADER_CG_UNUSED = 92,
-	//HEADER_CG_UNUSED = 93,
-	//HEADER_CG_UNUSED = 94,
-	//HEADER_CG_UNUSED = 95,
-
-	HEADER_CG_REFINE = 96,
-#if defined(__CUBE_RENEWAL__)
-	HEADER_CG_CUBE = 97,
-#endif
-	//HEADER_CG_UNUSED = 98,
-	//HEADER_CG_UNUSED = 99,
-
-	HEADER_CG_MARK_LOGIN = 100,
-	HEADER_CG_MARK_CRCLIST = 101,
-	HEADER_CG_MARK_UPLOAD = 102,
-	//HEADER_CG_CRC_REPORT = 103,
-	HEADER_CG_MARK_IDXLIST = 104,
-
-	HEADER_CG_HACK = 105,
-	HEADER_CG_CHANGE_NAME = 106,
-	//HEADER_CG_UNUSED = 107,
-	//HEADER_CG_UNUSED = 108,
-	HEADER_CG_LOGIN2 = 109,
-	HEADER_CG_DUNGEON = 110,
-	HEADER_CG_LOGIN3 = 111,
-
-	HEADER_CG_GUILD_SYMBOL_UPLOAD = 112,
-	HEADER_CG_SYMBOL_CRC = 113,
-
-	// SCRIPT_SELECT_ITEM
-	HEADER_CG_SCRIPT_SELECT_ITEM = 114,
-	// END_OF_SCRIPT_SELECT_ITEM
-
-#if defined(__GEM_SYSTEM__)
-	HEADER_CG_SELECT_ITEM_EX = 115,
-#endif
-
-	//HEADER_CG_UNUSED = 116,
-	//HEADER_CG_UNUSED = 117,
-	//HEADER_CG_UNUSED = 118,
-	//HEADER_CG_UNUSED = 119,
-#if defined(__QUEST_REQUEST_EVENT__)
-	HEADER_CG_REQUEST_EVENT_QUEST = 120,
-#endif
-#if defined(__LEFT_SEAT__)
-	HEADER_CG_LEFT_SEAT = 121,
-#endif
-	//HEADER_CG_UNUSED = 122,
-	//HEADER_CG_UNUSED = 123,
-	//HEADER_CG_UNUSED = 124,
-	//HEADER_CG_UNUSED = 125,
-	//HEADER_CG_UNUSED = 126,
-	//HEADER_CG_UNUSED = 127,
-	//HEADER_CG_UNUSED = 128,
-	//HEADER_CG_UNUSED = 129,
-	//HEADER_CG_UNUSED = 130,
-	//HEADER_CG_UNUSED = 131,
-	//HEADER_CG_UNUSED = 132,
-	//HEADER_CG_UNUSED = 133,
-	//HEADER_CG_UNUSED = 134,
-	//HEADER_CG_UNUSED = 135,
-	//HEADER_CG_UNUSED = 136,
-	//HEADER_CG_UNUSED = 137,
-	//HEADER_CG_UNUSED = 138,
-	//HEADER_CG_UNUSED = 139,
-	//HEADER_CG_UNUSED = 140,
-	//HEADER_CG_UNUSED = 141,
-	//HEADER_CG_UNUSED = 142,
-	//HEADER_CG_UNUSED = 143,
-	//HEADER_CG_UNUSED = 144,
-#if defined(__FISHING_GAME__)
-	HEADER_CG_FISHING_GAME = 145,
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	HEADER_CG_REFINE_ELEMENT = 146,
-#endif
-	//HEADER_CG_UNUSED = 147,
-	//HEADER_CG_UNUSED = 148,
-	//HEADER_CG_UNUSED = 149,
-	//HEADER_CG_UNUSED = 150,
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-	HEADER_CG_SKILLBOOK_COMB = 151,
-#endif
-	//HEADER_CG_UNUSED = 152,
-	//HEADER_CG_UNUSED = 153,
-	//HEADER_CG_UNUSED = 154,
-	//HEADER_CG_UNUSED = 155,
-	//HEADER_CG_UNUSED = 156,
-	//HEADER_CG_UNUSED = 157,
-	//HEADER_CG_UNUSED = 158,
-	//HEADER_CG_UNUSED = 159,
-	//HEADER_CG_UNUSED = 160,
-	//HEADER_CG_UNUSED = 161,
-	//HEADER_CG_UNUSED = 162,
-	//HEADER_CG_UNUSED = 163,
-	//HEADER_CG_UNUSED = 164,
-	//HEADER_CG_UNUSED = 165,
-	//HEADER_CG_UNUSED = 166,
-	//HEADER_CG_UNUSED = 167,
-	//HEADER_CG_UNUSED = 168,
-#if defined(__ATTR_6TH_7TH__)
-	HEADER_CG_ATTR67_ADD = 169,
-#endif
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	HEADER_CG_SNOWFLAKE_STICK_EVENT = 170,
-#endif
-	//HEADER_CG_UNUSED = 171,
-	//HEADER_CG_UNUSED = 172,
-	//HEADER_CG_UNUSED = 173,
-	//HEADER_CG_UNUSED = 174,
-	//HEADER_CG_UNUSED = 175,
-	//HEADER_CG_UNUSED = 176,
-	//HEADER_CG_UNUSED = 177,
-	//HEADER_CG_UNUSED = 178,
-	//HEADER_CG_UNUSED = 179,
-	//HEADER_CG_UNUSED = 180,
-#if defined(__MINI_GAME_RUMI__)
-	HEADER_CG_MINI_GAME_RUMI = 181,
-#endif
-#if defined(__MINI_GAME_YUTNORI__)
-	HEADER_CG_MINI_GAME_YUTNORI = 182,
-#endif
-#if defined(__GEM_SHOP__)
-	HEADER_CG_GEM_SHOP = 183,
-#endif
-	//HEADER_CG_UNUSED = 184,
-	//HEADER_CG_UNUSED = 185,
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	HEADER_CG_MINI_GAME_ROULETTE = 186,
-#endif
-#if defined(__FLOWER_EVENT__)
-	HEADER_CG_FLOWER_EVENT = 187,
-#endif
-	//HEADER_CG_UNUSED = 188,
-	//HEADER_CG_UNUSED = 189,
-	//HEADER_CG_UNUSED = 190,
-	//HEADER_CG_UNUSED = 191,
-	//HEADER_CG_UNUSED = 192,
-	//HEADER_CG_UNUSED = 193,
-	//HEADER_CG_UNUSED = 194,
-	//HEADER_CG_UNUSED = 195,
-	//HEADER_CG_UNUSED = 196,
-	//HEADER_CG_UNUSED = 197,
-	//HEADER_CG_UNUSED = 198,
-	//HEADER_CG_UNUSED = 199,
-	//HEADER_CG_UNUSED = 200,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_CG_EXT_BATTLE_PASS_ACTION = 201,
-	HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM = 202,
-#endif
-
-	// NOTE : 이런 개XXX 정말 이거 Packet설계한 사람은 누구냐. 이렇게 코딩하고 밥이 넘어가나.
-	// enum을 별도로 구별을 하던가. 아님 namepsace로 구별을 하던가..
-	// 정말 packet generator까지는 바라지도 않는다. 이런 씨XX
-	// 이러다가 숫자 겹치면 누가 책임지는데???
-	//HEADER_CG_HS_ACK = 203,
-	//HEADER_CG_XTRAP_ACK = 204,
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	HEADER_CG_DRAGON_SOUL_REFINE = 205,
-#endif
-	HEADER_CG_STATE_CHECKER = 206,
-
-	//HEADER_CG_UNUSED = 207,
-#if defined(__LUCKY_BOX__)
-	HEADER_CG_LUCKY_BOX = 208,
-#endif
-	//HEADER_CG_UNUSED = 210,
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	HEADER_CG_ACCE_REFINE = 211,
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	HEADER_CG_AURA_REFINE = 212,
-#endif
-	//HEADER_CG_UNUSED = 213,
-	//HEADER_CG_UNUSED = 214,
-#if defined(__MAILBOX__)
-	HEADER_CG_MAILBOX_WRITE = 215,
-	HEADER_CG_MAILBOX_WRITE_CONFIRM = 216,
-	HEADER_CG_MAILBOX_PROCESS = 217,
-#endif
-#if defined(__MOVE_COSTUME_ATTR__)
-	HEADER_CG_ITEM_COMBINATION = 218,
-	HEADER_CG_ITEM_COMBINATION_CANCEL = 219,
-#endif
-	//HEADER_CG_UNUSED = 223,
-	//HEADER_CG_UNUSED = 224,
-	//HEADER_CG_UNUSED = 225,
-#if defined(__MINI_GAME_CATCH_KING__)
-	HEADER_CG_MINI_GAME_CATCH_KING = 226,
-#endif
-#if defined(__CHANGED_ATTR__)
-	HEADER_CG_ITEM_SELECT_ATTR = 227,
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	HEADER_CG_CHANGE_LOOK = 228,
-#endif
-	//HEADER_CG_UNUSED = 229,
-	//HEADER_CG_UNUSED = 230,
-	//HEADER_CG_UNUSED = 231,
-	//HEADER_CG_UNUSED = 232,
-	//HEADER_CG_UNUSED = 233,
-	//HEADER_CG_UNUSED = 234,
-#if defined(__LOOT_FILTER_SYSTEM__)
-	HEADER_CG_LOOT_FILTER = 235,
-#endif
-	//HEADER_CG_UNUSED = 236,
-	//HEADER_CG_UNUSED = 237,
-	//HEADER_CG_UNUSED = 238,
-	//HEADER_CG_UNUSED = 239,
-	//HEADER_CG_UNUSED = 240,
-	HEADER_CG_CLIENT_VERSION2 = 0xf1, // 241
-	//HEADER_CG_UNUSED = 242,
-	//HEADER_CG_UNUSED = 243,
-	//HEADER_CG_UNUSED = 244,
-	//HEADER_CG_UNUSED = 245,
-	//HEADER_CG_UNUSED = 246,
-	//HEADER_CG_UNUSED = 247,
-	//HEADER_CG_UNUSED = 248,
-	//HEADER_CG_UNUSED = 249,
-	//HEADER_CG_UNUSED = 250,
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	HEADER_CG_KEY_AGREEMENT = 0xfb, // 251
-#endif
-	HEADER_CG_TIME_SYNC = 0xfc, // 252
-	HEADER_CG_CLIENT_VERSION = 0xfd, // 253
-	HEADER_CG_PONG = 0xfe, // 254
-	HEADER_CG_HANDSHAKE = 0xff, // 255
-};
-
-enum GC_HEADERS
-{
-	HEADER_GC_CHARACTER_ADD = 1,
-	HEADER_GC_CHARACTER_DEL = 2,
-	HEADER_GC_MOVE = 3,
-	HEADER_GC_CHAT = 4,
-	HEADER_GC_SYNC_POSITION = 5,
-
-	HEADER_GC_LOGIN_SUCCESS = 6,
-	HEADER_GC_LOGIN_FAILURE = 7,
-
-	HEADER_GC_CHARACTER_CREATE_SUCCESS = 8,
-	HEADER_GC_CHARACTER_CREATE_FAILURE = 9,
-	HEADER_GC_CHARACTER_DELETE_SUCCESS = 10,
-	HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID = 11,
-
-	//HEADER_GC_UNUSED = 12,
-	HEADER_GC_STUN = 13,
-	HEADER_GC_DEAD = 14,
-
-	HEADER_GC_MAIN_CHARACTER_OLD = 15,
-	HEADER_GC_CHARACTER_POINTS = 16,
-	HEADER_GC_CHARACTER_POINT_CHANGE = 17,
-	HEADER_GC_CHANGE_SPEED = 18,
-	HEADER_GC_CHARACTER_UPDATE = 19,
-
-	HEADER_GC_ITEM_DEL = 20,
-	HEADER_GC_ITEM_SET = 21,
-	HEADER_GC_ITEM_USE = 22,
-	HEADER_GC_ITEM_DROP = 23,
-
-	//HEADER_GC_UNUSED = 24,
-	HEADER_GC_ITEM_UPDATE = 25,
-	HEADER_GC_ITEM_GROUND_ADD = 26,
-	HEADER_GC_ITEM_GROUND_DEL = 27,
-
-	HEADER_GC_QUICKSLOT_ADD = 28,
-	HEADER_GC_QUICKSLOT_DEL = 29,
-	HEADER_GC_QUICKSLOT_SWAP = 30,
-
-	HEADER_GC_ITEM_OWNERSHIP = 31,
-
-	HEADER_GC_LOGIN_SUCCESS_NEWSLOT = 32,
-
-	//HEADER_GC_UNUSED = 33,
-	HEADER_GC_WHISPER = 34,
-	//HEADER_GC_UNUSED = 35,
-
-	HEADER_GC_MOTION = 36,
-	HEADER_GC_EMOTE = 37,
-
-	HEADER_GC_SHOP = 38,
-	HEADER_GC_SHOP_SIGN = 39,
-
-	HEADER_GC_DUEL_START = 40,
-	HEADER_GC_PVP = 41,
-	HEADER_GC_EXCHANGE = 42,
-	HEADER_GC_CHARACTER_POSITION = 43,
-
-	HEADER_GC_PING = 44,
-	HEADER_GC_SCRIPT = 45,
-	HEADER_GC_QUEST_CONFIRM = 46,
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	HEADER_GC_EXTEND_INVEN = 47,
-	HEADER_GC_EXTEND_INVEN_ITEM_USE = 48,
-#endif
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	HEADER_GC_GUILD_DRAGONLAIR = 49,
-#endif
-#if defined(__CLIENT_TIMER__)
-	HEADER_GC_CLIENT_TIMER = 50,
-#endif
-#if defined(__OFFLINE_SHOP__)
-	HEADER_GC_OFFLINE_SHOP = 51,
-#endif
-	//HEADER_GC_UNUSED = 52,
-	//HEADER_GC_UNUSED = 53,
-	//HEADER_GC_UNUSED = 54,
-	//HEADER_GC_UNUSED = 55,
-	//HEADER_GC_UNUSED = 56,
-	//HEADER_GC_UNUSED = 57,
-#if defined(__SEND_TARGET_INFO__)
-	HEADER_GC_TARGET_INFO = 58,
-#endif
-	//HEADER_GC_UNUSED = 59,
-	//HEADER_GC_UNUSED = 60,
-	HEADER_GC_MOUNT = 61,
-	HEADER_GC_OWNERSHIP = 62,
-	HEADER_GC_TARGET = 63,
-	//HEADER_GC_UNUSED = 64,
-	HEADER_GC_WARP = 65,
-	//HEADER_GC_UNUSED = 66,
-	//HEADER_GC_UNUSED = 67,
-	//HEADER_GC_UNUSED = 68,
-	HEADER_GC_ADD_FLY_TARGETING = 69,
-
-	HEADER_GC_CREATE_FLY = 70,
-	HEADER_GC_FLY_TARGETING = 71,
-	HEADER_GC_SKILL_LEVEL_OLD = 72,
-	//HEADER_GC_UNUSED = 73,
-	HEADER_GC_MESSENGER = 74,
-	HEADER_GC_GUILD = 75,
-	HEADER_GC_SKILL_LEVEL = 76,
-
-	HEADER_GC_PARTY_INVITE = 77,
-	HEADER_GC_PARTY_ADD = 78,
-	HEADER_GC_PARTY_UPDATE = 79,
-	HEADER_GC_PARTY_REMOVE = 80,
-
-	HEADER_GC_QUEST_INFO = 81,
-	HEADER_GC_REQUEST_MAKE_GUILD = 82,
-	HEADER_GC_PARTY_PARAMETER = 83,
-	//HEADER_GC_UNUSED = 84,
-
-	HEADER_GC_SAFEBOX_SET = 85,
-	HEADER_GC_SAFEBOX_DEL = 86,
-	HEADER_GC_SAFEBOX_WRONG_PASSWORD = 87,
-	HEADER_GC_SAFEBOX_SIZE = 88,
-
-	HEADER_GC_FISHING = 89,
-
-	HEADER_GC_EMPIRE = 90,
-
-	HEADER_GC_PARTY_LINK = 91,
-	HEADER_GC_PARTY_UNLINK = 92,
-	//HEADER_GC_UNUSED = 93,
-	//HEADER_GC_UNUSED = 94,
-	//HEADER_GC_UNUSED = 95,
-	//HEADER_GC_UNUSED = 96,
-#if defined(__CUBE_RENEWAL__)
-	HEADER_GC_CUBE = 97,
-#endif
-	//HEADER_GC_UNUSED = 98,
-	HEADER_GC_VIEW_EQUIP = 99,
-
-	HEADER_GC_MARK_BLOCK = 100,
-	//HEADER_GC_MARK_DIFF_DATA = 101,
-	HEADER_GC_MARK_IDXLIST = 102,
-	//HEADER_GC_UNUSED = 103,
-	//HEADER_GC_UNUSED = 104,
-	//HEADER_GC_SLOW_TIMER = 105,
-	HEADER_GC_TIME = 106,
-	HEADER_GC_CHANGE_NAME = 107,
-	//HEADER_GC_UNUSED = 108,
-	//HEADER_GC_UNUSED = 109,
-
-	HEADER_GC_DUNGEON = 110,
-
-	HEADER_GC_WALK_MODE = 111,
-	HEADER_GC_SKILL_GROUP = 112,
-	HEADER_GC_MAIN_CHARACTER = 113,
-
-	HEADER_GC_SEPCIAL_EFFECT = 114,
-	HEADER_GC_NPC_POSITION = 115,
-
-	//HEADER_CG_UNUSED = 116,
-	//HEADER_GC_UNUSED = 117,
-	HEADER_GC_LOGIN_KEY = 118,
-
-	HEADER_GC_REFINE_INFORMATION = 119,
-	//HEADER_GC_UNUSED = 120,
-	HEADER_GC_CHANNEL = 121,
-
-	HEADER_GC_MALL_OPEN = 122,
-
-	HEADER_GC_TARGET_UPDATE = 123,
-	HEADER_GC_TARGET_DELETE = 124,
-	HEADER_GC_TARGET_CREATE = 125,
-
-	HEADER_GC_AFFECT_ADD = 126,
-	HEADER_GC_AFFECT_REMOVE = 127,
-
-	HEADER_GC_MALL_SET = 128,
-	HEADER_GC_MALL_DEL = 129,
-
-	HEADER_GC_LAND_LIST = 130,
-	HEADER_GC_LOVER_INFO = 131,
-	HEADER_GC_LOVE_POINT_UPDATE = 132,
-
-	HEADER_GC_SYMBOL_DATA = 133,
-
-	// MINING
-	HEADER_GC_DIG_MOTION = 134,
-	// END_OF_MINING
-
-	HEADER_GC_DAMAGE_INFO = 135,
-	HEADER_GC_CHAR_ADDITIONAL_INFO = 136,
-
-	// SUPPORT_BGM
-	HEADER_GC_MAIN_CHARACTER3_BGM = 137,
-	HEADER_GC_MAIN_CHARACTER4_BGM_VOL = 138,
-	// END_OF_SUPPORT_BGM
-
-	//HEADER_GC_UNUSED = 140,
-	//HEADER_GC_UNUSED = 141,
-	//HEADER_GC_UNUSED = 142,
-	//HEADER_GC_UNUSED = 143,
-	//HEADER_GC_UNUSED = 144,
-#if defined(__FISHING_GAME__)
-	HEADER_GC_FISHING_GAME = 145,
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	HEADER_GC_REFINE_ELEMENT = 146,
-#endif
-	//HEADER_GC_UNUSED = 147,
-	//HEADER_GC_UNUSED = 148,
-	//HEADER_GC_UNUSED = 149,
-
-	HEADER_GC_AUTH_SUCCESS = 150,
-	HEADER_GC_PANAMA_PACK = 151,
-
-	// HYBRID CRYPT
-	HEADER_GC_HYBRIDCRYPT_KEYS = 152,
-	HEADER_GC_HYBRIDCRYPT_SDB = 153, // SDB means Supplmentary Data Blocks
-	// HYBRID CRYPT
-
-#ifdef __SHOP_SEARCH__
-	HEADER_GC_SHOP_SEARCH_RESULT = 164,
-	HEADER_GC_SHOP_SEARCH_BUY_RESULT = 165,
-	HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE = 166,
-	HEADER_GC_SHOP_SEARCH_SOLD_INFO = 167,
-	HEADER_GC_ENTITY = 168,
-#endif
-	//HEADER_GC_UNUSED = 169,
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	HEADER_GC_SNOWFLAKE_STICK_EVENT = 170,
-#endif
-	//HEADER_GC_UNUSED = 171,
-	//HEADER_GC_UNUSED = 172,
-	//HEADER_GC_UNUSED = 173,
-	//HEADER_GC_UNUSED = 174,
-	//HEADER_GC_UNUSED = 175,
-	//HEADER_GC_UNUSED = 176,
-	//HEADER_GC_UNUSED = 177,
-	//HEADER_GC_UNUSED = 178,
-	//HEADER_GC_UNUSED = 179,
-	//HEADER_GC_UNUSED = 180,
-#if defined(__MINI_GAME_RUMI__)
-	HEADER_GC_MINI_GAME_RUMI = 181,
-#endif
-#if defined(__MINI_GAME_YUTNORI__)
-	HEADER_GC_MINI_GAME_YUTNORI = 182,
-#endif
-	//HEADER_GC_UNUSED = 183,
-	//HEADER_GC_UNUSED = 184,
-	//HEADER_GC_UNUSED = 185,
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	HEADER_GC_MINI_GAME_ROULETTE = 186,
-#endif
-#if defined(__FLOWER_EVENT__)
-	HEADER_GC_FLOWER_EVENT = 187,
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	HEADER_GC_PET = 188,
-	HEADER_GC_PET_SET = 189,
-	HEADER_GC_PET_SET_EXCHANGE = 190,
-	HEADER_GC_PET_DEL = 191,
-	HEADER_GC_PET_SUMMON = 192,
-	HEADER_GC_PET_POINT_CHANGE = 193,
-	HEADER_GC_PET_NAME_CHANGE_RESULT = 194,
-	HEADER_GC_PET_DETERMINE_RESULT = 195,
-	HEADER_GC_PET_ATTR_CHANGE_RESULT = 196,
-	HEADER_GC_PET_SKILL_UPDATE = 197,
-	HEADER_GC_PET_SKILL_COOLTIME = 198,
-#endif
-
-	//HEADER_GC_UNUSED = 199,
-	//HEADER_GC_UNUSED = 200,
-
-#if defined(__GEM_SHOP__)
-	HEADER_GC_GEM_SHOP = 201,
-	HEADER_GC_GEM_SHOP_PROCESS = 202,
-#endif
-	//HEADER_GC_UNUSED = 203,
-	//HEADER_GC_UNUSED = 204,
-	//HEADER_GC_UNUSED = 205,
-	//HEADER_GC_UNUSED = 206,
-	//HEADER_GC_UNUSED = 207,
-
-	HEADER_GC_SPECIFIC_EFFECT = 208,
-
-	HEADER_GC_DRAGON_SOUL_REFINE = 209,
-	HEADER_GC_RESPOND_CHANNELSTATUS = 210,
-
-	//HEADER_GC_UNUSED = 212,
-	//HEADER_GC_UNUSED = 213,
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	HEADER_GC_ACCE_REFINE = 214,
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	HEADER_GC_AURA_REFINE = 215,
-#endif
-	//HEADER_GC_UNUSED = 216,
-#if defined(__LUCKY_BOX__)
-	HEADER_GC_LUCKY_BOX = 217,
-#endif
-	//HEADER_GC_UNUSED = 218,
-	//HEADER_GC_UNUSED = 219,
-	//HEADER_GC_UNUSED = 220,
-#if defined(__MAILBOX__)
-	HEADER_GC_MAILBOX_PROCESS = 221,
-	HEADER_GC_MAILBOX = 222,
-	HEADER_GC_MAILBOX_ADD_DATA = 223,
-	HEADER_GC_MAILBOX_ALL = 224,
-	HEADER_GC_MAILBOX_UNREAD = 225,
-#endif
-	//HEADER_GC_UNUSED = 226,
-#if defined(__CHANGED_ATTR__)
-	HEADER_GC_ITEM_SELECT_ATTR = 227,
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	HEADER_GC_CHANGE_LOOK_SET = 228,
-	HEADER_GC_CHANGE_LOOK_DEL = 229,
-	HEADER_GC_CHANGE_LOOK_FREE_SET = 230,
-	HEADER_GC_CHANGE_LOOK_FREE_DEL = 231,
-#endif
-	//HEADER_GC_UNUSED = 232,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_GC_EXT_BATTLE_PASS_OPEN = 233,
-	HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO = 234,
-	HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO = 235,
-	HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE = 236,
-	HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING = 237,
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-	HEADER_GC_MINI_GAME_CATCH_KING = 238,
-#endif
-	//HEADER_GC_UNUSED = 239,
-#if defined(__RANKING_SYSTEM__)
-	HEADER_GC_RANKING = 240,
-#endif
-	//HEADER_GC_UNUSED = 241,
-	//HEADER_GC_UNUSED = 242,
-	//HEADER_GC_UNUSED = 243,
-	//HEADER_GC_UNUSED = 244,
-#if defined(__LOOT_FILTER_SYSTEM__)
-	HEADER_GC_LOOT_FILTER = 245,
-#endif
-	//HEADER_GC_UNUSED = 246,
-	//HEADER_GC_UNUSED = 247,
-	//HEADER_GC_UNUSED = 248,
-	//HEADER_GC_UNUSED = 249,
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	HEADER_GC_KEY_AGREEMENT_COMPLETED = 250, // 250
-	HEADER_GC_KEY_AGREEMENT = 251, // 251
-#endif
-	HEADER_GC_TIME_SYNC = 252, // 252
-	HEADER_GC_PHASE = 253, // 253
-	HEADER_GC_BINDUDP = 254, // 254
-	HEADER_GC_HANDSHAKE = 255, // 255
-};
-
-enum GG_HEADERS
-{
-	HEADER_GG_LOGIN = 1,
-	HEADER_GG_LOGOUT = 2,
-	HEADER_GG_RELAY = 3,
-	HEADER_GG_NOTICE = 4,
-	HEADER_GG_SHUTDOWN = 5,
-	HEADER_GG_GUILD = 6,
-	HEADER_GG_DISCONNECT = 7, // 누군가의 접속을 강제로 끊을 때
-	HEADER_GG_SHOUT = 8,
-	HEADER_GG_SETUP = 9,
-	HEADER_GG_MESSENGER_ADD = 10,
-	HEADER_GG_MESSENGER_REMOVE = 11,
-	HEADER_GG_FIND_POSITION = 12,
-	HEADER_GG_WARP_CHARACTER = 13,
-	//HEADER_GG_UNUSED = 14,
-	HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
-	HEADER_GG_TRANSFER = 16,
-#if defined(__XMAS_EVENT_2008__)
-	HEADER_GG_XMAS_WARP_SANTA = 17,
-	HEADER_GG_XMAS_WARP_SANTA_REPLY = 18,
-#endif
-	HEADER_GG_RELOAD_CRC_LIST = 19,
-	HEADER_GG_LOGIN_PING = 20,
-	HEADER_GG_CHECK_CLIENT_VERSION = 21,
-	HEADER_GG_BLOCK_CHAT = 22,
-	HEADER_GG_BIG_NOTICE = 23,
-	HEADER_GG_BLOCK_EXCEPTION = 24,
-	HEADER_GG_SIEGE = 25,
-	HEADER_GG_MONARCH_NOTICE = 26,
-	HEADER_GG_MONARCH_TRANSFER = 27,
-	HEADER_GG_PCBANG_UPDATE = 28,
-	HEADER_GG_CHECK_AWAKENESS = 29,
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	HEADER_GG_MESSENGER_BLOCK_ADD = 30,
-	HEADER_GG_MESSENGER_BLOCK_REMOVE = 31,
-#endif
-#if defined(__OFFLINE_SHOP__)
-	HEADER_GG_OFFLINE_SHOP = 33,
-	HEADER_GG_UPDATE_SELL_HISTORY = 34,
-#endif
-};
-
-#pragma pack(1)
-typedef struct SPacketGGSetup
-{
-	BYTE bHeader;
-	WORD wPort;
-	BYTE bChannel;
-} TPacketGGSetup;
-
-typedef struct SPacketGGLogin
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	DWORD dwPID;
-	BYTE bEmpire;
-	long lMapIndex;
-	BYTE bChannel;
-} TPacketGGLogin;
-
-typedef struct SPacketGGLogout
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGGLogout;
-
-typedef struct SPacketGGRelay
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lSize;
-} TPacketGGRelay;
-
-typedef struct SPacketGGNotice
-{
-	BYTE bHeader;
-	long lSize;
-	char szArg[CHAT_MAX_LEN + 1];
-	bool bBigFont;
-} TPacketGGNotice;
-
-typedef struct SPacketGGMonarchNotice
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-	long lSize;
-} TPacketGGMonarchNotice;
-
-// FORKED_ROAD
-typedef struct SPacketGGForkedMapInfo
-{
-	BYTE bHeader;
-	BYTE bPass;
-	BYTE bSungzi;
-} TPacketGGForkedMapInfo;
-// END_FORKED_ROAD
-
-typedef struct SPacketGGShutdown
-{
-	BYTE bHeader;
-} TPacketGGShutdown;
-
-typedef struct SPacketGGGuild
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwGuild;
-} TPacketGGGuild;
-
-enum
-{
-	GUILD_SUBHEADER_GG_CHAT,
-	GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS,
-};
-
-typedef struct SPacketGGGuildChat
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwGuild;
-	char szText[CHAT_MAX_LEN + 1];
-} TPacketGGGuildChat;
-
-typedef struct SPacketGGParty
-{
-	BYTE header;
-	BYTE subheader;
-	DWORD pid;
-	DWORD leaderpid;
-} TPacketGGParty;
-
-enum
-{
-	PARTY_SUBHEADER_GG_CREATE,
-	PARTY_SUBHEADER_GG_DESTROY,
-	PARTY_SUBHEADER_GG_JOIN,
-	PARTY_SUBHEADER_GG_QUIT,
-};
-
-typedef struct SPacketGGDisconnect
-{
-	BYTE bHeader;
-	char szLogin[LOGIN_MAX_LEN + 1];
-} TPacketGGDisconnect;
-
-typedef struct SPacketGGShout
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-	char szText[CHAT_MAX_LEN + 1];
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGGShout;
-
-#if defined(__XMAS_EVENT_2008__)
-typedef struct SPacketGGXmasWarpSanta
-{
-	BYTE bHeader;
-	BYTE bChannel;
-	long lMapIndex;
-} TPacketGGXmasWarpSanta;
-
-typedef struct SPacketGGXmasWarpSantaReply
-{
-	BYTE bHeader;
-	BYTE bChannel;
-} TPacketGGXmasWarpSantaReply;
-#endif
-
-typedef struct SPacketGGMessenger
-{
-	BYTE bHeader;
-	char szAccount[CHARACTER_NAME_MAX_LEN + 1];
-	char szCompanion[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGGMessenger;
-
-typedef struct SPacketGGFindPosition
-{
-	BYTE header;
-	DWORD dwFromPID; // 저 위치로 워프하려는 사람
-	DWORD dwTargetPID; // 찾는 사람
-} TPacketGGFindPosition;
-
-typedef struct SPacketGGWarpCharacter
-{
-	BYTE header;
-	DWORD pid;
-	long x;
-	long y;
-} TPacketGGWarpCharacter;
-
-//HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
-
-typedef struct SPacketGGGuildWarMapIndex
-{
-	BYTE bHeader;
-	DWORD dwGuildID1;
-	DWORD dwGuildID2;
-	long lMapIndex;
-} TPacketGGGuildWarMapIndex;
-
-typedef struct SPacketGGTransfer
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lX, lY;
-} TPacketGGTransfer;
-
-typedef struct SPacketGGLoginPing
-{
-	BYTE bHeader;
-	char szLogin[LOGIN_MAX_LEN + 1];
-} TPacketGGLoginPing;
-
-typedef struct SPacketGGBlockChat
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lBlockDuration;
-} TPacketGGBlockChat;
-
-/* 클라이언트 측에서 보내는 패킷 */
-typedef struct command_text
-{
-	BYTE bHeader;
-} TPacketCGText;
-
-typedef struct command_phase
-{
-	BYTE bHeader;
-} TPacketCGPhase;
-
-/* 로그인 (1) */
-typedef struct command_handshake
-{
-	BYTE bHeader;
-	DWORD dwHandshake;
-	DWORD dwTime;
-	long lDelta;
-} TPacketCGHandshake;
-
-typedef struct command_login
-{
-	BYTE header;
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-} TPacketCGLogin;
-
-typedef struct command_login2
-{
-	BYTE header;
-	char login[LOGIN_MAX_LEN + 1];
-	DWORD dwLoginKey;
-	DWORD adwClientKey[4];
-} TPacketCGLogin2;
-
-typedef struct command_login3
-{
-	BYTE header;
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-	DWORD adwClientKey[4];
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char country[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketCGLogin3;
-
-typedef struct packet_login_key
-{
-	BYTE bHeader;
-	DWORD dwLoginKey;
-} TPacketGCLoginKey;
-
-typedef struct command_player_select
-{
-	BYTE header;
-	BYTE index;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char country[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketCGPlayerSelect;
-
-typedef struct command_player_delete
-{
-	BYTE header;
-	BYTE index;
-	char private_code[8];
-} TPacketCGPlayerDelete;
-
-typedef struct command_player_create
-{
-	BYTE header;
-	BYTE index;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	WORD job;
-	BYTE shape;
-	BYTE Con;
-	BYTE Int;
-	BYTE Str;
-	BYTE Dex;
-} TPacketCGPlayerCreate;
-
-typedef struct command_player_create_success
-{
-	BYTE header;
-	BYTE bAccountCharacterIndex;
-	TSimplePlayer player;
-} TPacketGCPlayerCreateSuccess;
-
-// 공격
-typedef struct command_attack
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwVID;
-	BYTE bCRCMagicCubeProcPiece;
-	BYTE bCRCMagicCubeFilePiece;
-} TPacketCGAttack;
-
-enum EMoveFuncType
-{
-	FUNC_WAIT,
-	FUNC_MOVE,
-	FUNC_ATTACK,
-	FUNC_COMBO,
-	FUNC_MOB_SKILL,
-	_FUNC_SKILL,
-	FUNC_MAX_NUM,
-	FUNC_SKILL = 0x80,
-};
-
-// 이동
-typedef struct command_move
-{
-	BYTE bHeader;
-	BYTE bFunc;
-	BYTE bArg;
-	BYTE bRot;
-	long lX;
-	long lY;
-	DWORD dwTime;
-} TPacketCGMove;
-
-typedef struct command_sync_position_element
-{
-	DWORD dwVID;
-	long lX;
-	long lY;
-} TPacketCGSyncPositionElement;
-
-// 위치 동기화
-typedef struct command_sync_position // 가변 패킷
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketCGSyncPosition;
-
-/* 채팅 (3) */
-typedef struct command_chat // 가변 패킷
-{
-	BYTE header;
-	WORD size;
-	BYTE type;
-} TPacketCGChat;
-
-/* 귓속말 */
-typedef struct command_whisper
-{
-	BYTE bHeader;
-	WORD wSize;
-	char szNameTo[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGWhisper;
-
-typedef struct command_entergame
-{
-	BYTE header;
-} TPacketCGEnterGame;
-
-typedef struct command_item_use
-{
-	BYTE header;
-	TItemPos Cell;
-} TPacketCGItemUse;
-
-typedef struct command_item_use_to_item
-{
-	BYTE header;
-	TItemPos Cell;
-	TItemPos TargetCell;
-} TPacketCGItemUseToItem;
-
-typedef struct command_item_drop
-{
-	BYTE header;
-	TItemPos Cell;
-	DWORD gold;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD cheque;
-#endif
-} TPacketCGItemDrop;
-
-typedef struct command_item_drop2
-{
-	BYTE header;
-	TItemPos Cell;
-	DWORD gold;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD cheque;
-#endif
-	WORD count;
-} TPacketCGItemDrop2;
-
-#if defined(__NEW_DROP_DIALOG__)
-typedef struct command_item_destroy
-{
-	BYTE header;
-	TItemPos Cell;
-} TPacketCGItemDestroy;
-#endif
-
-typedef struct command_item_move
-{
-	BYTE header;
-	TItemPos Cell;
-	TItemPos CellTo;
-	WORD count;
-} TPacketCGItemMove;
-
-typedef struct command_item_pickup
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGItemPickup;
-
-typedef struct command_quickslot_add
-{
-	BYTE header;
-	BYTE pos;
-	TQuickslot slot;
-} TPacketCGQuickslotAdd;
-
-typedef struct command_quickslot_del
-{
-	BYTE header;
-	BYTE pos;
-} TPacketCGQuickslotDel;
-
-typedef struct command_quickslot_swap
-{
-	BYTE header;
-	BYTE pos;
-	BYTE change_pos;
-} TPacketCGQuickslotSwap;
-
-enum
-{
-	SHOP_SUBHEADER_CG_END,
-	SHOP_SUBHEADER_CG_BUY,
-	SHOP_SUBHEADER_CG_SELL,
-	SHOP_SUBHEADER_CG_SELL2,
-};
-
-typedef struct command_shop_buy
-{
-	BYTE count;
-} TPacketCGShopBuy;
-
-typedef struct command_shop_sell
-{
-	WORD wPos;
-	WORD wCount;
-	BYTE bType;
-} TPacketCGShopSell;
-
-typedef struct command_shop
-{
-	BYTE header;
-	WORD subheader;
-} TPacketCGShop;
-
-typedef struct command_on_click
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGOnClick;
-
-enum
-{
-	EXCHANGE_SUBHEADER_CG_START, /* arg1 == vid of target character */
-	EXCHANGE_SUBHEADER_CG_ITEM_ADD, /* arg1 == position of item */
-	EXCHANGE_SUBHEADER_CG_ITEM_DEL, /* arg1 == position of item */
-	EXCHANGE_SUBHEADER_CG_ELK_ADD, /* arg1 == amount of gold */
-#if defined(__CHEQUE_SYSTEM__)
-	EXCHANGE_SUBHEADER_CG_CHEQUE_ADD, /* arg1 == amount of cheque */
-#endif
-	EXCHANGE_SUBHEADER_CG_ACCEPT, /* arg1 == not used */
-	EXCHANGE_SUBHEADER_CG_CANCEL, /* arg1 == not used */
-};
-
-typedef struct command_exchange
-{
-	BYTE header;
-	BYTE sub_header;
-	DWORD arg1;
-	BYTE arg2;
-	TItemPos Pos;
-} TPacketCGExchange;
-
-typedef struct command_position
-{
-	BYTE header;
-	BYTE position;
-} TPacketCGPosition;
-
-typedef struct command_script_answer
-{
-	BYTE header;
-	BYTE answer;
-	//char file[32 + 1];
-	//BYTE answer[16 + 1];
-} TPacketCGScriptAnswer;
-
-typedef struct command_script_button
-{
-	BYTE header;
-	unsigned int idx;
-} TPacketCGScriptButton;
-
-typedef struct command_quest_input_string
-{
-	BYTE header;
-	char msg[64 + 1];
-} TPacketCGQuestInputString;
-
-#if defined(__OX_RENEWAL__)
-typedef struct command_quest_input_long_string
-{
-	BYTE header;
-	char msg[128 + 1];
-} TPacketCGQuestInputLongString;
-#endif
-
-typedef struct command_quest_confirm
-{
-	BYTE header;
-	BYTE answer;
-	DWORD requestPID;
-} TPacketCGQuestConfirm;
-
-/*
-* 서버 측에서 보내는 패킷
-*/
-typedef struct packet_quest_confirm
-{
-	BYTE header;
-	char msg[128 + 1];
-	long timeout;
-	DWORD requestPID;
-} TPacketGCQuestConfirm;
-
-typedef struct packet_handshake
-{
-	BYTE bHeader;
-	DWORD dwHandshake;
-	DWORD dwTime;
-	long lDelta;
-} TPacketGCHandshake;
-
-enum EPhase
-{
-	PHASE_CLOSE,
-	PHASE_HANDSHAKE,
-	PHASE_LOGIN,
-	PHASE_SELECT,
-	PHASE_LOADING,
-	PHASE_GAME,
-	PHASE_DEAD,
-
-	PHASE_CLIENT_CONNECTING,
-	PHASE_DBCLIENT,
-	PHASE_P2P,
-	PHASE_AUTH,
-};
-
-typedef struct packet_phase
-{
-	BYTE header;
-	BYTE phase;
-} TPacketGCPhase;
-
-typedef struct packet_bindudp
-{
-	BYTE header;
-	DWORD addr;
-	WORD port;
-} TPacketGCBindUDP;
-
-typedef struct packet_login_success
-{
-	BYTE bHeader;
-	TSimplePlayer players[PLAYER_PER_ACCOUNT];
-	DWORD guild_id[PLAYER_PER_ACCOUNT];
-	char guild_name[PLAYER_PER_ACCOUNT][GUILD_NAME_MAX_LEN + 1];
-
-	DWORD handle;
-	DWORD random_key;
-} TPacketGCLoginSuccess;
-
-typedef struct packet_auth_success
-{
-	BYTE bHeader;
-	DWORD dwLoginKey;
-	BYTE bResult;
-	BOOL bState;
-} TPacketGCAuthSuccess;
-
-enum ELoginFailure
-{
-	LOGIN_FAILURE_NONE,
-	LOGIN_FAILURE_ALREADY,
-	LOGIN_FAILURE_NOID,
-	LOGIN_FAILURE_WRONGPWD,
-	LOGIN_FAILURE_FULL,
-	LOGIN_FAILURE_SHUTDOWN,
-	LOGIN_FAILURE_REPAIR,
-	LOGIN_FAILURE_BLOCK,
-	LOGIN_FAILURE_WRONGMAT,
-	LOGIN_FAILURE_QUIT,
-	LOGIN_FAILURE_BESAMEKEY,
-	LOGIN_FAILURE_NOTAVAIL,
-	LOGIN_FAILURE_BLKLOGIN,
-	LOGIN_FAILURE_WEBBLK,
-	LOGIN_FAILURE_BADSCLID,
-	LOGIN_FAILURE_AGELIMIT,
-	LOGIN_FAILURE_CONFIRM,
-	LOGIN_FAILURE_INACTIVE,
-	LOGIN_FAILURE_UNMIGRATION,
-	LOGIN_FAILURE_MPROCESSING,
-	LOGIN_FAILURE_LOCKED,
-	LOGIN_FAILURE_BACKENDERR,
-	LOGIN_FAILURE_INTEGRTING,
-	LOGIN_FAILURE_COUNTRYERR,
-	LOGIN_FAILURE_IOVATION,
-	LOGIN_FAILURE_TNTERR,
-	LOGIN_FAILURE_SERVER_CLOSED,
-	LOGIN_FAILURE_SERVER_GRADE,
-};
-
-typedef struct packet_login_failure
-{
-	BYTE header;
-	char szStatus[ACCOUNT_STATUS_MAX_LEN + 1];
-} TPacketGCLoginFailure;
-
-typedef struct packet_create_failure
-{
-	BYTE header;
-	BYTE bType;
-} TPacketGCCreateFailure;
-
-enum
-{
-	ADD_CHARACTER_STATE_DEAD = (1 << 0),
-	ADD_CHARACTER_STATE_SPAWN = (1 << 1),
-	ADD_CHARACTER_STATE_GUNGON = (1 << 2),
-	ADD_CHARACTER_STATE_KILLER = (1 << 3),
-	ADD_CHARACTER_STATE_PARTY = (1 << 4),
-};
-
-enum ECharacterEquipmentPart
-{
-	CHR_EQUIPPART_ARMOR,
-	CHR_EQUIPPART_WEAPON,
-	CHR_EQUIPPART_HEAD,
-	CHR_EQUIPPART_HAIR,
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	CHR_EQUIPPART_ACCE,
-#endif
-	CHR_EQUIPPART_AURA,
-
-	CHR_EQUIPPART_NUM,
-};
-
-typedef struct packet_add_char
-{
-	BYTE header;
-	DWORD dwVID;
-
-#if defined(__WJ_SHOW_MOB_INFO__)
-	DWORD dwLevel;
-	DWORD dwAIFlag;
-#endif
-
-	float angle;
-	long x;
-	long y;
-	long z;
-
-	BYTE bType;
-	WORD wRaceNum;
-#if defined(__RACE_SWAP__)
-	DWORD dwEventRaceNum;
-#endif
-	BYTE bMovingSpeed;
-	BYTE bAttackSpeed;
-
-	BYTE bStateFlag;
-	DWORD dwAffectFlag[3]; // 효과
-} TPacketGCCharacterAdd;
-
-typedef struct packet_char_additional_info
-{
-	BYTE header;
-	DWORD dwVID;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	DWORD adwPart[CHR_EQUIPPART_NUM];
-	BYTE bEmpire;
-	DWORD dwGuildID;
-	DWORD dwLevel;
-#if defined(__CONQUEROR_LEVEL__)
-	DWORD dwConquerorLevel;
-#endif
-	short sAlignment; // 선악치
-	BYTE bPKMode;
-	DWORD dwMountVnum;
-#if defined(__QUIVER_SYSTEM__)
-	DWORD dwArrow;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	WORD wRefineElementAffectType;
-#endif
-#if defined(__GUILD_LEADER_GRADE_NAME__)
-	BYTE bGuildLeaderGrade;
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	BYTE bCharacterSize;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGCCharacterAdditionalInfo;
-
-typedef struct packet_update_char
-{
-	BYTE header;
-	DWORD dwVID;
-
-	DWORD adwPart[CHR_EQUIPPART_NUM];
-
-	BYTE bMovingSpeed;
-	BYTE bAttackSpeed;
-
-	BYTE bStateFlag;
-	DWORD dwAffectFlag[3];
-
-	DWORD dwGuildID;
-	short sAlignment;
-	DWORD dwLevel;
-#if defined(__CONQUEROR_LEVEL__)
-	DWORD dwConquerorLevel;
-#endif
-	BYTE bPKMode;
-	DWORD dwMountVnum;
-#if defined(__QUIVER_SYSTEM__)
-	DWORD dwArrow;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	WORD wRefineElementAffectType;
-#endif
-#if defined(__GUILD_LEADER_GRADE_NAME__)
-	BYTE bGuildLeaderGrade;
-#endif
-#if defined(__LEFT_SEAT__)
-	bool bLeftSeat;
-#endif
-} TPacketGCCharacterUpdate;
-
-typedef struct packet_del_char
-{
-	BYTE header;
-	DWORD id;
-} TPacketGCCharacterDelete;
-
-typedef struct packet_chat // 가변 패킷
-{
-	BYTE header;
-	WORD size;
-	BYTE type;
-	DWORD id;
-	BYTE bEmpire;
-#if defined(__LOCALE_CLIENT__)
-	bool bCanFormat;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-#if defined(__LOCALE_CLIENT__)
-	packet_chat() : bCanFormat(true) {}
-#endif
-} TPacketGCChat;
-
-typedef struct packet_whisper // 가변 패킷
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bType;
-	char szNameFrom[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(__LOCALE_CLIENT__)
-	bool bCanFormat;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-#if defined(__LOCALE_CLIENT__)
-	packet_whisper() : bCanFormat(true) {}
-#endif
-} TPacketGCWhisper;
-
-typedef struct packet_main_character
-{
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lx, ly, lz;
-	BYTE empire;
-	BYTE skill_group;
-} TPacketGCMainCharacter;
-
-// SUPPORT_BGM
-typedef struct packet_main_character3_bgm
-{
-	enum
-	{
-		MUSIC_NAME_LEN = 24,
-	};
-
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
-	char szBGMName[MUSIC_NAME_LEN + 1];
-	long lx, ly, lz;
-	BYTE empire;
-	BYTE skill_group;
-} TPacketGCMainCharacter3_BGM;
-
-typedef struct packet_main_character4_bgm_vol
-{
-	enum
-	{
-		MUSIC_NAME_LEN = 24,
-	};
-
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
-	char szBGMName[MUSIC_NAME_LEN + 1];
-	float fBGMVol;
-	long lx, ly, lz;
-	BYTE empire;
-	BYTE skill_group;
-} TPacketGCMainCharacter4_BGM_VOL;
-// END_OF_SUPPORT_BGM
-
-typedef struct packet_points
-{
-	BYTE bHeader;
-	POINT_VALUE lPoints[POINT_MAX_NUM];
-} TPacketGCPoints;
-
-typedef struct packet_skill_level
-{
-	BYTE bHeader;
-	TPlayerSkill skills[SKILL_MAX_NUM];
-} TPacketGCSkillLevel;
-
-typedef struct packet_point_change
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	POINT_TYPE wType;
-	POINT_VALUE lAmount;
-	POINT_VALUE lValue;
-} TPacketGCPointChange;
-
-typedef struct packet_stun
-{
-	BYTE header;
-	DWORD vid;
-} TPacketGCStun;
-
-typedef struct packet_dead
-{
-	BYTE header;
-	DWORD vid;
-	BYTE dialog_type;
-	long map_index;
-	packet_dead() : dialog_type(DEAD_DIALOG_NORMAL), map_index(0) {}
-} TPacketGCDead;
-
-typedef struct packet_item_set_empty
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwVnum;
-	DWORD dwCount;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemSetEmpty;
-
-typedef struct packet_item_set
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwVnum;
-	DWORD dwCount;
-	DWORD dwFlags;
-	DWORD dwAntiFlags;
-	bool bHighLight;
-#if defined(__SOUL_BIND_SYSTEM__)
-	long lSealDate;
-#endif
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemSet;
-
-typedef struct packet_item_del
-{
-	BYTE header;
-	BYTE pos;
-} TPacketGCItemDel;
-
-struct packet_item_use
-{
-	BYTE header;
-	TItemPos Cell;
-	DWORD ch_vid;
-	DWORD victim_vid;
-	DWORD vnum;
-};
-
-struct packet_item_move
-{
-	BYTE header;
-	TItemPos Cell;
-	TItemPos CellTo;
-};
-
-typedef struct packet_item_update
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwCount;
-#if defined(__SOUL_BIND_SYSTEM__)
-	long lSealDate;
-#endif
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemUpdate;
-
-typedef struct packet_item_ground_add
-{
-#if defined(__ITEM_DROP_RENEWAL__)
-	packet_item_ground_add()
-	{
-		memset(&alSockets, 0, sizeof(alSockets));
-		memset(&aAttrs, 0, sizeof(aAttrs));
-	}
-#endif
-
-	BYTE bHeader;
-	long lX, lY, lZ;
-	DWORD dwVID;
-	DWORD dwVnum;
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-
-#if defined(__ITEM_DROP_RENEWAL__)
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttrs[ITEM_ATTRIBUTE_MAX_NUM];
-#endif
-} TPacketGCItemGroundAdd;
-
-typedef struct packet_item_ownership
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCItemOwnership;
-
-typedef struct packet_item_ground_del
-{
-	BYTE bHeader;
-	DWORD dwVID;
-} TPacketGCItemGroundDel;
-
-struct packet_quickslot_add
-{
-	BYTE header;
-	BYTE pos;
-	TQuickslot slot;
-};
-
-struct packet_quickslot_del
-{
-	BYTE header;
-	BYTE pos;
-};
-
-struct packet_quickslot_swap
-{
-	BYTE header;
-	BYTE pos;
-	BYTE pos_to;
-};
-
-struct packet_motion
-{
-	BYTE header;
-	DWORD vid;
-	DWORD victim_vid;
-	WORD motion;
-};
-
-enum EPacketShopSubHeaders
-{
-	SHOP_SUBHEADER_GC_NONE,
-	SHOP_SUBHEADER_GC_START,
-	SHOP_SUBHEADER_GC_END,
-	SHOP_SUBHEADER_GC_UPDATE_ITEM,
-	SHOP_SUBHEADER_GC_UPDATE_PRICE,
-	SHOP_SUBHEADER_GC_OK,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY,
-	SHOP_SUBHEADER_GC_SOLDOUT,
-	SHOP_SUBHEADER_GC_INVENTORY_FULL,
-	SHOP_SUBHEADER_GC_INVALID_POS,
-	SHOP_SUBHEADER_GC_SOLD_OUT,
-	SHOP_SUBHEADER_GC_START_EX,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_BP,
-	SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY,
-#if defined(__MYSHOP_DECO__)
-	SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN,
-#endif
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN,
-	SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER,
-	SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING,
-	SHOP_SUBHEADER_GC_UNK_19,
-	SHOP_SUBHEADER_GC_UNK_20,
-	SHOP_SUBHEADER_GC_UNK_21,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW,
-#if defined(__SHOPEX_RENEWAL__)
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM,
-#endif
-};
-
-struct packet_shop_item
-{
-	DWORD dwVnum;
-	DWORD dwCount;
-	DWORD dwPrice;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD dwCheque;
-#endif
-	BYTE bDisplayPos;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-#if defined(__SHOPEX_RENEWAL__)
-	BYTE bPriceType;
-	DWORD dwPriceVnum;
-#endif
-	packet_shop_item()
-	{
-#if defined(__CHEQUE_SYSTEM__)
-		dwCheque = 0;
-#endif
-		memset(&alSockets, 0, sizeof(alSockets));
-		memset(&aAttr, 0, sizeof(aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		dwTransmutationVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		memset(&RefineElement, 0, sizeof(RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		memset(&aApplyRandom, 0, sizeof(aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-		bSetValue = 0;
-#endif
-#if defined(__SHOPEX_RENEWAL__)
-		bPriceType = SHOP_COIN_TYPE_GOLD;
-		dwPriceVnum = 0;
-#endif
-	}
-};
-
-typedef struct packet_shop_start
-{
-	DWORD owner_vid;
-#if defined(__MYSHOP_DECO__)
-	BYTE shop_tab_count;
-#endif
-#if defined(__MYSHOP_EXPANSION__)
-	struct packet_shop_item items[SHOP_HOST_ITEM_MAX];
-#else
-	struct packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
-#endif
-} TPacketGCShopStart;
-
-typedef struct packet_shop_start_ex // 다음에 TSubPacketShopTab* shop_tabs 이 따라옴.
-{
-	typedef struct sub_packet_shop_tab
-	{
-		char name[SHOP_TAB_NAME_MAX];
-		BYTE coin_type;
-		packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
-	} TSubPacketShopTab;
-	DWORD owner_vid;
-	BYTE shop_tab_count;
-} TPacketGCShopStartEx;
-
-typedef struct packet_shop_update_item
-{
-	BYTE pos;
-	struct packet_shop_item item;
-} TPacketGCShopUpdateItem;
-
-typedef struct packet_shop_update_price
-{
-	int iPrice;
-#if defined(__CHEQUE_SYSTEM__)
-	int iCheque;
-#endif
-} TPacketGCShopUpdatePrice;
-
-typedef struct packet_shop // 가변 패킷
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-} TPacketGCShop;
-
-typedef struct packet_exchange
-{
-	BYTE header;
-	BYTE sub_header;
-	BYTE is_me;
-	DWORD arg1; // vnum
-	TItemPos arg2; // cell
-	DWORD arg3; // count
-	TItemPos arg4;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetItem;
-#endif
-} TPacketGCExchange;
-
-enum EPacketTradeSubHeaders
-{
-	EXCHANGE_SUBHEADER_GC_START, /* arg1 == vid */
-	EXCHANGE_SUBHEADER_GC_ITEM_ADD, /* arg1 == vnum arg2 == pos arg3 == count */
-	EXCHANGE_SUBHEADER_GC_ITEM_DEL,
-	EXCHANGE_SUBHEADER_GC_GOLD_ADD, /* arg1 == gold */
-#if defined(__CHEQUE_SYSTEM__)
-	EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, /* arg1 == cheque */
-#endif
-	EXCHANGE_SUBHEADER_GC_ACCEPT, /* arg1 == accept */
-	EXCHANGE_SUBHEADER_GC_END, /* arg1 == not used */
-	EXCHANGE_SUBHEADER_GC_ALREADY, /* arg1 == not used */
-	EXCHANGE_SUBHEADER_GC_LESS_GOLD, /* arg1 == not used */
-#if defined(__CHEQUE_SYSTEM__)
-	EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, /* arg1 == not used */
-#endif
-};
-
-struct packet_position
-{
-	BYTE header;
-	DWORD vid;
-	BYTE position;
-};
-
-typedef struct packet_ping
-{
-	BYTE header;
-} TPacketGCPing;
-
-struct packet_script
-{
-	BYTE header;
-	WORD size;
-	BYTE skin;
-	WORD src_size;
-};
-
-typedef struct packet_change_speed
-{
-	BYTE header;
-	DWORD vid;
-	WORD moving_speed;
-} TPacketGCChangeSpeed;
-
-struct packet_mount
-{
-	BYTE header;
-	DWORD vid;
-	DWORD mount_vid;
-	BYTE pos;
-	DWORD x, y;
-};
-
-typedef struct packet_move
-{
-	BYTE bHeader;
-	BYTE bFunc;
-	BYTE bArg;
-	BYTE bRot;
-	DWORD dwVID;
-	long lX;
-	long lY;
-	DWORD dwTime;
-	DWORD dwDuration;
-} TPacketGCMove;
-
-// 소유권
-typedef struct packet_ownership
-{
-	BYTE bHeader;
-	DWORD dwOwnerVID;
-	DWORD dwVictimVID;
-} TPacketGCOwnership;
-
-// 위치 동기화 패킷의 bCount 만큼 붙는 단위
-typedef struct packet_sync_position_element
-{
-	DWORD dwVID;
-	long lX;
-	long lY;
-} TPacketGCSyncPositionElement;
-
-// 위치 동기화
-typedef struct packet_sync_position // 가변 패킷
-{
-	BYTE bHeader;
-	WORD wSize; // 개수 = (wSize - sizeof(TPacketGCSyncPosition)) / sizeof(TPacketGCSyncPositionElement) 
-} TPacketGCSyncPosition;
-
-typedef struct packet_fly
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwStartVID;
-	DWORD dwEndVID;
-} TPacketGCCreateFly;
-
-typedef struct command_fly_targeting
-{
-	BYTE bHeader;
-	DWORD dwTargetVID;
-	long x, y;
-} TPacketCGFlyTargeting;
-
-typedef struct packet_fly_targeting
-{
-	BYTE bHeader;
-	DWORD dwShooterVID;
-	DWORD dwTargetVID;
-	long x, y;
-} TPacketGCFlyTargeting;
-
-typedef struct packet_shoot
-{
-	BYTE bHeader;
-	BYTE bType;
-} TPacketCGShoot;
-
-typedef struct packet_duel_start
-{
-	BYTE header;
-	WORD wSize; // DWORD가 몇개? 개수 = (wSize - sizeof(TPacketGCPVPList)) / 4
-} TPacketGCDuelStart;
-
-enum EPVPModes
-{
-	PVP_MODE_NONE,
-	PVP_MODE_AGREE,
-	PVP_MODE_FIGHT,
-	PVP_MODE_REVENGE
-};
-
-typedef struct packet_pvp
-{
-	BYTE bHeader;
-	DWORD dwVIDSrc;
-	DWORD dwVIDDst;
-	BYTE bMode; // 0 이면 끔, 1이면 켬
-} TPacketGCPVP;
-
-typedef struct command_use_skill
-{
-	BYTE bHeader;
-	DWORD dwVnum;
-	DWORD dwVID;
-} TPacketCGUseSkill;
-
-typedef struct command_target
-{
-	BYTE header;
-	DWORD dwVID;
-} TPacketCGTarget;
-
-typedef struct packet_target
-{
-	BYTE header;
-	DWORD dwVID;
-	BYTE bHPPercent;
-#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
-	int iMinHP;
-	int iMaxHP;
-	bool bAlliance;
-#endif
-#if defined(__ELEMENT_SYSTEM__)
-	BYTE bElement[MOB_ELEMENT_MAX_NUM];
-#endif
-	packet_target() : dwVID(0), bHPPercent(0)
-	{
-#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
-		iMinHP = 0;
-		iMaxHP = 0;
-		bAlliance = false;
-#endif
-#if defined(__ELEMENT_SYSTEM__)
-		memset(&bElement, 0, sizeof(bElement));
-#endif
-	}
-} TPacketGCTarget;
-
-#if defined(__SEND_TARGET_INFO__)
-typedef struct SPacketGCTargetDropInfo
-{
-	DWORD dwVnum;
-	BYTE bCount;
-} TPacketGCTargetDropInfo;
-
-typedef struct SPacketGCTargetInfo
-{
-	BYTE bHeader;
-	WORD wSize;
-	DWORD dwRaceVnum;
-	DWORD dwVID;
-	bool bDropMetinStone;
-} TPacketGCTargetInfo;
-
-typedef struct SPacketCGTargetInfo
-{
-	BYTE bHeader;
-	DWORD dwVID;
-} TPacketCGTargetInfo;
-#endif
-
-typedef struct packet_warp
-{
-	BYTE bHeader;
-	long lX;
-	long lY;
-	long lAddr;
-	WORD wPort;
-} TPacketGCWarp;
-
-typedef struct command_warp
-{
-	BYTE bHeader;
-} TPacketCGWarp;
-
-struct packet_quest_info
-{
-	BYTE header;
-	WORD size;
-	WORD index;
-#if defined(__QUEST_RENEWAL__)
-	BYTE type;
-	bool is_confirmed;
-#endif
-	BYTE flag;
-};
-
-typedef struct command_safebox_checkout
-{
-	BYTE bHeader;
-	BYTE bSafePos;
-	TItemPos ItemPos;
-} TPacketCGSafeboxCheckout;
-
-typedef struct command_safebox_checkin
-{
-	BYTE bHeader;
-	BYTE bSafePos;
-	TItemPos ItemPos;
-} TPacketCGSafeboxCheckin;
-
-///////////////////////////////////////////////////////////////////////////////////
-// Messenger
-
-enum EMessengerConnectedState
-{
-	MESSENGER_CONNECTED_STATE_OFFLINE,
-	MESSENGER_CONNECTED_STATE_ONLINE
-};
-
-enum EGCMessengerSubHeader
-{
-	MESSENGER_SUBHEADER_GC_LIST,
-	MESSENGER_SUBHEADER_GC_LOGIN,
-	MESSENGER_SUBHEADER_GC_LOGOUT,
-	MESSENGER_SUBHEADER_GC_INVITE,
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	MESSENGER_SUBHEADER_GC_BLOCK_LIST,
-	MESSENGER_SUBHEADER_GC_BLOCK_LOGIN,
-	MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT,
-#endif
-#if defined(__MESSENGER_GM__)
-	MESSENGER_SUBHEADER_GC_GM_LIST,
-	MESSENGER_SUBHEADER_GC_GM_LOGIN,
-	MESSENGER_SUBHEADER_GC_GM_LOGOUT,
-#endif
-};
-
-typedef struct packet_messenger
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMessenger;
-
-typedef struct packet_messenger_list
-{
-	packet_messenger_list() :
-		bConnected(MESSENGER_CONNECTED_STATE_OFFLINE)
-#if defined(__MESSENGER_DETAILS__)
-		, dwLastPlayTime(0)
-#endif
-	{
-	}
-	BYTE bConnected;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(__MESSENGER_DETAILS__)
-	DWORD dwLastPlayTime;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1]{};
-#endif
-#endif
-} TPacketGCMessengerList;
-
-enum ECGMessengerSubHeader
-{
-	MESSENGER_SUBHEADER_CG_ADD_BY_VID,
-	MESSENGER_SUBHEADER_CG_ADD_BY_NAME,
-	MESSENGER_SUBHEADER_CG_REMOVE,
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID,
-	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME,
-	MESSENGER_SUBHEADER_CG_BLOCK_REMOVE,
-#endif
-};
-
-typedef struct command_messenger
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGMessenger;
-
-typedef struct command_messenger_add_by_vid
-{
-	DWORD dwVID;
-} TPacketCGMessengerAddByVID;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-typedef struct command_messenger_add_block_by_vid
-{
-	DWORD dwVID;
-} TPacketCGMessengerAddBlockByVID;
-#endif
-
-///////////////////////////////////////////////////////////////////////////////////
-// Party
-typedef struct command_party_parameter
-{
-	BYTE bHeader;
-	BYTE bDistributeMode;
-} TPacketCGPartyParameter;
-
-typedef struct paryt_parameter
-{
-	BYTE bHeader;
-	BYTE bDistributeMode;
-} TPacketGCPartyParameter;
-
-typedef struct packet_party_add
-{
-	BYTE header;
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	long mapIdx;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	BYTE channel;
-#endif
-} TPacketGCPartyAdd;
-
-typedef struct command_party_invite
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGPartyInvite;
-
-typedef struct packet_party_invite
-{
-	BYTE header;
-	DWORD leader_vid;
-} TPacketGCPartyInvite;
-
-typedef struct command_party_invite_answer
-{
-	BYTE header;
-	DWORD leader_vid;
-	BYTE accept;
-} TPacketCGPartyInviteAnswer;
-
-typedef struct packet_party_update
-{
-	BYTE header;
-	DWORD pid;
-	BYTE role;
-	BYTE percent_hp;
-	short affects[7];
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	long x;
-	long y;
-#endif
-} TPacketGCPartyUpdate;
-
-typedef struct packet_party_remove
-{
-	BYTE header;
-	DWORD pid;
-} TPacketGCPartyRemove;
-
-typedef struct packet_party_link
-{
-	BYTE header;
-	DWORD pid;
-	DWORD vid;
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	long mapIdx;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	BYTE channel;
-#endif
-} TPacketGCPartyLink;
-
-typedef struct command_party_remove
-{
-	BYTE header;
-	DWORD pid;
-} TPacketCGPartyRemove;
-
-typedef struct command_party_set_state
-{
-	BYTE header;
-	DWORD pid;
-	BYTE byRole;
-	BYTE flag;
-} TPacketCGPartySetState;
-
-enum
-{
-	PARTY_SKILL_HEAL = 1,
-	PARTY_SKILL_WARP = 2
-};
-
-typedef struct command_party_use_skill
-{
-	BYTE header;
-	BYTE bySkillIndex;
-	DWORD vid;
-} TPacketCGPartyUseSkill;
-
-typedef struct packet_safebox_size
-{
-	BYTE bHeader;
-	BYTE bSize;
-} TPacketCGSafeboxSize;
-
-typedef struct packet_safebox_wrong_password
-{
-	BYTE bHeader;
-} TPacketCGSafeboxWrongPassword;
-
-typedef struct command_empire
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-} TPacketCGEmpire;
-
-typedef struct packet_empire
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-} TPacketGCEmpire;
-
-enum
-{
-	SAFEBOX_MONEY_STATE_SAVE,
-	SAFEBOX_MONEY_STATE_WITHDRAW,
-};
-
-typedef struct command_safebox_money
-{
-	BYTE bHeader;
-	BYTE bState;
-	long lMoney;
-} TPacketCGSafeboxMoney;
-
-typedef struct packet_safebox_money_change
-{
-	BYTE bHeader;
-	long lMoney;
-} TPacketGCSafeboxMoneyChange;
-
-// Guild
-enum
-{
-	GUILD_SUBHEADER_GC_LOGIN,
-	GUILD_SUBHEADER_GC_LOGOUT,
-	GUILD_SUBHEADER_GC_LIST,
-	GUILD_SUBHEADER_GC_GRADE,
-	GUILD_SUBHEADER_GC_ADD,
-	GUILD_SUBHEADER_GC_REMOVE,
-	GUILD_SUBHEADER_GC_GRADE_NAME,
-	GUILD_SUBHEADER_GC_GRADE_AUTH,
-	GUILD_SUBHEADER_GC_INFO,
-	GUILD_SUBHEADER_GC_COMMENTS,
-	GUILD_SUBHEADER_GC_CHANGE_EXP,
-	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE,
-	GUILD_SUBHEADER_GC_SKILL_INFO,
-	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL,
-	GUILD_SUBHEADER_GC_GUILD_INVITE,
-	GUILD_SUBHEADER_GC_WAR,
-	GUILD_SUBHEADER_GC_GUILD_NAME,
-	GUILD_SUBHEADER_GC_GUILD_WAR_LIST,
-	GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST,
-	GUILD_SUBHEADER_GC_WAR_SCORE,
-	GUILD_SUBHEADER_GC_MONEY_CHANGE,
-};
-
-enum GUILD_SUBHEADER_CG
-{
-	GUILD_SUBHEADER_CG_ADD_MEMBER,
-	GUILD_SUBHEADER_CG_REMOVE_MEMBER,
-	GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME,
-	GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY,
-	GUILD_SUBHEADER_CG_OFFER,
-	GUILD_SUBHEADER_CG_POST_COMMENT,
-	GUILD_SUBHEADER_CG_DELETE_COMMENT,
-	GUILD_SUBHEADER_CG_REFRESH_COMMENT,
-	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE,
-	GUILD_SUBHEADER_CG_USE_SKILL,
-	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL,
-	GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER,
-	GUILD_SUBHEADER_CG_CHARGE_GSP,
-	GUILD_SUBHEADER_CG_DEPOSIT_MONEY,
-	GUILD_SUBHEADER_CG_WITHDRAW_MONEY,
-};
-
-typedef struct packet_guild
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-} TPacketGCGuild;
-
-typedef struct packet_guild_name_t
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-	DWORD guildID;
-	char guildName[GUILD_NAME_MAX_LEN];
-} TPacketGCGuildName;
-
-typedef struct packet_guild_war
-{
-	DWORD dwGuildSelf;
-	DWORD dwGuildOpp;
-	BYTE bType;
-	BYTE bWarState;
-} TPacketGCGuildWar;
-
-typedef struct command_guild
-{
-	BYTE header;
-	BYTE subheader;
-} TPacketCGGuild;
-
-typedef struct command_guild_answer_make_guild
-{
-	BYTE header;
-	char guild_name[GUILD_NAME_MAX_LEN + 1];
-} TPacketCGAnswerMakeGuild;
-
-typedef struct command_guild_use_skill
-{
-	DWORD dwVnum;
-	DWORD dwPID;
-} TPacketCGGuildUseSkill;
-
-// Guild Mark
-typedef struct command_mark_login
-{
-	BYTE header;
-	DWORD handle;
-	DWORD random_key;
-} TPacketCGMarkLogin;
-
-typedef struct command_mark_upload
-{
-	BYTE header;
-	DWORD gid;
-	BYTE image[16 * 12 * 4];
-} TPacketCGMarkUpload;
-
-typedef struct command_mark_idxlist
-{
-	BYTE header;
-} TPacketCGMarkIDXList;
-
-typedef struct command_mark_crclist
-{
-	BYTE header;
-	BYTE imgIdx;
-	DWORD crclist[80];
-} TPacketCGMarkCRCList;
-
-typedef struct packet_mark_idxlist
-{
-	BYTE header;
-	DWORD bufSize;
-	WORD count;
-	// 뒤에 size * (WORD + WORD)만큼 데이터 붙음
-} TPacketGCMarkIDXList;
-
-typedef struct packet_mark_block
-{
-	BYTE header;
-	DWORD bufSize;
-	BYTE imgIdx;
-	DWORD count;
-	// 뒤에 64 x 48 x 픽셀크기(4바이트) = 12288만큼 데이터 붙음
-} TPacketGCMarkBlock;
-
-typedef struct command_symbol_upload
-{
-	BYTE header;
-	WORD size;
-	DWORD guild_id;
-} TPacketCGGuildSymbolUpload;
-
-typedef struct command_symbol_crc
-{
-	BYTE header;
-	DWORD guild_id;
-	DWORD crc;
-	DWORD size;
-} TPacketCGSymbolCRC;
-
-typedef struct packet_symbol_data
-{
-	BYTE header;
-	WORD size;
-	DWORD guild_id;
-} TPacketGCGuildSymbolData;
-
-// Fishing
-typedef struct command_fishing
-{
-	BYTE header;
-	BYTE dir;
-} TPacketCGFishing;
-
-typedef struct packet_fishing
-{
-	BYTE header;
-	BYTE subheader;
-	DWORD info;
-	BYTE dir;
-} TPacketGCFishing;
-
-enum
-{
-	FISHING_SUBHEADER_GC_START,
-	FISHING_SUBHEADER_GC_STOP,
-	FISHING_SUBHEADER_GC_REACT,
-	FISHING_SUBHEADER_GC_SUCCESS,
-	FISHING_SUBHEADER_GC_FAIL,
-	FISHING_SUBHEADER_GC_FISH,
-};
-
-#if defined(__FISHING_GAME__)
-enum EFishingGameSubHeader
-{
-	FISHING_GAME_SUBHEADER_OPEN,
-	FISHING_GAME_SUBHEADER_GOAL,
-	FISHING_GAME_SUBHEADER_QUIT,
-};
-
-enum EFishingGameMisc
-{
-	FISHING_GAME_DURATION = 15,
-};
-
-typedef struct SPacketGCFishingGame
-{
-	SPacketGCFishingGame(const BYTE bSubHeader, const BYTE bLevel = 0) :
-		bHeader(HEADER_GC_FISHING_GAME),
-		bSubHeader(bSubHeader),
-		bLevel(bLevel)
-	{}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bLevel;
-} TPacketGCFishingGame;
-
-typedef struct SPacketCGFishingGame
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bGoals;
-} TPacketCGFishingGame;
-#endif
-
-typedef struct command_give_item
-{
-	BYTE byHeader;
-	DWORD dwTargetVID;
-	TItemPos ItemPos;
-	WORD wItemCount;
-} TPacketCGGiveItem;
-
-typedef struct SPacketCGHack
-{
-	BYTE bHeader;
-	char szBuf[255 + 1];
-} TPacketCGHack;
-
-// SubHeader - Dungeon
-enum
-{
-	DUNGEON_SUBHEADER_GC_TIME_ATTACK_START = 0,
-	DUNGEON_SUBHEADER_GC_DESTINATION_POSITION = 1,
-};
-
-typedef struct packet_dungeon
-{
-	BYTE bHeader;
-	WORD size;
-	BYTE subheader;
-} TPacketGCDungeon;
-
-typedef struct packet_dungeon_dest_position
-{
-	long x;
-	long y;
-} TPacketGCDungeonDestPosition;
-
-typedef struct SPacketGCShopSign
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	char szSign[SHOP_SIGN_MAX_LEN + 1];
-#if defined(__MYSHOP_DECO__)
-	BYTE bType;
-#endif
-} TPacketGCShopSign;
-
-typedef struct SPacketCGMyShop
-{
-	BYTE bHeader;
-	char szSign[SHOP_SIGN_MAX_LEN + 1];
-	BYTE bCount; // Count of TShopItemTable
-} TPacketCGMyShop;
-
-#if defined(__MYSHOP_DECO__)
-typedef struct SPacketGCMyPrivShopOpen
-{
-	BYTE bHeader;
-	bool bCashItem;
-	BYTE bTabCount;
-} TPacketGCMyPrivShopOpen;
-
-typedef struct SPacketCGMyShopDecoState
-{
-	BYTE bHeader;
-	BYTE bState;
-} TPacketCGMyShopDecoState;
-
-typedef struct SPacketCGMyShopDecoAdd
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwPolyVnum;
-} TPacketCGMyShopDecoAdd;
-#endif
-
-typedef struct SPacketGCTime
-{
-	BYTE bHeader;
-	time_t time;
-} TPacketGCTime;
-
-enum
-{
-	WALKMODE_RUN,
-	WALKMODE_WALK,
-};
-
-typedef struct SPacketGCWalkMode
-{
-	BYTE header;
-	DWORD vid;
-	BYTE mode;
-} TPacketGCWalkMode;
-
-typedef struct SPacketGCChangeSkillGroup
-{
-	BYTE header;
-	BYTE skill_group;
-} TPacketGCChangeSkillGroup;
-
-typedef struct SPacketCGRefine
-{
-	BYTE header;
-	BYTE pos;
-	BYTE type;
-} TPacketCGRefine;
-
-typedef struct SPacketCGRequestRefineInfo
-{
-	BYTE header;
-	BYTE pos;
-} TPacketCGRequestRefineInfo;
-
-typedef struct SPacketGCRefineInformaion
-{
-	BYTE header;
-	BYTE type;
-	BYTE pos;
-	DWORD src_vnum;
-	DWORD result_vnum;
-	WORD material_count;
-	int cost; // 소요 비용
-	int prob; // 확률
-	TRefineMaterial materials[REFINE_MATERIAL_MAX_NUM];
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-} TPacketGCRefineInformation;
-
-struct TNPCPosition
-{
-	BYTE bType;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	long x;
-	long y;
-};
-
-typedef struct SPacketGCNPCPosition
-{
-	BYTE header;
-	WORD size;
-	WORD count;
-	// array of TNPCPosition
-} TPacketGCNPCPosition;
-
-enum ESpecialEffectType
-{
-	SE_TYPE_NORMAL,
-	SE_TYPE_POSITION,
-};
-
-typedef struct SPacketGCSpecialEffect
-{
-	BYTE bHeader;
-	BYTE bEffectNum;
-	DWORD dwVID;
-	BYTE bEffectType;
-	long xEffectPos, yEffectPos;
-	SPacketGCSpecialEffect()
-		: bEffectType(SE_TYPE_NORMAL)
-		, xEffectPos(0)
-		, yEffectPos(0)
-	{}
-} TPacketGCSpecialEffect;
-
-typedef struct SPacketCGChangeName
-{
-	BYTE header;
-	BYTE index;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGChangeName;
-
-typedef struct SPacketGCChangeName
-{
-	BYTE header;
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCChangeName;
-
-typedef struct command_client_version
-{
-	BYTE header;
-	char filename[32 + 1];
-	char timestamp[32 + 1];
-} TPacketCGClientVersion;
-
-typedef struct command_client_version2
-{
-	BYTE header;
-	char filename[32 + 1];
-	char timestamp[32 + 1];
-} TPacketCGClientVersion2;
-
-typedef struct packet_channel
-{
-	BYTE header;
-	BYTE channel;
-} TPacketGCChannel;
-
-typedef struct SEquipmentItemSet
-{
-	DWORD dwVnum;
-	BYTE bCount;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TEquipmentItemSet;
-
-typedef struct pakcet_view_equip
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	TEquipmentItemSet Equips[WEAR_MAX_NUM];
-} TPacketGCViewEquip;
-
-typedef struct
-{
-	DWORD dwID;
-	long x, y;
-	long width, height;
-	DWORD dwGuildID;
-} TLandPacketElement;
-
-typedef struct packet_land_list
-{
-	BYTE header;
-	WORD size;
-} TPacketGCLandList;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-	char szName[32 + 1];
-	DWORD dwVID;
-	BYTE bType;
-} TPacketGCTargetCreate;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-	long lX, lY;
-} TPacketGCTargetUpdate;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-} TPacketGCTargetDelete;
-
-typedef struct
-{
-	BYTE bHeader;
-	TPacketAffectElement elem;
-} TPacketGCAffectAdd;
-
-typedef struct
-{
-	BYTE bHeader;
-	DWORD dwType;
-	POINT_TYPE wApplyOn;
-} TPacketGCAffectRemove;
-
-typedef struct packet_lover_info
-{
-	BYTE header;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE love_point;
-} TPacketGCLoverInfo;
-
-typedef struct packet_love_point_update
-{
-	BYTE header;
-	BYTE love_point;
-} TPacketGCLovePointUpdate;
-
-// MINING
-typedef struct packet_dig_motion
-{
-	BYTE header;
-	DWORD vid;
-	DWORD target_vid;
-	BYTE count;
-} TPacketGCDigMotion;
-// END_OF_MINING
-
-// SCRIPT_SELECT_ITEM
-typedef struct command_script_select_item
-{
-	BYTE header;
-	DWORD selection;
-} TPacketCGScriptSelectItem;
-// END_OF_SCRIPT_SELECT_ITEM
-
-#if defined(__GEM_SHOP__)
-typedef struct command_select_item_ex
-{
-	BYTE bHeader;
-	DWORD dwItemPos;
-	BYTE bType;
-} TPacketCGSelectItemEx;
-#endif
-
-typedef struct packet_damage_info
-{
-	BYTE header;
-	DWORD dwVID;
-	BYTE flag;
-	int damage;
-} TPacketGCDamageInfo;
-
-typedef struct tag_GGSiege
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-	BYTE bTowerCount;
-} TPacketGGSiege;
-
-typedef struct SPacketGGMonarchTransfer
-{
-	BYTE bHeader;
-	DWORD dwTargetPID;
-	long x;
-	long y;
-} TPacketMonarchGGTransfer;
-
-typedef struct SPacketGGPCBangUpdate
-{
-	BYTE bHeader;
-	unsigned long ulPCBangID;
-} TPacketPCBangUpdate;
-
-typedef struct SPacketGGCheckAwakeness
-{
-	BYTE bHeader;
-} TPacketGGCheckAwakeness;
-
-typedef struct SPacketGCPanamaPack
-{
-	BYTE bHeader;
-	char szPackName[256];
-	BYTE abIV[32];
-} TPacketGCPanamaPack;
-
-// TODO : 아우 짱나..가변패킷 사이즈 받아들일수 있게 패킷 핸들러 Refactoring 하자. 
-typedef struct SPacketGCHybridCryptKeys
-{
-	SPacketGCHybridCryptKeys() : m_pStream(NULL) {}
-	~SPacketGCHybridCryptKeys()
-	{
-		// GCC 에선 NULL delete 해도 괜찮나? 일단 안전하게 NULL 체크 하자. ( 근데 이거 C++ 표준아니었나 --a )
-		if (m_pStream)
-		{
-			delete[] m_pStream;
-			m_pStream = NULL;
-		}
-	}
-
-	DWORD GetStreamSize()
-	{
-		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + KeyStreamLen;
-	}
-
-	BYTE* GetStreamData()
-	{
-		if (m_pStream)
-			delete[] m_pStream;
-
-		uDynamicPacketSize = (WORD)GetStreamSize();
-
-		m_pStream = new BYTE[uDynamicPacketSize];
-
-		memcpy(m_pStream, &bHeader, 1);
-		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
-		memcpy(m_pStream + 3, &KeyStreamLen, 4);
-
-		if (KeyStreamLen > 0)
-			memcpy(m_pStream + 7, pDataKeyStream, KeyStreamLen);
-
-		return m_pStream;
-	}
-
-	BYTE bHeader;
-	WORD uDynamicPacketSize; // 빌어먹을 클라 DynamicPacketHeader 구조때문에 맞춰줘야한다 -_-;
-	int KeyStreamLen;
-	BYTE* pDataKeyStream;
-
-private:
-	BYTE* m_pStream;
-
-} TPacketGCHybridCryptKeys;
-
-typedef struct SPacketGCPackageSDB
-{
-	SPacketGCPackageSDB() : m_pDataSDBStream(NULL), m_pStream(NULL) {}
-	~SPacketGCPackageSDB()
-	{
-		if (m_pStream)
-		{
-			delete[] m_pStream;
-			m_pStream = NULL;
-		}
-	}
-
-	DWORD GetStreamSize()
-	{
-		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + iStreamLen;
-	}
-
-	BYTE* GetStreamData()
-	{
-		if (m_pStream)
-			delete[] m_pStream;
-
-		uDynamicPacketSize = static_cast<WORD>(GetStreamSize());
-
-		m_pStream = new BYTE[uDynamicPacketSize];
-
-		memcpy(m_pStream, &bHeader, 1);
-		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
-		memcpy(m_pStream + 3, &iStreamLen, 4);
-
-		if (iStreamLen > 0)
-			memcpy(m_pStream + 7, m_pDataSDBStream, iStreamLen);
-
-		return m_pStream;
-	}
-
-	BYTE bHeader;
-	WORD uDynamicPacketSize; // 빌어먹을 클라 DynamicPacketHeader 구조때문에 맞춰줘야한다 -_-;
-	int iStreamLen;
-	BYTE* m_pDataSDBStream;
-
-private:
-	BYTE* m_pStream;
-
-} TPacketGCPackageSDB;
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-struct TPacketKeyAgreement
-{
-	static const int MAX_DATA_LEN = 256;
-	BYTE bHeader;
-	WORD wAgreedLength;
-	WORD wDataLength;
-	BYTE data[MAX_DATA_LEN];
-};
-
-struct TPacketKeyAgreementCompleted
-{
-	BYTE bHeader;
-	BYTE data[3]; // dummy (not used)
-};
-#endif
-
-#define MAX_EFFECT_FILE_NAME 128
-typedef struct SPacketGCSpecificEffect
-{
-	BYTE header;
-	DWORD vid;
-	char effect_file[MAX_EFFECT_FILE_NAME];
-} TPacketGCSpecificEffect;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-// 용혼석
-enum EDragonSoulRefineWindowRefineType
-{
-	DragonSoulRefineWindow_UPGRADE,
-	DragonSoulRefineWindow_IMPROVEMENT,
-	DragonSoulRefineWindow_REFINE,
-};
-
-enum EPacketCGDragonSoulSubHeaderType
-{
-	DS_SUB_HEADER_OPEN,
-	DS_SUB_HEADER_CLOSE,
-	DS_SUB_HEADER_DO_REFINE_GRADE,
-	DS_SUB_HEADER_DO_REFINE_STEP,
-	DS_SUB_HEADER_DO_REFINE_STRENGTH,
-	DS_SUB_HEADER_REFINE_FAIL,
-	DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE,
-	DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL,
-	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY,
-	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL,
-	DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL,
-	DS_SUB_HEADER_REFINE_SUCCEED,
-#if defined(__DS_CHANGE_ATTR__)
-	DS_SUB_HEADER_OPEN_CHANGE_ATTR,
-	DS_SUB_HEADER_DO_CHANGE_ATTR,
-#endif
-};
-
-typedef struct SPacketCGDragonSoulRefine
-{
-	SPacketCGDragonSoulRefine() : header(HEADER_CG_DRAGON_SOUL_REFINE)
-	{}
-	BYTE header;
-	BYTE bSubType;
-	TItemPos ItemGrid[DRAGON_SOUL_REFINE_GRID_SIZE];
-} TPacketCGDragonSoulRefine;
-
-typedef struct SPacketGCDragonSoulRefine
-{
-	SPacketGCDragonSoulRefine() : header(HEADER_GC_DRAGON_SOUL_REFINE)
-	{}
-	BYTE header;
-	BYTE bSubType;
-	TItemPos Pos;
-} TPacketGCDragonSoulRefine;
-#endif
-
-typedef struct SPacketCGStateCheck
-{
-	BYTE header;
-	unsigned long key;
-	unsigned long index;
-} TPacketCGStateCheck;
-
-typedef struct SPacketGCStateCheck
-{
-	BYTE header;
-	unsigned long key;
-	unsigned long index;
-	unsigned char state;
-} TPacketGCStateCheck;
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-enum ESubHeaderGCAcceRefine
-{
-	ACCE_REFINE_SUBHEADER_GC_CLOSE,
-	ACCE_REFINE_SUBHEADER_GC_OPEN,
-	ACCE_REFINE_SUBHEADER_GC_SET_ITEM,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_RIGHT
-};
-
-typedef struct SSubPacketGCAcceRefineOpenClose
-{
-	BYTE bType;
-	bool bServerClose;
-} TSubPacketGCAcceRefineOpenClose;
-
-typedef struct SSubPacketGCAcceRefineSetItem
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	TItemData Item;
-} TSubPacketGCAcceRefineSetItem;
-
-typedef struct SSubPacketGCAcceRefineClearSlot
-{
-	BYTE bSlotIndex;
-} TSubPacketGCAcceRefineClearSlot;
-
-enum ESubHeaderCGAcceRefine
-{
-	ACCE_REFINE_SUBHEADER_CG_CHECKIN,
-	ACCE_REFINE_SUBHEADER_CG_CHECKOUT,
-	ACCE_REFINE_SUBHEADER_CG_ACCEPT,
-	ACCE_REFINE_SUBHEADER_CG_CANCEL
-};
-
-typedef struct SSubPacketCGAcceRefineCheckIn
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAcceRefineCheckIn;
-
-typedef struct SSubPacketCGAcceRefineCheckOut
-{
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAcceRefineCheckOut;
-
-typedef struct SSubPacketCGAcceRefineAccept
-{
-	BYTE bType;
-} TSubPacketCGAcceRefineAccept;
-
-typedef struct SPacketGCAcceRefine
-{
-	SPacketGCAcceRefine() : bHeader(HEADER_GC_ACCE_REFINE) {}
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCAcceRefine;
-
-typedef struct SPacketCGAcceRefine
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketCGAcceRefine;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-enum ESubHeaderGCAuraRefine
-{
-	AURA_REFINE_SUBHEADER_GC_CLOSE,
-	AURA_REFINE_SUBHEADER_GC_OPEN,
-	AURA_REFINE_SUBHEADER_GC_SET_ITEM,
-	AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT,
-	AURA_REFINE_SUBHEADER_GC_CLEAR_ALL,
-	AURA_REFINE_SUBHEADER_GC_INFO
-};
-
-typedef struct SSubPacketGCAuraRefineOpenClose
-{
-	BYTE bType;
-	bool bServerClose;
-} TSubPacketGCAuraRefineOpenClose;
-
-typedef struct SSubPacketGCAuraRefineSetItem
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	TItemData Item;
-} TSubPacketGCAuraRefineSetItem;
-
-typedef struct SSubPacketGCAuraRefineClearSlot
-{
-	BYTE bSlotIndex;
-} TSubPacketGCAuraRefineClearSlot;
-
-typedef struct SSubPacketGCAuraRefineInfo
-{
-	BYTE bInfoType;
-	BYTE bInfoLevel;
-	BYTE bInfoExpPercent;
-} TSubPacketGCAuraRefineInfo;
-
-enum ESubHeaderCGAuraRefine
-{
-	AURA_REFINE_SUBHEADER_CG_CHECKIN,
-	AURA_REFINE_SUBHEADER_CG_CHECKOUT,
-	AURA_REFINE_SUBHEADER_CG_ACCEPT,
-	AURA_REFINE_SUBHEADER_CG_CANCEL
-};
-
-typedef struct SSubPacketCGAuraRefineCheckIn
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAuraRefineCheckIn;
-
-typedef struct SSubPacketCGAuraRefineCheckOut
-{
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAuraRefineCheckOut;
-
-typedef struct SSubPacketCGAuraRefineAccept
-{
-	BYTE bType;
-} TSubPacketCGAuraRefineAccept;
-
-typedef struct SPacketGCAuraRefine
-{
-	SPacketGCAuraRefine() : bHeader(HEADER_GC_AURA_REFINE) {}
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCAuraRefine;
-
-typedef struct SPacketCGAuraRefine
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketCGAuraRefine;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-enum EMiniGameCatchKingCGSubHeader
-{
-	CATCHKING_CG_START,
-	CATCHKING_CG_CLICK_HAND,
-	CATCHKING_CG_CLICK_CARD,
-	CATCHKING_CG_REWARD,
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-	CATCHKING_CG_REQUEST_QUEST_FLAG,
-#endif
-};
-
-enum EMiniGameCatchKingGCSubHeader
-{
-	CATCHKING_GC_START,
-	CATCHKING_GC_SET_CARD,
-	CATCHKING_GC_RESULT_FIELD,
-	CATCHKING_GC_SET_END_CARD,
-	CATCHKING_GC_REWARD,
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-	CATCHKING_GC_SET_CARD_PIECE_FLAG,
-	CATCHKING_GC_SET_CARD_FLAG,
-	CATCHKING_GC_SET_QUEST_FLAG,
-	CATCHKING_GC_NO_MORE_GAIN,
-#endif
-};
-
-typedef struct SCatchKingCard
-{
-	SCatchKingCard() { bIndex = 0; bIsExposed = false; }
-	SCatchKingCard(BYTE index, bool isExposed)
-	{
-		bIndex = index;
-		bIsExposed = isExposed;
-	}
-
-	BYTE bIndex;
-	bool bIsExposed;
-} TCatchKingCard;
-
-typedef struct SPacketCGMiniGameCatchKing
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSubArgument;
-} TPacketCGMiniGameCatchKing;
-
-typedef struct SPacketGCMiniGameCatchKing
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameCatchKing;
-
-typedef struct SPacketGCMiniGameCatchKingResult
-{
-	DWORD dwPoints;
-	BYTE bRowType;
-	BYTE bCardPos;
-	BYTE bCardValue;
-	bool bKeepFieldCard;
-	bool bDestroyHandCard;
-	bool bGetReward;
-	bool bIsFiveNearBy;
-} TPacketGCMiniGameCatchKingResult;
-
-typedef struct SPacketGCMiniGameCatchKingSetEndCard
-{
-	BYTE bCardPos;
-	BYTE bCardValue;
-} TPacketGCMiniGameCatchKingSetEndCard;
-
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-typedef struct SPacketGCMiniGameCatchKingQuestFlag
-{
-	WORD wPieceCount, wPackCount;
-	SPacketGCMiniGameCatchKingQuestFlag(WORD wPieceCount, WORD wPackCount) :
-		wPieceCount(wPieceCount), wPackCount(wPackCount) {}
-} TPacketGCMiniGameCatchKingQuestFlag;
-#endif
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-typedef struct SPacketCGSkillBookCombination
-{
-	BYTE bHeader;
-	BYTE bAction;
-	TItemPos CombItemGrid[SKILLBOOK_COMB_SLOT_MAX];
-} TPacketCGSkillBookCombination;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-enum class EPacketCGChangeLookSubHeader : BYTE
-{
-	ITEM_CHECK_IN,
-	ITEM_CHECK_OUT,
-	FREE_ITEM_CHECK_IN,
-	FREE_ITEM_CHECK_OUT,
-	ACCEPT,
-	CANCEL
-};
-
-typedef struct packet_set_changelook
-{
-	BYTE bHeader;
-	WORD wCell;
-	BYTE bSlotIndex;
-} TPacketGCChangeLookSet;
-
-typedef struct packet_changelook_del
-{
-	BYTE bHeader;
-	WORD wCell;
-	BYTE bSlotIndex;
-} TPacketGCChangeLookDel;
-
-typedef struct command_changelook
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-	TItemPos ItemPos;
-} TPacketCGChangeLook;
-#endif
-
-#if defined(__MAILBOX__)
-typedef struct packet_mailbox_process
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bArg1;
-	BYTE bArg2;
-} TPacketMailboxProcess;
-
-typedef struct packet_mailbox_process_all
-{
-	BYTE Index;
-} TPacketGCMailboxProcessAll;
-
-typedef struct packet_mailbox
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketGCMailBox;
-
-typedef struct packet_mailbox_write
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	char szTitle[25 + 1];
-	char szMessage[100 + 1];
-	TItemPos pos;
-	int iYang;
-	int iWon;
-} TPacketCGMailboxWrite;
-
-typedef struct packet_mailbox_write_confirm
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGMailboxWriteConfirm;
-#endif
-
-#if defined(__RANKING_SYSTEM__)
-typedef struct SPacketGCRanking
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bType;
-	BYTE bCategory;
-} TPacketGCRanking;
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-typedef struct packet_cg_item_combination
-{
-	BYTE Header;
-	short MediumIndex;
-	short BaseIndex;
-	short MaterialIndex;
-} TPacketCGItemCombination;
-
-typedef struct packet_cg_item_combination_cancel
-{
-	BYTE Header;
-} TPacketCGItemCombinationCancel;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-typedef struct packet_gc_item_select_attr
-{
-	BYTE bHeader;
-	TItemPos pItemPos;
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-} TPacketGCItemSelectAttr;
-
-typedef struct packet_cg_item_select_attr
-{
-	BYTE bHeader;
-	bool bNew;
-	TItemPos pItemPos;
-} TPacketCGItemSelectAttr;
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-typedef struct SPacketCGLootFilter
-{
-	BYTE header;
-	BYTE settings[ELootFilter::LOOT_FILTER_SETTINGS_MAX];
-} TPacketCGLootFilter;
-
-typedef struct SPacketGCLootFilter
-{
-	BYTE header;
-	bool enable;
-	DWORD vid;
-} TPacketGCLootFilter;
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-enum EMiniGameRumiCGSubHeader
-{
-	RUMI_CG_SUBHEADER_END,
-	RUMI_CG_SUBHEADER_START,
-	RUMI_CG_SUBHEADER_DECK_CARD_CLICK,
-	RUMI_CG_SUBHEADER_HAND_CARD_CLICK,
-	RUMI_CG_SUBHEADER_FIELD_CARD_CLICK,
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-	RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
-#endif
-};
-
-enum EMiniGameRumiGCSubHeader
-{
-	RUMI_GC_SUBHEADER_END,
-	RUMI_GC_SUBHEADER_START,
-	RUMI_GC_SUBHEADER_SET_DECK,
-	RUMI_GC_SUBHEADER_SET_SCORE,
-	RUMI_GC_SUBHEADER_MOVE_CARD,
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-	RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG,
-	RUMI_GC_SUBHEADER_SET_CARD_FLAG,
-	RUMI_GC_SUBHEADER_SET_QUEST_FLAG,
-	RUMI_GC_SUBHEADER_NO_MORE_GAIN,
-#endif
-};
-
-typedef struct SPacketCGMiniGameRumi
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BOOL bUseCard;
-	BYTE bIndex;
-} TPacketCGMiniGameRumi;
-
-typedef struct SPacketGCMiniGameRumiSetDeck
-{
-	BYTE bDeckCount;
-	SPacketGCMiniGameRumiSetDeck(BYTE bDeckCount) : bDeckCount(bDeckCount) {}
-} TPacketGCMiniGameRumiSetDeck;
-
-typedef struct SPacketGCMiniGameRumiMoveCard
-{
-	BYTE bSrcPos, bSrcIndex, bSrcColor, bSrcNumber;
-	BYTE bDstPos, bDstIndex, bDstColor, bDstNumber;
-	SPacketGCMiniGameRumiMoveCard() :
-		bSrcPos(0), bSrcIndex(0), bSrcColor(0), bSrcNumber(0),
-		bDstPos(0), bDstIndex(0), bDstColor(0), bDstNumber(0) {}
-} TPacketGCMiniGameRumiMoveCard;
-
-typedef struct SPacketGCMiniGameRumiSetScore
-{
-	WORD wScore, wTotalScore;
-	SPacketGCMiniGameRumiSetScore(WORD wScore, WORD wTotalScore) :
-		wScore(wScore), wTotalScore(wTotalScore) {}
-} TPacketGCMiniGameRumiSetScore;
-
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-typedef struct SPacketGCMiniGameRumiQuestFlag
-{
-	WORD wCardPieceCount, wCardCount;
-	SPacketGCMiniGameRumiQuestFlag(WORD wCardPieceCount, WORD wCardCount) :
-		wCardPieceCount(wCardPieceCount), wCardCount(wCardCount) {}
-} TPacketGCMiniGameRumiQuestFlag;
-#endif
-
-typedef struct SPacketGCMiniGameRumi
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameRumi;
-#endif
-
-#if defined(__LUCKY_BOX__)
-enum ELUCKY_BOX_ACTION
-{
-	LUCKY_BOX_ACTION_RETRY,
-	LUCKY_BOX_ACTION_RECEIVE,
-};
-
-typedef struct SPacketCGLuckyBox
-{
-	BYTE bHeader;
-	BYTE bAction;
-} TPacketCGLuckyBox;
-
-typedef struct SPacketGCLuckyBox
-{
-	BYTE bHeader;
-	DWORD dwVNum;
-	BYTE bCount;
-	int iNeedMoney;
-	WORD wSlotIndex;
-} TPacketGCLuckyBox;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-enum EAttr67AddSubHeader
-{
-	SUBHEADER_CG_ATTR67_ADD_CLOSE,
-	SUBHEADER_CG_ATTR67_ADD_OPEN,
-	SUBHEADER_CG_ATTR67_ADD_REGIST,
-};
-
-typedef struct SPacketCGAttr67Add
-{
-	BYTE byHeader;
-	BYTE bySubHeader;
-	TAttr67AddData Attr67AddData;
-} TPacketCGAttr67Add;
-#endif
-
-#if defined(__GEM_SHOP__)
-enum EGemShopSubHeader : BYTE
-{
-	SUBHEADER_GEM_SHOP_CLOSE,
-	SUBHEADER_GEM_SHOP_OPEN,
-	SUBHEADER_GEM_SHOP_BUY,
-	SUBHEADER_GEM_SHOP_SLOT_ADD,
-	SUBHEADER_GEM_SHOP_REFRESH,
-	SUBHEADER_GEM_SHOP_MAX,
-};
-
-typedef struct SPacketGCGemShop
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketGCGemShop;
-
-typedef struct SPacketGCGemShopProcess
-{
-	SPacketGCGemShopProcess(const BYTE c_bSubHeader) :
-		bHeader(HEADER_GC_GEM_SHOP_PROCESS),
-		bSubHeader(c_bSubHeader),
-		bSlotIndex(GEM_SHOP_SLOT_COUNT),
-		bEnable(false)
-	{}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-	bool bEnable;
-} TPacketGCGemShopProcess;
-
-typedef struct command_gem_shop
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-} TPacketCGGemShop;
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-typedef struct SPacketCGExtendInven
-{
-	BYTE bHeader;
-	bool bUpgrade;
-	BYTE bIndex;
-} TPacketCGExtendInven;
-
-typedef struct SPacketGCExtendInven
-{
-	BYTE bHeader;
-	BYTE bStage;
-	WORD wMaxNum;
-} TPacketGCExtendInven;
-
-typedef struct SPacketGCExtendInvenItemUse
-{
-	BYTE bHeader;
-	BYTE bMsgResult;
-	BYTE bEnoughCount;
-} TPacketGCExtendInvenItemUse;
-#endif
-
-#if defined(__CLIENT_TIMER__)
-enum EClientTimerSubHeader
-{
-	CLIENT_TIMER_SUBHEADER_GC_SET,
-	CLIENT_TIMER_SUBHEADER_GC_DELETE
-};
-
-enum EClientTimer
-{
-	ECLIENT_TIMER_END_TIME,
-	ECLIENT_TIMER_ALARM_SECOND,
-	ECLIENT_TIMER_MAX
-};
-
-typedef struct SPacketGCClientTimer
-{
-	SPacketGCClientTimer(const BYTE _bSubHeader)
-		: bHeader(HEADER_GC_CLIENT_TIMER), bSubHeader(_bSubHeader)
-	{
-		memset(&dwData, 0, sizeof(dwData));
-	};
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwData[ECLIENT_TIMER_MAX];
-} TPacketGCClientTimer;
-#endif
-
-enum EEmoteSubHeader
-{
-	SUBHEADER_EMOTE_ADD,
-	SUBHEADER_EMOTE_CLEAR,
-	SUBHEADER_EMOTE_MOTION,
-	SUBHEADER_EMOTE_ICON,
-};
-
-typedef struct SPacketGCEmote
-{
-	SPacketGCEmote() : bHeader(HEADER_GC_EMOTE) {}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwEmoteVnum;
-	DWORD dwDuration;
-	DWORD dwMainVID, dwTargetVID;
-} TPacketGCEmote;
-
-#if defined(__CUBE_RENEWAL__)
-enum ECubeSubHeader
-{
-	SUBHEADER_GC_CUBE_OPEN = 0,
-	SUBHEADER_GC_CUBE_CLOSE,
-	SUBHEADER_GC_CUBE_RESULT,
-
-	SUBHEADER_CG_CUBE_CLOSE = 0,
-	SUBHEADER_CG_CUBE_MAKE,
-};
-
-typedef struct SPacketGCCube
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwNPCVnum;
-	BOOL bSuccess;
-	DWORD dwFileCrc;
-} TPacketGCCube;
-
-typedef struct SPacketCGCube
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	UINT iCubeIndex;
-	UINT iQuantity;
-	INT iImproveItemPos;
-	DWORD dwFileCrc;
-} TPacketCGCube;
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-enum ESubPacketGCSnowflakeStickEvent
-{
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_SNOW_BALL,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_TREE_BRANCH,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_SNOW_BALL_MAX,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_TREE_BRANCH_MAX,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_STICK_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_PET_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_MOUNT_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_RANK_BUFF,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_SNOWFLAKE_BUFF,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE,
-};
-
-enum ESnowflakeStickEventQuestFlagType
-{
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_USE_STICK_COOLDOWN,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM,
-};
-
-typedef struct SPacketGCSnowflakeStickEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM];
-	SPacketGCSnowflakeStickEvent(const BYTE c_bSubHeader)
-		: bHeader(HEADER_GC_SNOWFLAKE_STICK_EVENT), bSubHeader(c_bSubHeader)
-	{;
-		memset(&dwValue, 0, sizeof(dwValue));
-	}
-} TPacketGCSnowflakeStickEvent;
-
-enum ESubPacketCGSnowflakeStickEvent
-{
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT
-};
-
-typedef struct SPacketCGSnowflakeStickEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGSnowflakeStickEvent;
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-enum EPacketGCRefineElement
-{
-	REFINE_ELEMENT_GC_OPEN,
-	REFINE_ELEMENT_GC_RESULT
-};
-
-enum EPacketCGRefineElement
-{
-	REFINE_ELEMENT_CG_CLOSE,
-	REFINE_ELEMENT_CG_REFINE,
-};
-
-typedef struct SPacketGCRefineElement
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bRefineType;
-	BYTE bResult;
-	TItemPos SrcPos;
-	TItemPos DestPos;
-} TPacketGCRefineElement;
-
-typedef struct SPacketCGRefineElement
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	WORD wChangeElement;
-} TPacketCGRefineElement;
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-enum EMiniGameYutnoriGCSubHeader
-{
-	YUTNORI_GC_SUBHEADER_START,
-	YUTNORI_GC_SUBHEADER_STOP,
-	YUTNORI_GC_SUBHEADER_SET_PROB,
-	YUTNORI_GC_SUBHEADER_THROW,
-	YUTNORI_GC_SUBHEADER_MOVE,
-	YUTNORI_GC_SUBHEADER_AVAILABLE_AREA,
-	YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT,
-	YUTNORI_GC_SUBHEADER_SET_SCORE,
-	YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT,
-	YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN,
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-	YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG,
-	YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG,
-	YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG,
-	YUTNORI_GC_SUBHEADER_NO_MORE_GAIN,
-#endif
-};
-
-enum EMiniGameYutnoriCGSubHeader
-{
-	YUTNORI_CG_SUBHEADER_START,
-	YUTNORI_CG_SUBHEADER_GIVEUP,
-	YUTNORI_CG_SUBHEADER_SET_PROB,
-	YUTNORI_CG_SUBHEADER_CLICK_CHAR,
-	YUTNORI_CG_SUBHEADER_THROW,
-	YUTNORI_CG_SUBHEADER_MOVE,
-	YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION,
-	YUTNORI_CG_SUBHEADER_REWARD,
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-	YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
-#endif
-};
-
-typedef struct SPacketCGMiniGameYutnori
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bArgument;
-} TPacketCGMiniGameYutnori;
-
-typedef struct SPacketGCMiniGameYutnori
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameYutnori;
-
-typedef struct SPacketGCMiniGameYutnoriSetProb
-{
-	BYTE bProbIndex;
-	SPacketGCMiniGameYutnoriSetProb(BYTE bProbIndex)
-		: bProbIndex(bProbIndex) {}
-} TPacketGCMiniGameYutnoriSetProb;
-
-typedef struct SPacketGCMiniGameYutnoriThrow
-{
-	bool bPC;
-	BYTE bYut;
-	SPacketGCMiniGameYutnoriThrow(bool bPC, BYTE bYut)
-		: bPC(bPC), bYut(bYut) {}
-} TPacketGCMiniGameYutnoriThrow;
-
-typedef struct SPacketGCMiniGameYutnoriMove
-{
-	bool bPC;
-	BYTE bUnitIndex;
-	bool bIsCatch;
-	BYTE bStartIndex;
-	BYTE bDestIndex;
-	SPacketGCMiniGameYutnoriMove(bool bPC, BYTE bUnitIndex, bool bIsCatch, BYTE bStartIndex, BYTE bDestIndex)
-		: bPC(bPC), bUnitIndex(bUnitIndex), bIsCatch(bIsCatch), bStartIndex(bStartIndex), bDestIndex(bDestIndex) {}
-} TPacketGCMiniGameYutnoriMove;
-
-typedef struct SPacketGCMiniGameYutnoriAvailableArea
-{
-	BYTE bPlayerIndex;
-	BYTE bAvailableIndex;
-	SPacketGCMiniGameYutnoriAvailableArea(BYTE bPlayerIndex, BYTE bAvailableIndex)
-		: bPlayerIndex(bPlayerIndex), bAvailableIndex(bAvailableIndex) {}
-} TPacketGCMiniGameYutnoriAvailableArea;
-
-typedef struct SPacketGCMiniGameYutnoriPushCatchYut
-{
-	bool bPC;
-	BYTE bUnitIndex;
-	SPacketGCMiniGameYutnoriPushCatchYut(bool bPC, BYTE bUnitIndex)
-		: bPC(bPC), bUnitIndex(bUnitIndex) {}
-} TPacketGCMiniGameYutnoriPushCatchYut;
-
-typedef struct SPacketGCMiniGameYutnoriSetScore
-{
-	WORD wScore;
-	SPacketGCMiniGameYutnoriSetScore(WORD wScore)
-		: wScore(wScore) {}
-} TPacketGCMiniGameYutnoriSetScore;
-
-typedef struct SPacketGCMiniGameYutnoriSetRemainCount
-{
-	BYTE bRemainCount;
-	SPacketGCMiniGameYutnoriSetRemainCount(BYTE bRemainCount)
-		: bRemainCount(bRemainCount) {}
-} TPacketGCMiniGameYutnoriSetRemainCount;
-
-typedef struct SPacketGCMiniGameYutnoriPushNextTurn
-{
-	bool bPC;
-	BYTE bState;
-	SPacketGCMiniGameYutnoriPushNextTurn(bool bPC, BYTE bState)
-		: bPC(bPC), bState(bState) {}
-} TPacketGCMiniGameYutnoriPushNextTurn;
-
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-typedef struct SPacketGCMiniGameYutnoriQuestFlag
-{
-	WORD wYutPieceCount;
-	WORD wYutBoardCount;
-	SPacketGCMiniGameYutnoriQuestFlag(WORD wYutPieceCount, WORD wYutBoardCount)
-		: wYutPieceCount(wYutPieceCount), wYutBoardCount(wYutBoardCount) {}
-} TPacketGCMiniGameYutnoriQuestFlag;
-#endif
-#endif
-
-#if defined(__QUEST_REQUEST_EVENT__)
-typedef struct SPacketCGRequestEventQuest
-{
-	BYTE bHeader;
-	char szEventQuest[64 + 1];
-} TPacketCGRequestEventQuest;
-#endif
-
-#if defined(__LEFT_SEAT__)
-enum ELeftSeatCGSubHeader
-{
-	LEFT_SEAT_SET_WAIT_TIME_INDEX,
-	LEFT_SEAT_SET_LOGOUT_TIME_INDEX,
-	LEFT_SEAT_DISABLE_LOGOUT_STATE,
-};
-
-typedef struct SPacketCGLeftSeat
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bIndex;
-} TPacketCGLeftSeat;
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-enum EGuildDragonLairType
-{
-	GUILD_DRAGONLAIR_TYPE_RED,
-	GUILD_DRAGONLAIR_TYPE_BLUE,
-	GUILD_DRAGONLAIR_TYPE_GREEN,
-	GUILD_DRAGONLAIR_TYPE_MAX_NUM
-};
-
-enum EGuildDragonLairSubHeader
-{
-	GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING,
-#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
-	GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT,
-	GUILD_DRAGONLAIR_GC_SUBHEADER_START,
-	GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS,
-#endif
-};
-
-typedef struct SPacketGCGuildDragonLair
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-	BYTE bType;
-#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
-	DWORD dwFirstRankingTime;
-#endif
-} TPacketGCGuildDragonLair;
-
-typedef struct SPacketGCGuildDragonLairRanking
-{
-	BYTE bType;
-	DWORD dwGuildID;
-	char szGuildName[GUILD_NAME_MAX_LEN + 1];
-	BYTE bMemberCount;
-	DWORD dwTime;
-} TPacketGCGuildDragonLairRanking;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-enum EPacketGCMiniGameRouletteSubHeader
-{
-	ROULETTE_GC_OPEN,
-	ROULETTE_GC_START,
-	ROULETTE_GC_REQUEST,
-	ROULETTE_GC_END,
-	ROULETTE_GC_CLOSE
-};
-
-enum EPacketCGMiniGameRouletteSubHeader
-{
-	ROULETTE_CG_START,
-	ROULETTE_CG_REQUEST,
-	ROULETTE_CG_END,
-	ROULETTE_CG_CLOSE
-};
-
-typedef struct SPacketGCMiniGameRoulette
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bResult;
-	DWORD dwExpireTime;
-	struct
-	{
-		DWORD dwVnum;
-		BYTE bCount;
-	} ItemData[ROULETTE_ITEM_MAX];
-} TPacketGCMiniGameRoulette;
-
-typedef struct SPacketCGMiniGameRoulette
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGMiniGameRoulette;
-#endif
-
-#if defined(__FLOWER_EVENT__)
-enum EPacketGCFlowerEvent
-{
-	FLOWER_EVENT_SUBHEADER_GC_INFO_ALL,
-	FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
-	FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO,
-};
-
-typedef struct SPacketGCFlowerEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bChatType;
-	BYTE bShootType;
-	int aiShootCount[SHOOT_TYPE_MAX + 1];
-	SPacketGCFlowerEvent()
-		: bHeader(HEADER_GC_FLOWER_EVENT)
-		, bSubHeader(FLOWER_EVENT_SUBHEADER_GC_INFO_ALL)
-		, bChatType(FLOWER_EVENT_CHAT_TYPE_MAX)
-		, bShootType(SHOOT_TYPE_MAX)
-	{
-		memset(&aiShootCount, 0, sizeof(aiShootCount));
-	}
-} TPacketGCFlowerEvent;
-
-enum EPacketCGFlowerEvent
-{
-	FLOWER_EVENT_SUBHEADER_CG_INFO_ALL,
-	FLOWER_EVENT_SUBHEADER_CG_EXCHANGE
-};
-
-typedef struct SPacketCGFlowerEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bShootType;
-	BYTE bExchangeKey;
-}TPacketCGFlowerEvent;
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-typedef struct SPacketGGUpdateSellHistory {
-	BYTE		bHeader;
-	DWORD		pid;
-	TMySellHistory	sellItem;
-} TPacketGGUpdateSellHistory;
-#endif
-
-#ifdef __SHOP_SEARCH__
-typedef struct SPacketCGShopSearchByName {
-	BYTE	header;
-	char	itemName[ITEM_NAME_MAX_LEN + 1];
-	WORD	page;
-	BYTE	entryCountIdx;
-	BYTE	sortType;
-} TPacketCGShopSearchByName;
-
-typedef struct SPacketCGShopSearchByOptions {
-	BYTE	header;
-	TShopSearchOptions	options;
-	WORD	page;
-	BYTE	entryCountIdx;
-	BYTE	sortType;
-} TPacketCGShopSearchByOptions;
-
-typedef struct SPacketGCShopSearchResult {
-	BYTE	header;
-	WORD	size;
-	WORD	itemCount;
-	WORD	maxPageNum;
-} TPacketGCShopSearchResult;
-typedef struct SPacketCGShopSearchBuy {
-	BYTE	header;
-	TOfflineItemID	itemID;
-	DWORD	itemVnum;
-	int64_t	itemPrice;
-
-} TPacketCGShopSearchBuy;
-
-typedef struct SPacketGCShopSearchBuyResult {
-	BYTE	header;
-	BYTE	result;
-} TPacketGCShopSearchBuyResult;
-
-typedef struct SPacketCGShopSearchOwnerMessage {
-	BYTE	header;
-	DWORD	ownerID;
-} TPacketCGShopSearchOwnerMessage;
-
-typedef struct SPacketGCShopSearchOwnerMessage {
-	BYTE	header;
-	char	ownerName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCShopSearchOwnerMessage;
-
-typedef struct SPacketCGShopSearchRequestSoldInfo {
-	BYTE	header;
-	DWORD	itemVnum;
-} TPacketCGShopSearchRequestSoldInfo;
-
-typedef struct SPacketGCShopSearchSoldInfo {
-	BYTE	header;
-	WORD	size;
-	bool	results;
-} TPacketGCShopSearchSoldInfo;
-
-using TPacketGCEntity = struct SPacketGCEntity
-{
-	BYTE bHeader;
-	WORD wSize;
-};
-using TPacketEntityInfo = struct SPacketEntityInfo
-{
-	DWORD dwVID;
-	DWORD dwRaceVNum;
-	WORD wPart[CHR_EQUIPPART_NUM];
-	LONG xPos, yPos;
-};
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-typedef struct SPacketCGExtBattlePassAction
-{
-	BYTE bHeader;
-	BYTE bAction;
-} TPacketCGExtBattlePassAction;
-
-typedef struct SPacketCGExtBattlePassSendPremiumItem
-{
-	BYTE bHeader;
-	int iSlotIndex;
-} TPacketCGExtBattlePassSendPremiumItem;
-
-typedef struct SPacketGCExtBattlePassOpen
-{
-	BYTE bHeader;
-} TPacketGCExtBattlePassOpen;
-
-typedef struct SPacketGCExtBattlePassGeneralInfo
-{
-	BYTE bHeader;
-	BYTE bBattlePassType;
-	char	szSeasonName[64+1];
-	DWORD dwBattlePassID;
-	DWORD dwBattlePassStartTime;
-	DWORD dwBattlePassEndTime;
-} TPacketGCExtBattlePassGeneralInfo;
-
-typedef struct SPacketGCExtBattlePassMissionInfo
-{
-	BYTE bHeader;
-	WORD wSize;
-	WORD wRewardSize;
-	BYTE bBattlePassType;
-	DWORD dwBattlePassID;
-} TPacketGCExtBattlePassMissionInfo;
-
-typedef struct SPacketGCExtBattlePassMissionUpdate
-{
-	BYTE bHeader;
-	BYTE bBattlePassType;
-	BYTE bMissionIndex;
-	BYTE bMissionType;
-	DWORD dwNewProgress;
-} TPacketGCExtBattlePassMissionUpdate;
-
-typedef struct SPacketGCExtBattlePassRanking
-{
-	BYTE bHeader;
-	char	szPlayerName[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE bBattlePassType;
-	BYTE	bBattlePassID;
-	DWORD	dwStartTime;
-	DWORD	dwEndTime;
-} TPacketGCExtBattlePassRanking;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-enum EGrowthPetPoints
-{
-	POINT_UPBRINGING_PET_LEVEL,
-	POINT_UPBRINGING_PET_EXP,
-	POINT_UPBRINGING_PET_ITEM_EXP,
-	POINT_UPBRINGING_PET_NEXT_EXP,
-	POINT_UPBRINGING_PET_EVOL_LEVEL,
-	POINT_UPBRINGING_PET_HP,
-	POINT_UPBRINGING_PET_DEF_GRADE,
-	POINT_UPBRINGING_PET_SP,
-	POINT_UPBRINGING_DURATION,
-	POINT_UPBRINGING_MAX_DURATION,
-	POINT_UPBRINGING_BIRTHDAY,
-	
-	POINT_UPBRINGING_MAX_NUM
-};
-
-enum EGrowthPetSubheader
-{
-	SUBHEADER_PET_EGG_USE_SUCCESS,
-	SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME,
-	SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER,
-	SUBHEADER_PET_UNSUMMON,
-	SUBHEADER_PET_FEED_FAILED,
-	SUBHEADER_PET_FEED_SUCCESS,
-	SUBHEADER_PET_REVIVE_FAILED,
-	SUBHEADER_PET_REVIVE_SUCCESS,
-	SUBHEADER_PET_NAME_CHANGE_FAILED,
-	SUBHEADER_PET_NAME_CHANGE_SUCCESS,
-	SUBHEADER_PET_WINDOW_TYPE_INFO,
-	SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE,
-	SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED,
-};
-
-enum EGrowthPetWindow
-{
-	PET_WINDOW_HATCH,
-	PET_WINDOW_NAME_CHANGE,
-};
-
-typedef struct SPacketGCPet
-{
-	BYTE	header;
-	BYTE	subheader;
-} TPacketGCPet;
-
-typedef struct SPacketGCPetSet
-{
-	BYTE		header;
-	DWORD		dwID;
-	DWORD		dwSummonItemVnum;
-	char		szName[PET_NAME_MAX_SIZE + 1];
-	TPetSkill	aSkill[PET_SKILL_COUNT_MAX];
-	DWORD		dwPoints[POINT_UPBRINGING_MAX_NUM];
-} TPacketGCPetSet;
-
-typedef struct SPacketGCPetDelete
-{
-	BYTE		header;
-	DWORD		dwID;
-} TPacketGCPetDelete;
-
-typedef struct SPacketGCPetPointUpdate
-{
-	BYTE	header;
-	DWORD	dwID;
-	BYTE	bPoint;
-	DWORD	dwValue;
-} TPacketGCPetPointUpdate;
-
-typedef struct SPacketGCPetSummon
-{
-	BYTE		header;
-	DWORD		dwID;
-} TPacketGCPetSummon;
-
-typedef struct SPacketGCPetDetermineResult
-{
-	BYTE		header;
-	BYTE		type;
-} TPacketGCPetDetermineResult;
-
-typedef struct SPacketGCPetAttrChangeResult
-{
-	BYTE		header;
-	BYTE		type;
-	TItemPos	pos;
-} TPacketGCPetAttrChangeResult;
-
-typedef struct SPetSkillUpdatePacket
-{
-	bool	bLocked;
-	BYTE	bSkill;
-	BYTE	bLevel;
-	DWORD	dwCooltime;
-	BYTE	bSkillFormula1[PET_GROWTH_SKILL_LEVEL_MAX];
-	WORD	wSkillFormula2[PET_GROWTH_SKILL_LEVEL_MAX];
-	BYTE	bSkillFormula3[PET_GROWTH_SKILL_LEVEL_MAX];
-} TPetSkillUpdatePacket;
-
-typedef struct SPacketGCPetSkillCooltime
-{
-	BYTE		header;
-	DWORD		dwID;
-	BYTE		bSlot;
-	DWORD		dwCooltime;
-} TPacketGCPetSkillCooltime;
-
-typedef struct SPacketGCPetSkillUpdate
-{
-	BYTE		header;
-	DWORD		dwID;
-	TPetSkillUpdatePacket	aSkill[PET_SKILL_COUNT_MAX];
-} TPacketGCPetSkillUpdate;
-
-typedef struct SPacketGCPetNameChangeResult
-{
-	BYTE		header;
-	BYTE		subheader;
-	DWORD		dwID;
-	char		szName[PET_NAME_MAX_SIZE + 1];
-} TPacketGCPetNameChangeResult;
-
-typedef struct SPacketCGPetHatch
-{
-	BYTE		header;
-	char		name[PET_NAME_MAX_SIZE + 1];
-	TItemPos	eggPos;
-} TPacketCGPetHatch;
-
-typedef struct SPacketCGPetWindow
-{
-	BYTE	header;
-	BYTE	window;
-	bool	state;
-} TPacketCGPetWindow;
-
-typedef struct SPacketCGPetWindowType
-{
-	BYTE	header;
-	BYTE	type;
-} TPacketCGPetWindowType;
-
-typedef struct SPacketCGPeFeed
-{
-	BYTE		header;
-	BYTE		index;
-	WORD		pos[PET_FEED_SLOT_MAX];
-	WORD		count[PET_FEED_SLOT_MAX];
-} TPacketCGPetFeed;
-
-typedef struct SPacketCGPetDetermine
-{
-	BYTE		header;
-	TItemPos	determinePos;
-} TPacketCGPetDetermine;
-
-typedef struct SPacketCGPetAttrChange
-{
-	BYTE		header;
-	TItemPos	upBringingPos;
-	TItemPos	attrChangePos;
-} TPacketCGPetAttrChange;
-
-typedef struct SPacketCGPetRevive
-{
-	BYTE		header;
-	TItemPos	upBringingPos;
-	WORD		pos[PET_REVIVE_MATERIAL_SLOT_MAX];
-	WORD		count[PET_REVIVE_MATERIAL_SLOT_MAX];
-} TPacketCGPetRevive;
-
-typedef struct SPacketCGPetLearnSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-	TItemPos	learnSkillPos;
-} TPacketCGPetLearnSkill;
-
-typedef struct SPacketCGPetUpgradeSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-} TPacketCGPetSkillUpgrade;
-
-typedef struct SPacketCGPetDeleteSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-	TItemPos	deleteSkillPos;
-} TPacketCGPetDeleteSkill;
-
-typedef struct SPacketCGPetAllDeleteSkill
-{
-	BYTE		header;
-	TItemPos	deleteAllSkillPos;
-} TPacketCGPetDeleteAllSkill;
-
-typedef struct SPacketCGPetNameChange
-{
-	BYTE		header;
-	char		name[PET_NAME_MAX_SIZE + 1];
-	TItemPos	changeNamePos;
-	TItemPos	upBringingPos;
-} TPacketCGPetNameChange;
-#endif
-
-#pragma pack()
-#endif // __INC_PACKET_H__
+#ifndef __INC_PACKET_H__
+#define __INC_PACKET_H__
+
+enum CG_HEADERS
+{
+	HEADER_CG_LOGIN = 1,
+	HEADER_CG_ATTACK = 2,
+	HEADER_CG_CHAT = 3,
+	HEADER_CG_CHARACTER_CREATE = 4,
+	HEADER_CG_CHARACTER_DELETE = 5,
+	HEADER_CG_CHARACTER_SELECT = 6,
+	HEADER_CG_MOVE = 7,
+	HEADER_CG_SYNC_POSITION = 8,
+	//HEADER_CG_DIRECT_ENTER = 9,
+	HEADER_CG_ENTERGAME = 10,
+
+	HEADER_CG_ITEM_USE = 11,
+	HEADER_CG_ITEM_DROP = 12,
+	HEADER_CG_ITEM_MOVE = 13,
+	//HEADER_CG_UNUSED = 14,
+	HEADER_CG_ITEM_PICKUP = 15,
+
+	HEADER_CG_QUICKSLOT_ADD = 16,
+	HEADER_CG_QUICKSLOT_DEL = 17,
+	HEADER_CG_QUICKSLOT_SWAP = 18,
+	HEADER_CG_WHISPER = 19,
+	HEADER_CG_ITEM_DROP2 = 20,
+#if defined(__NEW_DROP_DIALOG__)
+	HEADER_CG_ITEM_DESTROY = 21,
+#endif
+
+	//HEADER_CG_UNUSED = 22,
+	//HEADER_CG_UNUSED = 23,
+	//HEADER_CG_UNUSED = 24,
+	//HEADER_CG_UNUSED = 25,
+
+	HEADER_CG_ON_CLICK = 26,
+	HEADER_CG_EXCHANGE = 27,
+	HEADER_CG_CHARACTER_POSITION = 28,
+	HEADER_CG_SCRIPT_ANSWER = 29,
+	HEADER_CG_QUEST_INPUT_STRING = 30,
+	HEADER_CG_QUEST_CONFIRM = 31,
+#if defined(__OX_RENEWAL__)
+	HEADER_CG_QUEST_INPUT_LONG_STRING = 32,
+#endif
+#if defined(__OFFLINE_SHOP__)
+	HEADER_CG_OFFLINE_SHOP = 33,
+#endif
+	//HEADER_CG_UNUSED = 34,
+
+#ifdef __GROWTH_PET_SYSTEM__
+	HEADER_CG_PET_HATCH = 35,
+	HEADER_CG_PET_WINDOW_TYPE = 36,
+	HEADER_CG_PET_WINDOW = 37,
+	HEADER_CG_PET_NAME_CHANGE = 38,
+	HEADER_CG_PET_FEED = 39,
+	HEADER_CG_PET_DETERMINE = 40,
+	HEADER_CG_PET_ATTR_CHANGE = 41,
+	HEADER_CG_PET_REVIVE = 42,
+	HEADER_CG_PET_LEARN_SKILL = 43,
+	HEADER_CG_PET_SKILL_UPGRADE = 44,
+	HEADER_CG_PET_DELETE_SKILL = 45,
+	HEADER_CG_PET_DELETE_ALL_SKILL = 46,
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	HEADER_CG_EXTEND_INVEN = 47,
+#endif
+	//HEADER_CG_UNUSED = 48,
+	//HEADER_CG_UNUSED = 49,
+
+	HEADER_CG_SHOP = 50,
+	HEADER_CG_FLY_TARGETING = 51,
+	HEADER_CG_USE_SKILL = 52,
+	HEADER_CG_ADD_FLY_TARGETING = 53,
+	HEADER_CG_SHOOT = 54,
+	HEADER_CG_MYSHOP = 55,
+#if defined(__MYSHOP_DECO__)
+	HEADER_CG_MYSHOP_DECO_STATE = 56,
+	HEADER_CG_MYSHOP_DECO_ADD = 57,
+#endif
+	//HEADER_CG_UNUSED = 58,
+
+#if defined(__SEND_TARGET_INFO__)
+	HEADER_CG_TARGET_INFO = 59,
+#endif
+	HEADER_CG_ITEM_USE_TO_ITEM = 60,
+	HEADER_CG_TARGET = 61,
+
+	//HEADER_CG_UNUSED = 62,
+	//HEADER_CG_UNUSED = 63,
+	HEADER_CG_TEXT = 64, // @  滂퓔 灣트 캭磯.
+	HEADER_CG_WARP = 65,
+	HEADER_CG_SCRIPT_BUTTON = 66,
+	HEADER_CG_MESSENGER = 67,
+	//HEADER_CG_UNUSED = 68,
+
+	HEADER_CG_MALL_CHECKOUT = 69,
+	HEADER_CG_SAFEBOX_CHECKIN = 70, //  창 쨈.
+	HEADER_CG_SAFEBOX_CHECKOUT = 71, //  창  쨈.
+
+	HEADER_CG_PARTY_INVITE = 72,
+	HEADER_CG_PARTY_INVITE_ANSWER = 73,
+	HEADER_CG_PARTY_REMOVE = 74,
+	HEADER_CG_PARTY_SET_STATE = 75,
+	HEADER_CG_PARTY_USE_SKILL = 76,
+	HEADER_CG_SAFEBOX_ITEM_MOVE = 77,
+	HEADER_CG_PARTY_PARAMETER = 78,
+	//HEADER_CG_UNUSED = 79,
+
+	HEADER_CG_GUILD = 80,
+	HEADER_CG_ANSWER_MAKE_GUILD = 81,
+	HEADER_CG_FISHING = 82,
+	HEADER_CG_ITEM_GIVE = 83,
+#ifdef __SHOP_SEARCH__
+	HEADER_CG_SHOP_SEARCH_BY_NAME = 84,
+	HEADER_CG_SHOP_SEARCH_BY_OPTION = 85,
+	HEADER_CG_SHOP_SEARCH_BUY = 86,
+	HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE = 87,
+	HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO = 88,
+#endif
+	HEADER_CG_EMPIRE = 90,
+	//HEADER_CG_UNUSED = 91,
+	//HEADER_CG_UNUSED = 92,
+	//HEADER_CG_UNUSED = 93,
+	//HEADER_CG_UNUSED = 94,
+	//HEADER_CG_UNUSED = 95,
+
+	HEADER_CG_REFINE = 96,
+#if defined(__CUBE_RENEWAL__)
+	HEADER_CG_CUBE = 97,
+#endif
+	//HEADER_CG_UNUSED = 98,
+	//HEADER_CG_UNUSED = 99,
+
+	HEADER_CG_MARK_LOGIN = 100,
+	HEADER_CG_MARK_CRCLIST = 101,
+	HEADER_CG_MARK_UPLOAD = 102,
+	//HEADER_CG_CRC_REPORT = 103,
+	HEADER_CG_MARK_IDXLIST = 104,
+
+	HEADER_CG_HACK = 105,
+	HEADER_CG_CHANGE_NAME = 106,
+	//HEADER_CG_UNUSED = 107,
+	//HEADER_CG_UNUSED = 108,
+	HEADER_CG_LOGIN2 = 109,
+	// HEADER_CG_DUNGEON = 110, // zombie: no handler registered
+	HEADER_CG_LOGIN3 = 111,
+
+	HEADER_CG_GUILD_SYMBOL_UPLOAD = 112,
+	HEADER_CG_SYMBOL_CRC = 113,
+
+	// SCRIPT_SELECT_ITEM
+	HEADER_CG_SCRIPT_SELECT_ITEM = 114,
+	// END_OF_SCRIPT_SELECT_ITEM
+
+#if defined(__GEM_SYSTEM__)
+	HEADER_CG_SELECT_ITEM_EX = 115,
+#endif
+
+	//HEADER_CG_UNUSED = 116,
+	//HEADER_CG_UNUSED = 117,
+	//HEADER_CG_UNUSED = 118,
+	//HEADER_CG_UNUSED = 119,
+#if defined(__QUEST_REQUEST_EVENT__)
+	HEADER_CG_REQUEST_EVENT_QUEST = 120,
+#endif
+#if defined(__LEFT_SEAT__)
+	HEADER_CG_LEFT_SEAT = 121,
+#endif
+	//HEADER_CG_UNUSED = 122,
+	//HEADER_CG_UNUSED = 123,
+	//HEADER_CG_UNUSED = 124,
+	//HEADER_CG_UNUSED = 125,
+	//HEADER_CG_UNUSED = 126,
+	//HEADER_CG_UNUSED = 127,
+	//HEADER_CG_UNUSED = 128,
+	//HEADER_CG_UNUSED = 129,
+	//HEADER_CG_UNUSED = 130,
+	//HEADER_CG_UNUSED = 131,
+	//HEADER_CG_UNUSED = 132,
+	//HEADER_CG_UNUSED = 133,
+	//HEADER_CG_UNUSED = 134,
+	//HEADER_CG_UNUSED = 135,
+	//HEADER_CG_UNUSED = 136,
+	//HEADER_CG_UNUSED = 137,
+	//HEADER_CG_UNUSED = 138,
+	//HEADER_CG_UNUSED = 139,
+	//HEADER_CG_UNUSED = 140,
+	//HEADER_CG_UNUSED = 141,
+	//HEADER_CG_UNUSED = 142,
+	//HEADER_CG_UNUSED = 143,
+	//HEADER_CG_UNUSED = 144,
+#if defined(__FISHING_GAME__)
+	HEADER_CG_FISHING_GAME = 145,
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	HEADER_CG_REFINE_ELEMENT = 146,
+#endif
+	//HEADER_CG_UNUSED = 147,
+	//HEADER_CG_UNUSED = 148,
+	//HEADER_CG_UNUSED = 149,
+	//HEADER_CG_UNUSED = 150,
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+	HEADER_CG_SKILLBOOK_COMB = 151,
+#endif
+	//HEADER_CG_UNUSED = 152,
+	//HEADER_CG_UNUSED = 153,
+	//HEADER_CG_UNUSED = 154,
+	//HEADER_CG_UNUSED = 155,
+	//HEADER_CG_UNUSED = 156,
+	//HEADER_CG_UNUSED = 157,
+	//HEADER_CG_UNUSED = 158,
+	//HEADER_CG_UNUSED = 159,
+	//HEADER_CG_UNUSED = 160,
+	//HEADER_CG_UNUSED = 161,
+	//HEADER_CG_UNUSED = 162,
+	//HEADER_CG_UNUSED = 163,
+	//HEADER_CG_UNUSED = 164,
+	//HEADER_CG_UNUSED = 165,
+	//HEADER_CG_UNUSED = 166,
+	//HEADER_CG_UNUSED = 167,
+	//HEADER_CG_UNUSED = 168,
+#if defined(__ATTR_6TH_7TH__)
+	HEADER_CG_ATTR67_ADD = 169,
+#endif
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	HEADER_CG_SNOWFLAKE_STICK_EVENT = 170,
+#endif
+	//HEADER_CG_UNUSED = 171,
+	//HEADER_CG_UNUSED = 172,
+	//HEADER_CG_UNUSED = 173,
+	//HEADER_CG_UNUSED = 174,
+	//HEADER_CG_UNUSED = 175,
+	//HEADER_CG_UNUSED = 176,
+	//HEADER_CG_UNUSED = 177,
+	//HEADER_CG_UNUSED = 178,
+	//HEADER_CG_UNUSED = 179,
+	//HEADER_CG_UNUSED = 180,
+#if defined(__MINI_GAME_RUMI__)
+	HEADER_CG_MINI_GAME_RUMI = 181,
+#endif
+#if defined(__MINI_GAME_YUTNORI__)
+	HEADER_CG_MINI_GAME_YUTNORI = 182,
+#endif
+#if defined(__GEM_SHOP__)
+	HEADER_CG_GEM_SHOP = 183,
+#endif
+	//HEADER_CG_UNUSED = 184,
+	//HEADER_CG_UNUSED = 185,
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	HEADER_CG_MINI_GAME_ROULETTE = 186,
+#endif
+#if defined(__FLOWER_EVENT__)
+	HEADER_CG_FLOWER_EVENT = 187,
+#endif
+	//HEADER_CG_UNUSED = 188,
+	//HEADER_CG_UNUSED = 189,
+	//HEADER_CG_UNUSED = 190,
+	//HEADER_CG_UNUSED = 191,
+	//HEADER_CG_UNUSED = 192,
+	//HEADER_CG_UNUSED = 193,
+	//HEADER_CG_UNUSED = 194,
+	//HEADER_CG_UNUSED = 195,
+	//HEADER_CG_UNUSED = 196,
+	//HEADER_CG_UNUSED = 197,
+	//HEADER_CG_UNUSED = 198,
+	//HEADER_CG_UNUSED = 199,
+	//HEADER_CG_UNUSED = 200,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_CG_EXT_BATTLE_PASS_ACTION = 201,
+	HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM = 202,
+#endif
+
+	// NOTE : 肩 XXX  隔 Packet  . 肩 湄構  耭載.
+	// enum   求. 틈 namepsace  求..
+	//  packet generator 帽 苛쨈. 肩 XX
+	// 肩鳴  치  책쨉???
+	//HEADER_CG_HS_ACK = 203,
+	//HEADER_CG_XTRAP_ACK = 204,
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	HEADER_CG_DRAGON_SOUL_REFINE = 205,
+#endif
+	HEADER_CG_STATE_CHECKER = 206,
+
+	//HEADER_CG_UNUSED = 207,
+#if defined(__LUCKY_BOX__)
+	HEADER_CG_LUCKY_BOX = 208,
+#endif
+	//HEADER_CG_UNUSED = 210,
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	HEADER_CG_ACCE_REFINE = 211,
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	HEADER_CG_AURA_REFINE = 212,
+#endif
+	//HEADER_CG_UNUSED = 213,
+	//HEADER_CG_UNUSED = 214,
+#if defined(__MAILBOX__)
+	HEADER_CG_MAILBOX_WRITE = 215,
+	HEADER_CG_MAILBOX_WRITE_CONFIRM = 216,
+	HEADER_CG_MAILBOX_PROCESS = 217,
+#endif
+#if defined(__MOVE_COSTUME_ATTR__)
+	HEADER_CG_ITEM_COMBINATION = 218,
+	HEADER_CG_ITEM_COMBINATION_CANCEL = 219,
+#endif
+	//HEADER_CG_UNUSED = 223,
+	//HEADER_CG_UNUSED = 224,
+	//HEADER_CG_UNUSED = 225,
+#if defined(__MINI_GAME_CATCH_KING__)
+	HEADER_CG_MINI_GAME_CATCH_KING = 226,
+#endif
+#if defined(__CHANGED_ATTR__)
+	HEADER_CG_ITEM_SELECT_ATTR = 227,
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	HEADER_CG_CHANGE_LOOK = 228,
+#endif
+	//HEADER_CG_UNUSED = 229,
+	//HEADER_CG_UNUSED = 230,
+	//HEADER_CG_UNUSED = 231,
+	//HEADER_CG_UNUSED = 232,
+	//HEADER_CG_UNUSED = 233,
+	//HEADER_CG_UNUSED = 234,
+#if defined(__LOOT_FILTER_SYSTEM__)
+	HEADER_CG_LOOT_FILTER = 235,
+#endif
+	//HEADER_CG_UNUSED = 236,
+	//HEADER_CG_UNUSED = 237,
+	//HEADER_CG_UNUSED = 238,
+	//HEADER_CG_UNUSED = 239,
+	//HEADER_CG_UNUSED = 240,
+	HEADER_CG_CLIENT_VERSION2 = 0xf1, // 241
+	//HEADER_CG_UNUSED = 242,
+	//HEADER_CG_UNUSED = 243,
+	//HEADER_CG_UNUSED = 244,
+	//HEADER_CG_UNUSED = 245,
+	//HEADER_CG_UNUSED = 246,
+	//HEADER_CG_UNUSED = 247,
+	//HEADER_CG_UNUSED = 248,
+	//HEADER_CG_UNUSED = 249,
+	//HEADER_CG_UNUSED = 250,
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	HEADER_CG_KEY_AGREEMENT = 0xfb, // 251
+#endif
+	HEADER_CG_TIME_SYNC = 0xfc, // 252
+	HEADER_CG_CLIENT_VERSION = 0xfd, // 253
+	HEADER_CG_PONG = 0xfe, // 254
+	HEADER_CG_HANDSHAKE = 0xff, // 255
+};
+
+enum GC_HEADERS
+{
+	HEADER_GC_CHARACTER_ADD = 1,
+	HEADER_GC_CHARACTER_DEL = 2,
+	HEADER_GC_MOVE = 3,
+	HEADER_GC_CHAT = 4,
+	HEADER_GC_SYNC_POSITION = 5,
+
+	HEADER_GC_LOGIN_SUCCESS = 6,
+	HEADER_GC_LOGIN_FAILURE = 7,
+
+	HEADER_GC_CHARACTER_CREATE_SUCCESS = 8,
+	HEADER_GC_CHARACTER_CREATE_FAILURE = 9,
+	HEADER_GC_CHARACTER_DELETE_SUCCESS = 10,
+	HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID = 11,
+
+	//HEADER_GC_UNUSED = 12,
+	HEADER_GC_STUN = 13,
+	HEADER_GC_DEAD = 14,
+
+	HEADER_GC_MAIN_CHARACTER_OLD = 15,
+	HEADER_GC_CHARACTER_POINTS = 16,
+	HEADER_GC_CHARACTER_POINT_CHANGE = 17,
+	HEADER_GC_CHANGE_SPEED = 18,
+	HEADER_GC_CHARACTER_UPDATE = 19,
+
+	HEADER_GC_ITEM_DEL = 20,
+	HEADER_GC_ITEM_SET = 21,
+	HEADER_GC_ITEM_USE = 22,
+	HEADER_GC_ITEM_DROP = 23,
+
+	//HEADER_GC_UNUSED = 24,
+	HEADER_GC_ITEM_UPDATE = 25,
+	HEADER_GC_ITEM_GROUND_ADD = 26,
+	HEADER_GC_ITEM_GROUND_DEL = 27,
+
+	HEADER_GC_QUICKSLOT_ADD = 28,
+	HEADER_GC_QUICKSLOT_DEL = 29,
+	HEADER_GC_QUICKSLOT_SWAP = 30,
+
+	HEADER_GC_ITEM_OWNERSHIP = 31,
+
+	HEADER_GC_LOGIN_SUCCESS_NEWSLOT = 32,
+
+	//HEADER_GC_UNUSED = 33,
+	HEADER_GC_WHISPER = 34,
+	//HEADER_GC_UNUSED = 35,
+
+	HEADER_GC_MOTION = 36,
+	HEADER_GC_EMOTE = 37,
+
+	HEADER_GC_SHOP = 38,
+	HEADER_GC_SHOP_SIGN = 39,
+
+	HEADER_GC_DUEL_START = 40,
+	HEADER_GC_PVP = 41,
+	HEADER_GC_EXCHANGE = 42,
+	HEADER_GC_CHARACTER_POSITION = 43,
+
+	HEADER_GC_PING = 44,
+	HEADER_GC_SCRIPT = 45,
+	HEADER_GC_QUEST_CONFIRM = 46,
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	HEADER_GC_EXTEND_INVEN = 47,
+	HEADER_GC_EXTEND_INVEN_ITEM_USE = 48,
+#endif
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	HEADER_GC_GUILD_DRAGONLAIR = 49,
+#endif
+#if defined(__CLIENT_TIMER__)
+	HEADER_GC_CLIENT_TIMER = 50,
+#endif
+#if defined(__OFFLINE_SHOP__)
+	HEADER_GC_OFFLINE_SHOP = 51,
+#endif
+	//HEADER_GC_UNUSED = 52,
+	//HEADER_GC_UNUSED = 53,
+	//HEADER_GC_UNUSED = 54,
+	//HEADER_GC_UNUSED = 55,
+	//HEADER_GC_UNUSED = 56,
+	//HEADER_GC_UNUSED = 57,
+#if defined(__SEND_TARGET_INFO__)
+	HEADER_GC_TARGET_INFO = 58,
+#endif
+	//HEADER_GC_UNUSED = 59,
+	//HEADER_GC_UNUSED = 60,
+	HEADER_GC_MOUNT = 61,
+	HEADER_GC_OWNERSHIP = 62,
+	HEADER_GC_TARGET = 63,
+	//HEADER_GC_UNUSED = 64,
+	HEADER_GC_WARP = 65,
+	//HEADER_GC_UNUSED = 66,
+	//HEADER_GC_UNUSED = 67,
+	//HEADER_GC_UNUSED = 68,
+	HEADER_GC_ADD_FLY_TARGETING = 69,
+
+	HEADER_GC_CREATE_FLY = 70,
+	HEADER_GC_FLY_TARGETING = 71,
+	HEADER_GC_SKILL_LEVEL_OLD = 72,
+	//HEADER_GC_UNUSED = 73,
+	HEADER_GC_MESSENGER = 74,
+	HEADER_GC_GUILD = 75,
+	HEADER_GC_SKILL_LEVEL = 76,
+
+	HEADER_GC_PARTY_INVITE = 77,
+	HEADER_GC_PARTY_ADD = 78,
+	HEADER_GC_PARTY_UPDATE = 79,
+	HEADER_GC_PARTY_REMOVE = 80,
+
+	HEADER_GC_QUEST_INFO = 81,
+	HEADER_GC_REQUEST_MAKE_GUILD = 82,
+	HEADER_GC_PARTY_PARAMETER = 83,
+	//HEADER_GC_UNUSED = 84,
+
+	HEADER_GC_SAFEBOX_SET = 85,
+	HEADER_GC_SAFEBOX_DEL = 86,
+	HEADER_GC_SAFEBOX_WRONG_PASSWORD = 87,
+	HEADER_GC_SAFEBOX_SIZE = 88,
+
+	HEADER_GC_FISHING = 89,
+
+	HEADER_GC_EMPIRE = 90,
+
+	HEADER_GC_PARTY_LINK = 91,
+	HEADER_GC_PARTY_UNLINK = 92,
+	//HEADER_GC_UNUSED = 93,
+	//HEADER_GC_UNUSED = 94,
+	//HEADER_GC_UNUSED = 95,
+	//HEADER_GC_UNUSED = 96,
+#if defined(__CUBE_RENEWAL__)
+	HEADER_GC_CUBE = 97,
+#endif
+	//HEADER_GC_UNUSED = 98,
+	HEADER_GC_VIEW_EQUIP = 99,
+
+	HEADER_GC_MARK_BLOCK = 100,
+	//HEADER_GC_MARK_DIFF_DATA = 101,
+	HEADER_GC_MARK_IDXLIST = 102,
+	//HEADER_GC_UNUSED = 103,
+	//HEADER_GC_UNUSED = 104,
+	//HEADER_GC_SLOW_TIMER = 105,
+	HEADER_GC_TIME = 106,
+	HEADER_GC_CHANGE_NAME = 107,
+	//HEADER_GC_UNUSED = 108,
+	//HEADER_GC_UNUSED = 109,
+
+	HEADER_GC_DUNGEON = 110,
+
+	HEADER_GC_WALK_MODE = 111,
+	HEADER_GC_SKILL_GROUP = 112,
+	HEADER_GC_MAIN_CHARACTER = 113,
+
+	HEADER_GC_SEPCIAL_EFFECT = 114,
+	HEADER_GC_NPC_POSITION = 115,
+
+	//HEADER_CG_UNUSED = 116,
+	//HEADER_GC_UNUSED = 117,
+	HEADER_GC_LOGIN_KEY = 118,
+
+	HEADER_GC_REFINE_INFORMATION = 119,
+	//HEADER_GC_UNUSED = 120,
+	HEADER_GC_CHANNEL = 121,
+
+	HEADER_GC_MALL_OPEN = 122,
+
+	HEADER_GC_TARGET_UPDATE = 123,
+	HEADER_GC_TARGET_DELETE = 124,
+	HEADER_GC_TARGET_CREATE = 125,
+
+	HEADER_GC_AFFECT_ADD = 126,
+	HEADER_GC_AFFECT_REMOVE = 127,
+
+	HEADER_GC_MALL_SET = 128,
+	HEADER_GC_MALL_DEL = 129,
+
+	HEADER_GC_LAND_LIST = 130,
+	HEADER_GC_LOVER_INFO = 131,
+	HEADER_GC_LOVE_POINT_UPDATE = 132,
+
+	HEADER_GC_SYMBOL_DATA = 133,
+
+	// MINING
+	HEADER_GC_DIG_MOTION = 134,
+	// END_OF_MINING
+
+	HEADER_GC_DAMAGE_INFO = 135,
+	HEADER_GC_CHAR_ADDITIONAL_INFO = 136,
+
+	// SUPPORT_BGM
+	HEADER_GC_MAIN_CHARACTER3_BGM = 137,
+	HEADER_GC_MAIN_CHARACTER4_BGM_VOL = 138,
+	// END_OF_SUPPORT_BGM
+
+	//HEADER_GC_UNUSED = 140,
+	//HEADER_GC_UNUSED = 141,
+	//HEADER_GC_UNUSED = 142,
+	//HEADER_GC_UNUSED = 143,
+	//HEADER_GC_UNUSED = 144,
+#if defined(__FISHING_GAME__)
+	HEADER_GC_FISHING_GAME = 145,
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	HEADER_GC_REFINE_ELEMENT = 146,
+#endif
+	//HEADER_GC_UNUSED = 147,
+	//HEADER_GC_UNUSED = 148,
+	//HEADER_GC_UNUSED = 149,
+
+	HEADER_GC_AUTH_SUCCESS = 150,
+	HEADER_GC_PANAMA_PACK = 151,
+
+	// HYBRID CRYPT
+	HEADER_GC_HYBRIDCRYPT_KEYS = 152,
+	HEADER_GC_HYBRIDCRYPT_SDB = 153, // SDB means Supplmentary Data Blocks
+	// HYBRID CRYPT
+
+#ifdef __SHOP_SEARCH__
+	HEADER_GC_SHOP_SEARCH_RESULT = 164,
+	HEADER_GC_SHOP_SEARCH_BUY_RESULT = 165,
+	HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE = 166,
+	HEADER_GC_SHOP_SEARCH_SOLD_INFO = 167,
+#endif
+	//HEADER_GC_UNUSED = 169,
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	HEADER_GC_SNOWFLAKE_STICK_EVENT = 170,
+#endif
+	//HEADER_GC_UNUSED = 171,
+	//HEADER_GC_UNUSED = 172,
+	//HEADER_GC_UNUSED = 173,
+	//HEADER_GC_UNUSED = 174,
+	//HEADER_GC_UNUSED = 175,
+	//HEADER_GC_UNUSED = 176,
+	//HEADER_GC_UNUSED = 177,
+	//HEADER_GC_UNUSED = 178,
+	//HEADER_GC_UNUSED = 179,
+	//HEADER_GC_UNUSED = 180,
+#if defined(__MINI_GAME_RUMI__)
+	HEADER_GC_MINI_GAME_RUMI = 181,
+#endif
+#if defined(__MINI_GAME_YUTNORI__)
+	HEADER_GC_MINI_GAME_YUTNORI = 182,
+#endif
+	//HEADER_GC_UNUSED = 183,
+	//HEADER_GC_UNUSED = 184,
+	//HEADER_GC_UNUSED = 185,
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	HEADER_GC_MINI_GAME_ROULETTE = 186,
+#endif
+#if defined(__FLOWER_EVENT__)
+	HEADER_GC_FLOWER_EVENT = 187,
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	HEADER_GC_PET = 188,
+	HEADER_GC_PET_SET = 189,
+	HEADER_GC_PET_SET_EXCHANGE = 190,
+	HEADER_GC_PET_DEL = 191,
+	HEADER_GC_PET_SUMMON = 192,
+	HEADER_GC_PET_POINT_CHANGE = 193,
+	HEADER_GC_PET_NAME_CHANGE_RESULT = 194,
+	HEADER_GC_PET_DETERMINE_RESULT = 195,
+	HEADER_GC_PET_ATTR_CHANGE_RESULT = 196,
+	HEADER_GC_PET_SKILL_UPDATE = 197,
+	HEADER_GC_PET_SKILL_COOLTIME = 198,
+#endif
+
+	//HEADER_GC_UNUSED = 199,
+	//HEADER_GC_UNUSED = 200,
+
+#if defined(__GEM_SHOP__)
+	HEADER_GC_GEM_SHOP = 201,
+	HEADER_GC_GEM_SHOP_PROCESS = 202,
+#endif
+	//HEADER_GC_UNUSED = 203,
+	//HEADER_GC_UNUSED = 204,
+	//HEADER_GC_UNUSED = 205,
+	//HEADER_GC_UNUSED = 206,
+	//HEADER_GC_UNUSED = 207,
+
+	HEADER_GC_SPECIFIC_EFFECT = 208,
+
+	HEADER_GC_DRAGON_SOUL_REFINE = 209,
+	HEADER_GC_RESPOND_CHANNELSTATUS = 210,
+
+	//HEADER_GC_UNUSED = 212,
+	//HEADER_GC_UNUSED = 213,
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	HEADER_GC_ACCE_REFINE = 214,
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	HEADER_GC_AURA_REFINE = 215,
+#endif
+	//HEADER_GC_UNUSED = 216,
+#if defined(__LUCKY_BOX__)
+	HEADER_GC_LUCKY_BOX = 217,
+#endif
+	//HEADER_GC_UNUSED = 218,
+	//HEADER_GC_UNUSED = 219,
+	//HEADER_GC_UNUSED = 220,
+#if defined(__MAILBOX__)
+	HEADER_GC_MAILBOX_PROCESS = 221,
+	HEADER_GC_MAILBOX = 222,
+	HEADER_GC_MAILBOX_ADD_DATA = 223,
+	HEADER_GC_MAILBOX_ALL = 224,
+	HEADER_GC_MAILBOX_UNREAD = 225,
+#endif
+	//HEADER_GC_UNUSED = 226,
+#if defined(__CHANGED_ATTR__)
+	HEADER_GC_ITEM_SELECT_ATTR = 227,
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	HEADER_GC_CHANGE_LOOK_SET = 228,
+	HEADER_GC_CHANGE_LOOK_DEL = 229,
+	HEADER_GC_CHANGE_LOOK_FREE_SET = 230,
+	HEADER_GC_CHANGE_LOOK_FREE_DEL = 231,
+#endif
+	//HEADER_GC_UNUSED = 232,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_GC_EXT_BATTLE_PASS_OPEN = 233,
+	HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO = 234,
+	HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO = 235,
+	HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE = 236,
+	HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING = 237,
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+	HEADER_GC_MINI_GAME_CATCH_KING = 238,
+#endif
+	//HEADER_GC_UNUSED = 239,
+#if defined(__RANKING_SYSTEM__)
+	HEADER_GC_RANKING = 240,
+#endif
+	//HEADER_GC_UNUSED = 241,
+	//HEADER_GC_UNUSED = 242,
+	//HEADER_GC_UNUSED = 243,
+	//HEADER_GC_UNUSED = 244,
+#if defined(__LOOT_FILTER_SYSTEM__)
+	HEADER_GC_LOOT_FILTER = 245,
+#endif
+	//HEADER_GC_UNUSED = 246,
+	//HEADER_GC_UNUSED = 247,
+	//HEADER_GC_UNUSED = 248,
+	//HEADER_GC_UNUSED = 249,
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	HEADER_GC_KEY_AGREEMENT_COMPLETED = 250, // 250
+	HEADER_GC_KEY_AGREEMENT = 251, // 251
+#endif
+	HEADER_GC_HANDSHAKE_OK = 252, // 252 (0xfc)
+	HEADER_GC_TIME_SYNC = 252, // legacy alias (handshake ok)
+	HEADER_GC_PHASE = 253, // 253
+	HEADER_GC_BINDUDP = 254, // 254
+	HEADER_GC_HANDSHAKE = 255, // 255
+};
+
+enum GG_HEADERS
+{
+	HEADER_GG_LOGIN = 1,
+	HEADER_GG_LOGOUT = 2,
+	HEADER_GG_RELAY = 3,
+	HEADER_GG_NOTICE = 4,
+	HEADER_GG_SHUTDOWN = 5,
+	HEADER_GG_GUILD = 6,
+	HEADER_GG_DISCONNECT = 7, //     
+	HEADER_GG_SHOUT = 8,
+	HEADER_GG_SETUP = 9,
+	HEADER_GG_MESSENGER_ADD = 10,
+	HEADER_GG_MESSENGER_REMOVE = 11,
+	HEADER_GG_FIND_POSITION = 12,
+	HEADER_GG_WARP_CHARACTER = 13,
+	//HEADER_GG_UNUSED = 14,
+	HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
+	HEADER_GG_TRANSFER = 16,
+#if defined(__XMAS_EVENT_2008__)
+	HEADER_GG_XMAS_WARP_SANTA = 17,
+	HEADER_GG_XMAS_WARP_SANTA_REPLY = 18,
+#endif
+	HEADER_GG_RELOAD_CRC_LIST = 19,
+	HEADER_GG_LOGIN_PING = 20,
+	HEADER_GG_CHECK_CLIENT_VERSION = 21,
+	HEADER_GG_BLOCK_CHAT = 22,
+	HEADER_GG_BIG_NOTICE = 23,
+	HEADER_GG_UNUSED_24 = 24,
+	HEADER_GG_SIEGE = 25,
+	HEADER_GG_MONARCH_NOTICE = 26,
+	HEADER_GG_MONARCH_TRANSFER = 27,
+	HEADER_GG_PCBANG_UPDATE = 28,
+	HEADER_GG_CHECK_AWAKENESS = 29,
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	HEADER_GG_MESSENGER_BLOCK_ADD = 30,
+	HEADER_GG_MESSENGER_BLOCK_REMOVE = 31,
+#endif
+#if defined(__OFFLINE_SHOP__)
+	HEADER_GG_OFFLINE_SHOP = 33,
+	HEADER_GG_UPDATE_SELL_HISTORY = 34,
+#endif
+};
+
+#pragma pack(1)
+typedef struct SPacketGGSetup
+{
+	BYTE bHeader;
+	WORD wPort;
+	BYTE bChannel;
+} TPacketGGSetup;
+
+typedef struct SPacketGGLogin
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	DWORD dwPID;
+	BYTE bEmpire;
+	long lMapIndex;
+	BYTE bChannel;
+} TPacketGGLogin;
+
+typedef struct SPacketGGLogout
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGGLogout;
+
+typedef struct SPacketGGRelay
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lSize;
+} TPacketGGRelay;
+
+typedef struct SPacketGGNotice
+{
+	BYTE bHeader;
+	long lSize;
+	char szArg[CHAT_MAX_LEN + 1];
+	bool bBigFont;
+} TPacketGGNotice;
+
+typedef struct SPacketGGMonarchNotice
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+	long lSize;
+} TPacketGGMonarchNotice;
+
+// FORKED_ROAD
+typedef struct SPacketGGForkedMapInfo
+{
+	BYTE bHeader;
+	BYTE bPass;
+	BYTE bSungzi;
+} TPacketGGForkedMapInfo;
+// END_FORKED_ROAD
+
+typedef struct SPacketGGShutdown
+{
+	BYTE bHeader;
+} TPacketGGShutdown;
+
+typedef struct SPacketGGGuild
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwGuild;
+} TPacketGGGuild;
+
+enum
+{
+	GUILD_SUBHEADER_GG_CHAT,
+	GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS,
+};
+
+typedef struct SPacketGGGuildChat
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwGuild;
+	char szText[CHAT_MAX_LEN + 1];
+} TPacketGGGuildChat;
+
+typedef struct SPacketGGParty
+{
+	BYTE header;
+	BYTE subheader;
+	DWORD pid;
+	DWORD leaderpid;
+} TPacketGGParty;
+
+enum
+{
+	PARTY_SUBHEADER_GG_CREATE,
+	PARTY_SUBHEADER_GG_DESTROY,
+	PARTY_SUBHEADER_GG_JOIN,
+	PARTY_SUBHEADER_GG_QUIT,
+};
+
+typedef struct SPacketGGDisconnect
+{
+	BYTE bHeader;
+	char szLogin[LOGIN_MAX_LEN + 1];
+} TPacketGGDisconnect;
+
+typedef struct SPacketGGShout
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+	char szText[CHAT_MAX_LEN + 1];
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGGShout;
+
+#if defined(__XMAS_EVENT_2008__)
+typedef struct SPacketGGXmasWarpSanta
+{
+	BYTE bHeader;
+	BYTE bChannel;
+	long lMapIndex;
+} TPacketGGXmasWarpSanta;
+
+typedef struct SPacketGGXmasWarpSantaReply
+{
+	BYTE bHeader;
+	BYTE bChannel;
+} TPacketGGXmasWarpSantaReply;
+#endif
+
+typedef struct SPacketGGMessenger
+{
+	BYTE bHeader;
+	char szAccount[CHARACTER_NAME_MAX_LEN + 1];
+	char szCompanion[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGGMessenger;
+
+typedef struct SPacketGGFindPosition
+{
+	BYTE header;
+	DWORD dwFromPID; //  치 狗 
+	DWORD dwTargetPID; // 찾 
+} TPacketGGFindPosition;
+
+typedef struct SPacketGGWarpCharacter
+{
+	BYTE header;
+	DWORD pid;
+	long x;
+	long y;
+} TPacketGGWarpCharacter;
+
+//HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
+
+typedef struct SPacketGGGuildWarMapIndex
+{
+	BYTE bHeader;
+	DWORD dwGuildID1;
+	DWORD dwGuildID2;
+	long lMapIndex;
+} TPacketGGGuildWarMapIndex;
+
+typedef struct SPacketGGTransfer
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lX, lY;
+} TPacketGGTransfer;
+
+typedef struct SPacketGGLoginPing
+{
+	BYTE bHeader;
+	char szLogin[LOGIN_MAX_LEN + 1];
+} TPacketGGLoginPing;
+
+typedef struct SPacketGGBlockChat
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lBlockDuration;
+} TPacketGGBlockChat;
+
+/* 클潔트   킷 */
+typedef struct command_text
+{
+	BYTE bHeader;
+} TPacketCGText;
+
+typedef struct command_phase
+{
+	BYTE bHeader;
+} TPacketCGPhase;
+
+/* 慣 (1) */
+typedef struct command_handshake
+{
+	BYTE bHeader;
+	DWORD dwHandshake;
+	DWORD dwTime;
+	long lDelta;
+} TPacketCGHandshake;
+
+typedef struct command_login
+{
+	BYTE header;
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+} TPacketCGLogin;
+
+typedef struct command_login2
+{
+	BYTE header;
+	char login[LOGIN_MAX_LEN + 1];
+	DWORD dwLoginKey;
+	DWORD adwClientKey[4];
+} TPacketCGLogin2;
+
+typedef struct command_login3
+{
+	BYTE header;
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+	DWORD adwClientKey[4];
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char country[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketCGLogin3;
+
+typedef struct packet_login_key
+{
+	BYTE bHeader;
+	DWORD dwLoginKey;
+} TPacketGCLoginKey;
+
+typedef struct command_player_select
+{
+	BYTE header;
+	BYTE index;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char country[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketCGPlayerSelect;
+
+typedef struct command_player_delete
+{
+	BYTE header;
+	BYTE index;
+	char private_code[8];
+} TPacketCGPlayerDelete;
+
+typedef struct command_player_create
+{
+	BYTE header;
+	BYTE index;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	WORD job;
+	BYTE shape;
+	BYTE Con;
+	BYTE Int;
+	BYTE Str;
+	BYTE Dex;
+} TPacketCGPlayerCreate;
+
+typedef struct command_player_create_success
+{
+	BYTE header;
+	BYTE bAccountCharacterIndex;
+	TSimplePlayer player;
+} TPacketGCPlayerCreateSuccess;
+
+// 
+typedef struct command_attack
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwVID;
+	BYTE bCRCMagicCubeProcPiece;
+	BYTE bCRCMagicCubeFilePiece;
+} TPacketCGAttack;
+
+enum EMoveFuncType
+{
+	FUNC_WAIT,
+	FUNC_MOVE,
+	FUNC_ATTACK,
+	FUNC_COMBO,
+	FUNC_MOB_SKILL,
+	_FUNC_SKILL,
+	FUNC_MAX_NUM,
+	FUNC_SKILL = 0x80,
+};
+
+// 絹
+typedef struct command_move
+{
+	BYTE bHeader;
+	BYTE bFunc;
+	BYTE bArg;
+	BYTE bRot;
+	long lX;
+	long lY;
+	DWORD dwTime;
+} TPacketCGMove;
+
+typedef struct command_sync_position_element
+{
+	DWORD dwVID;
+	long lX;
+	long lY;
+} TPacketCGSyncPositionElement;
+
+// 치 화
+typedef struct command_sync_position //  킷
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketCGSyncPosition;
+
+/* 채 (3) */
+typedef struct command_chat //  킷
+{
+	BYTE header;
+	WORD size;
+	BYTE type;
+} TPacketCGChat;
+
+/* 憺疸 */
+typedef struct command_whisper
+{
+	BYTE bHeader;
+	WORD wSize;
+	char szNameTo[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGWhisper;
+
+typedef struct command_entergame
+{
+	BYTE header;
+} TPacketCGEnterGame;
+
+typedef struct command_item_use
+{
+	BYTE header;
+	TItemPos Cell;
+} TPacketCGItemUse;
+
+typedef struct command_item_use_to_item
+{
+	BYTE header;
+	TItemPos Cell;
+	TItemPos TargetCell;
+} TPacketCGItemUseToItem;
+
+typedef struct command_item_drop
+{
+	BYTE header;
+	TItemPos Cell;
+	DWORD gold;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD cheque;
+#endif
+} TPacketCGItemDrop;
+
+typedef struct command_item_drop2
+{
+	BYTE header;
+	TItemPos Cell;
+	DWORD gold;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD cheque;
+#endif
+	WORD count;
+} TPacketCGItemDrop2;
+
+#if defined(__NEW_DROP_DIALOG__)
+typedef struct command_item_destroy
+{
+	BYTE header;
+	TItemPos Cell;
+} TPacketCGItemDestroy;
+#endif
+
+typedef struct command_item_move
+{
+	BYTE header;
+	TItemPos Cell;
+	TItemPos CellTo;
+	WORD count;
+} TPacketCGItemMove;
+
+typedef struct command_item_pickup
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGItemPickup;
+
+typedef struct command_quickslot_add
+{
+	BYTE header;
+	BYTE pos;
+	TQuickslot slot;
+} TPacketCGQuickslotAdd;
+
+typedef struct command_quickslot_del
+{
+	BYTE header;
+	BYTE pos;
+} TPacketCGQuickslotDel;
+
+typedef struct command_quickslot_swap
+{
+	BYTE header;
+	BYTE pos;
+	BYTE change_pos;
+} TPacketCGQuickslotSwap;
+
+enum
+{
+	SHOP_SUBHEADER_CG_END,
+	SHOP_SUBHEADER_CG_BUY,
+	SHOP_SUBHEADER_CG_SELL,
+	SHOP_SUBHEADER_CG_SELL2,
+};
+
+typedef struct command_shop_buy
+{
+	BYTE count;
+} TPacketCGShopBuy;
+
+typedef struct command_shop_sell
+{
+	WORD wPos;
+	WORD wCount;
+	BYTE bType;
+} TPacketCGShopSell;
+
+typedef struct command_shop
+{
+	BYTE header;
+	WORD subheader;
+} TPacketCGShop;
+
+typedef struct command_on_click
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGOnClick;
+
+enum
+{
+	EXCHANGE_SUBHEADER_CG_START, /* arg1 == vid of target character */
+	EXCHANGE_SUBHEADER_CG_ITEM_ADD, /* arg1 == position of item */
+	EXCHANGE_SUBHEADER_CG_ITEM_DEL, /* arg1 == position of item */
+	EXCHANGE_SUBHEADER_CG_ELK_ADD, /* arg1 == amount of gold */
+#if defined(__CHEQUE_SYSTEM__)
+	EXCHANGE_SUBHEADER_CG_CHEQUE_ADD, /* arg1 == amount of cheque */
+#endif
+	EXCHANGE_SUBHEADER_CG_ACCEPT, /* arg1 == not used */
+	EXCHANGE_SUBHEADER_CG_CANCEL, /* arg1 == not used */
+};
+
+typedef struct command_exchange
+{
+	BYTE header;
+	BYTE sub_header;
+	DWORD arg1;
+	BYTE arg2;
+	TItemPos Pos;
+} TPacketCGExchange;
+
+typedef struct command_position
+{
+	BYTE header;
+	BYTE position;
+} TPacketCGPosition;
+
+typedef struct command_script_answer
+{
+	BYTE header;
+	BYTE answer;
+	//char file[32 + 1];
+	//BYTE answer[16 + 1];
+} TPacketCGScriptAnswer;
+
+typedef struct command_script_button
+{
+	BYTE header;
+	unsigned int idx;
+} TPacketCGScriptButton;
+
+typedef struct command_quest_input_string
+{
+	BYTE header;
+	char msg[64 + 1];
+} TPacketCGQuestInputString;
+
+#if defined(__OX_RENEWAL__)
+typedef struct command_quest_input_long_string
+{
+	BYTE header;
+	char msg[128 + 1];
+} TPacketCGQuestInputLongString;
+#endif
+
+typedef struct command_quest_confirm
+{
+	BYTE header;
+	BYTE answer;
+	DWORD requestPID;
+} TPacketCGQuestConfirm;
+
+/*
+*    킷
+*/
+typedef struct packet_quest_confirm
+{
+	BYTE header;
+	char msg[128 + 1];
+	long timeout;
+	DWORD requestPID;
+} TPacketGCQuestConfirm;
+
+typedef struct packet_handshake
+{
+	BYTE bHeader;
+	DWORD dwHandshake;
+	DWORD dwTime;
+	long lDelta;
+} TPacketGCHandshake;
+
+enum EPhase
+{
+	PHASE_CLOSE,
+	PHASE_HANDSHAKE,
+	PHASE_LOGIN,
+	PHASE_SELECT,
+	PHASE_LOADING,
+	PHASE_GAME,
+	PHASE_DEAD,
+
+	PHASE_CLIENT_CONNECTING,
+	PHASE_DBCLIENT,
+	PHASE_P2P,
+	PHASE_AUTH,
+};
+
+typedef struct packet_phase
+{
+	BYTE header;
+	BYTE phase;
+} TPacketGCPhase;
+
+typedef struct packet_bindudp
+{
+	BYTE header;
+	DWORD addr;
+	WORD port;
+} TPacketGCBindUDP;
+
+typedef struct packet_login_success
+{
+	BYTE bHeader;
+	TSimplePlayer players[PLAYER_PER_ACCOUNT];
+	DWORD guild_id[PLAYER_PER_ACCOUNT];
+	char guild_name[PLAYER_PER_ACCOUNT][GUILD_NAME_MAX_LEN + 1];
+
+	DWORD handle;
+	DWORD random_key;
+} TPacketGCLoginSuccess;
+
+typedef struct packet_auth_success
+{
+	BYTE bHeader;
+	DWORD dwLoginKey;
+	BYTE bResult;
+	BOOL bState;
+} TPacketGCAuthSuccess;
+
+enum ELoginFailure
+{
+	LOGIN_FAILURE_NONE,
+	LOGIN_FAILURE_ALREADY,
+	LOGIN_FAILURE_NOID,
+	LOGIN_FAILURE_WRONGPWD,
+	LOGIN_FAILURE_FULL,
+	LOGIN_FAILURE_SHUTDOWN,
+	LOGIN_FAILURE_REPAIR,
+	LOGIN_FAILURE_BLOCK,
+	LOGIN_FAILURE_WRONGMAT,
+	LOGIN_FAILURE_QUIT,
+	LOGIN_FAILURE_BESAMEKEY,
+	LOGIN_FAILURE_NOTAVAIL,
+	LOGIN_FAILURE_BLKLOGIN,
+	LOGIN_FAILURE_WEBBLK,
+	LOGIN_FAILURE_BADSCLID,
+	LOGIN_FAILURE_AGELIMIT,
+	LOGIN_FAILURE_CONFIRM,
+	LOGIN_FAILURE_INACTIVE,
+	LOGIN_FAILURE_UNMIGRATION,
+	LOGIN_FAILURE_MPROCESSING,
+	LOGIN_FAILURE_LOCKED,
+	LOGIN_FAILURE_BACKENDERR,
+	LOGIN_FAILURE_INTEGRTING,
+	LOGIN_FAILURE_COUNTRYERR,
+	LOGIN_FAILURE_IOVATION,
+	LOGIN_FAILURE_TNTERR,
+	LOGIN_FAILURE_SERVER_CLOSED,
+	LOGIN_FAILURE_SERVER_GRADE,
+};
+
+typedef struct packet_login_failure
+{
+	BYTE header;
+	char szStatus[ACCOUNT_STATUS_MAX_LEN + 1];
+} TPacketGCLoginFailure;
+
+typedef struct packet_create_failure
+{
+	BYTE header;
+	BYTE bType;
+} TPacketGCCreateFailure;
+
+enum
+{
+	ADD_CHARACTER_STATE_DEAD = (1 << 0),
+	ADD_CHARACTER_STATE_SPAWN = (1 << 1),
+	ADD_CHARACTER_STATE_GUNGON = (1 << 2),
+	ADD_CHARACTER_STATE_KILLER = (1 << 3),
+	ADD_CHARACTER_STATE_PARTY = (1 << 4),
+};
+
+enum ECharacterEquipmentPart
+{
+	CHR_EQUIPPART_ARMOR,
+	CHR_EQUIPPART_WEAPON,
+	CHR_EQUIPPART_HEAD,
+	CHR_EQUIPPART_HAIR,
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	CHR_EQUIPPART_ACCE,
+#endif
+	CHR_EQUIPPART_AURA,
+
+	CHR_EQUIPPART_NUM,
+};
+
+typedef struct packet_add_char
+{
+	BYTE header;
+	DWORD dwVID;
+
+#if defined(__WJ_SHOW_MOB_INFO__)
+	DWORD dwLevel;
+	DWORD dwAIFlag;
+#endif
+
+	float angle;
+	long x;
+	long y;
+	long z;
+
+	BYTE bType;
+	WORD wRaceNum;
+#if defined(__RACE_SWAP__)
+	DWORD dwEventRaceNum;
+#endif
+	BYTE bMovingSpeed;
+	BYTE bAttackSpeed;
+
+	BYTE bStateFlag;
+	DWORD dwAffectFlag[3]; // 효
+} TPacketGCCharacterAdd;
+
+typedef struct packet_char_additional_info
+{
+	BYTE header;
+	DWORD dwVID;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	DWORD adwPart[CHR_EQUIPPART_NUM];
+	BYTE bEmpire;
+	DWORD dwGuildID;
+	DWORD dwLevel;
+#if defined(__CONQUEROR_LEVEL__)
+	DWORD dwConquerorLevel;
+#endif
+	short sAlignment; // 치
+	BYTE bPKMode;
+	DWORD dwMountVnum;
+#if defined(__QUIVER_SYSTEM__)
+	DWORD dwArrow;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	WORD wRefineElementAffectType;
+#endif
+#if defined(__GUILD_LEADER_GRADE_NAME__)
+	BYTE bGuildLeaderGrade;
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	BYTE bCharacterSize;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGCCharacterAdditionalInfo;
+
+typedef struct packet_update_char
+{
+	BYTE header;
+	DWORD dwVID;
+
+	DWORD adwPart[CHR_EQUIPPART_NUM];
+
+	BYTE bMovingSpeed;
+	BYTE bAttackSpeed;
+
+	BYTE bStateFlag;
+	DWORD dwAffectFlag[3];
+
+	DWORD dwGuildID;
+	short sAlignment;
+	DWORD dwLevel;
+#if defined(__CONQUEROR_LEVEL__)
+	DWORD dwConquerorLevel;
+#endif
+	BYTE bPKMode;
+	DWORD dwMountVnum;
+#if defined(__QUIVER_SYSTEM__)
+	DWORD dwArrow;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	WORD wRefineElementAffectType;
+#endif
+#if defined(__GUILD_LEADER_GRADE_NAME__)
+	BYTE bGuildLeaderGrade;
+#endif
+#if defined(__LEFT_SEAT__)
+	bool bLeftSeat;
+#endif
+} TPacketGCCharacterUpdate;
+
+typedef struct packet_del_char
+{
+	BYTE header;
+	DWORD id;
+} TPacketGCCharacterDelete;
+
+typedef struct packet_chat //  킷
+{
+	BYTE header;
+	WORD size;
+	BYTE type;
+	DWORD id;
+	BYTE bEmpire;
+#if defined(__LOCALE_CLIENT__)
+	bool bCanFormat;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+#if defined(__LOCALE_CLIENT__)
+	packet_chat() : bCanFormat(true) {}
+#endif
+} TPacketGCChat;
+
+typedef struct packet_whisper //  킷
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bType;
+	char szNameFrom[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(__LOCALE_CLIENT__)
+	bool bCanFormat;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+#if defined(__LOCALE_CLIENT__)
+	packet_whisper() : bCanFormat(true) {}
+#endif
+} TPacketGCWhisper;
+
+typedef struct packet_main_character
+{
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lx, ly, lz;
+	BYTE empire;
+	BYTE skill_group;
+} TPacketGCMainCharacter;
+
+// SUPPORT_BGM
+typedef struct packet_main_character3_bgm
+{
+	enum
+	{
+		MUSIC_NAME_LEN = 24,
+	};
+
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
+	char szBGMName[MUSIC_NAME_LEN + 1];
+	long lx, ly, lz;
+	BYTE empire;
+	BYTE skill_group;
+} TPacketGCMainCharacter3_BGM;
+
+typedef struct packet_main_character4_bgm_vol
+{
+	enum
+	{
+		MUSIC_NAME_LEN = 24,
+	};
+
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
+	char szBGMName[MUSIC_NAME_LEN + 1];
+	float fBGMVol;
+	long lx, ly, lz;
+	BYTE empire;
+	BYTE skill_group;
+} TPacketGCMainCharacter4_BGM_VOL;
+// END_OF_SUPPORT_BGM
+
+typedef struct packet_points
+{
+	BYTE bHeader;
+	POINT_VALUE lPoints[POINT_MAX_NUM];
+} TPacketGCPoints;
+
+typedef struct packet_skill_level
+{
+	BYTE bHeader;
+	TPlayerSkill skills[SKILL_MAX_NUM];
+} TPacketGCSkillLevel;
+
+typedef struct packet_point_change
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	POINT_TYPE wType;
+	POINT_VALUE lAmount;
+	POINT_VALUE lValue;
+} TPacketGCPointChange;
+
+typedef struct packet_stun
+{
+	BYTE header;
+	DWORD vid;
+} TPacketGCStun;
+
+typedef struct packet_dead
+{
+	BYTE header;
+	DWORD vid;
+	BYTE dialog_type;
+	long map_index;
+	packet_dead() : dialog_type(DEAD_DIALOG_NORMAL), map_index(0) {}
+} TPacketGCDead;
+
+typedef struct packet_item_set_empty
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwVnum;
+	DWORD dwCount;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemSetEmpty;
+
+typedef struct packet_item_set
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwVnum;
+	DWORD dwCount;
+	DWORD dwFlags;
+	DWORD dwAntiFlags;
+	bool bHighLight;
+#if defined(__SOUL_BIND_SYSTEM__)
+	long lSealDate;
+#endif
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemSet;
+
+typedef struct packet_item_del
+{
+	BYTE header;
+	BYTE pos;
+} TPacketGCItemDel;
+
+struct packet_item_use
+{
+	BYTE header;
+	TItemPos Cell;
+	DWORD ch_vid;
+	DWORD victim_vid;
+	DWORD vnum;
+};
+
+struct packet_item_move
+{
+	BYTE header;
+	TItemPos Cell;
+	TItemPos CellTo;
+};
+
+typedef struct packet_item_update
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwCount;
+#if defined(__SOUL_BIND_SYSTEM__)
+	long lSealDate;
+#endif
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemUpdate;
+
+typedef struct packet_item_ground_add
+{
+#if defined(__ITEM_DROP_RENEWAL__)
+	packet_item_ground_add()
+	{
+		memset(&alSockets, 0, sizeof(alSockets));
+		memset(&aAttrs, 0, sizeof(aAttrs));
+	}
+#endif
+
+	BYTE bHeader;
+	long lX, lY, lZ;
+	DWORD dwVID;
+	DWORD dwVnum;
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+
+#if defined(__ITEM_DROP_RENEWAL__)
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttrs[ITEM_ATTRIBUTE_MAX_NUM];
+#endif
+} TPacketGCItemGroundAdd;
+
+typedef struct packet_item_ownership
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCItemOwnership;
+
+typedef struct packet_item_ground_del
+{
+	BYTE bHeader;
+	DWORD dwVID;
+} TPacketGCItemGroundDel;
+
+struct packet_quickslot_add
+{
+	BYTE header;
+	BYTE pos;
+	TQuickslot slot;
+};
+
+struct packet_quickslot_del
+{
+	BYTE header;
+	BYTE pos;
+};
+
+struct packet_quickslot_swap
+{
+	BYTE header;
+	BYTE pos;
+	BYTE pos_to;
+};
+
+struct packet_motion
+{
+	BYTE header;
+	DWORD vid;
+	DWORD victim_vid;
+	WORD motion;
+};
+
+enum EPacketShopSubHeaders
+{
+	SHOP_SUBHEADER_GC_NONE,
+	SHOP_SUBHEADER_GC_START,
+	SHOP_SUBHEADER_GC_END,
+	SHOP_SUBHEADER_GC_UPDATE_ITEM,
+	SHOP_SUBHEADER_GC_UPDATE_PRICE,
+	SHOP_SUBHEADER_GC_OK,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY,
+	SHOP_SUBHEADER_GC_SOLDOUT,
+	SHOP_SUBHEADER_GC_INVENTORY_FULL,
+	SHOP_SUBHEADER_GC_INVALID_POS,
+	SHOP_SUBHEADER_GC_SOLD_OUT,
+	SHOP_SUBHEADER_GC_START_EX,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_BP,
+	SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY,
+#if defined(__MYSHOP_DECO__)
+	SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN,
+#endif
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN,
+	SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER,
+	SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING,
+	SHOP_SUBHEADER_GC_UNK_19,
+	SHOP_SUBHEADER_GC_UNK_20,
+	SHOP_SUBHEADER_GC_UNK_21,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW,
+#if defined(__SHOPEX_RENEWAL__)
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM,
+#endif
+};
+
+struct packet_shop_item
+{
+	DWORD dwVnum;
+	DWORD dwCount;
+	DWORD dwPrice;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD dwCheque;
+#endif
+	BYTE bDisplayPos;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+#if defined(__SHOPEX_RENEWAL__)
+	BYTE bPriceType;
+	DWORD dwPriceVnum;
+#endif
+	packet_shop_item()
+	{
+#if defined(__CHEQUE_SYSTEM__)
+		dwCheque = 0;
+#endif
+		memset(&alSockets, 0, sizeof(alSockets));
+		memset(&aAttr, 0, sizeof(aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		dwTransmutationVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		memset(&RefineElement, 0, sizeof(RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		memset(&aApplyRandom, 0, sizeof(aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+		bSetValue = 0;
+#endif
+#if defined(__SHOPEX_RENEWAL__)
+		bPriceType = SHOP_COIN_TYPE_GOLD;
+		dwPriceVnum = 0;
+#endif
+	}
+};
+
+typedef struct packet_shop_start
+{
+	DWORD owner_vid;
+#if defined(__MYSHOP_DECO__)
+	BYTE shop_tab_count;
+#endif
+#if defined(__MYSHOP_EXPANSION__)
+	struct packet_shop_item items[SHOP_HOST_ITEM_MAX];
+#else
+	struct packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
+#endif
+} TPacketGCShopStart;
+
+typedef struct packet_shop_start_ex //  TSubPacketShopTab* shop_tabs  .
+{
+	typedef struct sub_packet_shop_tab
+	{
+		char name[SHOP_TAB_NAME_MAX];
+		BYTE coin_type;
+		packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
+	} TSubPacketShopTab;
+	DWORD owner_vid;
+	BYTE shop_tab_count;
+} TPacketGCShopStartEx;
+
+typedef struct packet_shop_update_item
+{
+	BYTE pos;
+	struct packet_shop_item item;
+} TPacketGCShopUpdateItem;
+
+typedef struct packet_shop_update_price
+{
+	int iPrice;
+#if defined(__CHEQUE_SYSTEM__)
+	int iCheque;
+#endif
+} TPacketGCShopUpdatePrice;
+
+typedef struct packet_shop //  킷
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+} TPacketGCShop;
+
+typedef struct packet_exchange
+{
+	BYTE header;
+	BYTE sub_header;
+	BYTE is_me;
+	DWORD arg1; // vnum
+	TItemPos arg2; // cell
+	DWORD arg3; // count
+	TItemPos arg4;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetItem;
+#endif
+} TPacketGCExchange;
+
+enum EPacketTradeSubHeaders
+{
+	EXCHANGE_SUBHEADER_GC_START, /* arg1 == vid */
+	EXCHANGE_SUBHEADER_GC_ITEM_ADD, /* arg1 == vnum arg2 == pos arg3 == count */
+	EXCHANGE_SUBHEADER_GC_ITEM_DEL,
+	EXCHANGE_SUBHEADER_GC_GOLD_ADD, /* arg1 == gold */
+#if defined(__CHEQUE_SYSTEM__)
+	EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, /* arg1 == cheque */
+#endif
+	EXCHANGE_SUBHEADER_GC_ACCEPT, /* arg1 == accept */
+	EXCHANGE_SUBHEADER_GC_END, /* arg1 == not used */
+	EXCHANGE_SUBHEADER_GC_ALREADY, /* arg1 == not used */
+	EXCHANGE_SUBHEADER_GC_LESS_GOLD, /* arg1 == not used */
+#if defined(__CHEQUE_SYSTEM__)
+	EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, /* arg1 == not used */
+#endif
+};
+
+struct packet_position
+{
+	BYTE header;
+	DWORD vid;
+	BYTE position;
+};
+
+typedef struct packet_ping
+{
+	BYTE header;
+} TPacketGCPing;
+
+struct packet_script
+{
+	BYTE header;
+	WORD size;
+	BYTE skin;
+	WORD src_size;
+};
+
+typedef struct packet_change_speed
+{
+	BYTE header;
+	DWORD vid;
+	WORD moving_speed;
+} TPacketGCChangeSpeed;
+
+struct packet_mount
+{
+	BYTE header;
+	DWORD vid;
+	DWORD mount_vid;
+	BYTE pos;
+	DWORD x, y;
+};
+
+typedef struct packet_move
+{
+	BYTE bHeader;
+	BYTE bFunc;
+	BYTE bArg;
+	BYTE bRot;
+	DWORD dwVID;
+	long lX;
+	long lY;
+	DWORD dwTime;
+	DWORD dwDuration;
+} TPacketGCMove;
+
+// 
+typedef struct packet_ownership
+{
+	BYTE bHeader;
+	DWORD dwOwnerVID;
+	DWORD dwVictimVID;
+} TPacketGCOwnership;
+
+// 치 화 킷 bCount 큼 募 
+typedef struct packet_sync_position_element
+{
+	DWORD dwVID;
+	long lX;
+	long lY;
+} TPacketGCSyncPositionElement;
+
+// 치 화
+typedef struct packet_sync_position //  킷
+{
+	BYTE bHeader;
+	WORD wSize; //  = (wSize - sizeof(TPacketGCSyncPosition)) / sizeof(TPacketGCSyncPositionElement) 
+} TPacketGCSyncPosition;
+
+typedef struct packet_fly
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwStartVID;
+	DWORD dwEndVID;
+} TPacketGCCreateFly;
+
+typedef struct command_fly_targeting
+{
+	BYTE bHeader;
+	DWORD dwTargetVID;
+	long x, y;
+} TPacketCGFlyTargeting;
+
+typedef struct packet_fly_targeting
+{
+	BYTE bHeader;
+	DWORD dwShooterVID;
+	DWORD dwTargetVID;
+	long x, y;
+} TPacketGCFlyTargeting;
+
+typedef struct packet_shoot
+{
+	BYTE bHeader;
+	BYTE bType;
+} TPacketCGShoot;
+
+typedef struct packet_duel_start
+{
+	BYTE header;
+	WORD wSize; // DWORD 載?  = (wSize - sizeof(TPacketGCPVPList)) / 4
+} TPacketGCDuelStart;
+
+enum EPVPModes
+{
+	PVP_MODE_NONE,
+	PVP_MODE_AGREE,
+	PVP_MODE_FIGHT,
+	PVP_MODE_REVENGE
+};
+
+typedef struct packet_pvp
+{
+	BYTE bHeader;
+	DWORD dwVIDSrc;
+	DWORD dwVIDDst;
+	BYTE bMode; // 0 見 , 1見 
+} TPacketGCPVP;
+
+typedef struct command_use_skill
+{
+	BYTE bHeader;
+	DWORD dwVnum;
+	DWORD dwVID;
+} TPacketCGUseSkill;
+
+typedef struct command_target
+{
+	BYTE header;
+	DWORD dwVID;
+} TPacketCGTarget;
+
+typedef struct packet_target
+{
+	BYTE header;
+	DWORD dwVID;
+	BYTE bHPPercent;
+#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
+	int iMinHP;
+	int iMaxHP;
+	bool bAlliance;
+#endif
+#if defined(__ELEMENT_SYSTEM__)
+	BYTE bElement[MOB_ELEMENT_MAX_NUM];
+#endif
+	packet_target() : dwVID(0), bHPPercent(0)
+	{
+#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
+		iMinHP = 0;
+		iMaxHP = 0;
+		bAlliance = false;
+#endif
+#if defined(__ELEMENT_SYSTEM__)
+		memset(&bElement, 0, sizeof(bElement));
+#endif
+	}
+} TPacketGCTarget;
+
+#if defined(__SEND_TARGET_INFO__)
+typedef struct SPacketGCTargetDropInfo
+{
+	DWORD dwVnum;
+	BYTE bCount;
+} TPacketGCTargetDropInfo;
+
+typedef struct SPacketGCTargetInfo
+{
+	BYTE bHeader;
+	WORD wSize;
+	DWORD dwRaceVnum;
+	DWORD dwVID;
+	bool bDropMetinStone;
+} TPacketGCTargetInfo;
+
+typedef struct SPacketCGTargetInfo
+{
+	BYTE bHeader;
+	DWORD dwVID;
+} TPacketCGTargetInfo;
+#endif
+
+typedef struct packet_warp
+{
+	BYTE bHeader;
+	long lX;
+	long lY;
+	long lAddr;
+	WORD wPort;
+} TPacketGCWarp;
+
+typedef struct command_warp
+{
+	BYTE bHeader;
+} TPacketCGWarp;
+
+struct packet_quest_info
+{
+	BYTE header;
+	WORD size;
+	WORD index;
+#if defined(__QUEST_RENEWAL__)
+	BYTE type;
+	bool is_confirmed;
+#endif
+	BYTE flag;
+};
+
+typedef struct command_safebox_checkout
+{
+	BYTE bHeader;
+	BYTE bSafePos;
+	TItemPos ItemPos;
+} TPacketCGSafeboxCheckout;
+
+typedef struct command_safebox_checkin
+{
+	BYTE bHeader;
+	BYTE bSafePos;
+	TItemPos ItemPos;
+} TPacketCGSafeboxCheckin;
+
+///////////////////////////////////////////////////////////////////////////////////
+// Messenger
+
+enum EMessengerConnectedState
+{
+	MESSENGER_CONNECTED_STATE_OFFLINE,
+	MESSENGER_CONNECTED_STATE_ONLINE
+};
+
+enum EGCMessengerSubHeader
+{
+	MESSENGER_SUBHEADER_GC_LIST,
+	MESSENGER_SUBHEADER_GC_LOGIN,
+	MESSENGER_SUBHEADER_GC_LOGOUT,
+	MESSENGER_SUBHEADER_GC_INVITE,
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	MESSENGER_SUBHEADER_GC_BLOCK_LIST,
+	MESSENGER_SUBHEADER_GC_BLOCK_LOGIN,
+	MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT,
+#endif
+#if defined(__MESSENGER_GM__)
+	MESSENGER_SUBHEADER_GC_GM_LIST,
+	MESSENGER_SUBHEADER_GC_GM_LOGIN,
+	MESSENGER_SUBHEADER_GC_GM_LOGOUT,
+#endif
+};
+
+typedef struct packet_messenger
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMessenger;
+
+typedef struct packet_messenger_list
+{
+	packet_messenger_list() :
+		bConnected(MESSENGER_CONNECTED_STATE_OFFLINE)
+#if defined(__MESSENGER_DETAILS__)
+		, dwLastPlayTime(0)
+#endif
+	{
+	}
+	BYTE bConnected;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(__MESSENGER_DETAILS__)
+	DWORD dwLastPlayTime;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1]{};
+#endif
+#endif
+} TPacketGCMessengerList;
+
+enum ECGMessengerSubHeader
+{
+	MESSENGER_SUBHEADER_CG_ADD_BY_VID,
+	MESSENGER_SUBHEADER_CG_ADD_BY_NAME,
+	MESSENGER_SUBHEADER_CG_REMOVE,
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID,
+	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME,
+	MESSENGER_SUBHEADER_CG_BLOCK_REMOVE,
+#endif
+};
+
+typedef struct command_messenger
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGMessenger;
+
+typedef struct command_messenger_add_by_vid
+{
+	DWORD dwVID;
+} TPacketCGMessengerAddByVID;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+typedef struct command_messenger_add_block_by_vid
+{
+	DWORD dwVID;
+} TPacketCGMessengerAddBlockByVID;
+#endif
+
+///////////////////////////////////////////////////////////////////////////////////
+// Party
+typedef struct command_party_parameter
+{
+	BYTE bHeader;
+	BYTE bDistributeMode;
+} TPacketCGPartyParameter;
+
+typedef struct paryt_parameter
+{
+	BYTE bHeader;
+	BYTE bDistributeMode;
+} TPacketGCPartyParameter;
+
+typedef struct packet_party_add
+{
+	BYTE header;
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	long mapIdx;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	BYTE channel;
+#endif
+} TPacketGCPartyAdd;
+
+typedef struct command_party_invite
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGPartyInvite;
+
+typedef struct packet_party_invite
+{
+	BYTE header;
+	DWORD leader_vid;
+} TPacketGCPartyInvite;
+
+typedef struct command_party_invite_answer
+{
+	BYTE header;
+	DWORD leader_vid;
+	BYTE accept;
+} TPacketCGPartyInviteAnswer;
+
+typedef struct packet_party_update
+{
+	BYTE header;
+	DWORD pid;
+	BYTE role;
+	BYTE percent_hp;
+	short affects[7];
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	long x;
+	long y;
+#endif
+} TPacketGCPartyUpdate;
+
+typedef struct packet_party_remove
+{
+	BYTE header;
+	DWORD pid;
+} TPacketGCPartyRemove;
+
+typedef struct packet_party_link
+{
+	BYTE header;
+	DWORD pid;
+	DWORD vid;
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	long mapIdx;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	BYTE channel;
+#endif
+} TPacketGCPartyLink;
+
+typedef struct command_party_remove
+{
+	BYTE header;
+	DWORD pid;
+} TPacketCGPartyRemove;
+
+typedef struct command_party_set_state
+{
+	BYTE header;
+	DWORD pid;
+	BYTE byRole;
+	BYTE flag;
+} TPacketCGPartySetState;
+
+enum
+{
+	PARTY_SKILL_HEAL = 1,
+	PARTY_SKILL_WARP = 2
+};
+
+typedef struct command_party_use_skill
+{
+	BYTE header;
+	BYTE bySkillIndex;
+	DWORD vid;
+} TPacketCGPartyUseSkill;
+
+typedef struct packet_safebox_size
+{
+	BYTE bHeader;
+	BYTE bSize;
+} TPacketCGSafeboxSize;
+
+typedef struct packet_safebox_wrong_password
+{
+	BYTE bHeader;
+} TPacketCGSafeboxWrongPassword;
+
+typedef struct command_empire
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+} TPacketCGEmpire;
+
+typedef struct packet_empire
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+} TPacketGCEmpire;
+
+enum
+{
+	SAFEBOX_MONEY_STATE_SAVE,
+	SAFEBOX_MONEY_STATE_WITHDRAW,
+};
+
+typedef struct command_safebox_money
+{
+	BYTE bHeader;
+	BYTE bState;
+	long lMoney;
+} TPacketCGSafeboxMoney;
+
+typedef struct packet_safebox_money_change
+{
+	BYTE bHeader;
+	long lMoney;
+} TPacketGCSafeboxMoneyChange;
+
+// Guild
+enum
+{
+	GUILD_SUBHEADER_GC_LOGIN,
+	GUILD_SUBHEADER_GC_LOGOUT,
+	GUILD_SUBHEADER_GC_LIST,
+	GUILD_SUBHEADER_GC_GRADE,
+	GUILD_SUBHEADER_GC_ADD,
+	GUILD_SUBHEADER_GC_REMOVE,
+	GUILD_SUBHEADER_GC_GRADE_NAME,
+	GUILD_SUBHEADER_GC_GRADE_AUTH,
+	GUILD_SUBHEADER_GC_INFO,
+	GUILD_SUBHEADER_GC_COMMENTS,
+	GUILD_SUBHEADER_GC_CHANGE_EXP,
+	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE,
+	GUILD_SUBHEADER_GC_SKILL_INFO,
+	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL,
+	GUILD_SUBHEADER_GC_GUILD_INVITE,
+	GUILD_SUBHEADER_GC_WAR,
+	GUILD_SUBHEADER_GC_GUILD_NAME,
+	GUILD_SUBHEADER_GC_GUILD_WAR_LIST,
+	GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST,
+	GUILD_SUBHEADER_GC_WAR_SCORE,
+	GUILD_SUBHEADER_GC_MONEY_CHANGE,
+};
+
+enum GUILD_SUBHEADER_CG
+{
+	GUILD_SUBHEADER_CG_ADD_MEMBER,
+	GUILD_SUBHEADER_CG_REMOVE_MEMBER,
+	GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME,
+	GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY,
+	GUILD_SUBHEADER_CG_OFFER,
+	GUILD_SUBHEADER_CG_POST_COMMENT,
+	GUILD_SUBHEADER_CG_DELETE_COMMENT,
+	GUILD_SUBHEADER_CG_REFRESH_COMMENT,
+	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE,
+	GUILD_SUBHEADER_CG_USE_SKILL,
+	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL,
+	GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER,
+	GUILD_SUBHEADER_CG_CHARGE_GSP,
+	GUILD_SUBHEADER_CG_DEPOSIT_MONEY,
+	GUILD_SUBHEADER_CG_WITHDRAW_MONEY,
+};
+
+typedef struct packet_guild
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+} TPacketGCGuild;
+
+typedef struct packet_guild_name_t
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+	DWORD guildID;
+	char guildName[GUILD_NAME_MAX_LEN];
+} TPacketGCGuildName;
+
+typedef struct packet_guild_war
+{
+	DWORD dwGuildSelf;
+	DWORD dwGuildOpp;
+	BYTE bType;
+	BYTE bWarState;
+} TPacketGCGuildWar;
+
+typedef struct command_guild
+{
+	BYTE header;
+	BYTE subheader;
+} TPacketCGGuild;
+
+typedef struct command_guild_answer_make_guild
+{
+	BYTE header;
+	char guild_name[GUILD_NAME_MAX_LEN + 1];
+} TPacketCGAnswerMakeGuild;
+
+typedef struct command_guild_use_skill
+{
+	DWORD dwVnum;
+	DWORD dwPID;
+} TPacketCGGuildUseSkill;
+
+// Guild Mark
+typedef struct command_mark_login
+{
+	BYTE header;
+	DWORD handle;
+	DWORD random_key;
+} TPacketCGMarkLogin;
+
+typedef struct command_mark_upload
+{
+	BYTE header;
+	DWORD gid;
+	BYTE image[16 * 12 * 4];
+} TPacketCGMarkUpload;
+
+typedef struct command_mark_idxlist
+{
+	BYTE header;
+} TPacketCGMarkIDXList;
+
+typedef struct command_mark_crclist
+{
+	BYTE header;
+	BYTE imgIdx;
+	DWORD crclist[80];
+} TPacketCGMarkCRCList;
+
+typedef struct packet_mark_idxlist
+{
+	BYTE header;
+	DWORD bufSize;
+	WORD count;
+	// 悶 size * (WORD + WORD)큼  
+} TPacketGCMarkIDXList;
+
+typedef struct packet_mark_block
+{
+	BYTE header;
+	DWORD bufSize;
+	BYTE imgIdx;
+	DWORD count;
+	// 悶 64 x 48 x 횝크(4트) = 12288큼  
+} TPacketGCMarkBlock;
+
+typedef struct command_symbol_upload
+{
+	BYTE header;
+	WORD size;
+	DWORD guild_id;
+} TPacketCGGuildSymbolUpload;
+
+typedef struct command_symbol_crc
+{
+	BYTE header;
+	DWORD guild_id;
+	DWORD crc;
+	DWORD size;
+} TPacketCGSymbolCRC;
+
+typedef struct packet_symbol_data
+{
+	BYTE header;
+	WORD size;
+	DWORD guild_id;
+} TPacketGCGuildSymbolData;
+
+// Fishing
+typedef struct command_fishing
+{
+	BYTE header;
+	BYTE dir;
+} TPacketCGFishing;
+
+typedef struct packet_fishing
+{
+	BYTE header;
+	BYTE subheader;
+	DWORD info;
+	BYTE dir;
+} TPacketGCFishing;
+
+enum
+{
+	FISHING_SUBHEADER_GC_START,
+	FISHING_SUBHEADER_GC_STOP,
+	FISHING_SUBHEADER_GC_REACT,
+	FISHING_SUBHEADER_GC_SUCCESS,
+	FISHING_SUBHEADER_GC_FAIL,
+	FISHING_SUBHEADER_GC_FISH,
+};
+
+#if defined(__FISHING_GAME__)
+enum EFishingGameSubHeader
+{
+	FISHING_GAME_SUBHEADER_OPEN,
+	FISHING_GAME_SUBHEADER_GOAL,
+	FISHING_GAME_SUBHEADER_QUIT,
+};
+
+enum EFishingGameMisc
+{
+	FISHING_GAME_DURATION = 15,
+};
+
+typedef struct SPacketGCFishingGame
+{
+	SPacketGCFishingGame(const BYTE bSubHeader, const BYTE bLevel = 0) :
+		bHeader(HEADER_GC_FISHING_GAME),
+		bSubHeader(bSubHeader),
+		bLevel(bLevel)
+	{}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bLevel;
+} TPacketGCFishingGame;
+
+typedef struct SPacketCGFishingGame
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bGoals;
+} TPacketCGFishingGame;
+#endif
+
+typedef struct command_give_item
+{
+	BYTE byHeader;
+	DWORD dwTargetVID;
+	TItemPos ItemPos;
+	WORD wItemCount;
+} TPacketCGGiveItem;
+
+typedef struct SPacketCGHack
+{
+	BYTE bHeader;
+	char szBuf[255 + 1];
+} TPacketCGHack;
+
+// SubHeader - Dungeon
+enum
+{
+	DUNGEON_SUBHEADER_GC_TIME_ATTACK_START = 0,
+	DUNGEON_SUBHEADER_GC_DESTINATION_POSITION = 1,
+};
+
+typedef struct packet_dungeon
+{
+	BYTE bHeader;
+	WORD size;
+	BYTE subheader;
+} TPacketGCDungeon;
+
+typedef struct packet_dungeon_dest_position
+{
+	long x;
+	long y;
+} TPacketGCDungeonDestPosition;
+
+typedef struct SPacketGCShopSign
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+#if defined(__MYSHOP_DECO__)
+	BYTE bType;
+#endif
+} TPacketGCShopSign;
+
+typedef struct SPacketCGMyShop
+{
+	BYTE bHeader;
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+	BYTE bCount; // Count of TShopItemTable
+} TPacketCGMyShop;
+
+#if defined(__MYSHOP_DECO__)
+typedef struct SPacketGCMyPrivShopOpen
+{
+	BYTE bHeader;
+	bool bCashItem;
+	BYTE bTabCount;
+} TPacketGCMyPrivShopOpen;
+
+typedef struct SPacketCGMyShopDecoState
+{
+	BYTE bHeader;
+	BYTE bState;
+} TPacketCGMyShopDecoState;
+
+typedef struct SPacketCGMyShopDecoAdd
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwPolyVnum;
+} TPacketCGMyShopDecoAdd;
+#endif
+
+typedef struct SPacketGCTime
+{
+	BYTE bHeader;
+	time_t time;
+} TPacketGCTime;
+
+enum
+{
+	WALKMODE_RUN,
+	WALKMODE_WALK,
+};
+
+typedef struct SPacketGCWalkMode
+{
+	BYTE header;
+	DWORD vid;
+	BYTE mode;
+} TPacketGCWalkMode;
+
+typedef struct SPacketGCChangeSkillGroup
+{
+	BYTE header;
+	BYTE skill_group;
+} TPacketGCChangeSkillGroup;
+
+typedef struct SPacketCGRefine
+{
+	BYTE header;
+	BYTE pos;
+	BYTE type;
+} TPacketCGRefine;
+
+typedef struct SPacketCGRequestRefineInfo
+{
+	BYTE header;
+	BYTE pos;
+} TPacketCGRequestRefineInfo;
+
+typedef struct SPacketGCRefineInformaion
+{
+	BYTE header;
+	BYTE type;
+	BYTE pos;
+	DWORD src_vnum;
+	DWORD result_vnum;
+	WORD material_count;
+	int cost; // 奴 
+	int prob; // 확
+	TRefineMaterial materials[REFINE_MATERIAL_MAX_NUM];
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+} TPacketGCRefineInformation;
+
+struct TNPCPosition
+{
+	BYTE bType;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	long x;
+	long y;
+};
+
+typedef struct SPacketGCNPCPosition
+{
+	BYTE header;
+	WORD size;
+	WORD count;
+	// array of TNPCPosition
+} TPacketGCNPCPosition;
+
+enum ESpecialEffectType
+{
+	SE_TYPE_NORMAL,
+	SE_TYPE_POSITION,
+};
+
+typedef struct SPacketGCSpecialEffect
+{
+	BYTE bHeader;
+	BYTE bEffectNum;
+	DWORD dwVID;
+	BYTE bEffectType;
+	long xEffectPos, yEffectPos;
+	SPacketGCSpecialEffect()
+		: bEffectType(SE_TYPE_NORMAL)
+		, xEffectPos(0)
+		, yEffectPos(0)
+	{}
+} TPacketGCSpecialEffect;
+
+typedef struct SPacketCGChangeName
+{
+	BYTE header;
+	BYTE index;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGChangeName;
+
+typedef struct SPacketGCChangeName
+{
+	BYTE header;
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCChangeName;
+
+typedef struct command_client_version
+{
+	BYTE header;
+	char filename[32 + 1];
+	char timestamp[32 + 1];
+} TPacketCGClientVersion;
+
+typedef struct command_client_version2
+{
+	BYTE header;
+	char filename[32 + 1];
+	char timestamp[32 + 1];
+} TPacketCGClientVersion2;
+
+typedef struct packet_channel
+{
+	BYTE header;
+	BYTE channel;
+} TPacketGCChannel;
+
+typedef struct SEquipmentItemSet
+{
+	DWORD dwVnum;
+	BYTE bCount;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TEquipmentItemSet;
+
+typedef struct pakcet_view_equip
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	TEquipmentItemSet Equips[WEAR_MAX_NUM];
+} TPacketGCViewEquip;
+
+typedef struct
+{
+	DWORD dwID;
+	long x, y;
+	long width, height;
+	DWORD dwGuildID;
+} TLandPacketElement;
+
+typedef struct packet_land_list
+{
+	BYTE header;
+	WORD size;
+} TPacketGCLandList;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+	char szName[32 + 1];
+	DWORD dwVID;
+	BYTE bType;
+} TPacketGCTargetCreate;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+	long lX, lY;
+} TPacketGCTargetUpdate;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+} TPacketGCTargetDelete;
+
+typedef struct
+{
+	BYTE bHeader;
+	TPacketAffectElement elem;
+} TPacketGCAffectAdd;
+
+typedef struct
+{
+	BYTE bHeader;
+	DWORD dwType;
+	POINT_TYPE wApplyOn;
+} TPacketGCAffectRemove;
+
+typedef struct packet_lover_info
+{
+	BYTE header;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE love_point;
+} TPacketGCLoverInfo;
+
+typedef struct packet_love_point_update
+{
+	BYTE header;
+	BYTE love_point;
+} TPacketGCLovePointUpdate;
+
+// MINING
+typedef struct packet_dig_motion
+{
+	BYTE header;
+	DWORD vid;
+	DWORD target_vid;
+	BYTE count;
+} TPacketGCDigMotion;
+// END_OF_MINING
+
+// SCRIPT_SELECT_ITEM
+typedef struct command_script_select_item
+{
+	BYTE header;
+	DWORD selection;
+} TPacketCGScriptSelectItem;
+// END_OF_SCRIPT_SELECT_ITEM
+
+#if defined(__GEM_SHOP__)
+typedef struct command_select_item_ex
+{
+	BYTE bHeader;
+	DWORD dwItemPos;
+	BYTE bType;
+} TPacketCGSelectItemEx;
+#endif
+
+typedef struct packet_damage_info
+{
+	BYTE header;
+	DWORD dwVID;
+	BYTE flag;
+	int damage;
+} TPacketGCDamageInfo;
+
+typedef struct tag_GGSiege
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+	BYTE bTowerCount;
+} TPacketGGSiege;
+
+typedef struct SPacketGGMonarchTransfer
+{
+	BYTE bHeader;
+	DWORD dwTargetPID;
+	long x;
+	long y;
+} TPacketMonarchGGTransfer;
+
+typedef struct SPacketGGPCBangUpdate
+{
+	BYTE bHeader;
+	unsigned long ulPCBangID;
+} TPacketPCBangUpdate;
+
+typedef struct SPacketGGCheckAwakeness
+{
+	BYTE bHeader;
+} TPacketGGCheckAwakeness;
+
+typedef struct SPacketGCPanamaPack
+{
+	BYTE bHeader;
+	char szPackName[256];
+	BYTE abIV[32];
+} TPacketGCPanamaPack;
+
+// TODO : 틸 짱..킷  騁틉究 斂 킷 湄冗 Refactoring . 
+typedef struct SPacketGCHybridCryptKeys
+{
+	SPacketGCHybridCryptKeys() : m_pStream(NULL) {}
+	~SPacketGCHybridCryptKeys()
+	{
+		// GCC  NULL delete 巒 ? 求 構 NULL 체크 . ( 姆 隔 C++ 표瞞틈耉 --a )
+		if (m_pStream)
+		{
+			delete[] m_pStream;
+			m_pStream = NULL;
+		}
+	}
+
+	DWORD GetStreamSize()
+	{
+		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + KeyStreamLen;
+	}
+
+	BYTE* GetStreamData()
+	{
+		if (m_pStream)
+			delete[] m_pStream;
+
+		uDynamicPacketSize = (WORD)GetStreamSize();
+
+		m_pStream = new BYTE[uDynamicPacketSize];
+
+		memcpy(m_pStream, &bHeader, 1);
+		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
+		memcpy(m_pStream + 3, &KeyStreamLen, 4);
+
+		if (KeyStreamLen > 0)
+			memcpy(m_pStream + 7, pDataKeyStream, KeyStreamLen);
+
+		return m_pStream;
+	}
+
+	BYTE bHeader;
+	WORD uDynamicPacketSize; //  클 DynamicPacketHeader  磯 -_-;
+	int KeyStreamLen;
+	BYTE* pDataKeyStream;
+
+private:
+	BYTE* m_pStream;
+
+} TPacketGCHybridCryptKeys;
+
+typedef struct SPacketGCPackageSDB
+{
+	SPacketGCPackageSDB() : m_pDataSDBStream(NULL), m_pStream(NULL) {}
+	~SPacketGCPackageSDB()
+	{
+		if (m_pStream)
+		{
+			delete[] m_pStream;
+			m_pStream = NULL;
+		}
+	}
+
+	DWORD GetStreamSize()
+	{
+		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + iStreamLen;
+	}
+
+	BYTE* GetStreamData()
+	{
+		if (m_pStream)
+			delete[] m_pStream;
+
+		uDynamicPacketSize = static_cast<WORD>(GetStreamSize());
+
+		m_pStream = new BYTE[uDynamicPacketSize];
+
+		memcpy(m_pStream, &bHeader, 1);
+		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
+		memcpy(m_pStream + 3, &iStreamLen, 4);
+
+		if (iStreamLen > 0)
+			memcpy(m_pStream + 7, m_pDataSDBStream, iStreamLen);
+
+		return m_pStream;
+	}
+
+	BYTE bHeader;
+	WORD uDynamicPacketSize; //  클 DynamicPacketHeader  磯 -_-;
+	int iStreamLen;
+	BYTE* m_pDataSDBStream;
+
+private:
+	BYTE* m_pStream;
+
+} TPacketGCPackageSDB;
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+struct TPacketKeyAgreement
+{
+	static const int MAX_DATA_LEN = 256;
+	BYTE bHeader;
+	WORD wAgreedLength;
+	WORD wDataLength;
+	BYTE data[MAX_DATA_LEN];
+};
+
+struct TPacketKeyAgreementCompleted
+{
+	BYTE bHeader;
+	BYTE data[3]; // dummy (not used)
+};
+#endif
+
+#define MAX_EFFECT_FILE_NAME 128
+typedef struct SPacketGCSpecificEffect
+{
+	BYTE header;
+	DWORD vid;
+	char effect_file[MAX_EFFECT_FILE_NAME];
+} TPacketGCSpecificEffect;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+// 혼
+enum EDragonSoulRefineWindowRefineType
+{
+	DragonSoulRefineWindow_UPGRADE,
+	DragonSoulRefineWindow_IMPROVEMENT,
+	DragonSoulRefineWindow_REFINE,
+};
+
+enum EPacketCGDragonSoulSubHeaderType
+{
+	DS_SUB_HEADER_OPEN,
+	DS_SUB_HEADER_CLOSE,
+	DS_SUB_HEADER_DO_REFINE_GRADE,
+	DS_SUB_HEADER_DO_REFINE_STEP,
+	DS_SUB_HEADER_DO_REFINE_STRENGTH,
+	DS_SUB_HEADER_REFINE_FAIL,
+	DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE,
+	DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL,
+	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY,
+	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL,
+	DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL,
+	DS_SUB_HEADER_REFINE_SUCCEED,
+#if defined(__DS_CHANGE_ATTR__)
+	DS_SUB_HEADER_OPEN_CHANGE_ATTR,
+	DS_SUB_HEADER_DO_CHANGE_ATTR,
+#endif
+};
+
+typedef struct SPacketCGDragonSoulRefine
+{
+	SPacketCGDragonSoulRefine() : header(HEADER_CG_DRAGON_SOUL_REFINE)
+	{}
+	BYTE header;
+	BYTE bSubType;
+	TItemPos ItemGrid[DRAGON_SOUL_REFINE_GRID_SIZE];
+} TPacketCGDragonSoulRefine;
+
+typedef struct SPacketGCDragonSoulRefine
+{
+	SPacketGCDragonSoulRefine() : header(HEADER_GC_DRAGON_SOUL_REFINE)
+	{}
+	BYTE header;
+	BYTE bSubType;
+	TItemPos Pos;
+} TPacketGCDragonSoulRefine;
+#endif
+
+typedef struct SPacketCGStateCheck
+{
+	BYTE header;
+	unsigned long key;
+	unsigned long index;
+} TPacketCGStateCheck;
+
+typedef struct SPacketGCStateCheck
+{
+	BYTE header;
+	unsigned long key;
+	unsigned long index;
+	unsigned char state;
+} TPacketGCStateCheck;
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+enum ESubHeaderGCAcceRefine
+{
+	ACCE_REFINE_SUBHEADER_GC_CLOSE,
+	ACCE_REFINE_SUBHEADER_GC_OPEN,
+	ACCE_REFINE_SUBHEADER_GC_SET_ITEM,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_RIGHT
+};
+
+typedef struct SSubPacketGCAcceRefineOpenClose
+{
+	BYTE bType;
+	bool bServerClose;
+} TSubPacketGCAcceRefineOpenClose;
+
+typedef struct SSubPacketGCAcceRefineSetItem
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	TItemData Item;
+} TSubPacketGCAcceRefineSetItem;
+
+typedef struct SSubPacketGCAcceRefineClearSlot
+{
+	BYTE bSlotIndex;
+} TSubPacketGCAcceRefineClearSlot;
+
+enum ESubHeaderCGAcceRefine
+{
+	ACCE_REFINE_SUBHEADER_CG_CHECKIN,
+	ACCE_REFINE_SUBHEADER_CG_CHECKOUT,
+	ACCE_REFINE_SUBHEADER_CG_ACCEPT,
+	ACCE_REFINE_SUBHEADER_CG_CANCEL
+};
+
+typedef struct SSubPacketCGAcceRefineCheckIn
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAcceRefineCheckIn;
+
+typedef struct SSubPacketCGAcceRefineCheckOut
+{
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAcceRefineCheckOut;
+
+typedef struct SSubPacketCGAcceRefineAccept
+{
+	BYTE bType;
+} TSubPacketCGAcceRefineAccept;
+
+typedef struct SPacketGCAcceRefine
+{
+	SPacketGCAcceRefine() : bHeader(HEADER_GC_ACCE_REFINE) {}
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCAcceRefine;
+
+typedef struct SPacketCGAcceRefine
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketCGAcceRefine;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+enum ESubHeaderGCAuraRefine
+{
+	AURA_REFINE_SUBHEADER_GC_CLOSE,
+	AURA_REFINE_SUBHEADER_GC_OPEN,
+	AURA_REFINE_SUBHEADER_GC_SET_ITEM,
+	AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT,
+	AURA_REFINE_SUBHEADER_GC_CLEAR_ALL,
+	AURA_REFINE_SUBHEADER_GC_INFO
+};
+
+typedef struct SSubPacketGCAuraRefineOpenClose
+{
+	BYTE bType;
+	bool bServerClose;
+} TSubPacketGCAuraRefineOpenClose;
+
+typedef struct SSubPacketGCAuraRefineSetItem
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	TItemData Item;
+} TSubPacketGCAuraRefineSetItem;
+
+typedef struct SSubPacketGCAuraRefineClearSlot
+{
+	BYTE bSlotIndex;
+} TSubPacketGCAuraRefineClearSlot;
+
+typedef struct SSubPacketGCAuraRefineInfo
+{
+	BYTE bInfoType;
+	BYTE bInfoLevel;
+	BYTE bInfoExpPercent;
+} TSubPacketGCAuraRefineInfo;
+
+enum ESubHeaderCGAuraRefine
+{
+	AURA_REFINE_SUBHEADER_CG_CHECKIN,
+	AURA_REFINE_SUBHEADER_CG_CHECKOUT,
+	AURA_REFINE_SUBHEADER_CG_ACCEPT,
+	AURA_REFINE_SUBHEADER_CG_CANCEL
+};
+
+typedef struct SSubPacketCGAuraRefineCheckIn
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAuraRefineCheckIn;
+
+typedef struct SSubPacketCGAuraRefineCheckOut
+{
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAuraRefineCheckOut;
+
+typedef struct SSubPacketCGAuraRefineAccept
+{
+	BYTE bType;
+} TSubPacketCGAuraRefineAccept;
+
+typedef struct SPacketGCAuraRefine
+{
+	SPacketGCAuraRefine() : bHeader(HEADER_GC_AURA_REFINE) {}
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCAuraRefine;
+
+typedef struct SPacketCGAuraRefine
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketCGAuraRefine;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+enum EMiniGameCatchKingCGSubHeader
+{
+	CATCHKING_CG_START,
+	CATCHKING_CG_CLICK_HAND,
+	CATCHKING_CG_CLICK_CARD,
+	CATCHKING_CG_REWARD,
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+	CATCHKING_CG_REQUEST_QUEST_FLAG,
+#endif
+};
+
+enum EMiniGameCatchKingGCSubHeader
+{
+	CATCHKING_GC_START,
+	CATCHKING_GC_SET_CARD,
+	CATCHKING_GC_RESULT_FIELD,
+	CATCHKING_GC_SET_END_CARD,
+	CATCHKING_GC_REWARD,
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+	CATCHKING_GC_SET_CARD_PIECE_FLAG,
+	CATCHKING_GC_SET_CARD_FLAG,
+	CATCHKING_GC_SET_QUEST_FLAG,
+	CATCHKING_GC_NO_MORE_GAIN,
+#endif
+};
+
+typedef struct SCatchKingCard
+{
+	SCatchKingCard() { bIndex = 0; bIsExposed = false; }
+	SCatchKingCard(BYTE index, bool isExposed)
+	{
+		bIndex = index;
+		bIsExposed = isExposed;
+	}
+
+	BYTE bIndex;
+	bool bIsExposed;
+} TCatchKingCard;
+
+typedef struct SPacketCGMiniGameCatchKing
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSubArgument;
+} TPacketCGMiniGameCatchKing;
+
+typedef struct SPacketGCMiniGameCatchKing
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameCatchKing;
+
+typedef struct SPacketGCMiniGameCatchKingResult
+{
+	DWORD dwPoints;
+	BYTE bRowType;
+	BYTE bCardPos;
+	BYTE bCardValue;
+	bool bKeepFieldCard;
+	bool bDestroyHandCard;
+	bool bGetReward;
+	bool bIsFiveNearBy;
+} TPacketGCMiniGameCatchKingResult;
+
+typedef struct SPacketGCMiniGameCatchKingSetEndCard
+{
+	BYTE bCardPos;
+	BYTE bCardValue;
+} TPacketGCMiniGameCatchKingSetEndCard;
+
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+typedef struct SPacketGCMiniGameCatchKingQuestFlag
+{
+	WORD wPieceCount, wPackCount;
+	SPacketGCMiniGameCatchKingQuestFlag(WORD wPieceCount, WORD wPackCount) :
+		wPieceCount(wPieceCount), wPackCount(wPackCount) {}
+} TPacketGCMiniGameCatchKingQuestFlag;
+#endif
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+typedef struct SPacketCGSkillBookCombination
+{
+	BYTE bHeader;
+	BYTE bAction;
+	TItemPos CombItemGrid[SKILLBOOK_COMB_SLOT_MAX];
+} TPacketCGSkillBookCombination;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+enum class EPacketCGChangeLookSubHeader : BYTE
+{
+	ITEM_CHECK_IN,
+	ITEM_CHECK_OUT,
+	FREE_ITEM_CHECK_IN,
+	FREE_ITEM_CHECK_OUT,
+	ACCEPT,
+	CANCEL
+};
+
+typedef struct packet_set_changelook
+{
+	BYTE bHeader;
+	WORD wCell;
+	BYTE bSlotIndex;
+} TPacketGCChangeLookSet;
+
+typedef struct packet_changelook_del
+{
+	BYTE bHeader;
+	WORD wCell;
+	BYTE bSlotIndex;
+} TPacketGCChangeLookDel;
+
+typedef struct command_changelook
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+	TItemPos ItemPos;
+} TPacketCGChangeLook;
+#endif
+
+#if defined(__MAILBOX__)
+typedef struct packet_mailbox_process
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bArg1;
+	BYTE bArg2;
+} TPacketMailboxProcess;
+
+typedef struct packet_mailbox_process_all
+{
+	BYTE Index;
+} TPacketGCMailboxProcessAll;
+
+typedef struct packet_mailbox
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketGCMailBox;
+
+typedef struct packet_mailbox_write
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	char szTitle[25 + 1];
+	char szMessage[100 + 1];
+	TItemPos pos;
+	int iYang;
+	int iWon;
+} TPacketCGMailboxWrite;
+
+typedef struct packet_mailbox_write_confirm
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGMailboxWriteConfirm;
+#endif
+
+#if defined(__RANKING_SYSTEM__)
+typedef struct SPacketGCRanking
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bType;
+	BYTE bCategory;
+} TPacketGCRanking;
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+typedef struct packet_cg_item_combination
+{
+	BYTE Header;
+	short MediumIndex;
+	short BaseIndex;
+	short MaterialIndex;
+} TPacketCGItemCombination;
+
+typedef struct packet_cg_item_combination_cancel
+{
+	BYTE Header;
+} TPacketCGItemCombinationCancel;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+typedef struct packet_gc_item_select_attr
+{
+	BYTE bHeader;
+	TItemPos pItemPos;
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+} TPacketGCItemSelectAttr;
+
+typedef struct packet_cg_item_select_attr
+{
+	BYTE bHeader;
+	bool bNew;
+	TItemPos pItemPos;
+} TPacketCGItemSelectAttr;
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+typedef struct SPacketCGLootFilter
+{
+	BYTE header;
+	BYTE settings[ELootFilter::LOOT_FILTER_SETTINGS_MAX];
+} TPacketCGLootFilter;
+
+typedef struct SPacketGCLootFilter
+{
+	BYTE header;
+	bool enable;
+	DWORD vid;
+} TPacketGCLootFilter;
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+enum EMiniGameRumiCGSubHeader
+{
+	RUMI_CG_SUBHEADER_END,
+	RUMI_CG_SUBHEADER_START,
+	RUMI_CG_SUBHEADER_DECK_CARD_CLICK,
+	RUMI_CG_SUBHEADER_HAND_CARD_CLICK,
+	RUMI_CG_SUBHEADER_FIELD_CARD_CLICK,
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+	RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
+#endif
+};
+
+enum EMiniGameRumiGCSubHeader
+{
+	RUMI_GC_SUBHEADER_END,
+	RUMI_GC_SUBHEADER_START,
+	RUMI_GC_SUBHEADER_SET_DECK,
+	RUMI_GC_SUBHEADER_SET_SCORE,
+	RUMI_GC_SUBHEADER_MOVE_CARD,
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+	RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG,
+	RUMI_GC_SUBHEADER_SET_CARD_FLAG,
+	RUMI_GC_SUBHEADER_SET_QUEST_FLAG,
+	RUMI_GC_SUBHEADER_NO_MORE_GAIN,
+#endif
+};
+
+typedef struct SPacketCGMiniGameRumi
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BOOL bUseCard;
+	BYTE bIndex;
+} TPacketCGMiniGameRumi;
+
+typedef struct SPacketGCMiniGameRumiSetDeck
+{
+	BYTE bDeckCount;
+	SPacketGCMiniGameRumiSetDeck(BYTE bDeckCount) : bDeckCount(bDeckCount) {}
+} TPacketGCMiniGameRumiSetDeck;
+
+typedef struct SPacketGCMiniGameRumiMoveCard
+{
+	BYTE bSrcPos, bSrcIndex, bSrcColor, bSrcNumber;
+	BYTE bDstPos, bDstIndex, bDstColor, bDstNumber;
+	SPacketGCMiniGameRumiMoveCard() :
+		bSrcPos(0), bSrcIndex(0), bSrcColor(0), bSrcNumber(0),
+		bDstPos(0), bDstIndex(0), bDstColor(0), bDstNumber(0) {}
+} TPacketGCMiniGameRumiMoveCard;
+
+typedef struct SPacketGCMiniGameRumiSetScore
+{
+	WORD wScore, wTotalScore;
+	SPacketGCMiniGameRumiSetScore(WORD wScore, WORD wTotalScore) :
+		wScore(wScore), wTotalScore(wTotalScore) {}
+} TPacketGCMiniGameRumiSetScore;
+
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+typedef struct SPacketGCMiniGameRumiQuestFlag
+{
+	WORD wCardPieceCount, wCardCount;
+	SPacketGCMiniGameRumiQuestFlag(WORD wCardPieceCount, WORD wCardCount) :
+		wCardPieceCount(wCardPieceCount), wCardCount(wCardCount) {}
+} TPacketGCMiniGameRumiQuestFlag;
+#endif
+
+typedef struct SPacketGCMiniGameRumi
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameRumi;
+#endif
+
+#if defined(__LUCKY_BOX__)
+enum ELUCKY_BOX_ACTION
+{
+	LUCKY_BOX_ACTION_RETRY,
+	LUCKY_BOX_ACTION_RECEIVE,
+};
+
+typedef struct SPacketCGLuckyBox
+{
+	BYTE bHeader;
+	BYTE bAction;
+} TPacketCGLuckyBox;
+
+typedef struct SPacketGCLuckyBox
+{
+	BYTE bHeader;
+	DWORD dwVNum;
+	BYTE bCount;
+	int iNeedMoney;
+	WORD wSlotIndex;
+} TPacketGCLuckyBox;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+enum EAttr67AddSubHeader
+{
+	SUBHEADER_CG_ATTR67_ADD_CLOSE,
+	SUBHEADER_CG_ATTR67_ADD_OPEN,
+	SUBHEADER_CG_ATTR67_ADD_REGIST,
+};
+
+typedef struct SPacketCGAttr67Add
+{
+	BYTE byHeader;
+	BYTE bySubHeader;
+	TAttr67AddData Attr67AddData;
+} TPacketCGAttr67Add;
+#endif
+
+#if defined(__GEM_SHOP__)
+enum EGemShopSubHeader : BYTE
+{
+	SUBHEADER_GEM_SHOP_CLOSE,
+	SUBHEADER_GEM_SHOP_OPEN,
+	SUBHEADER_GEM_SHOP_BUY,
+	SUBHEADER_GEM_SHOP_SLOT_ADD,
+	SUBHEADER_GEM_SHOP_REFRESH,
+	SUBHEADER_GEM_SHOP_MAX,
+};
+
+typedef struct SPacketGCGemShop
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketGCGemShop;
+
+typedef struct SPacketGCGemShopProcess
+{
+	SPacketGCGemShopProcess(const BYTE c_bSubHeader) :
+		bHeader(HEADER_GC_GEM_SHOP_PROCESS),
+		bSubHeader(c_bSubHeader),
+		bSlotIndex(GEM_SHOP_SLOT_COUNT),
+		bEnable(false)
+	{}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+	bool bEnable;
+} TPacketGCGemShopProcess;
+
+typedef struct command_gem_shop
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+} TPacketCGGemShop;
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+typedef struct SPacketCGExtendInven
+{
+	BYTE bHeader;
+	bool bUpgrade;
+	BYTE bIndex;
+} TPacketCGExtendInven;
+
+typedef struct SPacketGCExtendInven
+{
+	BYTE bHeader;
+	BYTE bStage;
+	WORD wMaxNum;
+} TPacketGCExtendInven;
+
+typedef struct SPacketGCExtendInvenItemUse
+{
+	BYTE bHeader;
+	BYTE bMsgResult;
+	BYTE bEnoughCount;
+} TPacketGCExtendInvenItemUse;
+#endif
+
+#if defined(__CLIENT_TIMER__)
+enum EClientTimerSubHeader
+{
+	CLIENT_TIMER_SUBHEADER_GC_SET,
+	CLIENT_TIMER_SUBHEADER_GC_DELETE
+};
+
+enum EClientTimer
+{
+	ECLIENT_TIMER_END_TIME,
+	ECLIENT_TIMER_ALARM_SECOND,
+	ECLIENT_TIMER_MAX
+};
+
+typedef struct SPacketGCClientTimer
+{
+	SPacketGCClientTimer(const BYTE _bSubHeader)
+		: bHeader(HEADER_GC_CLIENT_TIMER), bSubHeader(_bSubHeader)
+	{
+		memset(&dwData, 0, sizeof(dwData));
+	};
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwData[ECLIENT_TIMER_MAX];
+} TPacketGCClientTimer;
+#endif
+
+enum EEmoteSubHeader
+{
+	SUBHEADER_EMOTE_ADD,
+	SUBHEADER_EMOTE_CLEAR,
+	SUBHEADER_EMOTE_MOTION,
+	SUBHEADER_EMOTE_ICON,
+};
+
+typedef struct SPacketGCEmote
+{
+	SPacketGCEmote() : bHeader(HEADER_GC_EMOTE) {}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwEmoteVnum;
+	DWORD dwDuration;
+	DWORD dwMainVID, dwTargetVID;
+} TPacketGCEmote;
+
+#if defined(__CUBE_RENEWAL__)
+enum ECubeSubHeader
+{
+	SUBHEADER_GC_CUBE_OPEN = 0,
+	SUBHEADER_GC_CUBE_CLOSE,
+	SUBHEADER_GC_CUBE_RESULT,
+
+	SUBHEADER_CG_CUBE_CLOSE = 0,
+	SUBHEADER_CG_CUBE_MAKE,
+};
+
+typedef struct SPacketGCCube
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwNPCVnum;
+	BOOL bSuccess;
+	DWORD dwFileCrc;
+} TPacketGCCube;
+
+typedef struct SPacketCGCube
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	UINT iCubeIndex;
+	UINT iQuantity;
+	INT iImproveItemPos;
+	DWORD dwFileCrc;
+} TPacketCGCube;
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+enum ESubPacketGCSnowflakeStickEvent
+{
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_SNOW_BALL,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_TREE_BRANCH,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_SNOW_BALL_MAX,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_TREE_BRANCH_MAX,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_STICK_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_PET_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_MOUNT_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_RANK_BUFF,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_SNOWFLAKE_BUFF,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE,
+};
+
+enum ESnowflakeStickEventQuestFlagType
+{
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_USE_STICK_COOLDOWN,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM,
+};
+
+typedef struct SPacketGCSnowflakeStickEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM];
+	SPacketGCSnowflakeStickEvent(const BYTE c_bSubHeader)
+		: bHeader(HEADER_GC_SNOWFLAKE_STICK_EVENT), bSubHeader(c_bSubHeader)
+	{;
+		memset(&dwValue, 0, sizeof(dwValue));
+	}
+} TPacketGCSnowflakeStickEvent;
+
+enum ESubPacketCGSnowflakeStickEvent
+{
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT
+};
+
+typedef struct SPacketCGSnowflakeStickEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGSnowflakeStickEvent;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+enum EPacketGCRefineElement
+{
+	REFINE_ELEMENT_GC_OPEN,
+	REFINE_ELEMENT_GC_RESULT
+};
+
+enum EPacketCGRefineElement
+{
+	REFINE_ELEMENT_CG_CLOSE,
+	REFINE_ELEMENT_CG_REFINE,
+};
+
+typedef struct SPacketGCRefineElement
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bRefineType;
+	BYTE bResult;
+	TItemPos SrcPos;
+	TItemPos DestPos;
+} TPacketGCRefineElement;
+
+typedef struct SPacketCGRefineElement
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	WORD wChangeElement;
+} TPacketCGRefineElement;
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+enum EMiniGameYutnoriGCSubHeader
+{
+	YUTNORI_GC_SUBHEADER_START,
+	YUTNORI_GC_SUBHEADER_STOP,
+	YUTNORI_GC_SUBHEADER_SET_PROB,
+	YUTNORI_GC_SUBHEADER_THROW,
+	YUTNORI_GC_SUBHEADER_MOVE,
+	YUTNORI_GC_SUBHEADER_AVAILABLE_AREA,
+	YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT,
+	YUTNORI_GC_SUBHEADER_SET_SCORE,
+	YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT,
+	YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN,
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+	YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG,
+	YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG,
+	YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG,
+	YUTNORI_GC_SUBHEADER_NO_MORE_GAIN,
+#endif
+};
+
+enum EMiniGameYutnoriCGSubHeader
+{
+	YUTNORI_CG_SUBHEADER_START,
+	YUTNORI_CG_SUBHEADER_GIVEUP,
+	YUTNORI_CG_SUBHEADER_SET_PROB,
+	YUTNORI_CG_SUBHEADER_CLICK_CHAR,
+	YUTNORI_CG_SUBHEADER_THROW,
+	YUTNORI_CG_SUBHEADER_MOVE,
+	YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION,
+	YUTNORI_CG_SUBHEADER_REWARD,
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+	YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
+#endif
+};
+
+typedef struct SPacketCGMiniGameYutnori
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bArgument;
+} TPacketCGMiniGameYutnori;
+
+typedef struct SPacketGCMiniGameYutnori
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameYutnori;
+
+typedef struct SPacketGCMiniGameYutnoriSetProb
+{
+	BYTE bProbIndex;
+	SPacketGCMiniGameYutnoriSetProb(BYTE bProbIndex)
+		: bProbIndex(bProbIndex) {}
+} TPacketGCMiniGameYutnoriSetProb;
+
+typedef struct SPacketGCMiniGameYutnoriThrow
+{
+	bool bPC;
+	BYTE bYut;
+	SPacketGCMiniGameYutnoriThrow(bool bPC, BYTE bYut)
+		: bPC(bPC), bYut(bYut) {}
+} TPacketGCMiniGameYutnoriThrow;
+
+typedef struct SPacketGCMiniGameYutnoriMove
+{
+	bool bPC;
+	BYTE bUnitIndex;
+	bool bIsCatch;
+	BYTE bStartIndex;
+	BYTE bDestIndex;
+	SPacketGCMiniGameYutnoriMove(bool bPC, BYTE bUnitIndex, bool bIsCatch, BYTE bStartIndex, BYTE bDestIndex)
+		: bPC(bPC), bUnitIndex(bUnitIndex), bIsCatch(bIsCatch), bStartIndex(bStartIndex), bDestIndex(bDestIndex) {}
+} TPacketGCMiniGameYutnoriMove;
+
+typedef struct SPacketGCMiniGameYutnoriAvailableArea
+{
+	BYTE bPlayerIndex;
+	BYTE bAvailableIndex;
+	SPacketGCMiniGameYutnoriAvailableArea(BYTE bPlayerIndex, BYTE bAvailableIndex)
+		: bPlayerIndex(bPlayerIndex), bAvailableIndex(bAvailableIndex) {}
+} TPacketGCMiniGameYutnoriAvailableArea;
+
+typedef struct SPacketGCMiniGameYutnoriPushCatchYut
+{
+	bool bPC;
+	BYTE bUnitIndex;
+	SPacketGCMiniGameYutnoriPushCatchYut(bool bPC, BYTE bUnitIndex)
+		: bPC(bPC), bUnitIndex(bUnitIndex) {}
+} TPacketGCMiniGameYutnoriPushCatchYut;
+
+typedef struct SPacketGCMiniGameYutnoriSetScore
+{
+	WORD wScore;
+	SPacketGCMiniGameYutnoriSetScore(WORD wScore)
+		: wScore(wScore) {}
+} TPacketGCMiniGameYutnoriSetScore;
+
+typedef struct SPacketGCMiniGameYutnoriSetRemainCount
+{
+	BYTE bRemainCount;
+	SPacketGCMiniGameYutnoriSetRemainCount(BYTE bRemainCount)
+		: bRemainCount(bRemainCount) {}
+} TPacketGCMiniGameYutnoriSetRemainCount;
+
+typedef struct SPacketGCMiniGameYutnoriPushNextTurn
+{
+	bool bPC;
+	BYTE bState;
+	SPacketGCMiniGameYutnoriPushNextTurn(bool bPC, BYTE bState)
+		: bPC(bPC), bState(bState) {}
+} TPacketGCMiniGameYutnoriPushNextTurn;
+
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+typedef struct SPacketGCMiniGameYutnoriQuestFlag
+{
+	WORD wYutPieceCount;
+	WORD wYutBoardCount;
+	SPacketGCMiniGameYutnoriQuestFlag(WORD wYutPieceCount, WORD wYutBoardCount)
+		: wYutPieceCount(wYutPieceCount), wYutBoardCount(wYutBoardCount) {}
+} TPacketGCMiniGameYutnoriQuestFlag;
+#endif
+#endif
+
+#if defined(__QUEST_REQUEST_EVENT__)
+typedef struct SPacketCGRequestEventQuest
+{
+	BYTE bHeader;
+	char szEventQuest[64 + 1];
+} TPacketCGRequestEventQuest;
+#endif
+
+#if defined(__LEFT_SEAT__)
+enum ELeftSeatCGSubHeader
+{
+	LEFT_SEAT_SET_WAIT_TIME_INDEX,
+	LEFT_SEAT_SET_LOGOUT_TIME_INDEX,
+	LEFT_SEAT_DISABLE_LOGOUT_STATE,
+};
+
+typedef struct SPacketCGLeftSeat
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bIndex;
+} TPacketCGLeftSeat;
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+enum EGuildDragonLairType
+{
+	GUILD_DRAGONLAIR_TYPE_RED,
+	GUILD_DRAGONLAIR_TYPE_BLUE,
+	GUILD_DRAGONLAIR_TYPE_GREEN,
+	GUILD_DRAGONLAIR_TYPE_MAX_NUM
+};
+
+enum EGuildDragonLairSubHeader
+{
+	GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING,
+#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
+	GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT,
+	GUILD_DRAGONLAIR_GC_SUBHEADER_START,
+	GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS,
+#endif
+};
+
+typedef struct SPacketGCGuildDragonLair
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+	BYTE bType;
+#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
+	DWORD dwFirstRankingTime;
+#endif
+} TPacketGCGuildDragonLair;
+
+typedef struct SPacketGCGuildDragonLairRanking
+{
+	BYTE bType;
+	DWORD dwGuildID;
+	char szGuildName[GUILD_NAME_MAX_LEN + 1];
+	BYTE bMemberCount;
+	DWORD dwTime;
+} TPacketGCGuildDragonLairRanking;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+enum EPacketGCMiniGameRouletteSubHeader
+{
+	ROULETTE_GC_OPEN,
+	ROULETTE_GC_START,
+	ROULETTE_GC_REQUEST,
+	ROULETTE_GC_END,
+	ROULETTE_GC_CLOSE
+};
+
+enum EPacketCGMiniGameRouletteSubHeader
+{
+	ROULETTE_CG_START,
+	ROULETTE_CG_REQUEST,
+	ROULETTE_CG_END,
+	ROULETTE_CG_CLOSE
+};
+
+typedef struct SPacketGCMiniGameRoulette
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bResult;
+	DWORD dwExpireTime;
+	struct
+	{
+		DWORD dwVnum;
+		BYTE bCount;
+	} ItemData[ROULETTE_ITEM_MAX];
+} TPacketGCMiniGameRoulette;
+
+typedef struct SPacketCGMiniGameRoulette
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGMiniGameRoulette;
+#endif
+
+#if defined(__FLOWER_EVENT__)
+enum EPacketGCFlowerEvent
+{
+	FLOWER_EVENT_SUBHEADER_GC_INFO_ALL,
+	FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
+	FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO,
+};
+
+typedef struct SPacketGCFlowerEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bChatType;
+	BYTE bShootType;
+	int aiShootCount[SHOOT_TYPE_MAX + 1];
+	SPacketGCFlowerEvent()
+		: bHeader(HEADER_GC_FLOWER_EVENT)
+		, bSubHeader(FLOWER_EVENT_SUBHEADER_GC_INFO_ALL)
+		, bChatType(FLOWER_EVENT_CHAT_TYPE_MAX)
+		, bShootType(SHOOT_TYPE_MAX)
+	{
+		memset(&aiShootCount, 0, sizeof(aiShootCount));
+	}
+} TPacketGCFlowerEvent;
+
+enum EPacketCGFlowerEvent
+{
+	FLOWER_EVENT_SUBHEADER_CG_INFO_ALL,
+	FLOWER_EVENT_SUBHEADER_CG_EXCHANGE
+};
+
+typedef struct SPacketCGFlowerEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bShootType;
+	BYTE bExchangeKey;
+}TPacketCGFlowerEvent;
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+typedef struct SPacketGGUpdateSellHistory {
+	BYTE		bHeader;
+	DWORD		pid;
+	TMySellHistory	sellItem;
+} TPacketGGUpdateSellHistory;
+#endif
+
+#ifdef __SHOP_SEARCH__
+typedef struct SPacketCGShopSearchByName {
+	BYTE	header;
+	char	itemName[ITEM_NAME_MAX_LEN + 1];
+	WORD	page;
+	BYTE	entryCountIdx;
+	BYTE	sortType;
+} TPacketCGShopSearchByName;
+
+typedef struct SPacketCGShopSearchByOptions {
+	BYTE	header;
+	TShopSearchOptions	options;
+	WORD	page;
+	BYTE	entryCountIdx;
+	BYTE	sortType;
+} TPacketCGShopSearchByOptions;
+
+typedef struct SPacketGCShopSearchResult {
+	BYTE	header;
+	WORD	size;
+	WORD	itemCount;
+	WORD	maxPageNum;
+} TPacketGCShopSearchResult;
+typedef struct SPacketCGShopSearchBuy {
+	BYTE	header;
+	TOfflineItemID	itemID;
+	DWORD	itemVnum;
+	int64_t	itemPrice;
+
+} TPacketCGShopSearchBuy;
+
+typedef struct SPacketGCShopSearchBuyResult {
+	BYTE	header;
+	BYTE	result;
+} TPacketGCShopSearchBuyResult;
+
+typedef struct SPacketCGShopSearchOwnerMessage {
+	BYTE	header;
+	DWORD	ownerID;
+} TPacketCGShopSearchOwnerMessage;
+
+typedef struct SPacketGCShopSearchOwnerMessage {
+	BYTE	header;
+	char	ownerName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCShopSearchOwnerMessage;
+
+typedef struct SPacketCGShopSearchRequestSoldInfo {
+	BYTE	header;
+	DWORD	itemVnum;
+} TPacketCGShopSearchRequestSoldInfo;
+
+typedef struct SPacketGCShopSearchSoldInfo {
+	BYTE	header;
+	WORD	size;
+	bool	results;
+} TPacketGCShopSearchSoldInfo;
+
+using TPacketGCEntity = struct SPacketGCEntity
+{
+	BYTE bHeader;
+	WORD wSize;
+};
+using TPacketEntityInfo = struct SPacketEntityInfo
+{
+	DWORD dwVID;
+	DWORD dwRaceVNum;
+	WORD wPart[CHR_EQUIPPART_NUM];
+	LONG xPos, yPos;
+};
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+typedef struct SPacketCGExtBattlePassAction
+{
+	BYTE bHeader;
+	BYTE bAction;
+} TPacketCGExtBattlePassAction;
+
+typedef struct SPacketCGExtBattlePassSendPremiumItem
+{
+	BYTE bHeader;
+	int iSlotIndex;
+} TPacketCGExtBattlePassSendPremiumItem;
+
+typedef struct SPacketGCExtBattlePassOpen
+{
+	BYTE bHeader;
+} TPacketGCExtBattlePassOpen;
+
+typedef struct SPacketGCExtBattlePassGeneralInfo
+{
+	BYTE bHeader;
+	BYTE bBattlePassType;
+	char	szSeasonName[64+1];
+	DWORD dwBattlePassID;
+	DWORD dwBattlePassStartTime;
+	DWORD dwBattlePassEndTime;
+} TPacketGCExtBattlePassGeneralInfo;
+
+typedef struct SPacketGCExtBattlePassMissionInfo
+{
+	BYTE bHeader;
+	WORD wSize;
+	WORD wRewardSize;
+	BYTE bBattlePassType;
+	DWORD dwBattlePassID;
+} TPacketGCExtBattlePassMissionInfo;
+
+typedef struct SPacketGCExtBattlePassMissionUpdate
+{
+	BYTE bHeader;
+	BYTE bBattlePassType;
+	BYTE bMissionIndex;
+	BYTE bMissionType;
+	DWORD dwNewProgress;
+} TPacketGCExtBattlePassMissionUpdate;
+
+typedef struct SPacketGCExtBattlePassRanking
+{
+	BYTE bHeader;
+	char	szPlayerName[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE bBattlePassType;
+	BYTE	bBattlePassID;
+	DWORD	dwStartTime;
+	DWORD	dwEndTime;
+} TPacketGCExtBattlePassRanking;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+enum EGrowthPetPoints
+{
+	POINT_UPBRINGING_PET_LEVEL,
+	POINT_UPBRINGING_PET_EXP,
+	POINT_UPBRINGING_PET_ITEM_EXP,
+	POINT_UPBRINGING_PET_NEXT_EXP,
+	POINT_UPBRINGING_PET_EVOL_LEVEL,
+	POINT_UPBRINGING_PET_HP,
+	POINT_UPBRINGING_PET_DEF_GRADE,
+	POINT_UPBRINGING_PET_SP,
+	POINT_UPBRINGING_DURATION,
+	POINT_UPBRINGING_MAX_DURATION,
+	POINT_UPBRINGING_BIRTHDAY,
+	
+	POINT_UPBRINGING_MAX_NUM
+};
+
+enum EGrowthPetSubheader
+{
+	SUBHEADER_PET_EGG_USE_SUCCESS,
+	SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME,
+	SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER,
+	SUBHEADER_PET_UNSUMMON,
+	SUBHEADER_PET_FEED_FAILED,
+	SUBHEADER_PET_FEED_SUCCESS,
+	SUBHEADER_PET_REVIVE_FAILED,
+	SUBHEADER_PET_REVIVE_SUCCESS,
+	SUBHEADER_PET_NAME_CHANGE_FAILED,
+	SUBHEADER_PET_NAME_CHANGE_SUCCESS,
+	SUBHEADER_PET_WINDOW_TYPE_INFO,
+	SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE,
+	SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED,
+};
+
+enum EGrowthPetWindow
+{
+	PET_WINDOW_HATCH,
+	PET_WINDOW_NAME_CHANGE,
+};
+
+typedef struct SPacketGCPet
+{
+	BYTE	header;
+	BYTE	subheader;
+} TPacketGCPet;
+
+typedef struct SPacketGCPetSet
+{
+	BYTE		header;
+	DWORD		dwID;
+	DWORD		dwSummonItemVnum;
+	char		szName[PET_NAME_MAX_SIZE + 1];
+	TPetSkill	aSkill[PET_SKILL_COUNT_MAX];
+	DWORD		dwPoints[POINT_UPBRINGING_MAX_NUM];
+} TPacketGCPetSet;
+
+typedef struct SPacketGCPetDelete
+{
+	BYTE		header;
+	DWORD		dwID;
+} TPacketGCPetDelete;
+
+typedef struct SPacketGCPetPointUpdate
+{
+	BYTE	header;
+	DWORD	dwID;
+	BYTE	bPoint;
+	DWORD	dwValue;
+} TPacketGCPetPointUpdate;
+
+typedef struct SPacketGCPetSummon
+{
+	BYTE		header;
+	DWORD		dwID;
+} TPacketGCPetSummon;
+
+typedef struct SPacketGCPetDetermineResult
+{
+	BYTE		header;
+	BYTE		type;
+} TPacketGCPetDetermineResult;
+
+typedef struct SPacketGCPetAttrChangeResult
+{
+	BYTE		header;
+	BYTE		type;
+	TItemPos	pos;
+} TPacketGCPetAttrChangeResult;
+
+typedef struct SPetSkillUpdatePacket
+{
+	bool	bLocked;
+	BYTE	bSkill;
+	BYTE	bLevel;
+	DWORD	dwCooltime;
+	BYTE	bSkillFormula1[PET_GROWTH_SKILL_LEVEL_MAX];
+	WORD	wSkillFormula2[PET_GROWTH_SKILL_LEVEL_MAX];
+	BYTE	bSkillFormula3[PET_GROWTH_SKILL_LEVEL_MAX];
+} TPetSkillUpdatePacket;
+
+typedef struct SPacketGCPetSkillCooltime
+{
+	BYTE		header;
+	DWORD		dwID;
+	BYTE		bSlot;
+	DWORD		dwCooltime;
+} TPacketGCPetSkillCooltime;
+
+typedef struct SPacketGCPetSkillUpdate
+{
+	BYTE		header;
+	DWORD		dwID;
+	TPetSkillUpdatePacket	aSkill[PET_SKILL_COUNT_MAX];
+} TPacketGCPetSkillUpdate;
+
+typedef struct SPacketGCPetNameChangeResult
+{
+	BYTE		header;
+	BYTE		subheader;
+	DWORD		dwID;
+	char		szName[PET_NAME_MAX_SIZE + 1];
+} TPacketGCPetNameChangeResult;
+
+typedef struct SPacketCGPetHatch
+{
+	BYTE		header;
+	char		name[PET_NAME_MAX_SIZE + 1];
+	TItemPos	eggPos;
+} TPacketCGPetHatch;
+
+typedef struct SPacketCGPetWindow
+{
+	BYTE	header;
+	BYTE	window;
+	bool	state;
+} TPacketCGPetWindow;
+
+typedef struct SPacketCGPetWindowType
+{
+	BYTE	header;
+	BYTE	type;
+} TPacketCGPetWindowType;
+
+typedef struct SPacketCGPeFeed
+{
+	BYTE		header;
+	BYTE		index;
+	WORD		pos[PET_FEED_SLOT_MAX];
+	WORD		count[PET_FEED_SLOT_MAX];
+} TPacketCGPetFeed;
+
+typedef struct SPacketCGPetDetermine
+{
+	BYTE		header;
+	TItemPos	determinePos;
+} TPacketCGPetDetermine;
+
+typedef struct SPacketCGPetAttrChange
+{
+	BYTE		header;
+	TItemPos	upBringingPos;
+	TItemPos	attrChangePos;
+} TPacketCGPetAttrChange;
+
+typedef struct SPacketCGPetRevive
+{
+	BYTE		header;
+	TItemPos	upBringingPos;
+	WORD		pos[PET_REVIVE_MATERIAL_SLOT_MAX];
+	WORD		count[PET_REVIVE_MATERIAL_SLOT_MAX];
+} TPacketCGPetRevive;
+
+typedef struct SPacketCGPetLearnSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+	TItemPos	learnSkillPos;
+} TPacketCGPetLearnSkill;
+
+typedef struct SPacketCGPetUpgradeSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+} TPacketCGPetSkillUpgrade;
+
+typedef struct SPacketCGPetDeleteSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+	TItemPos	deleteSkillPos;
+} TPacketCGPetDeleteSkill;
+
+typedef struct SPacketCGPetAllDeleteSkill
+{
+	BYTE		header;
+	TItemPos	deleteAllSkillPos;
+} TPacketCGPetDeleteAllSkill;
+
+typedef struct SPacketCGPetNameChange
+{
+	BYTE		header;
+	char		name[PET_NAME_MAX_SIZE + 1];
+	TItemPos	changeNamePos;
+	TItemPos	upBringingPos;
+} TPacketCGPetNameChange;
+#endif
+
+#pragma pack()
+#endif // __INC_PACKET_H__
diff --git a/server/metin2/Source/Server/game/src/panama.cpp b/server/metin2/Source/Server/game/src/panama.cpp
index 0d0661d..9fa0e6f 100644
--- a/server/metin2/Source/Server/game/src/panama.cpp
+++ b/server/metin2/Source/Server/game/src/panama.cpp
@@ -1,93 +1,94 @@
-#include "stdafx.h"
-#include "desc.h"
-#include "packet.h"
-
-typedef std::vector<std::pair<std::string, BYTE*>> PanamaVectorType;
-static PanamaVectorType s_panamaVector;
-
-size_t PanamaLoad()
-{
-	FILE* fp;
-
-	fp = fopen("panama/panama.lst", "r");
-
-	if (!fp)
-		return 0;
-
-	char buf[256];
-
-	while (fgets(buf, 256, fp))
-	{
-		char szPackName[256];
-		char szIVFileName[256];
-		char szIVFileNameConfig[256];
-
-		sscanf(buf, " %s %s ", szPackName, szIVFileNameConfig);
-		snprintf(szIVFileName, sizeof(szIVFileName), "panama/%s", szIVFileNameConfig);
-
-		FILE* fpIV = fopen(szIVFileName, "rb");
-
-		if (!fpIV)
-		{
-			sys_err("cannot open iv file %s", szIVFileName);
-			continue;
-		}
-
-		BYTE abIV[32];
-
-		if (32 != fread(abIV, sizeof(BYTE), 32, fpIV))
-			sys_err("IV file format error! %s", szIVFileName);
-		else
-		{
-			char szHex[64 + 1];
-
-			for (int i = 0; i < 32; ++i)
-				snprintf(szHex + i * 2, sizeof(szHex) - i * 2, "%02x", abIV[i]);
-
-			sys_log(0, "PANAMA: %s %s", szPackName, szHex);
-
-			s_panamaVector.push_back(std::make_pair(szPackName, M2_NEW BYTE[32]));
-			memcpy(s_panamaVector[s_panamaVector.size() - 1].second, abIV, 32);
-		}
-
-		fclose(fpIV);
-	}
-
-	fclose(fp);
-	return s_panamaVector.size();
-}
-
-void PanamaDestroy()
-{
-	PanamaVectorType::iterator it = s_panamaVector.begin();
-
-	while (it != s_panamaVector.end())
-	{
-		M2_DELETE_ARRAY(it->second);
-		++it;
-	}
-}
-
-void SendPanamaList(LPDESC d)
-{
-	TPacketGCPanamaPack pack;
-
-	pack.bHeader = HEADER_GC_PANAMA_PACK;
-
-	PanamaVectorType::iterator it = s_panamaVector.begin();
-
-	while (it != s_panamaVector.end())
-	{
-		strlcpy(pack.szPackName, it->first.c_str(), sizeof(pack.szPackName));
-		memcpy(pack.abIV, it->second, sizeof(pack.abIV));
-
-		DWORD* ivs = (DWORD*)pack.abIV;
-		for (int i = 0; i != 32 / sizeof(DWORD); i++)
-		{
-			ivs[i] ^= d->GetPanamaKey() + i * 16777619; // 더블워드단위로 변형된 파나마 키를 XOR 해준다
-		}
-		++it;
-
-		d->Packet(&pack, sizeof(pack));
-	}
-}
+#include "stdafx.h"
+#include "desc.h"
+#include "packet.h"
+
+typedef std::vector<std::pair<std::string, BYTE*>> PanamaVectorType;
+static PanamaVectorType s_panamaVector;
+
+size_t PanamaLoad()
+{
+	FILE* fp;
+
+	fp = fopen("panama/panama.lst", "r");
+
+	if (!fp)
+		return 0;
+
+	char buf[256];
+
+	while (fgets(buf, 256, fp))
+	{
+		char szPackName[256];
+		char szIVFileName[256];
+		char szIVFileNameConfig[256];
+
+		sscanf(buf, " %s %s ", szPackName, szIVFileNameConfig);
+		snprintf(szIVFileName, sizeof(szIVFileName), "panama/%s", szIVFileNameConfig);
+
+		FILE* fpIV = fopen(szIVFileName, "rb");
+
+		if (!fpIV)
+		{
+			sys_err("cannot open iv file %s", szIVFileName);
+			continue;
+		}
+
+		BYTE abIV[32];
+
+		if (32 != fread(abIV, sizeof(BYTE), 32, fpIV))
+			sys_err("IV file format error! %s", szIVFileName);
+		else
+		{
+			char szHex[64 + 1];
+
+			for (int i = 0; i < 32; ++i)
+				snprintf(szHex + i * 2, sizeof(szHex) - i * 2, "%02x", abIV[i]);
+
+			sys_log(0, "PANAMA: %s %s", szPackName, szHex);
+
+			s_panamaVector.push_back(std::make_pair(szPackName, M2_NEW BYTE[32]));
+			memcpy(s_panamaVector[s_panamaVector.size() - 1].second, abIV, 32);
+		}
+
+		fclose(fpIV);
+	}
+
+	fclose(fp);
+	return s_panamaVector.size();
+}
+
+void PanamaDestroy()
+{
+	PanamaVectorType::iterator it = s_panamaVector.begin();
+
+	while (it != s_panamaVector.end())
+	{
+		M2_DELETE_ARRAY(it->second);
+		++it;
+	}
+	s_panamaVector.clear();
+}
+
+void SendPanamaList(LPDESC d)
+{
+	TPacketGCPanamaPack pack;
+
+	pack.bHeader = HEADER_GC_PANAMA_PACK;
+
+	PanamaVectorType::iterator it = s_panamaVector.begin();
+
+	while (it != s_panamaVector.end())
+	{
+		strlcpy(pack.szPackName, it->first.c_str(), sizeof(pack.szPackName));
+		memcpy(pack.abIV, it->second, sizeof(pack.abIV));
+
+		DWORD* ivs = (DWORD*)pack.abIV;
+		for (int i = 0; i != 32 / sizeof(DWORD); i++)
+		{
+			ivs[i] ^= d->GetPanamaKey() + i * 16777619; //   캐 키 XOR 娩
+		}
+		++it;
+
+		d->Packet(&pack, sizeof(pack));
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/party.h b/server/metin2/Source/Server/game/src/party.h
index ac74795..3ef4c22 100644
--- a/server/metin2/Source/Server/game/src/party.h
+++ b/server/metin2/Source/Server/game/src/party.h
@@ -1,476 +1,486 @@
-#ifndef __INC_PARTY_H__
-#define __INC_PARTY_H__
-
-#include "char.h"
-#if defined(__DICE_SYSTEM__)
-#	include "item.h"
-#endif
-#if defined(__PET_LOOT__)
-#	include "PetSystem.h"
-#endif
-
-enum // unit : minute
-{
-	PARTY_ENOUGH_MINUTE_FOR_EXP_BONUS = 60, // 파티 결성 후 60분 후 부터 추가 경험치 보너스
-	PARTY_HEAL_COOLTIME_LONG = 60,
-	PARTY_HEAL_COOLTIME_SHORT = 30,
-#if !defined(__RANKING_SYSTEM__)
-	PARTY_MAX_MEMBER = 8,
-#endif
-	PARTY_DEFAULT_RANGE = 5000,
-};
-
-enum EPartyRole
-{
-	PARTY_ROLE_NORMAL,
-	PARTY_ROLE_LEADER,
-	PARTY_ROLE_ATTACKER,
-	PARTY_ROLE_TANKER,
-	PARTY_ROLE_BUFFER,
-	PARTY_ROLE_SKILL_MASTER,
-	PARTY_ROLE_HASTE,
-	PARTY_ROLE_DEFENDER,
-	PARTY_ROLE_MAX_NUM,
-};
-
-enum EPartyExpDistributionModes
-{
-	PARTY_EXP_DISTRIBUTION_NON_PARITY,
-	PARTY_EXP_DISTRIBUTION_PARITY,
-	PARTY_EXP_DISTRIBUTION_MAX_NUM
-};
-
-class CParty;
-class CDungeon;
-
-class CPartyManager : public singleton<CPartyManager>
-{
-public:
-	typedef std::map<DWORD, LPPARTY> TPartyMap;
-	typedef std::set<LPPARTY> TPCPartySet;
-
-public:
-	CPartyManager();
-	virtual ~CPartyManager();
-
-	void Initialize();
-
-	//void SendPartyToDB();
-
-	void EnablePCParty() { m_bEnablePCParty = true; sys_log(0, "PARTY Enable"); }
-	void DisablePCParty() { m_bEnablePCParty = false; sys_log(0, "PARTY Disable"); }
-	bool IsEnablePCParty() { return m_bEnablePCParty; }
-
-	LPPARTY FindParty(DWORD dwPID);
-	LPPARTY CreateParty(LPCHARACTER pkLeader);
-	void DeleteParty(LPPARTY pParty);
-	void DeleteAllParty();
-	bool SetParty(LPCHARACTER pkChr);
-
-	void SetPartyMember(DWORD dwPID, LPPARTY pParty);
-
-	void P2PLogin(DWORD pid, const char* name
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-		, long mapIdx
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-		, BYTE channel
-#endif
-	);
-	void P2PLogout(DWORD pid);
-
-	LPPARTY P2PCreateParty(DWORD pid);
-	void P2PDeleteParty(DWORD pid);
-	void P2PJoinParty(DWORD leader, DWORD pid, BYTE role = 0);
-	void P2PQuitParty(DWORD pid);
-
-private:
-	TPartyMap m_map_pkParty; // PID로 어느 파티에 있나 검색하기 위한 컨테이너
-	TPartyMap m_map_pkMobParty; // Mob 파티는 PID 대신 VID 로 따로 관리한다.
-
-	TPCPartySet m_set_pkPCParty; // 사람들의 파티 전체 집합
-
-	bool m_bEnablePCParty; // 디비가 켜져있지 않으면 사람들의 파티 상태가 변경불가
-};
-
-enum EPartyMessages
-{
-	PM_ATTACK, // Attack him
-	PM_RETURN, // Return back to position
-	PM_ATTACKED_BY, // I was attacked by someone
-	PM_AGGRO_INCREASE, // My aggro is increased
-};
-
-class CParty
-{
-public:
-	typedef struct SMember
-	{
-		LPCHARACTER pCharacter;
-		bool bNear;
-		BYTE bRole;
-		BYTE bLevel;
-		std::string strName;
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-		long lMapIndex;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-		BYTE bChannel;
-#endif
-	} TMember;
-
-	typedef std::map<DWORD, TMember> TMemberMap;
-
-	typedef std::map<std::string, int> TFlagMap;
-
-public:
-	CParty();
-	virtual ~CParty();
-
-	void P2PJoin(DWORD dwPID);
-	void P2PQuit(DWORD dwPID);
-	virtual void Join(DWORD dwPID);
-	void Quit(DWORD dwPID);
-	void Link(LPCHARACTER pkChr);
-	void Unlink(LPCHARACTER pkChr);
-
-	void ChatPacketToAllMember(BYTE type, const char* format, ...);
-
-	void UpdateOnlineState(DWORD dwPID, const char* name
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-		, long mapIdx
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-		, BYTE channel
-#endif
-	);
-	void UpdateOfflineState(DWORD dwPID);
-
-	DWORD GetLeaderPID();
-	LPCHARACTER GetLeaderCharacter();
-	LPCHARACTER GetLeader() { return m_pkChrLeader; }
-
-	DWORD GetMemberCount();
-	DWORD GetNearMemberCount() { return m_iCountNearPartyMember; }
-
-	bool IsMember(DWORD pid) { return m_memberMap.find(pid) != m_memberMap.end(); }
-
-	bool IsNearLeader(DWORD pid);
-
-	bool IsPositionNearLeader(LPCHARACTER ch);
-
-	void SendMessage(LPCHARACTER ch, BYTE bMsg, DWORD dwArg1, DWORD dwArg2);
-
-	void SendPartyJoinOneToAll(DWORD dwPID);
-	void SendPartyJoinAllToOne(LPCHARACTER ch);
-	void SendPartyRemoveOneToAll(DWORD dwPID);
-
-	void SendPartyInfoOneToAll(DWORD pid);
-	void SendPartyInfoOneToAll(LPCHARACTER ch);
-	void SendPartyInfoAllToOne(LPCHARACTER ch);
-
-	void SendPartyLinkOneToAll(LPCHARACTER ch);
-	void SendPartyLinkAllToOne(LPCHARACTER ch);
-	void SendPartyUnlinkOneToAll(LPCHARACTER ch);
-
-	int GetPartyBonusExpPercent() { return m_iExpBonus; }
-	int GetPartyBonusAttackGrade() { return m_iAttBonus; }
-	int GetPartyBonusDefenseGrade() { return m_iDefBonus; }
-
-	int ComputePartyBonusExpPercent();
-	inline int ComputePartyBonusAttackGrade();
-	inline int ComputePartyBonusDefenseGrade();
-
-	template <class Func> void ForEachMember(Func& f);
-	template <class Func> void ForEachMemberPtr(Func& f);
-	template <class Func> void ForEachOnlineMember(Func& f);
-	template <class Func> void ForEachNearMember(Func& f);
-	template <class Func> void ForEachOnMapMember(Func& f, long lMapIndex);
-	template <class Func> bool ForEachOnMapMemberBool(Func& f, long lMapIndex);
-
-	void Update();
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	void UpdatePosition() const;
-#endif
-
-	int GetExpBonusPercent();
-
-	bool SetRole(DWORD pid, BYTE bRole, bool on);
-	BYTE GetRole(DWORD pid);
-	bool IsRole(DWORD pid, BYTE bRole);
-
-	BYTE GetMemberMaxLevel();
-	BYTE GetMemberMinLevel();
-
-	void ComputeRolePoint(LPCHARACTER ch, BYTE bRole, bool bAdd);
-
-	void HealParty();
-	void SummonToLeader(DWORD pid);
-
-	void SetPCParty(bool b) { m_bPCParty = b; }
-
-	LPCHARACTER GetNextOwnership(LPCHARACTER ch, long x, long y);
-
-	void SetFlag(const std::string& name, int value);
-	int GetFlag(const std::string& name);
-
-	void SetDungeon(LPDUNGEON pDungeon);
-	LPDUNGEON GetDungeon();
-
-	BYTE CountMemberByVnum(DWORD dwVnum);
-
-	void SetParameter(int iMode);
-	int GetExpDistributionMode();
-
-	void SetExpCentralizeCharacter(DWORD pid);
-	LPCHARACTER GetExpCentralizeCharacter();
-
-	void RequestSetMemberLevel(DWORD pid, BYTE level);
-	void P2PSetMemberLevel(DWORD pid, BYTE level);
-
-protected:
-	void IncreaseOwnership();
-
-	virtual void Initialize();
-	void Destroy();
-	void RemovePartyBonus();
-
-	void RemoveBonus();
-	void RemoveBonusForOne(DWORD pid);
-
-	void SendParameter(LPCHARACTER ch);
-	void SendParameterToAll();
-
-	TMemberMap m_memberMap;
-	DWORD m_dwLeaderPID;
-	LPCHARACTER m_pkChrLeader;
-
-	LPEVENT m_eventUpdate;
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	LPEVENT m_eventUpdatePosition;
-#endif
-
-	TMemberMap::iterator m_itNextOwner;
-
-private:
-	int m_iExpDistributionMode;
-	LPCHARACTER m_pkChrExpCentralize;
-
-	DWORD m_dwPartyStartTime;
-
-	DWORD m_dwPartyHealTime;
-	bool m_bPartyHealReady;
-	bool m_bCanUsePartyHeal;
-
-	int m_anRoleCount[PARTY_ROLE_MAX_NUM];
-	int m_anMaxRole[PARTY_ROLE_MAX_NUM];
-
-	int m_iLongTimeExpBonus;
-
-	// used in Update
-	int m_iLeadership;
-	int m_iExpBonus;
-	int m_iAttBonus;
-	int m_iDefBonus;
-
-	// changed only in Update
-	int m_iCountNearPartyMember;
-
-	bool m_bPCParty;
-
-	TFlagMap m_map_iFlag;
-
-	LPDUNGEON m_pkDungeon;
-	// 아귀 동굴용 dungeon 멤버 변수.
-	// 정말 이렇게까지 하고 싶진 않았는데, 던전에서 party 관리가 정말로 개판이라
-	// 그거 고치기 전까지는 이렇게 임시로 해놓는다.
-	LPDUNGEON m_pkDungeon_for_Only_party;
-
-public:
-	void SetDungeon_for_Only_party(LPDUNGEON pDungeon);
-	LPDUNGEON GetDungeon_for_Only_party();
-};
-
-template <class Func> void CParty::ForEachMember(Func& f)
-{
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-		f(it->first);
-}
-
-template <class Func> void CParty::ForEachMemberPtr(Func& f)
-{
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-		f(it->second.pCharacter);
-}
-
-template <class Func> void CParty::ForEachOnlineMember(Func& f)
-{
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-		if (it->second.pCharacter)
-			f(it->second.pCharacter);
-}
-
-template <class Func> void CParty::ForEachNearMember(Func& f)
-{
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-		if (it->second.pCharacter && it->second.bNear)
-			f(it->second.pCharacter);
-}
-
-template <class Func> void CParty::ForEachOnMapMember(Func& f, long lMapIndex)
-{
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		LPCHARACTER ch = it->second.pCharacter;
-		if (ch)
-		{
-			if (ch->GetMapIndex() == lMapIndex)
-				f(ch);
-		}
-	}
-}
-
-template <class Func> bool CParty::ForEachOnMapMemberBool(Func& f, long lMapIndex)
-{
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		LPCHARACTER ch = it->second.pCharacter;
-		if (ch)
-		{
-			if (ch->GetMapIndex() == lMapIndex)
-			{
-				if (f(ch) == false)
-				{
-					return false;
-
-				}
-			}
-		}
-	}
-	return true;
-}
-
-inline int CParty::ComputePartyBonusAttackGrade()
-{
-	/*
-	if (GetNearMemberCount() <= 1)
-		return 0;
-
-	int leadership = GetLeaderCharacter()->GetLeadershipSkillLevel();
-	int n = GetNearMemberCount();
-
-	if (n >= 3 && leadership >= 10)
-		return 2;
-
-	if (n >= 2 && leadership >= 4)
-		return 1;
-	*/
-
-	return 0;
-}
-
-inline int CParty::ComputePartyBonusDefenseGrade()
-{
-	/*
-	if (GetNearMemberCount() <= 1)
-		return 0;
-
-	int leadership = GetLeaderCharacter()->GetLeadershipSkillLevel();
-	int n = GetNearMemberCount();
-
-	if (n >= 5 && leadership >= 24)
-		return 2;
-
-	if (n >= 4 && leadership >= 16)
-		return 1;
-	*/
-
-	return 0;
-}
-
-#if defined(__DICE_SYSTEM__)
-struct FPartyDropDiceRoll
-{
-	const LPITEM m_pItemDrop;
-	LPCHARACTER m_pItemOwner;
-	int m_iLastNumber;
-
-	FPartyDropDiceRoll(const LPITEM pItemDrop, LPCHARACTER pItemOwner) : m_pItemDrop(pItemDrop), m_pItemOwner(pItemOwner), m_iLastNumber(0) {};
-
-	void Process(const LPCHARACTER pMobVictim)
-	{
-		if ((!pMobVictim || (pMobVictim->GetMobRank() >= MOB_RANK_BOSS && pMobVictim->GetMobRank() <= MOB_RANK_KING)) && m_pItemOwner->GetParty() && m_pItemOwner->GetParty()->GetNearMemberCount() > 1)
-		{
-			const LPPARTY pParty = m_pItemOwner->GetParty();
-			pParty->ChatPacketToAllMember(CHAT_TYPE_DICE_INFO, LC_STRING("@*** Rolling for the following item: %s ***", LC_ITEM(m_pItemDrop->GetVnum())));
-
-			pParty->ForEachNearMember(*this);
-			if (m_pItemOwner)
-				pParty->ChatPacketToAllMember(CHAT_TYPE_DICE_INFO, LC_STRING("$*** Winner of the item %s is: %s ***", LC_ITEM(m_pItemDrop->GetVnum()), m_pItemOwner->GetName()));
-		}
-	}
-
-	LPCHARACTER GetItemOwner()
-	{
-		return m_pItemOwner;
-	}
-
-	const LPITEM GetItemDrop()
-	{
-		return m_pItemDrop;
-	}
-
-	void operator () (LPCHARACTER pChar)
-	{
-		if (!pChar)
-			return;
-
-		LPPARTY pParty = pChar->GetParty();
-		if (!pParty)
-			return;
-
-		while (true)
-		{
-			int iPickedNumber = number(10000, 99999);
-			if (iPickedNumber > m_iLastNumber)
-			{
-				m_iLastNumber = iPickedNumber;
-				m_pItemOwner = pChar;
-			}
-
-			if (iPickedNumber == m_iLastNumber)
-				continue;
-
-			pParty->ChatPacketToAllMember(CHAT_TYPE_DICE_INFO, LC_STRING("@*** ->%*s - Dice score: %4d ***", pChar->GetName(), iPickedNumber));
-			break;
-		}
-	}
-};
-#endif
-
-#if defined(__PARTY_KILL_RENEWAL__)
-struct FPartyKill
-{
-	LPCHARACTER m_pVictim;
-	LPCHARACTER m_pAttacker;
-
-	FPartyKill(LPCHARACTER pVictim, LPCHARACTER pAttacker)
-		: m_pVictim(pVictim), m_pAttacker(pAttacker) {}
-
-	void operator()(LPCHARACTER pMember);
-};
-#endif
-
-#endif // __INC_PARTY_H__
+#ifndef __INC_PARTY_H__
+#define __INC_PARTY_H__
+
+#include "char.h"
+#if defined(__DICE_SYSTEM__)
+#	include "item.h"
+#endif
+#if defined(__PET_LOOT__)
+#	include "PetSystem.h"
+#endif
+
+enum // unit : minute
+{
+	PARTY_ENOUGH_MINUTE_FOR_EXP_BONUS = 60, // 티 消  60   煞 치 駕
+	PARTY_HEAL_COOLTIME_LONG = 60,
+	PARTY_HEAL_COOLTIME_SHORT = 30,
+#if !defined(__RANKING_SYSTEM__)
+	PARTY_MAX_MEMBER = 8,
+#endif
+	PARTY_DEFAULT_RANGE = 5000,
+};
+
+enum EPartyRole
+{
+	PARTY_ROLE_NORMAL,
+	PARTY_ROLE_LEADER,
+	PARTY_ROLE_ATTACKER,
+	PARTY_ROLE_TANKER,
+	PARTY_ROLE_BUFFER,
+	PARTY_ROLE_SKILL_MASTER,
+	PARTY_ROLE_HASTE,
+	PARTY_ROLE_DEFENDER,
+	PARTY_ROLE_MAX_NUM,
+};
+
+enum EPartyExpDistributionModes
+{
+	PARTY_EXP_DISTRIBUTION_NON_PARITY,
+	PARTY_EXP_DISTRIBUTION_PARITY,
+	PARTY_EXP_DISTRIBUTION_MAX_NUM
+};
+
+class CParty;
+class CDungeon;
+
+class CPartyManager : public singleton<CPartyManager>
+{
+public:
+	typedef std::map<DWORD, LPPARTY> TPartyMap;
+	typedef std::set<LPPARTY> TPCPartySet;
+
+public:
+	CPartyManager();
+	virtual ~CPartyManager();
+
+	void Initialize();
+
+	//void SendPartyToDB();
+
+	void EnablePCParty() { m_bEnablePCParty = true; sys_log(0, "PARTY Enable"); }
+	void DisablePCParty() { m_bEnablePCParty = false; sys_log(0, "PARTY Disable"); }
+	bool IsEnablePCParty() { return m_bEnablePCParty; }
+
+	LPPARTY FindParty(DWORD dwPID);
+	LPPARTY CreateParty(LPCHARACTER pkLeader);
+	void DeleteParty(LPPARTY pParty);
+	void DeleteAllParty();
+	bool SetParty(LPCHARACTER pkChr);
+
+	void SetPartyMember(DWORD dwPID, LPPARTY pParty);
+
+	void P2PLogin(DWORD pid, const char* name
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+		, long mapIdx
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+		, BYTE channel
+#endif
+	);
+	void P2PLogout(DWORD pid);
+
+	LPPARTY P2PCreateParty(DWORD pid);
+	void P2PDeleteParty(DWORD pid);
+	void P2PJoinParty(DWORD leader, DWORD pid, BYTE role = 0);
+	void P2PQuitParty(DWORD pid);
+
+private:
+	TPartyMap m_map_pkParty; // PID  티 簾 講歐  犬
+	TPartyMap m_map_pkMobParty; // Mob 티 PID  VID   磯.
+
+	TPCPartySet m_set_pkPCParty; //  티 체 
+
+	bool m_bEnablePCParty; //     티 째 柰
+};
+
+enum EPartyMessages
+{
+	PM_ATTACK, // Attack him
+	PM_RETURN, // Return back to position
+	PM_ATTACKED_BY, // I was attacked by someone
+	PM_AGGRO_INCREASE, // My aggro is increased
+};
+
+class CParty
+{
+public:
+	typedef struct SMember
+	{
+		LPCHARACTER pCharacter;
+		bool bNear;
+		BYTE bRole;
+		BYTE bLevel;
+		std::string strName;
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+		long lMapIndex;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+		BYTE bChannel;
+#endif
+	} TMember;
+
+	typedef std::map<DWORD, TMember> TMemberMap;
+
+	typedef std::map<std::string, int> TFlagMap;
+
+public:
+	CParty();
+	virtual ~CParty();
+
+	void P2PJoin(DWORD dwPID);
+	void P2PQuit(DWORD dwPID);
+	virtual void Join(DWORD dwPID);
+	void Quit(DWORD dwPID);
+	void Link(LPCHARACTER pkChr);
+	void Unlink(LPCHARACTER pkChr);
+
+	void ChatPacketToAllMember(BYTE type, const char* format, ...);
+
+	void UpdateOnlineState(DWORD dwPID, const char* name
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+		, long mapIdx
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+		, BYTE channel
+#endif
+	);
+	void UpdateOfflineState(DWORD dwPID);
+
+	DWORD GetLeaderPID();
+	LPCHARACTER GetLeaderCharacter();
+	LPCHARACTER GetLeader() { return m_pkChrLeader; }
+
+	DWORD GetMemberCount();
+	DWORD GetNearMemberCount() { return m_iCountNearPartyMember; }
+
+	bool IsMember(DWORD pid) { return m_memberMap.find(pid) != m_memberMap.end(); }
+
+	bool IsNearLeader(DWORD pid);
+
+	bool IsPositionNearLeader(LPCHARACTER ch);
+
+	void SendMessage(LPCHARACTER ch, BYTE bMsg, DWORD dwArg1, DWORD dwArg2);
+
+	void SendPartyJoinOneToAll(DWORD dwPID);
+	void SendPartyJoinAllToOne(LPCHARACTER ch);
+	void SendPartyRemoveOneToAll(DWORD dwPID);
+
+	void SendPartyInfoOneToAll(DWORD pid);
+	void SendPartyInfoOneToAll(LPCHARACTER ch);
+	void SendPartyInfoAllToOne(LPCHARACTER ch);
+
+	void SendPartyLinkOneToAll(LPCHARACTER ch);
+	void SendPartyLinkAllToOne(LPCHARACTER ch);
+	void SendPartyUnlinkOneToAll(LPCHARACTER ch);
+
+	int GetPartyBonusExpPercent() { return m_iExpBonus; }
+	int GetPartyBonusAttackGrade() { return m_iAttBonus; }
+	int GetPartyBonusDefenseGrade() { return m_iDefBonus; }
+
+	int ComputePartyBonusExpPercent();
+	inline int ComputePartyBonusAttackGrade();
+	inline int ComputePartyBonusDefenseGrade();
+
+	template <class Func> void ForEachMember(Func& f);
+	template <class Func> void ForEachMemberPtr(Func& f);
+	template <class Func> void ForEachOnlineMember(Func& f);
+	template <class Func> void ForEachNearMember(Func& f);
+	template <class Func> void ForEachOnMapMember(Func& f, long lMapIndex);
+	template <class Func> bool ForEachOnMapMemberBool(Func& f, long lMapIndex);
+
+	void Update();
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	void UpdatePosition() const;
+#endif
+
+	int GetExpBonusPercent();
+
+	bool SetRole(DWORD pid, BYTE bRole, bool on);
+	BYTE GetRole(DWORD pid);
+	bool IsRole(DWORD pid, BYTE bRole);
+
+	BYTE GetMemberMaxLevel();
+	BYTE GetMemberMinLevel();
+
+	void ComputeRolePoint(LPCHARACTER ch, BYTE bRole, bool bAdd);
+
+	void HealParty();
+	void SummonToLeader(DWORD pid);
+
+	void SetPCParty(bool b) { m_bPCParty = b; }
+
+	LPCHARACTER GetNextOwnership(LPCHARACTER ch, long x, long y);
+
+	void SetFlag(const std::string& name, int value);
+	int GetFlag(const std::string& name);
+
+	void SetDungeon(LPDUNGEON pDungeon);
+	LPDUNGEON GetDungeon();
+
+	BYTE CountMemberByVnum(DWORD dwVnum);
+
+	void SetParameter(int iMode);
+	int GetExpDistributionMode();
+
+	void SetExpCentralizeCharacter(DWORD pid);
+	LPCHARACTER GetExpCentralizeCharacter();
+
+	void RequestSetMemberLevel(DWORD pid, BYTE level);
+	void P2PSetMemberLevel(DWORD pid, BYTE level);
+
+protected:
+	void IncreaseOwnership();
+
+	virtual void Initialize();
+	void Destroy();
+	void RemovePartyBonus();
+
+	void RemoveBonus();
+	void RemoveBonusForOne(DWORD pid);
+
+	void SendParameter(LPCHARACTER ch);
+	void SendParameterToAll();
+
+	TMemberMap m_memberMap;
+	DWORD m_dwLeaderPID;
+	LPCHARACTER m_pkChrLeader;
+
+	LPEVENT m_eventUpdate;
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	LPEVENT m_eventUpdatePosition;
+#endif
+
+	TMemberMap::iterator m_itNextOwner;
+
+private:
+	int m_iExpDistributionMode;
+	LPCHARACTER m_pkChrExpCentralize;
+
+	DWORD m_dwPartyStartTime;
+
+	DWORD m_dwPartyHealTime;
+	bool m_bPartyHealReady;
+	bool m_bCanUsePartyHeal;
+
+	int m_anRoleCount[PARTY_ROLE_MAX_NUM];
+	int m_anMaxRole[PARTY_ROLE_MAX_NUM];
+
+	int m_iLongTimeExpBonus;
+
+	// used in Update
+	int m_iLeadership;
+	int m_iExpBonus;
+	int m_iAttBonus;
+	int m_iDefBonus;
+
+	// changed only in Update
+	int m_iCountNearPartyMember;
+
+	bool m_bPCParty;
+
+	TFlagMap m_map_iFlag;
+
+	LPDUNGEON m_pkDungeon;
+	// 튿  dungeon  .
+	//  肩逃 構  刻年쨉,  party   繭
+	// 陋 치  肩 擔첨 卍쨈.
+	LPDUNGEON m_pkDungeon_for_Only_party;
+
+public:
+	void SetDungeon_for_Only_party(LPDUNGEON pDungeon);
+	LPDUNGEON GetDungeon_for_Only_party();
+};
+
+template <class Func> void CParty::ForEachMember(Func& f)
+{
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+		f(it->first);
+}
+
+template <class Func> void CParty::ForEachMemberPtr(Func& f)
+{
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+		f(it->second.pCharacter);
+}
+
+template <class Func> void CParty::ForEachOnlineMember(Func& f)
+{
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		const DWORD pid = it->first;
+		LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+		if (ch && ch->GetParty() == this)
+			f(ch);
+	}
+}
+
+template <class Func> void CParty::ForEachNearMember(Func& f)
+{
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (!it->second.bNear)
+			continue;
+
+		const DWORD pid = it->first;
+		LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+		if (ch && ch->GetParty() == this)
+			f(ch);
+	}
+}
+
+template <class Func> void CParty::ForEachOnMapMember(Func& f, long lMapIndex)
+{
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		const DWORD pid = it->first;
+		LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+		if (!ch || ch->GetParty() != this)
+			continue;
+
+		if (ch->GetMapIndex() == lMapIndex)
+			f(ch);
+	}
+}
+
+template <class Func> bool CParty::ForEachOnMapMemberBool(Func& f, long lMapIndex)
+{
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		const DWORD pid = it->first;
+		LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+		if (!ch || ch->GetParty() != this)
+			continue;
+
+		if (ch->GetMapIndex() == lMapIndex)
+		{
+			if (f(ch) == false)
+				return false;
+		}
+	}
+	return true;
+}
+
+inline int CParty::ComputePartyBonusAttackGrade()
+{
+	/*
+	if (GetNearMemberCount() <= 1)
+		return 0;
+
+	int leadership = GetLeaderCharacter()->GetLeadershipSkillLevel();
+	int n = GetNearMemberCount();
+
+	if (n >= 3 && leadership >= 10)
+		return 2;
+
+	if (n >= 2 && leadership >= 4)
+		return 1;
+	*/
+
+	return 0;
+}
+
+inline int CParty::ComputePartyBonusDefenseGrade()
+{
+	/*
+	if (GetNearMemberCount() <= 1)
+		return 0;
+
+	int leadership = GetLeaderCharacter()->GetLeadershipSkillLevel();
+	int n = GetNearMemberCount();
+
+	if (n >= 5 && leadership >= 24)
+		return 2;
+
+	if (n >= 4 && leadership >= 16)
+		return 1;
+	*/
+
+	return 0;
+}
+
+#if defined(__DICE_SYSTEM__)
+struct FPartyDropDiceRoll
+{
+	const LPITEM m_pItemDrop;
+	LPCHARACTER m_pItemOwner;
+	int m_iLastNumber;
+
+	FPartyDropDiceRoll(const LPITEM pItemDrop, LPCHARACTER pItemOwner) : m_pItemDrop(pItemDrop), m_pItemOwner(pItemOwner), m_iLastNumber(0) {};
+
+	void Process(const LPCHARACTER pMobVictim)
+	{
+		if ((!pMobVictim || (pMobVictim->GetMobRank() >= MOB_RANK_BOSS && pMobVictim->GetMobRank() <= MOB_RANK_KING)) && m_pItemOwner->GetParty() && m_pItemOwner->GetParty()->GetNearMemberCount() > 1)
+		{
+			const LPPARTY pParty = m_pItemOwner->GetParty();
+			pParty->ChatPacketToAllMember(CHAT_TYPE_DICE_INFO, LC_STRING("@*** Rolling for the following item: %s ***", LC_ITEM(m_pItemDrop->GetVnum())));
+
+			pParty->ForEachNearMember(*this);
+			if (m_pItemOwner)
+				pParty->ChatPacketToAllMember(CHAT_TYPE_DICE_INFO, LC_STRING("$*** Winner of the item %s is: %s ***", LC_ITEM(m_pItemDrop->GetVnum()), m_pItemOwner->GetName()));
+		}
+	}
+
+	LPCHARACTER GetItemOwner()
+	{
+		return m_pItemOwner;
+	}
+
+	const LPITEM GetItemDrop()
+	{
+		return m_pItemDrop;
+	}
+
+	void operator () (LPCHARACTER pChar)
+	{
+		if (!pChar)
+			return;
+
+		LPPARTY pParty = pChar->GetParty();
+		if (!pParty)
+			return;
+
+		while (true)
+		{
+			int iPickedNumber = number(10000, 99999);
+			if (iPickedNumber > m_iLastNumber)
+			{
+				m_iLastNumber = iPickedNumber;
+				m_pItemOwner = pChar;
+			}
+
+			if (iPickedNumber == m_iLastNumber)
+				continue;
+
+			pParty->ChatPacketToAllMember(CHAT_TYPE_DICE_INFO, LC_STRING("@*** ->%*s - Dice score: %4d ***", pChar->GetName(), iPickedNumber));
+			break;
+		}
+	}
+};
+#endif
+
+#if defined(__PARTY_KILL_RENEWAL__)
+struct FPartyKill
+{
+	LPCHARACTER m_pVictim;
+	LPCHARACTER m_pAttacker;
+
+	FPartyKill(LPCHARACTER pVictim, LPCHARACTER pAttacker)
+		: m_pVictim(pVictim), m_pAttacker(pAttacker) {}
+
+	void operator()(LPCHARACTER pMember);
+};
+#endif
+
+#endif // __INC_PARTY_H__
diff --git a/server/metin2/Source/Server/game/src/perftest/alloc_perf_test.cpp b/server/metin2/Source/Server/game/src/perftest/alloc_perf_test.cpp
index 6f0e87b..42898e4 100644
--- a/server/metin2/Source/Server/game/src/perftest/alloc_perf_test.cpp
+++ b/server/metin2/Source/Server/game/src/perftest/alloc_perf_test.cpp
@@ -1,143 +1,143 @@
-#define CASE_DEBUG_NEW_DELETE
-
-#if defined(CASE_RAW_NEW_DELETE)
-#elif defined(CASE_RAW_MALLOC_FREE)
-#elif defined(CASE_ALLOC_NEW_DELETE)
-#define REPLACE_GLOBAL_NEW_DELETE
-#elif defined(CASE_ALLOC_MALLOC_FREE)
-#define REPLACE_CRT_MALLOC_FREE
-#elif defined(CASE_DEBUG_NEW_DELETE)
-#define DEBUG_ALLOC
-#define REPLACE_GLOBAL_NEW_DELETE
-#elif defined(CASE_DEBUG_MALLOC_FREE)
-#define DEBUG_ALLOC
-#define REPLACE_CRT_MALLOC_FREE
-#endif
-
-#include <sys/time.h>
-
-#include <iostream>
-#include <string>
-
-#include "../allocator.h" // REPLACE* should be off.
-
-#include "timeval_subtract.c"
-
-using namespace std;
-
-string str_elapsed_secs(struct timeval* from, struct timeval* to)
-{
-	struct timeval tv;
-	if (timeval_subtract(&tv, to, from) != 0)
-		return "invalid";
-
-	char buf[256];
-	sprintf(buf, "%d.%06d", tv.tv_sec, tv.tv_usec);
-	return buf;
-}
-
-class Foo
-{
-public:
-	Foo() : bar_(0) {}
-	~Foo() {}
-
-private:
-	int bar_;
-};
-
-int main(int argc, char* argv[])
-{
-	const int kCount = 1;
-
-	Allocator::StaticSetUp();
-
-#if defined(CASE_RAW_NEW_DELETE)
-	cout << "Raw new/delete " << kCount << " times" << endl;
-	Foo* p[kCount];
-#elif defined(CASE_RAW_MALLOC_FREE)
-	cout << "Raw malloc/free " << kCount << " times" << endl;
-	void* p[kCount];
-#elif defined(CASE_ALLOC_MALLOC_FREE)
-	cout << "Allocator malloc/free " << kCount << " times" << endl;
-	void* p[kCount];
-#elif defined(CASE_ALLOC_NEW_DELETE)
-	cout << "Allocator new/delete " << kCount << " times" << endl;
-	Foo* p[kCount];
-#elif defined(CASE_DEBUG_MALLOC_FREE)
-	cout << "DebugAllocator malloc/free " << kCount << " times" << endl;
-	void* p[kCount];
-#elif defined(CASE_DEBUG_NEW_DELETE)
-	cout << "DebugAllocator new/delete " << kCount << " times" << endl;
-	Foo* p[kCount];
-#endif
-
-	struct timeval from;
-	struct timeval to;
-
-	gettimeofday(&from, NULL);
-
-#if defined(CASE_RAW_NEW_DELETE)
-	for (int i = 0; i < kCount; ++i)
-	{
-		p[i] = new Foo;
-	}
-	for (int i = 0; i < kCount; ++i)
-	{
-		delete p[i];
-	}
-#elif defined(CASE_RAW_MALLOC_FREE)
-	for (int i = 0; i < kCount; ++i)
-	{
-		p[i] = malloc(sizeof(Foo));
-	}
-	for (int i = 0; i < kCount; ++i)
-	{
-		free(p[i]);
-	}
-#elif defined(CASE_ALLOC_MALLOC_FREE)
-	for (int i = 0; i < kCount; ++i)
-	{
-		p[i] = M2_MALLOC(sizeof(Foo));
-	}
-	for (int i = 0; i < kCount; ++i)
-	{
-		M2_FREE(p[i]);
-	}
-#elif defined(CASE_ALLOC_NEW_DELETE)
-	for (int i = 0; i < kCount; ++i)
-	{
-		p[i] = M2_NEW Foo;
-	}
-	for (int i = 0; i < kCount; ++i)
-	{
-		M2_DELETE(p[i]);
-	}
-#elif defined(CASE_DEBUG_MALLOC_FREE)
-	for (int i = 0; i < kCount; ++i)
-	{
-		p[i] = M2_MALLOC(sizeof(Foo));
-	}
-	for (int i = 0; i < kCount; ++i)
-	{
-		M2_FREE(p[i]);
-	}
-#elif defined(CASE_DEBUG_NEW_DELETE)
-	for (int i = 0; i < kCount; ++i)
-	{
-		p[i] = M2_NEW Foo;
-	}
-	for (int i = 0; i < kCount; ++i)
-	{
-		M2_DELETE(p[i]);
-	}
-#endif
-
-	gettimeofday(&to, NULL);
-
-	cout << "Elapsed " << str_elapsed_secs(&from, &to) << " sec(s)" << endl;
-
-	Allocator::StaticTearDown();
-
-	return 0;
-}
+#define CASE_DEBUG_NEW_DELETE
+
+#if defined(CASE_RAW_NEW_DELETE)
+#elif defined(CASE_RAW_MALLOC_FREE)
+#elif defined(CASE_ALLOC_NEW_DELETE)
+#define REPLACE_GLOBAL_NEW_DELETE
+#elif defined(CASE_ALLOC_MALLOC_FREE)
+#define REPLACE_CRT_MALLOC_FREE
+#elif defined(CASE_DEBUG_NEW_DELETE)
+#define DEBUG_ALLOC
+#define REPLACE_GLOBAL_NEW_DELETE
+#elif defined(CASE_DEBUG_MALLOC_FREE)
+#define DEBUG_ALLOC
+#define REPLACE_CRT_MALLOC_FREE
+#endif
+
+#include <sys/time.h>
+
+#include <iostream>
+#include <string>
+
+#include "../allocator.h" // REPLACE* should be off.
+
+#include "timeval_subtract.c"
+
+using namespace std;
+
+string str_elapsed_secs(struct timeval* from, struct timeval* to)
+{
+	struct timeval tv;
+	if (timeval_subtract(&tv, to, from) != 0)
+		return "invalid";
+
+	char buf[256];
+	snprintf(buf, sizeof(buf), "%d.%06d", tv.tv_sec, tv.tv_usec);
+	return buf;
+}
+
+class Foo
+{
+public:
+	Foo() : bar_(0) {}
+	~Foo() {}
+
+private:
+	int bar_;
+};
+
+int main(int argc, char* argv[])
+{
+	const int kCount = 1;
+
+	Allocator::StaticSetUp();
+
+#if defined(CASE_RAW_NEW_DELETE)
+	cout << "Raw new/delete " << kCount << " times" << endl;
+	Foo* p[kCount];
+#elif defined(CASE_RAW_MALLOC_FREE)
+	cout << "Raw malloc/free " << kCount << " times" << endl;
+	void* p[kCount];
+#elif defined(CASE_ALLOC_MALLOC_FREE)
+	cout << "Allocator malloc/free " << kCount << " times" << endl;
+	void* p[kCount];
+#elif defined(CASE_ALLOC_NEW_DELETE)
+	cout << "Allocator new/delete " << kCount << " times" << endl;
+	Foo* p[kCount];
+#elif defined(CASE_DEBUG_MALLOC_FREE)
+	cout << "DebugAllocator malloc/free " << kCount << " times" << endl;
+	void* p[kCount];
+#elif defined(CASE_DEBUG_NEW_DELETE)
+	cout << "DebugAllocator new/delete " << kCount << " times" << endl;
+	Foo* p[kCount];
+#endif
+
+	struct timeval from;
+	struct timeval to;
+
+	gettimeofday(&from, NULL);
+
+#if defined(CASE_RAW_NEW_DELETE)
+	for (int i = 0; i < kCount; ++i)
+	{
+		p[i] = new Foo;
+	}
+	for (int i = 0; i < kCount; ++i)
+	{
+		delete p[i];
+	}
+#elif defined(CASE_RAW_MALLOC_FREE)
+	for (int i = 0; i < kCount; ++i)
+	{
+		p[i] = malloc(sizeof(Foo));
+	}
+	for (int i = 0; i < kCount; ++i)
+	{
+		free(p[i]);
+	}
+#elif defined(CASE_ALLOC_MALLOC_FREE)
+	for (int i = 0; i < kCount; ++i)
+	{
+		p[i] = M2_MALLOC(sizeof(Foo));
+	}
+	for (int i = 0; i < kCount; ++i)
+	{
+		M2_FREE(p[i]);
+	}
+#elif defined(CASE_ALLOC_NEW_DELETE)
+	for (int i = 0; i < kCount; ++i)
+	{
+		p[i] = M2_NEW Foo;
+	}
+	for (int i = 0; i < kCount; ++i)
+	{
+		M2_DELETE(p[i]);
+	}
+#elif defined(CASE_DEBUG_MALLOC_FREE)
+	for (int i = 0; i < kCount; ++i)
+	{
+		p[i] = M2_MALLOC(sizeof(Foo));
+	}
+	for (int i = 0; i < kCount; ++i)
+	{
+		M2_FREE(p[i]);
+	}
+#elif defined(CASE_DEBUG_NEW_DELETE)
+	for (int i = 0; i < kCount; ++i)
+	{
+		p[i] = M2_NEW Foo;
+	}
+	for (int i = 0; i < kCount; ++i)
+	{
+		M2_DELETE(p[i]);
+	}
+#endif
+
+	gettimeofday(&to, NULL);
+
+	cout << "Elapsed " << str_elapsed_secs(&from, &to) << " sec(s)" << endl;
+
+	Allocator::StaticTearDown();
+
+	return 0;
+}
diff --git a/server/metin2/Source/Server/game/src/questlua.cpp b/server/metin2/Source/Server/game/src/questlua.cpp
index 077b47b..f261a5a 100644
--- a/server/metin2/Source/Server/game/src/questlua.cpp
+++ b/server/metin2/Source/Server/game/src/questlua.cpp
@@ -1,950 +1,965 @@
-#include "stdafx.h"
-
-#include <sstream>
-
-#include "questmanager.h"
-#include "questlua.h"
-#include "config.h"
-#include "desc.h"
-#include "char.h"
-#include "char_manager.h"
-#include "buffer_manager.h"
-#include "db.h"
-#include "xmas_event.h"
-#include "locale_service.h"
-#include "regen.h"
-#include "affect.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "sectree_manager.h"
-
-#if defined(__DUNGEON_RENEWAL__)
-#	include "utils.h"
-#endif
-
-#undef sys_err
-#ifndef __WIN32__
-#define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
-#else
-#define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
-#endif
-
-namespace quest
-{
-	using namespace std;
-
-	string ScriptToString(const string& str)
-	{
-		lua_State* L = CQuestManager::instance().GetLuaState();
-		int x = lua_gettop(L);
-
-		int errcode = lua_dobuffer(L, ("return " + str).c_str(), str.size() + 7, "ScriptToString");
-		string retstr;
-		if (!errcode)
-		{
-			if (lua_isstring(L, -1))
-				retstr = lua_tostring(L, -1);
-		}
-		else
-		{
-			sys_err("LUA ScriptRunError (code:%d src:[%s])", errcode, str.c_str());
-		}
-		lua_settop(L, x);
-		return retstr;
-	}
-
-	void FSetWarpLocation::operator() (LPCHARACTER ch)
-	{
-		if (ch->IsPC())
-		{
-			ch->SetWarpLocation(map_index, x, y);
-		}
-	}
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	void FDungeonUpdateAllBattlepassProcess::operator() (LPCHARACTER ch)
-	{
-		if (ch->IsPC())
-			ch->UpdateExtBattlePassMissionProgress(COMPLETE_DUNGEON, 1, dungeon_index);
-	}
-#endif
-
-	void FSetQuestFlag::operator() (LPCHARACTER ch)
-	{
-		if (!ch->IsPC())
-			return;
-
-		PC* pPC = CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-
-		if (pPC)
-			pPC->SetFlag(flagname, value);
-	}
-
-#if defined(__DUNGEON_RENEWAL__)
-	void FSetQuestFlagToNearMembers::operator() (LPCHARACTER ch)
-	{
-		if (!ch->IsPC())
-			return;
-
-		PC* pPC = CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-		if (pPC && DISTANCE_APPROX(ch->GetX() - x * 100, ch->GetY() - y * 100) < dist * 100)
-			pPC->SetFlag(flagname, value);
-	}
-#endif
-
-	bool FPartyCheckFlagLt::operator() (LPCHARACTER ch)
-	{
-		if (!ch->IsPC())
-			return false;
-
-		PC* pPC = CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-		bool returnBool;
-		if (pPC)
-		{
-			int flagValue = pPC->GetFlag(flagname);
-			if (value > flagValue)
-				returnBool = true;
-			else
-				returnBool = false;
-		}
-
-		return returnBool;
-	}
-
-	FPartyChat::FPartyChat(int ChatType, const char* str) : iChatType(ChatType), str(str)
-	{
-	}
-
-	void FPartyChat::operator() (LPCHARACTER ch)
-	{
-		ch->ChatPacket(iChatType, "%s", str);
-	}
-
-	void FPartyClearReady::operator() (LPCHARACTER ch)
-	{
-		ch->RemoveAffect(AFFECT_DUNGEON_READY);
-	}
-
-	void FSendPacket::operator() (LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-
-			if (ch->GetDesc())
-			{
-				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-			}
-		}
-	}
-
-	void FSendPacketToEmpire::operator() (LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-
-			if (ch->GetDesc())
-			{
-				if (ch->GetEmpire() == bEmpire)
-					ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-			}
-		}
-	}
-
-	void FWarpEmpire::operator() (LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-
-			if (ch->IsPC() && ch->GetEmpire() == m_bEmpire)
-			{
-				ch->WarpSet(m_x, m_y, m_lMapIndexTo);
-			}
-		}
-	}
-
-	FBuildLuaGuildWarList::FBuildLuaGuildWarList(lua_State* lua_state) : L(lua_state), m_count(1)
-	{
-		lua_newtable(lua_state);
-	}
-
-	void FBuildLuaGuildWarList::operator() (DWORD g1, DWORD g2)
-	{
-		CGuild* g = CGuildManager::instance().FindGuild(g1);
-
-		if (!g)
-			return;
-
-		if (g->GetGuildWarType(g2) == GUILD_WAR_TYPE_FIELD)
-			return;
-
-		if (g->GetGuildWarState(g2) != GUILD_WAR_ON_WAR)
-			return;
-
-		lua_newtable(L);
-		lua_pushnumber(L, g1);
-		lua_rawseti(L, -2, 1);
-		lua_pushnumber(L, g2);
-		lua_rawseti(L, -2, 2);
-		lua_rawseti(L, -2, m_count++);
-	}
-
-	bool IsScriptTrue(const char* code, int size)
-	{
-		if (size == 0)
-			return true;
-
-		lua_State* L = CQuestManager::instance().GetLuaState();
-		int x = lua_gettop(L);
-		int errcode = lua_dobuffer(L, code, size, "IsScriptTrue");
-		int bStart = lua_toboolean(L, -1);
-		if (errcode)
-		{
-			char buf[100];
-			snprintf(buf, sizeof(buf), "LUA ScriptRunError (code:%%d src:[%%%ds])", size);
-			sys_err(buf, errcode, code);
-		}
-		lua_settop(L, x);
-		return bStart != 0;
-	}
-
-	void combine_lua_string(lua_State* L, ostringstream& s)
-	{
-		char buf[32];
-
-		int n = lua_gettop(L);
-		int i;
-
-		for (i = 1; i <= n; ++i)
-		{
-			if (lua_isstring(L, i))
-				//printf("%s\n",lua_tostring(L,i));
-				s << lua_tostring(L, i);
-			else if (lua_isnumber(L, i))
-			{
-				snprintf(buf, sizeof(buf), "%.14g\n", lua_tonumber(L, i));
-				s << buf;
-			}
-		}
-	}
-
-	int highscore_show(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		const char* pszBoardName = lua_tostring(L, 1);
-		DWORD mypid = q.GetCurrentCharacterPtr()->GetPlayerID();
-		bool bOrder = (int)lua_tonumber(L, 2) != 0 ? true : false;
-
-		DBManager::instance().ReturnQuery(QID_HIGHSCORE_SHOW, mypid, NULL,
-			"SELECT h.pid, p.name, h.value FROM highscore%s as h, player%s as p WHERE h.board = '%s' AND h.pid = p.id ORDER BY h.value %s LIMIT 10",
-			get_table_postfix(), get_table_postfix(), pszBoardName, bOrder ? "DESC" : "");
-		return 0;
-	}
-
-	int highscore_register(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-
-		THighscoreRegisterQueryInfo* qi = M2_NEW THighscoreRegisterQueryInfo;
-
-		strlcpy(qi->szBoard, lua_tostring(L, 1), sizeof(qi->szBoard));
-		qi->dwPID = q.GetCurrentCharacterPtr()->GetPlayerID();
-		qi->iValue = (int)lua_tonumber(L, 2);
-		qi->bOrder = (int)lua_tonumber(L, 3);
-
-		DBManager::instance().ReturnQuery(QID_HIGHSCORE_REGISTER, qi->dwPID, qi,
-			"SELECT value FROM highscore%s WHERE board='%s' AND pid=%u", get_table_postfix(), qi->szBoard, qi->dwPID);
-		return 1;
-	}
-
-	//
-	// "member" Lua functions
-	//
-	int member_chat(lua_State* L)
-	{
-		ostringstream s;
-		combine_lua_string(L, s);
-		CQuestManager::Instance().GetCurrentPartyMember()->ChatPacket(CHAT_TYPE_TALKING, "%s", s.str().c_str());
-		return 0;
-	}
-
-	int member_clear_ready(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentPartyMember();
-		ch->RemoveAffect(AFFECT_DUNGEON_READY);
-		return 0;
-	}
-
-	int member_set_ready(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentPartyMember();
-		ch->AddAffect(AFFECT_DUNGEON_READY, POINT_NONE, 0, AFF_DUNGEON_READY, 65535, 0, true);
-		return 0;
-	}
-
-	// 20190817.Owsap : Purge monster after spawn.
-	EVENTFUNC(purge_time_event)
-	{
-		char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-
-		if (!info)
-		{
-			sys_err("purge_time_event> <Factor> Null pointer");
-			return 0;
-		}
-
-		LPCHARACTER ch = info->ch;
-		if (!ch)
-			return 0;
-
-		M2_DESTROY_CHARACTER(ch);
-		return 0;
-	}
-
-	int mob_spawn(lua_State* L)
-	{
-		/*
-		* arg1 : vnum
-		* arg2 : x
-		* arg3 : y
-		* arg4 : radius
-		* arg5 : aggressive
-		* arg6 : count
-		* arg7 : purge time 20190817.Owsap : Purge monster after spawn.
-		*/
-
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
-		{
-			sys_err("invalid argument");
-			return 0;
-		}
-
-		DWORD mob_vnum = (DWORD)lua_tonumber(L, 1);
-		long local_x = (long)lua_tonumber(L, 2) * 100;
-		long local_y = (long)lua_tonumber(L, 3) * 100;
-		float radius = (float)lua_tonumber(L, 4) * 100;
-		bool bAggressive = lua_toboolean(L, 5);
-		DWORD count = (lua_isnumber(L, 6)) ? (DWORD)lua_tonumber(L, 6) : 1;
-
-		if (count == 0)
-			count = 1;
-		else if (count > 10)
-		{
-			sys_err("count bigger than 10");
-			count = 10;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
-
-		if (pMap == NULL)
-			return 0;
-
-		DWORD dwQuestIdx = CQuestManager::instance().GetCurrentPC()->GetCurrentQuestIndex();
-
-		bool ret = false;
-		LPCHARACTER mob = NULL;
-
-		while (count--)
-		{
-			for (int loop = 0; loop < 8; ++loop)
-			{
-				float angle = number(0, 999) * M_PI * 2 / 1000;
-				float r = number(0, 999) * radius / 1000;
-
-				long x = local_x + pMap->m_setting.iBaseX + (long)(r * cos(angle));
-				long y = local_y + pMap->m_setting.iBaseY + (long)(r * sin(angle));
-
-				mob = CHARACTER_MANAGER::instance().SpawnMob(mob_vnum, ch->GetMapIndex(), x, y, 0);
-
-				if (mob)
-				{
-					// 20190817.Owsap : Purge monster after spawn.
-					if (lua_isnumber(L, 7))
-					{
-						long lPurgeTime = (long)lua_tonumber(L, 7);
-						if (lPurgeTime > 0)
-						{
-							char_event_info* info = AllocEventInfo<char_event_info>();
-							info->ch = mob;
-							event_create(purge_time_event, info, PASSES_PER_SEC(lPurgeTime));
-						}
-					}
-					break;
-				}
-			}
-
-			if (mob)
-			{
-				if (bAggressive)
-					mob->SetAggressive();
-
-				mob->SetQuestBy(dwQuestIdx);
-
-				if (!ret)
-				{
-					ret = true;
-					lua_pushnumber(L, (DWORD)mob->GetVID());
-				}
-			}
-		}
-
-		if (!ret)
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int mob_spawn_group(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4) || !lua_isnumber(L, 6))
-		{
-			sys_err("invalid argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		DWORD group_vnum = (DWORD)lua_tonumber(L, 1);
-		long local_x = (long)lua_tonumber(L, 2) * 100;
-		long local_y = (long)lua_tonumber(L, 3) * 100;
-		float radius = (float)lua_tonumber(L, 4) * 100;
-		bool bAggressive = lua_toboolean(L, 5);
-		DWORD count = (DWORD)lua_tonumber(L, 6);
-
-		if (count == 0)
-			count = 1;
-		else if (count > 10)
-		{
-			sys_err("count bigger than 10");
-			count = 10;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
-		if (pMap == NULL)
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		DWORD dwQuestIdx = CQuestManager::instance().GetCurrentPC()->GetCurrentQuestIndex();
-
-		bool ret = false;
-		LPCHARACTER mob = NULL;
-
-		while (count--)
-		{
-			for (int loop = 0; loop < 8; ++loop)
-			{
-				float angle = number(0, 999) * M_PI * 2 / 1000;
-				float r = number(0, 999) * radius / 1000;
-
-				long x = local_x + pMap->m_setting.iBaseX + (long)(r * cos(angle));
-				long y = local_y + pMap->m_setting.iBaseY + (long)(r * sin(angle));
-
-				mob = CHARACTER_MANAGER::instance().SpawnGroup(group_vnum, ch->GetMapIndex(), x, y, x, y, NULL, bAggressive);
-
-				if (mob)
-					break;
-			}
-
-			if (mob)
-			{
-				mob->SetQuestBy(dwQuestIdx);
-
-				if (!ret)
-				{
-					ret = true;
-					lua_pushnumber(L, (DWORD)mob->GetVID());
-				}
-			}
-		}
-
-		if (!ret)
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	//
-	// global Lua functions
-	//
-	//
-	// Registers Lua function table
-	//
-	void CQuestManager::AddLuaFunctionTable(const char* c_pszName, luaL_reg* preg)
-	{
-		lua_newtable(L);
-
-		while ((preg->name))
-		{
-			lua_pushstring(L, preg->name);
-			lua_pushcfunction(L, preg->func);
-			lua_rawset(L, -3);
-			preg++;
-		}
-
-		lua_setglobal(L, c_pszName);
-	}
-
-	void CQuestManager::BuildStateIndexToName(const char* questName)
-	{
-		int x = lua_gettop(L);
-		lua_getglobal(L, questName);
-
-		if (lua_isnil(L, -1))
-		{
-			sys_err("QUEST wrong quest state file for quest %s", questName);
-			lua_settop(L, x);
-			return;
-		}
-
-		for (lua_pushnil(L); lua_next(L, -2);)
-		{
-			if (lua_isstring(L, -2) && lua_isnumber(L, -1))
-			{
-				lua_pushvalue(L, -2);
-				lua_rawset(L, -4);
-			}
-			else
-			{
-				lua_pop(L, 1);
-			}
-		}
-
-		lua_settop(L, x);
-	}
-
-	/**
-	* @version 05/06/08 Bang2ni - __get_guildid_byname 스크립트 함수 등록
-	**/
-	bool CQuestManager::InitializeLua()
-	{
-		L = lua_open();
-
-		luaopen_base(L);
-		luaopen_table(L);
-		luaopen_string(L);
-		luaopen_math(L);
-		// TEMP
-		luaopen_io(L);
-		luaopen_debug(L);
-
-		RegisterAffectFunctionTable();
-		RegisterBuildingFunctionTable();
-		RegisterDungeonFunctionTable();
-		RegisterGameFunctionTable();
-		RegisterGuildFunctionTable();
-		RegisterHorseFunctionTable();
-#if defined(__PET_SYSTEM__)
-		RegisterPetFunctionTable();
-#endif
-		RegisterITEMFunctionTable();
-		RegisterMarriageFunctionTable();
-		RegisterNPCFunctionTable();
-		RegisterPartyFunctionTable();
-		RegisterPCFunctionTable();
-		RegisterQuestFunctionTable();
-		RegisterTargetFunctionTable();
-		RegisterArenaFunctionTable();
-		RegisterForkedFunctionTable();
-		RegisterMonarchFunctionTable();
-		RegisterOXEventFunctionTable();
-		RegisterMgmtFunctionTable();
-		RegisterBattleArenaFunctionTable();
-		RegisterDanceEventFunctionTable();
-		RegisterDragonLairFunctionTable();
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-		RegisterGuildDragonLairFunctionTable();
-#endif
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		RegisterDragonSoulFunctionTable();
-#endif
-#if defined(__DEFENSE_WAVE__)
-		RegisterDefenseWaveFunctionTable();
-#endif
-#ifdef ENABLE_QUEEN_NETHIS
-		RegisterSnakeLairFunctionTable();
-#endif
-#if defined(__ATTR_6TH_7TH__)
-		RegisterAttr67AddFunctionTable();
-#endif
-
-		{
-			luaL_reg member_functions[] =
-			{
-				{ "chat", member_chat },
-				{ "set_ready", member_set_ready },
-				{ "clear_ready", member_clear_ready },
-				{ NULL, NULL }
-			};
-
-			AddLuaFunctionTable("member", member_functions);
-		}
-
-		{
-			luaL_reg highscore_functions[] =
-			{
-				{ "register", highscore_register },
-				{ "show", highscore_show },
-				{ NULL, NULL }
-			};
-
-			AddLuaFunctionTable("highscore", highscore_functions);
-		}
-
-		{
-			luaL_reg mob_functions[] =
-			{
-				{ "spawn", mob_spawn },
-				{ "spawn_group", mob_spawn_group },
-				{ NULL, NULL }
-			};
-
-			AddLuaFunctionTable("mob", mob_functions);
-		}
-
-		//
-		// global namespace functions
-		//
-		RegisterGlobalFunctionTable(L);
-
-		// LUA_INIT_ERROR_MESSAGE
-		{
-			char settingsFileName[256];
-			snprintf(settingsFileName, sizeof(settingsFileName), "%s/settings.lua", LocaleService_GetBasePath().c_str());
-
-			int settingsLoadingResult = lua_dofile(L, settingsFileName);
-			sys_log(0, "LoadSettings(%s), returns %d", settingsFileName, settingsLoadingResult);
-			if (settingsLoadingResult != 0)
-			{
-				sys_err("LOAD_SETTINS_FAILURE(%s)", settingsFileName);
-				return false;
-			}
-		}
-
-		{
-			char questlibFileName[256];
-			snprintf(questlibFileName, sizeof(questlibFileName), "%s/questlib.lua", LocaleService_GetQuestPath().c_str());
-
-			int questlibLoadingResult = lua_dofile(L, questlibFileName);
-			sys_log(0, "LoadQuestlib(%s), returns %d", questlibFileName, questlibLoadingResult);
-			if (questlibLoadingResult != 0)
-			{
-				sys_err("LOAD_QUESTLIB_FAILURE(%s)", questlibFileName);
-				return false;
-			}
-		}
-
-		if (LC_IsEurope())
-		{
-			char translateFileName[256];
-			snprintf(translateFileName, sizeof(translateFileName), "%s/translate.lua", LocaleService_GetBasePath().c_str());
-
-			int translateLoadingResult = lua_dofile(L, translateFileName);
-			sys_log(0, "LoadTranslate(%s), returns %d", translateFileName, translateLoadingResult);
-			if (translateLoadingResult != 0)
-			{
-				sys_err("LOAD_TRANSLATE_ERROR(%s)", translateFileName);
-				return false;
-			}
-		}
-
-		{
-			char questLocaleFileName[256];
-			if (LC_IsEurope())
-			{
-				snprintf(questLocaleFileName, sizeof(questLocaleFileName), "%s/locale.lua", g_stQuestDir.c_str());
-			}
-			else
-			{
-				snprintf(questLocaleFileName, sizeof(questLocaleFileName), "%s/locale_%s.lua", g_stQuestDir.c_str(), g_stLocale.c_str());
-			}
-
-			int questLocaleLoadingResult = lua_dofile(L, questLocaleFileName);
-			sys_log(0, "LoadQuestLocale(%s), returns %d", questLocaleFileName, questLocaleLoadingResult);
-			if (questLocaleLoadingResult != 0)
-			{
-				sys_err("LoadQuestLocale(%s) FAILURE", questLocaleFileName);
-				return false;
-			}
-		}
-		// END_OF_LUA_INIT_ERROR_MESSAGE
-
-		for (auto it = g_setQuestObjectDir.begin(); it != g_setQuestObjectDir.end(); ++it)
-		{
-			const string& stQuestObjectDir = *it;
-			char buf[PATH_MAX];
-			snprintf(buf, sizeof(buf), "%s/state/", stQuestObjectDir.c_str());
-			DIR* pdir = opendir(buf);
-			int iQuestIdx = 0;
-
-			if (pdir)
-			{
-				dirent* pde;
-
-				while ((pde = readdir(pdir)))
-				{
-					if (pde->d_name[0] == '.')
-						continue;
-
-					snprintf(buf + 11, sizeof(buf) - 11, "%s", pde->d_name);
-
-					RegisterQuest(pde->d_name, ++iQuestIdx);
-					int ret = lua_dofile(L, (stQuestObjectDir + "/state/" + pde->d_name).c_str());
-					sys_log(0, "QUEST: loading %s, returns %d", (stQuestObjectDir + "/state/" + pde->d_name).c_str(), ret);
-
-					BuildStateIndexToName(pde->d_name);
-				}
-
-				closedir(pdir);
-			}
-		}
-
-		lua_setgcthreshold(L, 0);
-
-		lua_newtable(L);
-		lua_setglobal(L, "__codecache");
-		return true;
-	}
-
-	void CQuestManager::GotoSelectState(QuestState& qs)
-	{
-		lua_checkstack(qs.co, 1);
-
-		//int n = lua_gettop(L);
-		int n = luaL_getn(qs.co, -1);
-		qs.args = n;
-		//cout << "select here (1-" << qs.args << ")" << endl;
-		//
-
-		ostringstream os;
-		os << "[QUESTION ";
-
-		for (int i = 1; i <= n; i++)
-		{
-			lua_rawgeti(qs.co, -1, i);
-			if (lua_isstring(qs.co, -1))
-			{
-				//printf("%d\t%s\n",i,lua_tostring(qs.co,-1));
-				if (i != 1)
-					os << "|";
-				os << i << ";" << lua_tostring(qs.co, -1);
-			}
-			else
-			{
-				sys_err("SELECT wrong data %s", lua_typename(qs.co, -1));
-				sys_err("here");
-			}
-			lua_pop(qs.co, 1);
-		}
-		os << "]";
-
-		AddScript(os.str());
-		qs.suspend_state = SUSPEND_STATE_SELECT;
-		if (test_server)
-			sys_log(0, "%s", m_strScript.c_str());
-		SendScript();
-	}
-
-	EVENTINFO(confirm_timeout_event_info)
-	{
-		DWORD dwWaitPID;
-		DWORD dwReplyPID;
-
-		confirm_timeout_event_info()
-			: dwWaitPID(0)
-			, dwReplyPID(0)
-		{
-		}
-	};
-
-	EVENTFUNC(confirm_timeout_event)
-	{
-		confirm_timeout_event_info* info = dynamic_cast<confirm_timeout_event_info*>(event->info);
-
-		if (info == NULL)
-		{
-			sys_err("confirm_timeout_event> <Factor> Null pointer");
-			return 0;
-		}
-
-		LPCHARACTER chWait = CHARACTER_MANAGER::instance().FindByPID(info->dwWaitPID);
-		LPCHARACTER chReply = NULL; //CHARACTER_MANAGER::info().FindByPID(info->dwReplyPID);
-
-		if (chReply)
-		{
-			// 시간 지나면 알아서 닫힘
-		}
-
-		if (chWait)
-		{
-			CQuestManager::instance().Confirm(info->dwWaitPID, CONFIRM_TIMEOUT);
-		}
-
-		return 0;
-	}
-
-	void CQuestManager::GotoConfirmState(QuestState& qs)
-	{
-		qs.suspend_state = SUSPEND_STATE_CONFIRM;
-		DWORD dwVID = (DWORD)lua_tonumber(qs.co, -3);
-		const char* szMsg = lua_tostring(qs.co, -2);
-		int iTimeout = (int)lua_tonumber(qs.co, -1);
-
-		sys_log(0, "GotoConfirmState vid %u msg '%s', timeout %d", dwVID, szMsg, iTimeout);
-
-		// 1. 상대방에게 확인창 띄움
-		// 2. 나에게 확인 기다린다고 표시하는 창 띄움
-		// 3. 타임아웃 설정 (타임아웃 되면 상대방 창 닫고 나에게도 창 닫으라고 보냄)
-
-		// 1
-		// 상대방이 없는 경우는 그냥 상대방에게 보내지 않는다. 타임아웃에 의해서 넘어가게됨
-		LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(dwVID);
-		if (ch && ch->IsPC())
-		{
-			ch->ConfirmWithMsg(szMsg, iTimeout, GetCurrentCharacterPtr()->GetPlayerID());
-		}
-
-		// 2
-		GetCurrentPC()->SetConfirmWait((ch && ch->IsPC()) ? ch->GetPlayerID() : 0);
-		ostringstream os;
-		os << "[CONFIRM_WAIT timeout;" << iTimeout << "]";
-		AddScript(os.str());
-		SendScript();
-
-		// 3
-		confirm_timeout_event_info* info = AllocEventInfo<confirm_timeout_event_info>();
-
-		info->dwWaitPID = GetCurrentCharacterPtr()->GetPlayerID();
-		info->dwReplyPID = (ch && ch->IsPC()) ? ch->GetPlayerID() : 0;
-
-		event_create(confirm_timeout_event, info, PASSES_PER_SEC(iTimeout));
-	}
-
-	void CQuestManager::GotoSelectItemState(QuestState& qs)
-	{
-		qs.suspend_state = SUSPEND_STATE_SELECT_ITEM;
-		AddScript("[SELECT_ITEM]");
-		SendScript();
-	}
-
-	void CQuestManager::GotoInputState(QuestState& qs)
-	{
-		qs.suspend_state = SUSPEND_STATE_INPUT;
-		AddScript("[INPUT]");
-		SendScript();
-
-		// 시간 제한을 검
-		//event_create(input_timeout_event, dwEI, PASSES_PER_SEC(iTimeout));
-	}
-
-	void CQuestManager::GotoPauseState(QuestState& qs)
-	{
-		qs.suspend_state = SUSPEND_STATE_PAUSE;
-		AddScript("[NEXT]");
-		SendScript();
-	}
-
-	void CQuestManager::GotoEndState(QuestState& qs)
-	{
-		AddScript("[DONE]");
-		SendScript();
-	}
-
-	//
-	// * OpenState
-	//
-	// The beginning of script
-	//
-
-	QuestState CQuestManager::OpenState(const string& quest_name, int state_index)
-	{
-		QuestState qs;
-		qs.args = 0;
-		qs.st = state_index;
-		qs.co = lua_newthread(L);
-		qs.ico = lua_ref(L, 1 /* qs.co */);
-		return qs;
-	}
-
-	//
-	// * RunState
-	//
-	// decides script to wait for user input, or finish
-	//
-	bool CQuestManager::RunState(QuestState& qs)
-	{
-		ClearError();
-
-		m_CurrentRunningState = &qs;
-		int ret = lua_resume(qs.co, qs.args);
-
-		if (ret == 0)
-		{
-			if (lua_gettop(qs.co) == 0)
-			{
-				// end of quest
-				GotoEndState(qs);
-				return false;
-			}
-
-			if (!strcmp(lua_tostring(qs.co, 1), "select"))
-			{
-				GotoSelectState(qs);
-				return true;
-			}
-
-			if (!strcmp(lua_tostring(qs.co, 1), "wait"))
-			{
-				GotoPauseState(qs);
-				return true;
-			}
-
-			if (!strcmp(lua_tostring(qs.co, 1), "input"))
-			{
-				GotoInputState(qs);
-				return true;
-			}
-
-			if (!strcmp(lua_tostring(qs.co, 1), "confirm"))
-			{
-				GotoConfirmState(qs);
-				return true;
-			}
-
-			if (!strcmp(lua_tostring(qs.co, 1), "select_item"))
-			{
-				GotoSelectItemState(qs);
-				return true;
-			}
-		}
-		else
-		{
-			sys_err("LUA_ERROR: %s", lua_tostring(qs.co, 1));
-		}
-
-		WriteRunningStateToSyserr();
-		SetError();
-
-		GotoEndState(qs);
-		return false;
-	}
-
-	//
-	// * CloseState
-	//
-	// makes script end
-	//
-	void CQuestManager::CloseState(QuestState& qs)
-	{
-		if (qs.co)
-		{
-			//cerr << "ICO "<<qs.ico <<endl;
-			lua_unref(L, qs.ico);
-			qs.co = 0;
-		}
-	}
-}
+static void EscapeLuaSQLString(char* out, size_t outSize, const char* in)
+{
+	if (!out || outSize == 0)
+		return;
+	if (!in)
+	{
+		out[0] = '\0';
+		return;
+	}
+	DBManager::instance().EscapeString(out, outSize, in, strlen(in));
+}
+#include "stdafx.h"
+
+#include <sstream>
+
+#include "questmanager.h"
+#include "questlua.h"
+#include "config.h"
+#include "desc.h"
+#include "char.h"
+#include "char_manager.h"
+#include "buffer_manager.h"
+#include "db.h"
+#include "xmas_event.h"
+#include "locale_service.h"
+#include "regen.h"
+#include "affect.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "sectree_manager.h"
+
+#if defined(__DUNGEON_RENEWAL__)
+#	include "utils.h"
+#endif
+
+#undef sys_err
+#ifndef __WIN32__
+#define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
+#else
+#define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
+#endif
+
+namespace quest
+{
+	using namespace std;
+
+	string ScriptToString(const string& str)
+	{
+		lua_State* L = CQuestManager::instance().GetLuaState();
+		int x = lua_gettop(L);
+
+		int errcode = lua_dobuffer(L, ("return " + str).c_str(), str.size() + 7, "ScriptToString");
+		string retstr;
+		if (!errcode)
+		{
+			if (lua_isstring(L, -1))
+				retstr = lua_tostring(L, -1);
+		}
+		else
+		{
+			sys_err("LUA ScriptRunError (code:%d src:[%s])", errcode, str.c_str());
+		}
+		lua_settop(L, x);
+		return retstr;
+	}
+
+	void FSetWarpLocation::operator() (LPCHARACTER ch)
+	{
+		if (ch->IsPC())
+		{
+			ch->SetWarpLocation(map_index, x, y);
+		}
+	}
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	void FDungeonUpdateAllBattlepassProcess::operator() (LPCHARACTER ch)
+	{
+		if (ch->IsPC())
+			ch->UpdateExtBattlePassMissionProgress(COMPLETE_DUNGEON, 1, dungeon_index);
+	}
+#endif
+
+	void FSetQuestFlag::operator() (LPCHARACTER ch)
+	{
+		if (!ch->IsPC())
+			return;
+
+		PC* pPC = CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+
+		if (pPC)
+			pPC->SetFlag(flagname, value);
+	}
+
+#if defined(__DUNGEON_RENEWAL__)
+	void FSetQuestFlagToNearMembers::operator() (LPCHARACTER ch)
+	{
+		if (!ch->IsPC())
+			return;
+
+		PC* pPC = CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+		if (pPC && DISTANCE_APPROX(ch->GetX() - x * 100, ch->GetY() - y * 100) < dist * 100)
+			pPC->SetFlag(flagname, value);
+	}
+#endif
+
+	bool FPartyCheckFlagLt::operator() (LPCHARACTER ch)
+	{
+		if (!ch->IsPC())
+			return false;
+
+		PC* pPC = CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+		bool returnBool;
+		if (pPC)
+		{
+			int flagValue = pPC->GetFlag(flagname);
+			if (value > flagValue)
+				returnBool = true;
+			else
+				returnBool = false;
+		}
+
+		return returnBool;
+	}
+
+	FPartyChat::FPartyChat(int ChatType, const char* str) : iChatType(ChatType), str(str)
+	{
+	}
+
+	void FPartyChat::operator() (LPCHARACTER ch)
+	{
+		ch->ChatPacket(iChatType, "%s", str);
+	}
+
+	void FPartyClearReady::operator() (LPCHARACTER ch)
+	{
+		ch->RemoveAffect(AFFECT_DUNGEON_READY);
+	}
+
+	void FSendPacket::operator() (LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+
+			if (ch->GetDesc())
+			{
+				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+			}
+		}
+	}
+
+	void FSendPacketToEmpire::operator() (LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+
+			if (ch->GetDesc())
+			{
+				if (ch->GetEmpire() == bEmpire)
+					ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+			}
+		}
+	}
+
+	void FWarpEmpire::operator() (LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+
+			if (ch->IsPC() && ch->GetEmpire() == m_bEmpire)
+			{
+				ch->WarpSet(m_x, m_y, m_lMapIndexTo);
+			}
+		}
+	}
+
+	FBuildLuaGuildWarList::FBuildLuaGuildWarList(lua_State* lua_state) : L(lua_state), m_count(1)
+	{
+		lua_newtable(lua_state);
+	}
+
+	void FBuildLuaGuildWarList::operator() (DWORD g1, DWORD g2)
+	{
+		CGuild* g = CGuildManager::instance().FindGuild(g1);
+
+		if (!g)
+			return;
+
+		if (g->GetGuildWarType(g2) == GUILD_WAR_TYPE_FIELD)
+			return;
+
+		if (g->GetGuildWarState(g2) != GUILD_WAR_ON_WAR)
+			return;
+
+		lua_newtable(L);
+		lua_pushnumber(L, g1);
+		lua_rawseti(L, -2, 1);
+		lua_pushnumber(L, g2);
+		lua_rawseti(L, -2, 2);
+		lua_rawseti(L, -2, m_count++);
+	}
+
+	bool IsScriptTrue(const char* code, int size)
+	{
+		if (size == 0)
+			return true;
+
+		lua_State* L = CQuestManager::instance().GetLuaState();
+		int x = lua_gettop(L);
+		int errcode = lua_dobuffer(L, code, size, "IsScriptTrue");
+		int bStart = lua_toboolean(L, -1);
+		if (errcode)
+		{
+			char buf[100];
+			snprintf(buf, sizeof(buf), "LUA ScriptRunError (code:%%d src:[%%%ds])", size);
+			sys_err(buf, errcode, code);
+		}
+		lua_settop(L, x);
+		return bStart != 0;
+	}
+
+	void combine_lua_string(lua_State* L, ostringstream& s)
+	{
+		char buf[32];
+
+		int n = lua_gettop(L);
+		int i;
+
+		for (i = 1; i <= n; ++i)
+		{
+			if (lua_isstring(L, i))
+				//printf("%s\n",lua_tostring(L,i));
+				s << lua_tostring(L, i);
+			else if (lua_isnumber(L, i))
+			{
+				snprintf(buf, sizeof(buf), "%.14g\n", lua_tonumber(L, i));
+				s << buf;
+			}
+		}
+	}
+
+	int highscore_show(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		const char* pszBoardName = lua_tostring(L, 1);
+		char szBoardEsc[512];
+		DBManager::instance().EscapeString(szBoardEsc, pszBoardName ? pszBoardName : "", pszBoardName ? strlen(pszBoardName) : 0);
+		DWORD mypid = q.GetCurrentCharacterPtr()->GetPlayerID();
+		bool bOrder = (int)lua_tonumber(L, 2) != 0 ? true : false;
+
+		DBManager::instance().ReturnQuery(QID_HIGHSCORE_SHOW, mypid, NULL,
+			"SELECT h.pid, p.name, h.value FROM highscore%s as h, player%s as p WHERE h.board = '%s' AND h.pid = p.id ORDER BY h.value %s LIMIT 10",
+			get_table_postfix(), get_table_postfix(), szBoardEsc, bOrder ? "DESC" : "");
+		return 0;
+	}
+
+	int highscore_register(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+
+		THighscoreRegisterQueryInfo* qi = M2_NEW THighscoreRegisterQueryInfo;
+
+		strlcpy(qi->szBoard, lua_tostring(L, 1), sizeof(qi->szBoard));
+		char szBoardEsc[sizeof(qi->szBoard) * 2 + 1];
+		DBManager::instance().EscapeString(szBoardEsc, qi->szBoard, strnlen(qi->szBoard, sizeof(qi->szBoard)));
+		qi->dwPID = q.GetCurrentCharacterPtr()->GetPlayerID();
+		qi->iValue = (int)lua_tonumber(L, 2);
+		qi->bOrder = (int)lua_tonumber(L, 3);
+
+		DBManager::instance().ReturnQuery(QID_HIGHSCORE_REGISTER, qi->dwPID, qi,
+			"SELECT value FROM highscore%s WHERE board='%s' AND pid=%u", get_table_postfix(), szBoardEsc, qi->dwPID);
+		return 1;
+	}
+
+	//
+	// "member" Lua functions
+	//
+	int member_chat(lua_State* L)
+	{
+		ostringstream s;
+		combine_lua_string(L, s);
+		CQuestManager::Instance().GetCurrentPartyMember()->ChatPacket(CHAT_TYPE_TALKING, "%s", s.str().c_str());
+		return 0;
+	}
+
+	int member_clear_ready(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentPartyMember();
+		ch->RemoveAffect(AFFECT_DUNGEON_READY);
+		return 0;
+	}
+
+	int member_set_ready(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentPartyMember();
+		ch->AddAffect(AFFECT_DUNGEON_READY, POINT_NONE, 0, AFF_DUNGEON_READY, 65535, 0, true);
+		return 0;
+	}
+
+	// 20190817.Owsap : Purge monster after spawn.
+	EVENTFUNC(purge_time_event)
+	{
+		char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+
+		if (!info)
+		{
+			sys_err("purge_time_event> <Factor> Null pointer");
+			return 0;
+		}
+
+		LPCHARACTER ch = info->ch;
+		if (!ch)
+			return 0;
+
+		M2_DESTROY_CHARACTER(ch);
+		return 0;
+	}
+
+	int mob_spawn(lua_State* L)
+	{
+		/*
+		* arg1 : vnum
+		* arg2 : x
+		* arg3 : y
+		* arg4 : radius
+		* arg5 : aggressive
+		* arg6 : count
+		* arg7 : purge time 20190817.Owsap : Purge monster after spawn.
+		*/
+
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
+		{
+			sys_err("invalid argument");
+			return 0;
+		}
+
+		DWORD mob_vnum = (DWORD)lua_tonumber(L, 1);
+		long local_x = (long)lua_tonumber(L, 2) * 100;
+		long local_y = (long)lua_tonumber(L, 3) * 100;
+		float radius = (float)lua_tonumber(L, 4) * 100;
+		bool bAggressive = lua_toboolean(L, 5);
+		DWORD count = (lua_isnumber(L, 6)) ? (DWORD)lua_tonumber(L, 6) : 1;
+
+		if (count == 0)
+			count = 1;
+		else if (count > 10)
+		{
+			sys_err("count bigger than 10");
+			count = 10;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
+
+		if (pMap == NULL)
+			return 0;
+
+		DWORD dwQuestIdx = CQuestManager::instance().GetCurrentPC()->GetCurrentQuestIndex();
+
+		bool ret = false;
+		LPCHARACTER mob = NULL;
+
+		while (count--)
+		{
+			for (int loop = 0; loop < 8; ++loop)
+			{
+				float angle = number(0, 999) * M_PI * 2 / 1000;
+				float r = number(0, 999) * radius / 1000;
+
+				long x = local_x + pMap->m_setting.iBaseX + (long)(r * cos(angle));
+				long y = local_y + pMap->m_setting.iBaseY + (long)(r * sin(angle));
+
+				mob = CHARACTER_MANAGER::instance().SpawnMob(mob_vnum, ch->GetMapIndex(), x, y, 0);
+
+				if (mob)
+				{
+					// 20190817.Owsap : Purge monster after spawn.
+					if (lua_isnumber(L, 7))
+					{
+						long lPurgeTime = (long)lua_tonumber(L, 7);
+						if (lPurgeTime > 0)
+						{
+							char_event_info* info = AllocEventInfo<char_event_info>();
+							info->ch = mob;
+							event_create(purge_time_event, info, PASSES_PER_SEC(lPurgeTime));
+						}
+					}
+					break;
+				}
+			}
+
+			if (mob)
+			{
+				if (bAggressive)
+					mob->SetAggressive();
+
+				mob->SetQuestBy(dwQuestIdx);
+
+				if (!ret)
+				{
+					ret = true;
+					lua_pushnumber(L, (DWORD)mob->GetVID());
+				}
+			}
+		}
+
+		if (!ret)
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int mob_spawn_group(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4) || !lua_isnumber(L, 6))
+		{
+			sys_err("invalid argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		DWORD group_vnum = (DWORD)lua_tonumber(L, 1);
+		long local_x = (long)lua_tonumber(L, 2) * 100;
+		long local_y = (long)lua_tonumber(L, 3) * 100;
+		float radius = (float)lua_tonumber(L, 4) * 100;
+		bool bAggressive = lua_toboolean(L, 5);
+		DWORD count = (DWORD)lua_tonumber(L, 6);
+
+		if (count == 0)
+			count = 1;
+		else if (count > 10)
+		{
+			sys_err("count bigger than 10");
+			count = 10;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
+		if (pMap == NULL)
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		DWORD dwQuestIdx = CQuestManager::instance().GetCurrentPC()->GetCurrentQuestIndex();
+
+		bool ret = false;
+		LPCHARACTER mob = NULL;
+
+		while (count--)
+		{
+			for (int loop = 0; loop < 8; ++loop)
+			{
+				float angle = number(0, 999) * M_PI * 2 / 1000;
+				float r = number(0, 999) * radius / 1000;
+
+				long x = local_x + pMap->m_setting.iBaseX + (long)(r * cos(angle));
+				long y = local_y + pMap->m_setting.iBaseY + (long)(r * sin(angle));
+
+				mob = CHARACTER_MANAGER::instance().SpawnGroup(group_vnum, ch->GetMapIndex(), x, y, x, y, NULL, bAggressive);
+
+				if (mob)
+					break;
+			}
+
+			if (mob)
+			{
+				mob->SetQuestBy(dwQuestIdx);
+
+				if (!ret)
+				{
+					ret = true;
+					lua_pushnumber(L, (DWORD)mob->GetVID());
+				}
+			}
+		}
+
+		if (!ret)
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	//
+	// global Lua functions
+	//
+	//
+	// Registers Lua function table
+	//
+	void CQuestManager::AddLuaFunctionTable(const char* c_pszName, luaL_reg* preg)
+	{
+		lua_newtable(L);
+
+		while ((preg->name))
+		{
+			lua_pushstring(L, preg->name);
+			lua_pushcfunction(L, preg->func);
+			lua_rawset(L, -3);
+			preg++;
+		}
+
+		lua_setglobal(L, c_pszName);
+	}
+
+	void CQuestManager::BuildStateIndexToName(const char* questName)
+	{
+		int x = lua_gettop(L);
+		lua_getglobal(L, questName);
+
+		if (lua_isnil(L, -1))
+		{
+			sys_err("QUEST wrong quest state file for quest %s", questName);
+			lua_settop(L, x);
+			return;
+		}
+
+		for (lua_pushnil(L); lua_next(L, -2);)
+		{
+			if (lua_isstring(L, -2) && lua_isnumber(L, -1))
+			{
+				lua_pushvalue(L, -2);
+				lua_rawset(L, -4);
+			}
+			else
+			{
+				lua_pop(L, 1);
+			}
+		}
+
+		lua_settop(L, x);
+	}
+
+	/**
+	* @version 05/06/08 Bang2ni - __get_guildid_byname 크트 獨 
+	**/
+	bool CQuestManager::InitializeLua()
+	{
+		L = lua_open();
+
+		luaopen_base(L);
+		luaopen_table(L);
+		luaopen_string(L);
+		luaopen_math(L);
+		// TEMP
+		luaopen_io(L);
+		luaopen_debug(L);
+
+		RegisterAffectFunctionTable();
+		RegisterBuildingFunctionTable();
+		RegisterDungeonFunctionTable();
+		RegisterGameFunctionTable();
+		RegisterGuildFunctionTable();
+		RegisterHorseFunctionTable();
+#if defined(__PET_SYSTEM__)
+		RegisterPetFunctionTable();
+#endif
+		RegisterITEMFunctionTable();
+		RegisterMarriageFunctionTable();
+		RegisterNPCFunctionTable();
+		RegisterPartyFunctionTable();
+		RegisterPCFunctionTable();
+		RegisterQuestFunctionTable();
+		RegisterTargetFunctionTable();
+		RegisterArenaFunctionTable();
+		RegisterForkedFunctionTable();
+		RegisterMonarchFunctionTable();
+		RegisterOXEventFunctionTable();
+		RegisterMgmtFunctionTable();
+		RegisterBattleArenaFunctionTable();
+		RegisterDanceEventFunctionTable();
+		RegisterDragonLairFunctionTable();
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+		RegisterGuildDragonLairFunctionTable();
+#endif
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		RegisterDragonSoulFunctionTable();
+#endif
+#if defined(__DEFENSE_WAVE__)
+		RegisterDefenseWaveFunctionTable();
+#endif
+#ifdef ENABLE_QUEEN_NETHIS
+		RegisterSnakeLairFunctionTable();
+#endif
+#if defined(__ATTR_6TH_7TH__)
+		RegisterAttr67AddFunctionTable();
+#endif
+
+		{
+			luaL_reg member_functions[] =
+			{
+				{ "chat", member_chat },
+				{ "set_ready", member_set_ready },
+				{ "clear_ready", member_clear_ready },
+				{ NULL, NULL }
+			};
+
+			AddLuaFunctionTable("member", member_functions);
+		}
+
+		{
+			luaL_reg highscore_functions[] =
+			{
+				{ "register", highscore_register },
+				{ "show", highscore_show },
+				{ NULL, NULL }
+			};
+
+			AddLuaFunctionTable("highscore", highscore_functions);
+		}
+
+		{
+			luaL_reg mob_functions[] =
+			{
+				{ "spawn", mob_spawn },
+				{ "spawn_group", mob_spawn_group },
+				{ NULL, NULL }
+			};
+
+			AddLuaFunctionTable("mob", mob_functions);
+		}
+
+		//
+		// global namespace functions
+		//
+		RegisterGlobalFunctionTable(L);
+
+		// LUA_INIT_ERROR_MESSAGE
+		{
+			char settingsFileName[256];
+			snprintf(settingsFileName, sizeof(settingsFileName), "%s/settings.lua", LocaleService_GetBasePath().c_str());
+
+			int settingsLoadingResult = lua_dofile(L, settingsFileName);
+			sys_log(0, "LoadSettings(%s), returns %d", settingsFileName, settingsLoadingResult);
+			if (settingsLoadingResult != 0)
+			{
+				sys_err("LOAD_SETTINS_FAILURE(%s)", settingsFileName);
+				return false;
+			}
+		}
+
+		{
+			char questlibFileName[256];
+			snprintf(questlibFileName, sizeof(questlibFileName), "%s/questlib.lua", LocaleService_GetQuestPath().c_str());
+
+			int questlibLoadingResult = lua_dofile(L, questlibFileName);
+			sys_log(0, "LoadQuestlib(%s), returns %d", questlibFileName, questlibLoadingResult);
+			if (questlibLoadingResult != 0)
+			{
+				sys_err("LOAD_QUESTLIB_FAILURE(%s)", questlibFileName);
+				return false;
+			}
+		}
+
+		if (LC_IsEurope())
+		{
+			char translateFileName[256];
+			snprintf(translateFileName, sizeof(translateFileName), "%s/translate.lua", LocaleService_GetBasePath().c_str());
+
+			int translateLoadingResult = lua_dofile(L, translateFileName);
+			sys_log(0, "LoadTranslate(%s), returns %d", translateFileName, translateLoadingResult);
+			if (translateLoadingResult != 0)
+			{
+				sys_err("LOAD_TRANSLATE_ERROR(%s)", translateFileName);
+				return false;
+			}
+		}
+
+		{
+			char questLocaleFileName[256];
+			if (LC_IsEurope())
+			{
+				snprintf(questLocaleFileName, sizeof(questLocaleFileName), "%s/locale.lua", g_stQuestDir.c_str());
+			}
+			else
+			{
+				snprintf(questLocaleFileName, sizeof(questLocaleFileName), "%s/locale_%s.lua", g_stQuestDir.c_str(), g_stLocale.c_str());
+			}
+
+			int questLocaleLoadingResult = lua_dofile(L, questLocaleFileName);
+			sys_log(0, "LoadQuestLocale(%s), returns %d", questLocaleFileName, questLocaleLoadingResult);
+			if (questLocaleLoadingResult != 0)
+			{
+				sys_err("LoadQuestLocale(%s) FAILURE", questLocaleFileName);
+				return false;
+			}
+		}
+		// END_OF_LUA_INIT_ERROR_MESSAGE
+
+		for (auto it = g_setQuestObjectDir.begin(); it != g_setQuestObjectDir.end(); ++it)
+		{
+			const string& stQuestObjectDir = *it;
+			char buf[PATH_MAX];
+			snprintf(buf, sizeof(buf), "%s/state/", stQuestObjectDir.c_str());
+			DIR* pdir = opendir(buf);
+			int iQuestIdx = 0;
+
+			if (pdir)
+			{
+				dirent* pde;
+
+				while ((pde = readdir(pdir)))
+				{
+					if (pde->d_name[0] == '.')
+						continue;
+
+					snprintf(buf + 11, sizeof(buf) - 11, "%s", pde->d_name);
+
+					RegisterQuest(pde->d_name, ++iQuestIdx);
+					int ret = lua_dofile(L, (stQuestObjectDir + "/state/" + pde->d_name).c_str());
+					sys_log(0, "QUEST: loading %s, returns %d", (stQuestObjectDir + "/state/" + pde->d_name).c_str(), ret);
+
+					BuildStateIndexToName(pde->d_name);
+				}
+
+				closedir(pdir);
+			}
+		}
+
+		lua_setgcthreshold(L, 0);
+
+		lua_newtable(L);
+		lua_setglobal(L, "__codecache");
+		return true;
+	}
+
+	void CQuestManager::GotoSelectState(QuestState& qs)
+	{
+		lua_checkstack(qs.co, 1);
+
+		//int n = lua_gettop(L);
+		int n = luaL_getn(qs.co, -1);
+		qs.args = n;
+		//cout << "select here (1-" << qs.args << ")" << endl;
+		//
+
+		ostringstream os;
+		os << "[QUESTION ";
+
+		for (int i = 1; i <= n; i++)
+		{
+			lua_rawgeti(qs.co, -1, i);
+			if (lua_isstring(qs.co, -1))
+			{
+				//printf("%d\t%s\n",i,lua_tostring(qs.co,-1));
+				if (i != 1)
+					os << "|";
+				os << i << ";" << lua_tostring(qs.co, -1);
+			}
+			else
+			{
+				sys_err("SELECT wrong data %s", lua_typename(qs.co, -1));
+				sys_err("here");
+			}
+			lua_pop(qs.co, 1);
+		}
+		os << "]";
+
+		AddScript(os.str());
+		qs.suspend_state = SUSPEND_STATE_SELECT;
+		if (test_server)
+			sys_log(0, "%s", m_strScript.c_str());
+		SendScript();
+	}
+
+	EVENTINFO(confirm_timeout_event_info)
+	{
+		DWORD dwWaitPID;
+		DWORD dwReplyPID;
+
+		confirm_timeout_event_info()
+			: dwWaitPID(0)
+			, dwReplyPID(0)
+		{
+		}
+	};
+
+	EVENTFUNC(confirm_timeout_event)
+	{
+		confirm_timeout_event_info* info = dynamic_cast<confirm_timeout_event_info*>(event->info);
+
+		if (info == NULL)
+		{
+			sys_err("confirm_timeout_event> <Factor> Null pointer");
+			return 0;
+		}
+
+		LPCHARACTER chWait = CHARACTER_MANAGER::instance().FindByPID(info->dwWaitPID);
+		LPCHARACTER chReply = NULL; //CHARACTER_MANAGER::info().FindByPID(info->dwReplyPID);
+
+		if (chReply)
+		{
+			// 챨  鱇티 
+		}
+
+		if (chWait)
+		{
+			CQuestManager::instance().Confirm(info->dwWaitPID, CONFIRM_TIMEOUT);
+		}
+
+		return 0;
+	}
+
+	void CQuestManager::GotoConfirmState(QuestState& qs)
+	{
+		qs.suspend_state = SUSPEND_STATE_CONFIRM;
+		DWORD dwVID = (DWORD)lua_tonumber(qs.co, -3);
+		const char* szMsg = lua_tostring(qs.co, -2);
+		int iTimeout = (int)lua_tonumber(qs.co, -1);
+
+		sys_log(0, "GotoConfirmState vid %u msg '%s', timeout %d", dwVID, szMsg, iTimeout);
+
+		// 1. 嚥 확창 
+		// 2.  확 摸鳴 표求 창 
+		// 3. 타曇틸  (타曇틸 퓔  창 腑 鍍 창  )
+
+		// 1
+		//    柳 嚥  苛쨈. 타曇틸 漫 耭載∇
+		LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(dwVID);
+		if (ch && ch->IsPC())
+		{
+			ch->ConfirmWithMsg(szMsg, iTimeout, GetCurrentCharacterPtr()->GetPlayerID());
+		}
+
+		// 2
+		GetCurrentPC()->SetConfirmWait((ch && ch->IsPC()) ? ch->GetPlayerID() : 0);
+		ostringstream os;
+		os << "[CONFIRM_WAIT timeout;" << iTimeout << "]";
+		AddScript(os.str());
+		SendScript();
+
+		// 3
+		confirm_timeout_event_info* info = AllocEventInfo<confirm_timeout_event_info>();
+
+		info->dwWaitPID = GetCurrentCharacterPtr()->GetPlayerID();
+		info->dwReplyPID = (ch && ch->IsPC()) ? ch->GetPlayerID() : 0;
+
+		event_create(confirm_timeout_event, info, PASSES_PER_SEC(iTimeout));
+	}
+
+	void CQuestManager::GotoSelectItemState(QuestState& qs)
+	{
+		qs.suspend_state = SUSPEND_STATE_SELECT_ITEM;
+		AddScript("[SELECT_ITEM]");
+		SendScript();
+	}
+
+	void CQuestManager::GotoInputState(QuestState& qs)
+	{
+		qs.suspend_state = SUSPEND_STATE_INPUT;
+		AddScript("[INPUT]");
+		SendScript();
+
+		// 챨  
+		//event_create(input_timeout_event, dwEI, PASSES_PER_SEC(iTimeout));
+	}
+
+	void CQuestManager::GotoPauseState(QuestState& qs)
+	{
+		qs.suspend_state = SUSPEND_STATE_PAUSE;
+		AddScript("[NEXT]");
+		SendScript();
+	}
+
+	void CQuestManager::GotoEndState(QuestState& qs)
+	{
+		AddScript("[DONE]");
+		SendScript();
+	}
+
+	//
+	// * OpenState
+	//
+	// The beginning of script
+	//
+
+	QuestState CQuestManager::OpenState(const string& quest_name, int state_index)
+	{
+		QuestState qs;
+		qs.args = 0;
+		qs.st = state_index;
+		qs.co = lua_newthread(L);
+		qs.ico = lua_ref(L, 1 /* qs.co */);
+		return qs;
+	}
+
+	//
+	// * RunState
+	//
+	// decides script to wait for user input, or finish
+	//
+	bool CQuestManager::RunState(QuestState& qs)
+	{
+		ClearError();
+
+		m_CurrentRunningState = &qs;
+		int ret = lua_resume(qs.co, qs.args);
+
+		if (ret == 0)
+		{
+			if (lua_gettop(qs.co) == 0)
+			{
+				// end of quest
+				GotoEndState(qs);
+				return false;
+			}
+
+			if (!strcmp(lua_tostring(qs.co, 1), "select"))
+			{
+				GotoSelectState(qs);
+				return true;
+			}
+
+			if (!strcmp(lua_tostring(qs.co, 1), "wait"))
+			{
+				GotoPauseState(qs);
+				return true;
+			}
+
+			if (!strcmp(lua_tostring(qs.co, 1), "input"))
+			{
+				GotoInputState(qs);
+				return true;
+			}
+
+			if (!strcmp(lua_tostring(qs.co, 1), "confirm"))
+			{
+				GotoConfirmState(qs);
+				return true;
+			}
+
+			if (!strcmp(lua_tostring(qs.co, 1), "select_item"))
+			{
+				GotoSelectItemState(qs);
+				return true;
+			}
+		}
+		else
+		{
+			sys_err("LUA_ERROR: %s", lua_tostring(qs.co, 1));
+		}
+
+		WriteRunningStateToSyserr();
+		SetError();
+
+		GotoEndState(qs);
+		return false;
+	}
+
+	//
+	// * CloseState
+	//
+	// makes script end
+	//
+	void CQuestManager::CloseState(QuestState& qs)
+	{
+		if (qs.co)
+		{
+			//cerr << "ICO "<<qs.ico <<endl;
+			lua_unref(L, qs.ico);
+			qs.co = 0;
+		}
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/questlua_dungeon.cpp b/server/metin2/Source/Server/game/src/questlua_dungeon.cpp
index 946354b..8e72edc 100644
--- a/server/metin2/Source/Server/game/src/questlua_dungeon.cpp
+++ b/server/metin2/Source/Server/game/src/questlua_dungeon.cpp
@@ -1,1809 +1,1838 @@
-#include "stdafx.h"
-#include "constants.h"
-#include "questmanager.h"
-#include "questlua.h"
-#include "dungeon.h"
-#include "char.h"
-#include "party.h"
-#include "buffer_manager.h"
-#include "char_manager.h"
-#include "packet.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-
-#include "config.h"
-#include "db.h"
-#include "p2p.h"
-
-#undef sys_err
-#ifndef __WIN32__
-#define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
-#else
-#define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
-#endif
-
-template <class Func> Func CDungeon::ForEachMember(Func f)
-{
-	auto it = m_set_pkCharacter.begin();
-	for (; it != m_set_pkCharacter.end(); ++it)
-	{
-		sys_log(0, "Dungeon ForEachMember %s", (*it)->GetName());
-		f(*it);
-	}
-	return f;
-}
-
-namespace quest
-{
-	//
-	// "dungeon" lua functions
-	//
-	int dungeon_notice(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->Notice(lua_tostring(L, 1));
-
-		return 0;
-	}
-
-	int dungeon_mission_msg(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->MissionMessage(lua_tostring(L, 1));
-
-		return 0;
-	}
-
-	int dungeon_sub_mission_msg(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SubMissionMessage(lua_tostring(L, 1));
-
-		return 0;
-	}
-
-	int dungeon_clear_mission_msg(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->MissionMessage("");
-
-		return 0;
-	}
-
-	int dungeon_set_quest_flag(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-
-		FSetQuestFlag f;
-
-		f.flagname = q.GetCurrentPC()->GetCurrentQuestName() + "." + lua_tostring(L, 1);
-		f.value = (int)rint(lua_tonumber(L, 2));
-
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->ForEachMember(f);
-
-		return 0;
-	}
-
-	int dungeon_set_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-		{
-			sys_err("wrong set flag");
-		}
-		else
-		{
-			CQuestManager& q = CQuestManager::instance();
-			LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-			if (pDungeon)
-			{
-				const char* sz = lua_tostring(L, 1);
-				int value = int(lua_tonumber(L, 2));
-				pDungeon->SetFlag(sz, value);
-			}
-			else
-			{
-				sys_err("no dungeon !!!");
-			}
-		}
-		return 0;
-	}
-
-	int dungeon_get_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			sys_err("wrong get flag");
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			const char* sz = lua_tostring(L, 1);
-			lua_pushnumber(L, pDungeon->GetFlag(sz));
-		}
-		else
-		{
-			sys_err("no dungeon !!!");
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-#if defined(__DUNGEON_RENEWAL__)
-	int dungeon_set_flag_for_map_index(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("invalid args");
-			return 0;
-		}
-
-		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 3);
-		if (dwMapIndex)
-		{
-			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
-			if (pDungeon)
-			{
-				const char* sz = lua_tostring(L, 1);
-				int value = lua_tonumber(L, 2);
-				pDungeon->SetFlag(sz, value);
-			}
-			else
-			{
-				sys_err("no dungeon !!!");
-				return 0;
-			}
-		}
-
-		return 0;
-	}
-
-	int dungeon_spawn_mob_for_map_index(lua_State* L)
-	{
-		// vnum x, y
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
-		{
-			sys_err("invalid argument");
-			return 0;
-		}
-
-		const long lMapIndex = static_cast<long>(lua_tonumber(L, 4));
-		const LPDUNGEON pDungeon = CDungeonManager::Instance().FindByMapIndex(lMapIndex);
-		if (pDungeon == nullptr)
-		{
-			sys_err("no dungeon");
-			return 0;
-		}
-
-		const DWORD dwVnum = static_cast<DWORD>(lua_tonumber(L, 1));
-		const long lPosX = static_cast<long>(lua_tonumber(L, 2));
-		const long lPosY = static_cast<long>(lua_tonumber(L, 3));
-
-		const LPCHARACTER pChar = pDungeon->SpawnMob(dwVnum, lPosX, lPosY);
-		if (pChar == nullptr)
-		{
-			sys_err("failed to spawn mob %d at %ld, %ld map index %ld", dwVnum, lPosX, lPosY, lMapIndex);
-			return 0;
-		}
-
-		return 0;
-	}
-
-	int dungeon_party_notice(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-			return 0;
-
-		CQuestManager& rQmgr = CQuestManager::instance();
-		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
-		if (pDungeon == nullptr)
-			return 0;
-
-		SendPartyNotice(pDungeon->GetParty(), lua_tostring(L, 1));
-		return 0;
-	}
-
-	int dungeon_syschat(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-			return 0;
-
-		CQuestManager& rQmgr = CQuestManager::instance();
-		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
-		if (pDungeon == nullptr)
-			return 0;
-
-		FPartyChat f(CHAT_TYPE_INFO, lua_tostring(L, 1));
-		pDungeon->ForEachMember(f);
-		return 0;
-	}
-
-	int dungeon_set_quest_flag2_all_near(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
-			sys_err("Invalid Argument");
-
-		CQuestManager& q = CQuestManager::Instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-		if (NULL == ch)
-			return 0;
-
-		FSetQuestFlagToNearMembers f;
-		f.flagname = string(lua_tostring(L, 1)) + "." + lua_tostring(L, 2);
-		f.value = (int)rint(lua_tonumber(L, 3));
-		f.x = ch->GetX();
-		f.y = ch->GetY();
-		f.dist = (int)lua_tonumber(L, 4);
-
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-		if (pDungeon)
-			pDungeon->ForEachMember(f);
-
-		return 0;
-	}
-#endif
-
-	int dungeon_get_flag_from_map_index(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-		{
-			sys_err("wrong get flag");
-		}
-
-		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 2);
-		if (dwMapIndex)
-		{
-			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
-			if (pDungeon)
-			{
-				const char* sz = lua_tostring(L, 1);
-				lua_pushnumber(L, pDungeon->GetFlag(sz));
-			}
-			else
-			{
-				sys_err("no dungeon !!!");
-				lua_pushnumber(L, 0);
-			}
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-		return 1;
-	}
-
-	int dungeon_get_map_index(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			sys_log(0, "Dungeon GetMapIndex %d", pDungeon->GetMapIndex());
-			lua_pushnumber(L, pDungeon->GetMapIndex());
-		}
-		else
-		{
-			sys_err("no dungeon !!!");
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int dungeon_regen_file(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			sys_err("wrong filename");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnRegen(lua_tostring(L, 1));
-
-		return 0;
-	}
-
-	int dungeon_set_regen_file(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			sys_err("wrong filename");
-			return 0;
-		}
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnRegen(lua_tostring(L, 1), false);
-		return 0;
-	}
-
-	int dungeon_clear_regen(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-		if (pDungeon)
-			pDungeon->ClearRegen();
-		return 0;
-	}
-
-	int dungeon_check_eliminated(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-		if (pDungeon)
-			pDungeon->CheckEliminated();
-		return 0;
-	}
-
-	int dungeon_set_exit_all_at_eliminate(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong time");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SetExitAllAtEliminate((long)lua_tonumber(L, 1));
-
-		return 0;
-	}
-
-	int dungeon_set_warp_at_eliminate(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong time");
-			return 0;
-		}
-
-		if (!lua_isnumber(L, 2))
-		{
-			sys_err("wrong map index");
-			return 0;
-		}
-
-		if (!lua_isnumber(L, 3))
-		{
-			sys_err("wrong X");
-			return 0;
-		}
-
-		if (!lua_isnumber(L, 4))
-		{
-			sys_err("wrong Y");
-			return 0;
-		}
-
-		const char* c_pszRegenFile = NULL;
-
-		if (lua_gettop(L) >= 5)
-			c_pszRegenFile = lua_tostring(L, 5);
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			pDungeon->SetWarpAtEliminate((long)lua_tonumber(L, 1),
-				(long)lua_tonumber(L, 2),
-				(long)lua_tonumber(L, 3),
-				(long)lua_tonumber(L, 4),
-				c_pszRegenFile);
-		}
-		else
-			sys_err("cannot find dungeon");
-
-		return 0;
-	}
-
-	int dungeon_new_jump(lua_State* L)
-	{
-		if (lua_gettop(L) < 3)
-		{
-			sys_err("not enough argument");
-			return 0;
-		}
-
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("wrong argument");
-			return 0;
-		}
-
-		long lMapIndex = (long)lua_tonumber(L, 1);
-
-		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
-
-		if (!pDungeon)
-		{
-			sys_err("cannot create dungeon %d", lMapIndex);
-			return 0;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		// ch->WarpSet(pDungeon->GetMapIndex(), (int) lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
-		ch->WarpSet((int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3), pDungeon->GetMapIndex());
-		return 0;
-	}
-
-	int dungeon_new_jump_all(lua_State* L)
-	{
-		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("not enough argument");
-			return 0;
-		}
-
-		long lMapIndex = (long)lua_tonumber(L, 1);
-
-		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
-
-		if (!pDungeon)
-		{
-			sys_err("cannot create dungeon %d", lMapIndex);
-			return 0;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		pDungeon->JumpAll(ch->GetMapIndex(), (int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
-
-		return 0;
-	}
-
-	int dungeon_new_jump_party(lua_State* L)
-	{
-		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("not enough argument");
-			return 0;
-		}
-
-		long lMapIndex = (long)lua_tonumber(L, 1);
-
-		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
-
-		if (!pDungeon)
-		{
-			sys_err("cannot create dungeon %d", lMapIndex);
-			return 0;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->GetParty() == NULL)
-		{
-			sys_err("cannot go to dungeon alone.");
-			return 0;
-		}
-		pDungeon->JumpParty(ch->GetParty(), ch->GetMapIndex(), (int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
-
-		return 0;
-	}
-
-#if defined(__DUNGEON_RENEWAL__)
-	int dungeon_create(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("invalid argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		const long lMapIndex = (long)lua_tonumber(L, 1);
-		const LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
-		if (pDungeon == nullptr)
-		{
-			sys_err("cannot create dungeon %d", lMapIndex);
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		CQuestManager& rQmgr = CQuestManager::instance();
-		LPCHARACTER pChar = rQmgr.GetCurrentCharacterPtr();
-		if (pChar->GetParty() == nullptr)
-		{
-			sys_err("cannot go to dungeon alone.");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		pDungeon->SetParty(pChar->GetParty());
-
-		lua_pushnumber(L, pDungeon->GetMapIndex());
-		return 1;
-	}
-
-	int dungeon_destroy(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("invalid argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		const long lMapIndex = (long)lua_tonumber(L, 1);
-		CQuestManager& rQmgr = CQuestManager::instance();
-		const LPDUNGEON pDungeon = CDungeonManager::Instance().FindByMapIndex(lMapIndex);
-		if (pDungeon == nullptr)
-		{
-			sys_err("no dungeon");
-			return 0;
-		}
-
-		pDungeon->Destroy();
-		return 0;
-	}
-#endif
-
-	int dungeon_jump_all(lua_State* L)
-	{
-		if (lua_gettop(L) < 2 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
-
-		if (!pDungeon)
-			return 0;
-
-		pDungeon->JumpAll(pDungeon->GetMapIndex(), (int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2));
-		return 0;
-	}
-
-	int dungeon_warp_all(lua_State* L)
-	{
-		if (lua_gettop(L) < 2 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
-
-		if (!pDungeon)
-			return 0;
-
-		pDungeon->WarpAll(pDungeon->GetMapIndex(), (int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2));
-		return 0;
-	}
-
-	int dungeon_get_kill_stone_count(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			lua_pushnumber(L, pDungeon->GetKillStoneCount());
-			return 1;
-		}
-
-		lua_pushnumber(L, 0);
-		return 1;
-	}
-
-	int dungeon_get_kill_mob_count(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			lua_pushnumber(L, pDungeon->GetKillMobCount());
-			return 1;
-		}
-
-		lua_pushnumber(L, 0);
-		return 1;
-	}
-
-	int dungeon_is_use_potion(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			lua_pushboolean(L, 1);
-			return 1;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			lua_pushboolean(L, pDungeon->IsUsePotion());
-			return 1;
-		}
-
-		lua_pushboolean(L, 1);
-		return 1;
-	}
-
-	int dungeon_revived(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			lua_pushboolean(L, 1);
-			return 1;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			lua_pushboolean(L, pDungeon->IsUseRevive());
-			return 1;
-		}
-
-		lua_pushboolean(L, 1);
-		return 1;
-	}
-
-	int dungeon_set_dest(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		LPPARTY pParty = ch->GetParty();
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon && pParty)
-			pDungeon->SendDestPositionToParty(pParty, (int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2));
-
-		return 0;
-	}
-
-	int dungeon_unique_set_maxhp(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->UniqueSetMaxHP(lua_tostring(L, 1), lua_tonumber(L, 2));
-
-		return 0;
-	}
-
-	int dungeon_unique_set_hp(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->UniqueSetHP(lua_tostring(L, 1), lua_tonumber(L, 2));
-
-		return 0;
-	}
-
-	int dungeon_unique_set_def_grade(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->UniqueSetDefGrade(lua_tostring(L, 1), lua_tonumber(L, 2));
-
-		return 0;
-	}
-
-	int dungeon_unique_get_hp_perc(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			lua_pushnumber(L, pDungeon->GetUniqueHpPerc(lua_tostring(L, 1)));
-			return 1;
-		}
-
-		lua_pushnumber(L, 0);
-		return 1;
-	}
-
-	int dungeon_is_unique_dead(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			lua_pushboolean(L, pDungeon->IsUniqueDead(lua_tostring(L, 1)) ? 1 : 0);
-			return 1;
-		}
-
-		lua_pushboolean(L, 0);
-		return 1;
-	}
-
-	int dungeon_purge_unique(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_PURGE_UNIQUE %s", lua_tostring(L, 1));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->PurgeUnique(lua_tostring(L, 1));
-
-		return 0;
-	}
-
-	struct FPurgeArea
-	{
-		int x1, y1, x2, y2;
-		LPCHARACTER ExceptChar;
-
-		FPurgeArea(int a, int b, int c, int d, LPCHARACTER p)
-			: x1(a), y1(b), x2(c), y2(d),
-			ExceptChar(p)
-		{}
-
-		void operator () (LPENTITY ent)
-		{
-			if (true == ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER pChar = static_cast<LPCHARACTER>(ent);
-				if (pChar == ExceptChar)
-					return;
-
-				if ((true == pChar->IsMonster() || true == pChar->IsStone())
-#if defined(__PET_SYSTEM__)
-					&& !pChar->IsPet()
-#endif
-					)
-				{
-					if (x1 <= pChar->GetX() && pChar->GetX() <= x2 && y1 <= pChar->GetY() && pChar->GetY() <= y2)
-					{
-						M2_DESTROY_CHARACTER(pChar);
-					}
-				}
-			}
-		}
-	};
-
-	int dungeon_purge_area(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_PURGE_AREA");
-
-		int x1 = lua_tonumber(L, 1);
-		int y1 = lua_tonumber(L, 2);
-		int x2 = lua_tonumber(L, 3);
-		int y2 = lua_tonumber(L, 4);
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		const int mapIndex = pDungeon->GetMapIndex();
-
-		if (0 == mapIndex)
-		{
-			sys_err("_purge_area: cannot get a map index with (%u, %u)", x1, y1);
-			return 0;
-		}
-
-		LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(mapIndex);
-
-		if (NULL != pSectree)
-		{
-			FPurgeArea func(x1, y1, x2, y2, CQuestManager::instance().GetCurrentNPCCharacterPtr());
-
-			pSectree->for_each(func);
-		}
-
-		return 0;
-	}
-
-	int dungeon_kill_unique(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_KILL_UNIQUE %s", lua_tostring(L, 1));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->KillUnique(lua_tostring(L, 1));
-
-		return 0;
-	}
-
-	int dungeon_spawn_stone_door(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isstring(L, 2))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_SPAWN_STONE_DOOR %s %s", lua_tostring(L, 1), lua_tostring(L, 2));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnStoneDoor(lua_tostring(L, 1), lua_tostring(L, 2));
-
-		return 0;
-	}
-
-	int dungeon_spawn_wooden_door(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isstring(L, 2))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_SPAWN_WOODEN_DOOR %s %s", lua_tostring(L, 1), lua_tostring(L, 2));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnWoodenDoor(lua_tostring(L, 1), lua_tostring(L, 2));
-
-		return 0;
-	}
-
-	int dungeon_spawn_move_group(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isstring(L, 2) || !lua_isstring(L, 3))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_SPAWN_MOVE_GROUP %d %s %s", (int)lua_tonumber(L, 1), lua_tostring(L, 2), lua_tostring(L, 3));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnMoveGroup((DWORD)lua_tonumber(L, 1), lua_tostring(L, 2), lua_tostring(L, 3));
-
-		return 0;
-	}
-
-	int dungeon_spawn_move_unique(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3) || !lua_isstring(L, 4))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_SPAWN_MOVE_UNIQUE %s %d %s %s", lua_tostring(L, 1), (int)lua_tonumber(L, 2), lua_tostring(L, 3), lua_tostring(L, 4));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnMoveUnique(lua_tostring(L, 1), (DWORD)lua_tonumber(L, 2), lua_tostring(L, 3), lua_tostring(L, 4));
-
-		return 0;
-	}
-
-	int dungeon_spawn_unique(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_SPAWN_UNIQUE %s %d %s", lua_tostring(L, 1), (int)lua_tonumber(L, 2), lua_tostring(L, 3));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnUnique(lua_tostring(L, 1), (DWORD)lua_tonumber(L, 2), lua_tostring(L, 3));
-
-		return 0;
-	}
-
-	int dungeon_spawn(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isstring(L, 2))
-			return 0;
-		sys_log(0, "QUEST_DUNGEON_SPAWN %d %s", (int)lua_tonumber(L, 1), lua_tostring(L, 2));
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->Spawn((DWORD)lua_tonumber(L, 1), lua_tostring(L, 2));
-
-		return 0;
-	}
-
-	int dungeon_set_unique(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		DWORD vid = (DWORD)lua_tonumber(L, 2);
-
-		if (pDungeon)
-			pDungeon->SetUnique(lua_tostring(L, 1), vid);
-		return 0;
-	}
-
-	int dungeon_get_unique_vid(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			lua_pushnumber(L, pDungeon->GetUniqueVID(lua_tostring(L, 1)));
-			return 1;
-		}
-
-		lua_pushnumber(L, 0);
-		return 1;
-	}
-
-	int dungeon_spawn_mob(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("invalid argument");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		DWORD vid = 0;
-
-		if (pDungeon)
-		{
-			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
-			long x = (long)lua_tonumber(L, 2);
-			long y = (long)lua_tonumber(L, 3);
-			float radius = lua_isnumber(L, 4) ? (float)lua_tonumber(L, 4) : 0;
-			DWORD count = (lua_isnumber(L, 5)) ? (DWORD)lua_tonumber(L, 5) : 1;
-
-			sys_log(0, "dungeon_spawn_mob %u %d %d", dwVnum, x, y);
-
-			if (count == 0)
-				count = 1;
-
-			while (count--)
-			{
-				if (radius < 1)
-				{
-					LPCHARACTER ch = pDungeon->SpawnMob(dwVnum, x, y);
-					if (ch && !vid)
-						vid = ch->GetVID();
-				}
-				else
-				{
-					float angle = number(0, 999) * M_PI * 2 / 1000;
-					float r = number(0, 999) * radius / 1000;
-
-					long nx = x + (long)(r * cos(angle));
-					long ny = y + (long)(r * sin(angle));
-
-					LPCHARACTER ch = pDungeon->SpawnMob(dwVnum, nx, ny);
-					if (ch && !vid)
-						vid = ch->GetVID();
-				}
-			}
-		}
-
-		lua_pushnumber(L, vid);
-		return 1;
-	}
-
-	int dungeon_spawn_mob_dir(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
-		{
-			sys_err("invalid argument");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		DWORD vid = 0;
-
-		if (pDungeon)
-		{
-			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
-			long x = (long)lua_tonumber(L, 2);
-			long y = (long)lua_tonumber(L, 3);
-			BYTE dir = (int)lua_tonumber(L, 4);
-
-			LPCHARACTER ch = pDungeon->SpawnMob(dwVnum, x, y, dir);
-			if (ch && !vid)
-				vid = ch->GetVID();
-		}
-		lua_pushnumber(L, vid);
-		return 1;
-	}
-
-	int dungeon_spawn_mob_ac_dir(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
-		{
-			sys_err("invalid argument");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		DWORD vid = 0;
-
-		if (pDungeon)
-		{
-			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
-			long x = (long)lua_tonumber(L, 2);
-			long y = (long)lua_tonumber(L, 3);
-			BYTE dir = (int)lua_tonumber(L, 4);
-
-			LPCHARACTER ch = pDungeon->SpawnMob_ac_dir(dwVnum, x, y, dir);
-			if (ch && !vid)
-				vid = ch->GetVID();
-		}
-		lua_pushnumber(L, vid);
-		return 1;
-	}
-
-	int dungeon_spawn_goto_mob(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
-			return 0;
-
-		long lFromX = (long)lua_tonumber(L, 1);
-		long lFromY = (long)lua_tonumber(L, 2);
-		long lToX = (long)lua_tonumber(L, 3);
-		long lToY = (long)lua_tonumber(L, 4);
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->SpawnGotoMob(lFromX, lFromY, lToX, lToY);
-
-		return 0;
-	}
-
-	int dungeon_spawn_name_mob(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isstring(L, 4))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
-			long x = (long)lua_tonumber(L, 2);
-			long y = (long)lua_tonumber(L, 3);
-			pDungeon->SpawnNameMob(dwVnum, x, y, lua_tostring(L, 4));
-		}
-		return 0;
-	}
-
-	int dungeon_spawn_group(lua_State* L)
-	{
-		//
-		// argument: vnum,x,y,radius,aggressive,count
-		//
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4) || !lua_isnumber(L, 6))
-		{
-			sys_err("invalid argument");
-			return 0;
-		}
-
-		DWORD vid = 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-		{
-			DWORD group_vnum = (DWORD)lua_tonumber(L, 1);
-			long local_x = (long)lua_tonumber(L, 2) * 100;
-			long local_y = (long)lua_tonumber(L, 3) * 100;
-			float radius = (float)lua_tonumber(L, 4) * 100;
-			bool bAggressive = lua_toboolean(L, 5);
-			DWORD count = (DWORD)lua_tonumber(L, 6);
-
-			LPCHARACTER chRet = pDungeon->SpawnGroup(group_vnum, local_x, local_y, radius, bAggressive, count);
-			if (chRet)
-				vid = chRet->GetVID();
-		}
-
-		lua_pushnumber(L, vid);
-		return 1;
-	}
-
-	int dungeon_join(lua_State* L)
-	{
-		if (lua_gettop(L) < 1 || !lua_isnumber(L, 1))
-			return 0;
-
-		long lMapIndex = (long)lua_tonumber(L, 1);
-		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
-
-		if (!pDungeon)
-			return 0;
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->GetParty() && ch->GetParty()->GetLeaderPID() == ch->GetPlayerID())
-			pDungeon->JoinParty(ch->GetParty());
-		else if (!ch->GetParty())
-			pDungeon->Join(ch);
-
-		return 0;
-	}
-
-	int dungeon_exit(lua_State* L) // 던전에 들어오기 전 위치로 보냄
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		ch->ExitToSavedLocation();
-		return 0;
-	}
-
-	int dungeon_exit_all(lua_State* L) // 던전에 있는 모든 사람을 던전에 들어오기 전 위치로 보냄
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->ExitAll();
-
-		return 0;
-	}
-
-	struct FSayDungeonByItemGroup
-	{
-		const CDungeon::ItemGroup* item_group;
-		std::string can_enter_ment;
-		std::string cant_enter_ment;
-		void operator()(LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-
-				if (ch->IsPC())
-				{
-					struct ::packet_script packet_script;
-					TEMP_BUFFER buf;
-
-					for (CDungeon::ItemGroup::const_iterator it = item_group->begin(); it != item_group->end(); ++it)
-					{
-						if (ch->CountSpecifyItem(it->first) >= it->second)
-						{
-							packet_script.header = HEADER_GC_SCRIPT;
-							packet_script.skin = quest::CQuestManager::QUEST_SKIN_NORMAL;
-							packet_script.src_size = can_enter_ment.size();
-							packet_script.size = packet_script.src_size + sizeof(struct packet_script);
-
-							buf.write(&packet_script, sizeof(struct packet_script));
-							buf.write(&can_enter_ment[0], can_enter_ment.size());
-							ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-							return;
-						}
-					}
-
-					packet_script.header = HEADER_GC_SCRIPT;
-					packet_script.skin = quest::CQuestManager::QUEST_SKIN_NORMAL;
-					packet_script.src_size = cant_enter_ment.size();
-					packet_script.size = packet_script.src_size + sizeof(struct packet_script);
-
-					buf.write(&packet_script, sizeof(struct packet_script));
-					buf.write(&cant_enter_ment[0], cant_enter_ment.size());
-					ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-				}
-			}
-		}
-	};
-
-	int dungeon_say_diff_by_item_group(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isstring(L, 3))
-		{
-			sys_log(0, "QUEST wrong set flag");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (!pDungeon)
-		{
-			sys_err("QUEST : no dungeon");
-			return 0;
-		}
-
-		SECTREE_MAP* pMap = SECTREE_MANAGER::instance().GetMap(pDungeon->GetMapIndex());
-
-		if (!pMap)
-		{
-			sys_err("cannot find map by index %d", pDungeon->GetMapIndex());
-			return 0;
-		}
-		FSayDungeonByItemGroup f;
-		sys_log(0, "diff_by_item");
-
-		std::string group_name(lua_tostring(L, 1));
-		f.item_group = pDungeon->GetItemGroup(group_name);
-
-		if (f.item_group == NULL)
-		{
-			sys_err("invalid item group");
-			return 0;
-		}
-
-		f.can_enter_ment = lua_tostring(L, 2);
-		f.can_enter_ment += "[ENTER][ENTER][ENTER][ENTER][DONE]";
-		f.cant_enter_ment = lua_tostring(L, 3);
-		f.cant_enter_ment += "[ENTER][ENTER][ENTER][ENTER][DONE]";
-
-		pMap->for_each(f);
-
-		return 0;
-	}
-
-	struct FExitDungeonByItemGroup
-	{
-		const CDungeon::ItemGroup* item_group;
-
-		void operator()(LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-
-				if (ch->IsPC())
-				{
-					for (CDungeon::ItemGroup::const_iterator it = item_group->begin(); it != item_group->end(); ++it)
-					{
-						if (ch->CountSpecifyItem(it->first) >= it->second)
-						{
-							return;
-						}
-					}
-					ch->ExitToSavedLocation();
-				}
-			}
-		}
-	};
-
-	int dungeon_exit_all_by_item_group(lua_State* L) // 특정 아이템 그룹에 속한 아이템이 없는사람은 강퇴
-	{
-		if (!lua_isstring(L, 1))
-		{
-			sys_log(0, "QUEST wrong set flag");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (!pDungeon)
-		{
-			sys_err("QUEST : no dungeon");
-			return 0;
-		}
-
-		SECTREE_MAP* pMap = SECTREE_MANAGER::instance().GetMap(pDungeon->GetMapIndex());
-
-		if (!pMap)
-		{
-			sys_err("cannot find map by index %d", pDungeon->GetMapIndex());
-			return 0;
-		}
-		FExitDungeonByItemGroup f;
-
-		std::string group_name(lua_tostring(L, 1));
-		f.item_group = pDungeon->GetItemGroup(group_name);
-
-		if (f.item_group == NULL)
-		{
-			sys_err("invalid item group");
-			return 0;
-		}
-
-		pMap->for_each(f);
-
-		return 0;
-	}
-
-	struct FDeleteItemInItemGroup
-	{
-		const CDungeon::ItemGroup* item_group;
-
-		void operator()(LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-
-				if (ch->IsPC())
-				{
-					for (CDungeon::ItemGroup::const_iterator it = item_group->begin(); it != item_group->end(); ++it)
-					{
-						if (ch->CountSpecifyItem(it->first) >= it->second)
-						{
-							ch->RemoveSpecifyItem(it->first, it->second);
-							return;
-						}
-					}
-				}
-			}
-		}
-	};
-
-	int dungeon_delete_item_in_item_group_from_all(lua_State* L) // 특정 아이템을 던전 내 pc에게서 삭제.
-	{
-		if (!lua_isstring(L, 1))
-		{
-			sys_log(0, "QUEST wrong set flag");
-			return 0;
-		}
-
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (!pDungeon)
-		{
-			sys_err("QUEST : no dungeon");
-			return 0;
-		}
-
-		SECTREE_MAP* pMap = SECTREE_MANAGER::instance().GetMap(pDungeon->GetMapIndex());
-
-		if (!pMap)
-		{
-			sys_err("cannot find map by index %d", pDungeon->GetMapIndex());
-			return 0;
-		}
-		FDeleteItemInItemGroup f;
-
-		std::string group_name(lua_tostring(L, 1));
-		f.item_group = pDungeon->GetItemGroup(group_name);
-
-		if (f.item_group == NULL)
-		{
-			sys_err("invalid item group");
-			return 0;
-		}
-
-		pMap->for_each(f);
-
-		return 0;
-	}
-
-	int dungeon_kill_all(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->KillAll();
-
-		return 0;
-	}
-
-	int dungeon_purge(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->Purge();
-
-		return 0;
-	}
-
-	int dungeon_exit_all_to_start_position(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->ExitAllToStartPosition();
-
-		return 0;
-	}
-
-	int dungeon_count_monster(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			lua_pushnumber(L, pDungeon->CountMonster());
-		else
-		{
-			sys_err("not in a dungeon");
-			lua_pushnumber(L, LONG_MAX);
-		}
-
-		return 1;
-	}
-
-	int dungeon_select(lua_State* L)
-	{
-		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 1);
-		if (dwMapIndex)
-		{
-			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
-			if (pDungeon)
-			{
-				CQuestManager::instance().SelectDungeon(pDungeon);
-				lua_pushboolean(L, 1);
-			}
-			else
-			{
-				CQuestManager::instance().SelectDungeon(NULL);
-				lua_pushboolean(L, 0);
-			}
-		}
-		else
-		{
-			CQuestManager::instance().SelectDungeon(NULL);
-			lua_pushboolean(L, 0);
-		}
-		return 1;
-	}
-
-	int dungeon_find(lua_State* L)
-	{
-		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 1);
-		if (dwMapIndex)
-		{
-			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
-			if (pDungeon)
-			{
-				lua_pushboolean(L, 1);
-			}
-			else
-			{
-				lua_pushboolean(L, 0);
-			}
-		}
-		else
-		{
-			lua_pushboolean(L, 0);
-		}
-		return 1;
-	}
-
-	int dungeon_all_near_to(lua_State* L)
-	{
-		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
-
-		if (pDungeon != NULL)
-		{
-			lua_pushboolean(L, pDungeon->IsAllPCNearTo((int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2), 30));
-		}
-		else
-		{
-			lua_pushboolean(L, false);
-		}
-
-		return 1;
-	}
-
-	int dungeon_set_warp_location(lua_State* L)
-	{
-		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
-
-		if (pDungeon == NULL)
-		{
-			return 0;
-		}
-
-		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			return 0;
-		}
-
-		FSetWarpLocation f((int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
-		pDungeon->ForEachMember(f);
-
-		return 0;
-	}
-
-	int dungeon_set_item_group(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-		{
-			return 0;
-		}
-		std::string group_name(lua_tostring(L, 1));
-		int size = lua_tonumber(L, 2);
-
-		CDungeon::ItemGroup item_group;
-
-		for (int i = 0; i < size; i++)
-		{
-			if (!lua_isnumber(L, i * 2 + 3) || !lua_isnumber(L, i * 2 + 4))
-			{
-				return 0;
-			}
-			item_group.push_back(std::pair <DWORD, int>(lua_tonumber(L, i * 2 + 3), lua_tonumber(L, i * 2 + 4)));
-		}
-		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
-
-		if (pDungeon == NULL)
-		{
-			return 0;
-		}
-
-		pDungeon->CreateItemGroup(group_name, item_group);
-		return 0;
-	}
-
-	int dungeon_set_quest_flag2(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-
-		FSetQuestFlag f;
-
-		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("Invalid Argument");
-		}
-
-		f.flagname = string(lua_tostring(L, 1)) + "." + lua_tostring(L, 2);
-		f.value = (int)rint(lua_tonumber(L, 3));
-
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-
-		if (pDungeon)
-			pDungeon->ForEachMember(f);
-
-		return 0;
-	}
-
-#if defined(__CLIENT_TIMER__)
-	struct FSendClientTimer
-	{
-		FSendClientTimer(const DWORD bSubHeader, const DWORD dwEndTime = 0, const DWORD dwAlarmSec = 0)
-			: m_bSubHeader(bSubHeader), m_dwEndTime(dwEndTime), m_dwAlarmSec(dwAlarmSec)
-		{}
-		void operator() (const LPCHARACTER pChar)
-		{
-			if (pChar != nullptr)
-				pChar->SendClientTimer(m_bSubHeader, m_dwEndTime, m_dwAlarmSec);
-		}
-		BYTE m_bSubHeader;
-		DWORD m_dwEndTime, m_dwAlarmSec;
-	};
-
-	/*
-	* Usage: d.setct(end_time, alarm_sec)
-	* Function: Clears the client timer for all members.
-	* @arg1 - end_time : should be in a timestamp format (time + (duration))
-	* @arg2 - alarm sec : triggers the alarm color with then alarm secs.
-	*/
-	int dungeon_set_client_timer(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("Invalid Argument");
-			return 0;
-		}
-
-		DWORD dwEndTime = lua_tonumber(L, 1);
-		DWORD dwAlarmTime = lua_isnumber(L, 2) ? lua_tonumber(L, 2) : 0;
-
-		FSendClientTimer ClientTimer(CLIENT_TIMER_SUBHEADER_GC_SET, dwEndTime, dwAlarmTime);
-
-		CQuestManager& rQmgr = CQuestManager::instance();
-		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
-		if (pDungeon)
-			pDungeon->ForEachMember(ClientTimer);
-
-		return 0;
-	}
-
-	/*
-	* Usage: d.clearct()
-	* Function: Clears the client timer for all members.
-	*/
-	int dungeon_clear_client_timer(lua_State* L)
-	{
-		FSendClientTimer ClientTimer(CLIENT_TIMER_SUBHEADER_GC_DELETE);
-		CQuestManager& rQmgr = CQuestManager::instance();
-		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
-		if (pDungeon)
-			pDungeon->ForEachMember(ClientTimer);
-
-		return 0;
-	}
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	int dungeon_battlepass_update_progress(lua_State* L)
-	{
-		CQuestManager & q = CQuestManager::instance();
-
-		FDungeonUpdateAllBattlepassProcess f;
-		
-		if (!lua_isnumber(L, 1)) {
-			sys_err("arg1 must be number (dungeon_index)");
-			return 0;
-		}
-		
-		f.dungeon_index = (int)lua_tonumber(L, 1);
-
-		LPDUNGEON pDungeon = q.GetCurrentDungeon();
-		
-		if (pDungeon)
-			pDungeon->ForEachMember(f);
-		return 0;
-	}
-#endif
-
-	void RegisterDungeonFunctionTable()
-	{
-		luaL_reg dungeon_functions[] =
-		{
-			{ "join", dungeon_join },
-			{ "exit", dungeon_exit },
-			{ "exit_all", dungeon_exit_all },
-			{ "set_item_group", dungeon_set_item_group },
-			{ "exit_all_by_item_group", dungeon_exit_all_by_item_group },
-			{ "say_diff_by_item_group", dungeon_say_diff_by_item_group },
-			{ "delete_item_in_item_group_from_all", dungeon_delete_item_in_item_group_from_all },
-			{ "purge", dungeon_purge },
-			{ "kill_all", dungeon_kill_all },
-			{ "spawn", dungeon_spawn },
-			{ "spawn_mob", dungeon_spawn_mob },
-			{ "spawn_mob_dir", dungeon_spawn_mob_dir },
-			{ "spawn_mob_ac_dir", dungeon_spawn_mob_ac_dir },
-			{ "spawn_name_mob", dungeon_spawn_name_mob },
-			{ "spawn_goto_mob", dungeon_spawn_goto_mob },
-			{ "spawn_group", dungeon_spawn_group },
-			{ "spawn_unique", dungeon_spawn_unique },
-			{ "spawn_move_unique", dungeon_spawn_move_unique },
-			{ "spawn_move_group", dungeon_spawn_move_group },
-			{ "spawn_stone_door", dungeon_spawn_stone_door },
-			{ "spawn_wooden_door", dungeon_spawn_wooden_door },
-			{ "purge_unique", dungeon_purge_unique },
-			{ "purge_area", dungeon_purge_area },
-			{ "kill_unique", dungeon_kill_unique },
-			{ "is_unique_dead", dungeon_is_unique_dead },
-			{ "unique_get_hp_perc", dungeon_unique_get_hp_perc },
-			{ "unique_set_def_grade", dungeon_unique_set_def_grade },
-			{ "unique_set_hp", dungeon_unique_set_hp },
-			{ "unique_set_maxhp", dungeon_unique_set_maxhp },
-			{ "get_unique_vid", dungeon_get_unique_vid },
-			{ "get_kill_stone_count", dungeon_get_kill_stone_count },
-			{ "get_kill_mob_count", dungeon_get_kill_mob_count },
-			{ "is_use_potion", dungeon_is_use_potion },
-			{ "revived", dungeon_revived },
-			{ "set_dest", dungeon_set_dest },
-			{ "jump_all", dungeon_jump_all },
-			{ "warp_all", dungeon_warp_all },
-			{ "new_jump_all", dungeon_new_jump_all },
-			{ "new_jump_party", dungeon_new_jump_party },
-			{ "new_jump", dungeon_new_jump },
-			{ "regen_file", dungeon_regen_file },
-			{ "set_regen_file", dungeon_set_regen_file },
-			{ "clear_regen", dungeon_clear_regen },
-			{ "set_exit_all_at_eliminate", dungeon_set_exit_all_at_eliminate},
-			{ "set_warp_at_eliminate", dungeon_set_warp_at_eliminate},
-			{ "get_map_index", dungeon_get_map_index },
-			{ "check_eliminated", dungeon_check_eliminated },
-			{ "exit_all_to_start_position", dungeon_exit_all_to_start_position },
-			{ "count_monster", dungeon_count_monster },
-			{ "setf", dungeon_set_flag },
-			{ "getf", dungeon_get_flag },
-			{ "getf_from_map_index", dungeon_get_flag_from_map_index },
-			{ "set_unique", dungeon_set_unique },
-			{ "select", dungeon_select },
-			{ "find", dungeon_find },
-			{ "notice", dungeon_notice },
-			{ "mission_msg", dungeon_mission_msg },
-			{ "sub_mission_msg", dungeon_sub_mission_msg },
-			{ "clear_mission_msg", dungeon_clear_mission_msg },
-			{ "setqf", dungeon_set_quest_flag },
-			{ "all_near_to", dungeon_all_near_to },
-			{ "set_warp_location", dungeon_set_warp_location },
-			{ "setqf2", dungeon_set_quest_flag2 },
-#if defined(__DUNGEON_RENEWAL__)
-			{ "create", dungeon_create },
-			{ "destroy", dungeon_destroy },
-			{ "setf_for_map_index", dungeon_set_flag_for_map_index },
-			{ "spawn_for_map_index", dungeon_spawn_mob_for_map_index },
-			{ "party_notice", dungeon_party_notice },
-			{ "syschat", dungeon_syschat },
-			{ "setqf2_all_near", dungeon_set_quest_flag2_all_near },
-#endif
-#if defined(__CLIENT_TIMER__)
-			{ "setct", dungeon_set_client_timer },
-			{ "clearct", dungeon_clear_client_timer },
-#endif
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			{ "battlepass_update_progress", dungeon_battlepass_update_progress },
-#endif
-			{ NULL, NULL }
-		};
-
-		CQuestManager::instance().AddLuaFunctionTable("d", dungeon_functions);
-	}
-}
+#include "stdafx.h"
+#include "constants.h"
+#include "questmanager.h"
+#include "questlua.h"
+#include "dungeon.h"
+#include "char.h"
+#include "party.h"
+#include "buffer_manager.h"
+#include "char_manager.h"
+#include "packet.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+
+#include "config.h"
+#include "db.h"
+#include "p2p.h"
+
+#undef sys_err
+#ifndef __WIN32__
+#define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
+#else
+#define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
+#endif
+
+template <class Func> Func CDungeon::ForEachMember(Func f)
+{
+	// Safe iteration: f() may trigger logout/warp which can remove the character
+	// from m_set_pkCharacter, so we must advance the iterator before calling f().
+	auto it = m_set_pkCharacter.begin();
+	while (it != m_set_pkCharacter.end())
+	{
+		LPCHARACTER ch = *it;
+		++it;
+
+		if (!ch)
+			continue;
+
+		sys_log(0, "Dungeon ForEachMember %s", ch->GetName());
+		f(ch);
+	}
+	return f;
+}
+
+namespace quest
+{
+	//
+	// "dungeon" lua functions
+	//
+	int dungeon_notice(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->Notice(lua_tostring(L, 1));
+
+		return 0;
+	}
+
+	int dungeon_mission_msg(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->MissionMessage(lua_tostring(L, 1));
+
+		return 0;
+	}
+
+	int dungeon_sub_mission_msg(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SubMissionMessage(lua_tostring(L, 1));
+
+		return 0;
+	}
+
+	int dungeon_clear_mission_msg(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->MissionMessage("");
+
+		return 0;
+	}
+
+	int dungeon_set_quest_flag(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+
+		FSetQuestFlag f;
+
+		f.flagname = q.GetCurrentPC()->GetCurrentQuestName() + "." + lua_tostring(L, 1);
+		f.value = (int)rint(lua_tonumber(L, 2));
+
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->ForEachMember(f);
+
+		return 0;
+	}
+
+	int dungeon_set_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+		{
+			sys_err("wrong set flag");
+		}
+		else
+		{
+			CQuestManager& q = CQuestManager::instance();
+			LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+			if (pDungeon)
+			{
+				const char* sz = lua_tostring(L, 1);
+				int value = int(lua_tonumber(L, 2));
+				pDungeon->SetFlag(sz, value);
+			}
+			else
+			{
+				sys_err("no dungeon !!!");
+			}
+		}
+		return 0;
+	}
+
+	int dungeon_get_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			sys_err("wrong get flag");
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			const char* sz = lua_tostring(L, 1);
+			lua_pushnumber(L, pDungeon->GetFlag(sz));
+		}
+		else
+		{
+			sys_err("no dungeon !!!");
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+#if defined(__DUNGEON_RENEWAL__)
+	int dungeon_set_flag_for_map_index(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("invalid args");
+			return 0;
+		}
+
+		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 3);
+		if (dwMapIndex)
+		{
+			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
+			if (pDungeon)
+			{
+				const char* sz = lua_tostring(L, 1);
+				int value = lua_tonumber(L, 2);
+				pDungeon->SetFlag(sz, value);
+			}
+			else
+			{
+				sys_err("no dungeon !!!");
+				return 0;
+			}
+		}
+
+		return 0;
+	}
+
+	int dungeon_spawn_mob_for_map_index(lua_State* L)
+	{
+		// vnum x, y
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
+		{
+			sys_err("invalid argument");
+			return 0;
+		}
+
+		const long lMapIndex = static_cast<long>(lua_tonumber(L, 4));
+		const LPDUNGEON pDungeon = CDungeonManager::Instance().FindByMapIndex(lMapIndex);
+		if (pDungeon == nullptr)
+		{
+			sys_err("no dungeon");
+			return 0;
+		}
+
+		const DWORD dwVnum = static_cast<DWORD>(lua_tonumber(L, 1));
+		const long lPosX = static_cast<long>(lua_tonumber(L, 2));
+		const long lPosY = static_cast<long>(lua_tonumber(L, 3));
+
+		const LPCHARACTER pChar = pDungeon->SpawnMob(dwVnum, lPosX, lPosY);
+		if (pChar == nullptr)
+		{
+			sys_err("failed to spawn mob %d at %ld, %ld map index %ld", dwVnum, lPosX, lPosY, lMapIndex);
+			return 0;
+		}
+
+		return 0;
+	}
+
+	int dungeon_party_notice(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+			return 0;
+
+		CQuestManager& rQmgr = CQuestManager::instance();
+		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
+		if (pDungeon == nullptr)
+			return 0;
+
+		SendPartyNotice(pDungeon->GetParty(), lua_tostring(L, 1));
+		return 0;
+	}
+
+	int dungeon_syschat(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+			return 0;
+
+		CQuestManager& rQmgr = CQuestManager::instance();
+		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
+		if (pDungeon == nullptr)
+			return 0;
+
+		FPartyChat f(CHAT_TYPE_INFO, lua_tostring(L, 1));
+		pDungeon->ForEachMember(f);
+		return 0;
+	}
+
+	int dungeon_set_quest_flag2_all_near(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
+			sys_err("Invalid Argument");
+
+		CQuestManager& q = CQuestManager::Instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+		if (NULL == ch)
+			return 0;
+
+		FSetQuestFlagToNearMembers f;
+		f.flagname = string(lua_tostring(L, 1)) + "." + lua_tostring(L, 2);
+		f.value = (int)rint(lua_tonumber(L, 3));
+		f.x = ch->GetX();
+		f.y = ch->GetY();
+		f.dist = (int)lua_tonumber(L, 4);
+
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+		if (pDungeon)
+			pDungeon->ForEachMember(f);
+
+		return 0;
+	}
+#endif
+
+	int dungeon_get_flag_from_map_index(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+		{
+			sys_err("wrong get flag");
+		}
+
+		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 2);
+		if (dwMapIndex)
+		{
+			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
+			if (pDungeon)
+			{
+				const char* sz = lua_tostring(L, 1);
+				lua_pushnumber(L, pDungeon->GetFlag(sz));
+			}
+			else
+			{
+				sys_err("no dungeon !!!");
+				lua_pushnumber(L, 0);
+			}
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+		return 1;
+	}
+
+	int dungeon_get_map_index(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			sys_log(0, "Dungeon GetMapIndex %d", pDungeon->GetMapIndex());
+			lua_pushnumber(L, pDungeon->GetMapIndex());
+		}
+		else
+		{
+			sys_err("no dungeon !!!");
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int dungeon_regen_file(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			sys_err("wrong filename");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnRegen(lua_tostring(L, 1));
+
+		return 0;
+	}
+
+	int dungeon_set_regen_file(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			sys_err("wrong filename");
+			return 0;
+		}
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnRegen(lua_tostring(L, 1), false);
+		return 0;
+	}
+
+	int dungeon_clear_regen(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+		if (pDungeon)
+			pDungeon->ClearRegen();
+		return 0;
+	}
+
+	int dungeon_check_eliminated(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+		if (pDungeon)
+			pDungeon->CheckEliminated();
+		return 0;
+	}
+
+	int dungeon_set_exit_all_at_eliminate(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong time");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SetExitAllAtEliminate((long)lua_tonumber(L, 1));
+
+		return 0;
+	}
+
+	int dungeon_set_warp_at_eliminate(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong time");
+			return 0;
+		}
+
+		if (!lua_isnumber(L, 2))
+		{
+			sys_err("wrong map index");
+			return 0;
+		}
+
+		if (!lua_isnumber(L, 3))
+		{
+			sys_err("wrong X");
+			return 0;
+		}
+
+		if (!lua_isnumber(L, 4))
+		{
+			sys_err("wrong Y");
+			return 0;
+		}
+
+		const char* c_pszRegenFile = NULL;
+
+		if (lua_gettop(L) >= 5)
+			c_pszRegenFile = lua_tostring(L, 5);
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			pDungeon->SetWarpAtEliminate((long)lua_tonumber(L, 1),
+				(long)lua_tonumber(L, 2),
+				(long)lua_tonumber(L, 3),
+				(long)lua_tonumber(L, 4),
+				c_pszRegenFile);
+		}
+		else
+			sys_err("cannot find dungeon");
+
+		return 0;
+	}
+
+	int dungeon_new_jump(lua_State* L)
+	{
+		if (lua_gettop(L) < 3)
+		{
+			sys_err("not enough argument");
+			return 0;
+		}
+
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("wrong argument");
+			return 0;
+		}
+
+		long lMapIndex = (long)lua_tonumber(L, 1);
+
+		// Prevent invalid/unloaded map index from freezing/crashing core
+		if (SECTREE_MANAGER::instance().GetMap(lMapIndex) == NULL)
+		{
+			sys_err("d.new_jump: invalid map index %ld", lMapIndex);
+			return 0;
+		}
+
+		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
+
+		if (!pDungeon)
+		{
+			sys_err("cannot create dungeon %d", lMapIndex);
+			return 0;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		// ch->WarpSet(pDungeon->GetMapIndex(), (int) lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
+		ch->WarpSet((int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3), pDungeon->GetMapIndex());
+		return 0;
+	}
+
+	int dungeon_new_jump_all(lua_State* L)
+	{
+		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("not enough argument");
+			return 0;
+		}
+
+		long lMapIndex = (long)lua_tonumber(L, 1);
+
+		// Prevent invalid/unloaded map index from freezing/crashing core
+		if (SECTREE_MANAGER::instance().GetMap(lMapIndex) == NULL)
+		{
+			sys_err("d.new_jump_all: invalid map index %ld", lMapIndex);
+			return 0;
+		}
+
+		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
+
+		if (!pDungeon)
+		{
+			sys_err("cannot create dungeon %d", lMapIndex);
+			return 0;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		pDungeon->JumpAll(ch->GetMapIndex(), (int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
+
+		return 0;
+	}
+
+	int dungeon_new_jump_party(lua_State* L)
+	{
+		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("not enough argument");
+			return 0;
+		}
+
+		long lMapIndex = (long)lua_tonumber(L, 1);
+
+		// Prevent invalid/unloaded map index from freezing/crashing core
+		if (SECTREE_MANAGER::instance().GetMap(lMapIndex) == NULL)
+		{
+			sys_err("d.new_jump_party: invalid map index %ld", lMapIndex);
+			return 0;
+		}
+
+		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
+
+		if (!pDungeon)
+		{
+			sys_err("cannot create dungeon %d", lMapIndex);
+			return 0;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->GetParty() == NULL)
+		{
+			sys_err("cannot go to dungeon alone.");
+			return 0;
+		}
+		pDungeon->JumpParty(ch->GetParty(), ch->GetMapIndex(), (int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
+
+		return 0;
+	}
+
+#if defined(__DUNGEON_RENEWAL__)
+	int dungeon_create(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("invalid argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		const long lMapIndex = (long)lua_tonumber(L, 1);
+		const LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
+		if (pDungeon == nullptr)
+		{
+			sys_err("cannot create dungeon %d", lMapIndex);
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		CQuestManager& rQmgr = CQuestManager::instance();
+		LPCHARACTER pChar = rQmgr.GetCurrentCharacterPtr();
+		if (pChar->GetParty() == nullptr)
+		{
+			sys_err("cannot go to dungeon alone.");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		pDungeon->SetParty(pChar->GetParty());
+
+		lua_pushnumber(L, pDungeon->GetMapIndex());
+		return 1;
+	}
+
+	int dungeon_destroy(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("invalid argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		const long lMapIndex = (long)lua_tonumber(L, 1);
+		CQuestManager& rQmgr = CQuestManager::instance();
+		const LPDUNGEON pDungeon = CDungeonManager::Instance().FindByMapIndex(lMapIndex);
+		if (pDungeon == nullptr)
+		{
+			sys_err("no dungeon");
+			return 0;
+		}
+
+		pDungeon->Destroy();
+		return 0;
+	}
+#endif
+
+	int dungeon_jump_all(lua_State* L)
+	{
+		if (lua_gettop(L) < 2 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
+
+		if (!pDungeon)
+			return 0;
+
+		pDungeon->JumpAll(pDungeon->GetMapIndex(), (int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2));
+		return 0;
+	}
+
+	int dungeon_warp_all(lua_State* L)
+	{
+		if (lua_gettop(L) < 2 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
+
+		if (!pDungeon)
+			return 0;
+
+		pDungeon->WarpAll(pDungeon->GetMapIndex(), (int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2));
+		return 0;
+	}
+
+	int dungeon_get_kill_stone_count(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			lua_pushnumber(L, pDungeon->GetKillStoneCount());
+			return 1;
+		}
+
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+
+	int dungeon_get_kill_mob_count(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			lua_pushnumber(L, pDungeon->GetKillMobCount());
+			return 1;
+		}
+
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+
+	int dungeon_is_use_potion(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			lua_pushboolean(L, 1);
+			return 1;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			lua_pushboolean(L, pDungeon->IsUsePotion());
+			return 1;
+		}
+
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+
+	int dungeon_revived(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			lua_pushboolean(L, 1);
+			return 1;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			lua_pushboolean(L, pDungeon->IsUseRevive());
+			return 1;
+		}
+
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+
+	int dungeon_set_dest(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		LPPARTY pParty = ch->GetParty();
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon && pParty)
+			pDungeon->SendDestPositionToParty(pParty, (int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2));
+
+		return 0;
+	}
+
+	int dungeon_unique_set_maxhp(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->UniqueSetMaxHP(lua_tostring(L, 1), lua_tonumber(L, 2));
+
+		return 0;
+	}
+
+	int dungeon_unique_set_hp(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->UniqueSetHP(lua_tostring(L, 1), lua_tonumber(L, 2));
+
+		return 0;
+	}
+
+	int dungeon_unique_set_def_grade(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->UniqueSetDefGrade(lua_tostring(L, 1), lua_tonumber(L, 2));
+
+		return 0;
+	}
+
+	int dungeon_unique_get_hp_perc(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			lua_pushnumber(L, pDungeon->GetUniqueHpPerc(lua_tostring(L, 1)));
+			return 1;
+		}
+
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+
+	int dungeon_is_unique_dead(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			lua_pushboolean(L, pDungeon->IsUniqueDead(lua_tostring(L, 1)) ? 1 : 0);
+			return 1;
+		}
+
+		lua_pushboolean(L, 0);
+		return 1;
+	}
+
+	int dungeon_purge_unique(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_PURGE_UNIQUE %s", lua_tostring(L, 1));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->PurgeUnique(lua_tostring(L, 1));
+
+		return 0;
+	}
+
+	struct FPurgeArea
+	{
+		int x1, y1, x2, y2;
+		LPCHARACTER ExceptChar;
+
+		FPurgeArea(int a, int b, int c, int d, LPCHARACTER p)
+			: x1(a), y1(b), x2(c), y2(d),
+			ExceptChar(p)
+		{}
+
+		void operator () (LPENTITY ent)
+		{
+			if (true == ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER pChar = static_cast<LPCHARACTER>(ent);
+				if (pChar == ExceptChar)
+					return;
+
+				if ((true == pChar->IsMonster() || true == pChar->IsStone())
+#if defined(__PET_SYSTEM__)
+					&& !pChar->IsPet()
+#endif
+					)
+				{
+					if (x1 <= pChar->GetX() && pChar->GetX() <= x2 && y1 <= pChar->GetY() && pChar->GetY() <= y2)
+					{
+						M2_DESTROY_CHARACTER(pChar);
+					}
+				}
+			}
+		}
+	};
+
+	int dungeon_purge_area(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_PURGE_AREA");
+
+		int x1 = lua_tonumber(L, 1);
+		int y1 = lua_tonumber(L, 2);
+		int x2 = lua_tonumber(L, 3);
+		int y2 = lua_tonumber(L, 4);
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		const int mapIndex = pDungeon->GetMapIndex();
+
+		if (0 == mapIndex)
+		{
+			sys_err("_purge_area: cannot get a map index with (%u, %u)", x1, y1);
+			return 0;
+		}
+
+		LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(mapIndex);
+
+		if (NULL != pSectree)
+		{
+			FPurgeArea func(x1, y1, x2, y2, CQuestManager::instance().GetCurrentNPCCharacterPtr());
+
+			pSectree->for_each(func);
+		}
+
+		return 0;
+	}
+
+	int dungeon_kill_unique(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_KILL_UNIQUE %s", lua_tostring(L, 1));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->KillUnique(lua_tostring(L, 1));
+
+		return 0;
+	}
+
+	int dungeon_spawn_stone_door(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isstring(L, 2))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_SPAWN_STONE_DOOR %s %s", lua_tostring(L, 1), lua_tostring(L, 2));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnStoneDoor(lua_tostring(L, 1), lua_tostring(L, 2));
+
+		return 0;
+	}
+
+	int dungeon_spawn_wooden_door(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isstring(L, 2))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_SPAWN_WOODEN_DOOR %s %s", lua_tostring(L, 1), lua_tostring(L, 2));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnWoodenDoor(lua_tostring(L, 1), lua_tostring(L, 2));
+
+		return 0;
+	}
+
+	int dungeon_spawn_move_group(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isstring(L, 2) || !lua_isstring(L, 3))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_SPAWN_MOVE_GROUP %d %s %s", (int)lua_tonumber(L, 1), lua_tostring(L, 2), lua_tostring(L, 3));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnMoveGroup((DWORD)lua_tonumber(L, 1), lua_tostring(L, 2), lua_tostring(L, 3));
+
+		return 0;
+	}
+
+	int dungeon_spawn_move_unique(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3) || !lua_isstring(L, 4))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_SPAWN_MOVE_UNIQUE %s %d %s %s", lua_tostring(L, 1), (int)lua_tonumber(L, 2), lua_tostring(L, 3), lua_tostring(L, 4));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnMoveUnique(lua_tostring(L, 1), (DWORD)lua_tonumber(L, 2), lua_tostring(L, 3), lua_tostring(L, 4));
+
+		return 0;
+	}
+
+	int dungeon_spawn_unique(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_SPAWN_UNIQUE %s %d %s", lua_tostring(L, 1), (int)lua_tonumber(L, 2), lua_tostring(L, 3));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnUnique(lua_tostring(L, 1), (DWORD)lua_tonumber(L, 2), lua_tostring(L, 3));
+
+		return 0;
+	}
+
+	int dungeon_spawn(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isstring(L, 2))
+			return 0;
+		sys_log(0, "QUEST_DUNGEON_SPAWN %d %s", (int)lua_tonumber(L, 1), lua_tostring(L, 2));
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->Spawn((DWORD)lua_tonumber(L, 1), lua_tostring(L, 2));
+
+		return 0;
+	}
+
+	int dungeon_set_unique(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		DWORD vid = (DWORD)lua_tonumber(L, 2);
+
+		if (pDungeon)
+			pDungeon->SetUnique(lua_tostring(L, 1), vid);
+		return 0;
+	}
+
+	int dungeon_get_unique_vid(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			lua_pushnumber(L, pDungeon->GetUniqueVID(lua_tostring(L, 1)));
+			return 1;
+		}
+
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+
+	int dungeon_spawn_mob(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("invalid argument");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		DWORD vid = 0;
+
+		if (pDungeon)
+		{
+			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
+			long x = (long)lua_tonumber(L, 2);
+			long y = (long)lua_tonumber(L, 3);
+			float radius = lua_isnumber(L, 4) ? (float)lua_tonumber(L, 4) : 0;
+			DWORD count = (lua_isnumber(L, 5)) ? (DWORD)lua_tonumber(L, 5) : 1;
+
+			sys_log(0, "dungeon_spawn_mob %u %d %d", dwVnum, x, y);
+
+			if (count == 0)
+				count = 1;
+
+			while (count--)
+			{
+				if (radius < 1)
+				{
+					LPCHARACTER ch = pDungeon->SpawnMob(dwVnum, x, y);
+					if (ch && !vid)
+						vid = ch->GetVID();
+				}
+				else
+				{
+					float angle = number(0, 999) * M_PI * 2 / 1000;
+					float r = number(0, 999) * radius / 1000;
+
+					long nx = x + (long)(r * cos(angle));
+					long ny = y + (long)(r * sin(angle));
+
+					LPCHARACTER ch = pDungeon->SpawnMob(dwVnum, nx, ny);
+					if (ch && !vid)
+						vid = ch->GetVID();
+				}
+			}
+		}
+
+		lua_pushnumber(L, vid);
+		return 1;
+	}
+
+	int dungeon_spawn_mob_dir(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
+		{
+			sys_err("invalid argument");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		DWORD vid = 0;
+
+		if (pDungeon)
+		{
+			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
+			long x = (long)lua_tonumber(L, 2);
+			long y = (long)lua_tonumber(L, 3);
+			BYTE dir = (int)lua_tonumber(L, 4);
+
+			LPCHARACTER ch = pDungeon->SpawnMob(dwVnum, x, y, dir);
+			if (ch && !vid)
+				vid = ch->GetVID();
+		}
+		lua_pushnumber(L, vid);
+		return 1;
+	}
+
+	int dungeon_spawn_mob_ac_dir(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
+		{
+			sys_err("invalid argument");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		DWORD vid = 0;
+
+		if (pDungeon)
+		{
+			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
+			long x = (long)lua_tonumber(L, 2);
+			long y = (long)lua_tonumber(L, 3);
+			BYTE dir = (int)lua_tonumber(L, 4);
+
+			LPCHARACTER ch = pDungeon->SpawnMob_ac_dir(dwVnum, x, y, dir);
+			if (ch && !vid)
+				vid = ch->GetVID();
+		}
+		lua_pushnumber(L, vid);
+		return 1;
+	}
+
+	int dungeon_spawn_goto_mob(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4))
+			return 0;
+
+		long lFromX = (long)lua_tonumber(L, 1);
+		long lFromY = (long)lua_tonumber(L, 2);
+		long lToX = (long)lua_tonumber(L, 3);
+		long lToY = (long)lua_tonumber(L, 4);
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->SpawnGotoMob(lFromX, lFromY, lToX, lToY);
+
+		return 0;
+	}
+
+	int dungeon_spawn_name_mob(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isstring(L, 4))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
+			long x = (long)lua_tonumber(L, 2);
+			long y = (long)lua_tonumber(L, 3);
+			pDungeon->SpawnNameMob(dwVnum, x, y, lua_tostring(L, 4));
+		}
+		return 0;
+	}
+
+	int dungeon_spawn_group(lua_State* L)
+	{
+		//
+		// argument: vnum,x,y,radius,aggressive,count
+		//
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3) || !lua_isnumber(L, 4) || !lua_isnumber(L, 6))
+		{
+			sys_err("invalid argument");
+			return 0;
+		}
+
+		DWORD vid = 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+		{
+			DWORD group_vnum = (DWORD)lua_tonumber(L, 1);
+			long local_x = (long)lua_tonumber(L, 2) * 100;
+			long local_y = (long)lua_tonumber(L, 3) * 100;
+			float radius = (float)lua_tonumber(L, 4) * 100;
+			bool bAggressive = lua_toboolean(L, 5);
+			DWORD count = (DWORD)lua_tonumber(L, 6);
+
+			LPCHARACTER chRet = pDungeon->SpawnGroup(group_vnum, local_x, local_y, radius, bAggressive, count);
+			if (chRet)
+				vid = chRet->GetVID();
+		}
+
+		lua_pushnumber(L, vid);
+		return 1;
+	}
+
+	int dungeon_join(lua_State* L)
+	{
+		if (lua_gettop(L) < 1 || !lua_isnumber(L, 1))
+			return 0;
+
+		long lMapIndex = (long)lua_tonumber(L, 1);
+		LPDUNGEON pDungeon = CDungeonManager::instance().Create(lMapIndex);
+
+		if (!pDungeon)
+			return 0;
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->GetParty() && ch->GetParty()->GetLeaderPID() == ch->GetPlayerID())
+			pDungeon->JoinParty(ch->GetParty());
+		else if (!ch->GetParty())
+			pDungeon->Join(ch);
+
+		return 0;
+	}
+
+	int dungeon_exit(lua_State* L) //    치 
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		ch->ExitToSavedLocation();
+		return 0;
+	}
+
+	int dungeon_exit_all(lua_State* L) //  獵      치 
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->ExitAll();
+
+		return 0;
+	}
+
+	struct FSayDungeonByItemGroup
+	{
+		const CDungeon::ItemGroup* item_group;
+		std::string can_enter_ment;
+		std::string cant_enter_ment;
+		void operator()(LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+
+				if (ch->IsPC())
+				{
+					struct ::packet_script packet_script;
+					TEMP_BUFFER buf;
+
+					for (CDungeon::ItemGroup::const_iterator it = item_group->begin(); it != item_group->end(); ++it)
+					{
+						if (ch->CountSpecifyItem(it->first) >= it->second)
+						{
+							packet_script.header = HEADER_GC_SCRIPT;
+							packet_script.skin = quest::CQuestManager::QUEST_SKIN_NORMAL;
+							packet_script.src_size = can_enter_ment.size();
+							packet_script.size = packet_script.src_size + sizeof(struct packet_script);
+
+							buf.write(&packet_script, sizeof(struct packet_script));
+							buf.write(&can_enter_ment[0], can_enter_ment.size());
+							ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+							return;
+						}
+					}
+
+					packet_script.header = HEADER_GC_SCRIPT;
+					packet_script.skin = quest::CQuestManager::QUEST_SKIN_NORMAL;
+					packet_script.src_size = cant_enter_ment.size();
+					packet_script.size = packet_script.src_size + sizeof(struct packet_script);
+
+					buf.write(&packet_script, sizeof(struct packet_script));
+					buf.write(&cant_enter_ment[0], cant_enter_ment.size());
+					ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+				}
+			}
+		}
+	};
+
+	int dungeon_say_diff_by_item_group(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isstring(L, 3))
+		{
+			sys_log(0, "QUEST wrong set flag");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (!pDungeon)
+		{
+			sys_err("QUEST : no dungeon");
+			return 0;
+		}
+
+		SECTREE_MAP* pMap = SECTREE_MANAGER::instance().GetMap(pDungeon->GetMapIndex());
+
+		if (!pMap)
+		{
+			sys_err("cannot find map by index %d", pDungeon->GetMapIndex());
+			return 0;
+		}
+		FSayDungeonByItemGroup f;
+		sys_log(0, "diff_by_item");
+
+		std::string group_name(lua_tostring(L, 1));
+		f.item_group = pDungeon->GetItemGroup(group_name);
+
+		if (f.item_group == NULL)
+		{
+			sys_err("invalid item group");
+			return 0;
+		}
+
+		f.can_enter_ment = lua_tostring(L, 2);
+		f.can_enter_ment += "[ENTER][ENTER][ENTER][ENTER][DONE]";
+		f.cant_enter_ment = lua_tostring(L, 3);
+		f.cant_enter_ment += "[ENTER][ENTER][ENTER][ENTER][DONE]";
+
+		pMap->for_each(f);
+
+		return 0;
+	}
+
+	struct FExitDungeonByItemGroup
+	{
+		const CDungeon::ItemGroup* item_group;
+
+		void operator()(LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+
+				if (ch->IsPC())
+				{
+					for (CDungeon::ItemGroup::const_iterator it = item_group->begin(); it != item_group->end(); ++it)
+					{
+						if (ch->CountSpecifyItem(it->first) >= it->second)
+						{
+							return;
+						}
+					}
+					ch->ExitToSavedLocation();
+				}
+			}
+		}
+	};
+
+	int dungeon_exit_all_by_item_group(lua_State* L) // 특  瀏荑   쨩 
+	{
+		if (!lua_isstring(L, 1))
+		{
+			sys_log(0, "QUEST wrong set flag");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (!pDungeon)
+		{
+			sys_err("QUEST : no dungeon");
+			return 0;
+		}
+
+		SECTREE_MAP* pMap = SECTREE_MANAGER::instance().GetMap(pDungeon->GetMapIndex());
+
+		if (!pMap)
+		{
+			sys_err("cannot find map by index %d", pDungeon->GetMapIndex());
+			return 0;
+		}
+		FExitDungeonByItemGroup f;
+
+		std::string group_name(lua_tostring(L, 1));
+		f.item_group = pDungeon->GetItemGroup(group_name);
+
+		if (f.item_group == NULL)
+		{
+			sys_err("invalid item group");
+			return 0;
+		}
+
+		pMap->for_each(f);
+
+		return 0;
+	}
+
+	struct FDeleteItemInItemGroup
+	{
+		const CDungeon::ItemGroup* item_group;
+
+		void operator()(LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+
+				if (ch->IsPC())
+				{
+					for (CDungeon::ItemGroup::const_iterator it = item_group->begin(); it != item_group->end(); ++it)
+					{
+						if (ch->CountSpecifyItem(it->first) >= it->second)
+						{
+							ch->RemoveSpecifyItem(it->first, it->second);
+							return;
+						}
+					}
+				}
+			}
+		}
+	};
+
+	int dungeon_delete_item_in_item_group_from_all(lua_State* L) // 특    pc獨 .
+	{
+		if (!lua_isstring(L, 1))
+		{
+			sys_log(0, "QUEST wrong set flag");
+			return 0;
+		}
+
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (!pDungeon)
+		{
+			sys_err("QUEST : no dungeon");
+			return 0;
+		}
+
+		SECTREE_MAP* pMap = SECTREE_MANAGER::instance().GetMap(pDungeon->GetMapIndex());
+
+		if (!pMap)
+		{
+			sys_err("cannot find map by index %d", pDungeon->GetMapIndex());
+			return 0;
+		}
+		FDeleteItemInItemGroup f;
+
+		std::string group_name(lua_tostring(L, 1));
+		f.item_group = pDungeon->GetItemGroup(group_name);
+
+		if (f.item_group == NULL)
+		{
+			sys_err("invalid item group");
+			return 0;
+		}
+
+		pMap->for_each(f);
+
+		return 0;
+	}
+
+	int dungeon_kill_all(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->KillAll();
+
+		return 0;
+	}
+
+	int dungeon_purge(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->Purge();
+
+		return 0;
+	}
+
+	int dungeon_exit_all_to_start_position(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->ExitAllToStartPosition();
+
+		return 0;
+	}
+
+	int dungeon_count_monster(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			lua_pushnumber(L, pDungeon->CountMonster());
+		else
+		{
+			sys_err("not in a dungeon");
+			lua_pushnumber(L, LONG_MAX);
+		}
+
+		return 1;
+	}
+
+	int dungeon_select(lua_State* L)
+	{
+		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 1);
+		if (dwMapIndex)
+		{
+			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
+			if (pDungeon)
+			{
+				CQuestManager::instance().SelectDungeon(pDungeon);
+				lua_pushboolean(L, 1);
+			}
+			else
+			{
+				CQuestManager::instance().SelectDungeon(NULL);
+				lua_pushboolean(L, 0);
+			}
+		}
+		else
+		{
+			CQuestManager::instance().SelectDungeon(NULL);
+			lua_pushboolean(L, 0);
+		}
+		return 1;
+	}
+
+	int dungeon_find(lua_State* L)
+	{
+		DWORD dwMapIndex = (DWORD)lua_tonumber(L, 1);
+		if (dwMapIndex)
+		{
+			LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(dwMapIndex);
+			if (pDungeon)
+			{
+				lua_pushboolean(L, 1);
+			}
+			else
+			{
+				lua_pushboolean(L, 0);
+			}
+		}
+		else
+		{
+			lua_pushboolean(L, 0);
+		}
+		return 1;
+	}
+
+	int dungeon_all_near_to(lua_State* L)
+	{
+		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
+
+		if (pDungeon != NULL)
+		{
+			lua_pushboolean(L, pDungeon->IsAllPCNearTo((int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2), 30));
+		}
+		else
+		{
+			lua_pushboolean(L, false);
+		}
+
+		return 1;
+	}
+
+	int dungeon_set_warp_location(lua_State* L)
+	{
+		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
+
+		if (pDungeon == NULL)
+		{
+			return 0;
+		}
+
+		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			return 0;
+		}
+
+		FSetWarpLocation f((int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2), (int)lua_tonumber(L, 3));
+		pDungeon->ForEachMember(f);
+
+		return 0;
+	}
+
+	int dungeon_set_item_group(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+		{
+			return 0;
+		}
+		std::string group_name(lua_tostring(L, 1));
+		int size = lua_tonumber(L, 2);
+
+		CDungeon::ItemGroup item_group;
+
+		for (int i = 0; i < size; i++)
+		{
+			if (!lua_isnumber(L, i * 2 + 3) || !lua_isnumber(L, i * 2 + 4))
+			{
+				return 0;
+			}
+			item_group.push_back(std::pair <DWORD, int>(lua_tonumber(L, i * 2 + 3), lua_tonumber(L, i * 2 + 4)));
+		}
+		LPDUNGEON pDungeon = CQuestManager::instance().GetCurrentDungeon();
+
+		if (pDungeon == NULL)
+		{
+			return 0;
+		}
+
+		pDungeon->CreateItemGroup(group_name, item_group);
+		return 0;
+	}
+
+	int dungeon_set_quest_flag2(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+
+		FSetQuestFlag f;
+
+		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("Invalid Argument");
+		}
+
+		f.flagname = string(lua_tostring(L, 1)) + "." + lua_tostring(L, 2);
+		f.value = (int)rint(lua_tonumber(L, 3));
+
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+
+		if (pDungeon)
+			pDungeon->ForEachMember(f);
+
+		return 0;
+	}
+
+#if defined(__CLIENT_TIMER__)
+	struct FSendClientTimer
+	{
+		FSendClientTimer(const DWORD bSubHeader, const DWORD dwEndTime = 0, const DWORD dwAlarmSec = 0)
+			: m_bSubHeader(bSubHeader), m_dwEndTime(dwEndTime), m_dwAlarmSec(dwAlarmSec)
+		{}
+		void operator() (const LPCHARACTER pChar)
+		{
+			if (pChar != nullptr)
+				pChar->SendClientTimer(m_bSubHeader, m_dwEndTime, m_dwAlarmSec);
+		}
+		BYTE m_bSubHeader;
+		DWORD m_dwEndTime, m_dwAlarmSec;
+	};
+
+	/*
+	* Usage: d.setct(end_time, alarm_sec)
+	* Function: Clears the client timer for all members.
+	* @arg1 - end_time : should be in a timestamp format (time + (duration))
+	* @arg2 - alarm sec : triggers the alarm color with then alarm secs.
+	*/
+	int dungeon_set_client_timer(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("Invalid Argument");
+			return 0;
+		}
+
+		DWORD dwEndTime = lua_tonumber(L, 1);
+		DWORD dwAlarmTime = lua_isnumber(L, 2) ? lua_tonumber(L, 2) : 0;
+
+		FSendClientTimer ClientTimer(CLIENT_TIMER_SUBHEADER_GC_SET, dwEndTime, dwAlarmTime);
+
+		CQuestManager& rQmgr = CQuestManager::instance();
+		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
+		if (pDungeon)
+			pDungeon->ForEachMember(ClientTimer);
+
+		return 0;
+	}
+
+	/*
+	* Usage: d.clearct()
+	* Function: Clears the client timer for all members.
+	*/
+	int dungeon_clear_client_timer(lua_State* L)
+	{
+		FSendClientTimer ClientTimer(CLIENT_TIMER_SUBHEADER_GC_DELETE);
+		CQuestManager& rQmgr = CQuestManager::instance();
+		const LPDUNGEON pDungeon = rQmgr.GetCurrentDungeon();
+		if (pDungeon)
+			pDungeon->ForEachMember(ClientTimer);
+
+		return 0;
+	}
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	int dungeon_battlepass_update_progress(lua_State* L)
+	{
+		CQuestManager & q = CQuestManager::instance();
+
+		FDungeonUpdateAllBattlepassProcess f;
+		
+		if (!lua_isnumber(L, 1)) {
+			sys_err("arg1 must be number (dungeon_index)");
+			return 0;
+		}
+		
+		f.dungeon_index = (int)lua_tonumber(L, 1);
+
+		LPDUNGEON pDungeon = q.GetCurrentDungeon();
+		
+		if (pDungeon)
+			pDungeon->ForEachMember(f);
+		return 0;
+	}
+#endif
+
+	void RegisterDungeonFunctionTable()
+	{
+		luaL_reg dungeon_functions[] =
+		{
+			{ "join", dungeon_join },
+			{ "exit", dungeon_exit },
+			{ "exit_all", dungeon_exit_all },
+			{ "set_item_group", dungeon_set_item_group },
+			{ "exit_all_by_item_group", dungeon_exit_all_by_item_group },
+			{ "say_diff_by_item_group", dungeon_say_diff_by_item_group },
+			{ "delete_item_in_item_group_from_all", dungeon_delete_item_in_item_group_from_all },
+			{ "purge", dungeon_purge },
+			{ "kill_all", dungeon_kill_all },
+			{ "spawn", dungeon_spawn },
+			{ "spawn_mob", dungeon_spawn_mob },
+			{ "spawn_mob_dir", dungeon_spawn_mob_dir },
+			{ "spawn_mob_ac_dir", dungeon_spawn_mob_ac_dir },
+			{ "spawn_name_mob", dungeon_spawn_name_mob },
+			{ "spawn_goto_mob", dungeon_spawn_goto_mob },
+			{ "spawn_group", dungeon_spawn_group },
+			{ "spawn_unique", dungeon_spawn_unique },
+			{ "spawn_move_unique", dungeon_spawn_move_unique },
+			{ "spawn_move_group", dungeon_spawn_move_group },
+			{ "spawn_stone_door", dungeon_spawn_stone_door },
+			{ "spawn_wooden_door", dungeon_spawn_wooden_door },
+			{ "purge_unique", dungeon_purge_unique },
+			{ "purge_area", dungeon_purge_area },
+			{ "kill_unique", dungeon_kill_unique },
+			{ "is_unique_dead", dungeon_is_unique_dead },
+			{ "unique_get_hp_perc", dungeon_unique_get_hp_perc },
+			{ "unique_set_def_grade", dungeon_unique_set_def_grade },
+			{ "unique_set_hp", dungeon_unique_set_hp },
+			{ "unique_set_maxhp", dungeon_unique_set_maxhp },
+			{ "get_unique_vid", dungeon_get_unique_vid },
+			{ "get_kill_stone_count", dungeon_get_kill_stone_count },
+			{ "get_kill_mob_count", dungeon_get_kill_mob_count },
+			{ "is_use_potion", dungeon_is_use_potion },
+			{ "revived", dungeon_revived },
+			{ "set_dest", dungeon_set_dest },
+			{ "jump_all", dungeon_jump_all },
+			{ "warp_all", dungeon_warp_all },
+			{ "new_jump_all", dungeon_new_jump_all },
+			{ "new_jump_party", dungeon_new_jump_party },
+			{ "new_jump", dungeon_new_jump },
+			{ "regen_file", dungeon_regen_file },
+			{ "set_regen_file", dungeon_set_regen_file },
+			{ "clear_regen", dungeon_clear_regen },
+			{ "set_exit_all_at_eliminate", dungeon_set_exit_all_at_eliminate},
+			{ "set_warp_at_eliminate", dungeon_set_warp_at_eliminate},
+			{ "get_map_index", dungeon_get_map_index },
+			{ "check_eliminated", dungeon_check_eliminated },
+			{ "exit_all_to_start_position", dungeon_exit_all_to_start_position },
+			{ "count_monster", dungeon_count_monster },
+			{ "setf", dungeon_set_flag },
+			{ "getf", dungeon_get_flag },
+			{ "getf_from_map_index", dungeon_get_flag_from_map_index },
+			{ "set_unique", dungeon_set_unique },
+			{ "select", dungeon_select },
+			{ "find", dungeon_find },
+			{ "notice", dungeon_notice },
+			{ "mission_msg", dungeon_mission_msg },
+			{ "sub_mission_msg", dungeon_sub_mission_msg },
+			{ "clear_mission_msg", dungeon_clear_mission_msg },
+			{ "setqf", dungeon_set_quest_flag },
+			{ "all_near_to", dungeon_all_near_to },
+			{ "set_warp_location", dungeon_set_warp_location },
+			{ "setqf2", dungeon_set_quest_flag2 },
+#if defined(__DUNGEON_RENEWAL__)
+			{ "create", dungeon_create },
+			{ "destroy", dungeon_destroy },
+			{ "setf_for_map_index", dungeon_set_flag_for_map_index },
+			{ "spawn_for_map_index", dungeon_spawn_mob_for_map_index },
+			{ "party_notice", dungeon_party_notice },
+			{ "syschat", dungeon_syschat },
+			{ "setqf2_all_near", dungeon_set_quest_flag2_all_near },
+#endif
+#if defined(__CLIENT_TIMER__)
+			{ "setct", dungeon_set_client_timer },
+			{ "clearct", dungeon_clear_client_timer },
+#endif
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			{ "battlepass_update_progress", dungeon_battlepass_update_progress },
+#endif
+			{ NULL, NULL }
+		};
+
+		CQuestManager::instance().AddLuaFunctionTable("d", dungeon_functions);
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/questlua_horse.cpp b/server/metin2/Source/Server/game/src/questlua_horse.cpp
index 7d18eab..4851c9a 100644
--- a/server/metin2/Source/Server/game/src/questlua_horse.cpp
+++ b/server/metin2/Source/Server/game/src/questlua_horse.cpp
@@ -1,313 +1,320 @@
-#include "stdafx.h"
-
-#include "questlua.h"
-#include "questmanager.h"
-#include "horsename_manager.h"
-#include "char.h"
-#include "affect.h"
-#include "config.h"
-#include "utils.h"
-
-#undef sys_err
-#ifndef __WIN32__
-#define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
-#else
-#define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
-#endif
-
-extern int (*check_name) (const char* str);
-
-namespace quest
-{
-	//
-	// "horse" Lua functions
-	//
-	int horse_is_riding(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->IsHorseRiding())
-			lua_pushnumber(L, 1);
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int horse_is_summon(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != ch)
-		{
-			lua_pushboolean(L, (ch->GetHorse() != NULL) ? true : false);
-		}
-		else
-		{
-			lua_pushboolean(L, false);
-		}
-
-		return 1;
-	}
-
-	int horse_ride(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->StartRiding();
-		return 0;
-	}
-
-	int horse_unride(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->StopRiding();
-		return 0;
-	}
-
-	int horse_summon(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		// 소환하면 멀리서부터 달려오는지 여부
-		bool bFromFar = lua_isboolean(L, 1) ? lua_toboolean(L, 1) : false;
-
-		// 소환수의 vnum
-		DWORD horseVnum = lua_isnumber(L, 2) ? lua_tonumber(L, 2) : 0;
-
-		const char* name = lua_isstring(L, 3) ? lua_tostring(L, 3) : 0;
-		ch->HorseSummon(true, bFromFar, horseVnum, name);
-		return 0;
-	}
-
-	int horse_unsummon(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->HorseSummon(false);
-		return 0;
-	}
-
-	int horse_is_mine(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPCHARACTER horse = CQuestManager::instance().GetCurrentNPCCharacterPtr();
-
-		lua_pushboolean(L, horse && horse->GetRider() == ch);
-		return 1;
-	}
-
-	int horse_set_level(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-			return 0;
-
-		int newlevel = MINMAX(0, (int)lua_tonumber(L, 1), HORSE_MAX_LEVEL);
-		ch->SetHorseLevel(newlevel);
-		ch->ComputePoints();
-		ch->SkillLevelPacket();
-		return 0;
-	}
-
-	int horse_get_level(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetHorseLevel());
-		return 1;
-	}
-
-	int horse_advance(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->GetHorseLevel() >= HORSE_MAX_LEVEL)
-			return 0;
-
-		ch->SetHorseLevel(ch->GetHorseLevel() + 1);
-		ch->ComputePoints();
-		ch->SkillLevelPacket();
-		return 0;
-	}
-
-	int horse_get_health(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->GetHorseLevel())
-			lua_pushnumber(L, ch->GetHorseHealth());
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int horse_get_health_pct(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		int pct = MINMAX(0, ch->GetHorseHealth() * 100 / ch->GetHorseMaxHealth(), 100);
-		sys_log(1, "horse.get_health_pct %d", pct);
-
-		if (ch->GetHorseLevel())
-			lua_pushnumber(L, pct);
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int horse_get_stamina(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->GetHorseLevel())
-			lua_pushnumber(L, ch->GetHorseStamina());
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int horse_get_stamina_pct(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int pct = MINMAX(0, ch->GetHorseStamina() * 100 / ch->GetHorseMaxStamina(), 100);
-		sys_log(1, "horse.get_stamina_pct %d", pct);
-
-		if (ch->GetHorseLevel())
-			lua_pushnumber(L, pct);
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int horse_get_grade(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetHorseGrade());
-		return 1;
-	}
-
-	int horse_is_dead(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->GetHorseHealth() <= 0);
-		return 1;
-	}
-
-	int horse_revive(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch->GetHorseLevel() > 0 && ch->GetHorseHealth() <= 0)
-		{
-			ch->ReviveHorse();
-		}
-		return 0;
-	}
-
-	int horse_feed(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		//DWORD dwHorseFood = ch->GetHorseLevel() + ITEM_HORSE_FOOD_1 - 1;
-		if (ch->GetHorseLevel() > 0 && ch->GetHorseHealth() > 0)
-		{
-			ch->FeedHorse();
-		}
-		return 0;
-	}
-
-	int horse_set_name(lua_State* L)
-	{
-		// 리턴값
-		// 0 : 소유한 말이 없다
-		// 1 : 잘못된 이름이다
-		// 2 : 이름 바꾸기 성공
-
-		if (!lua_isstring(L, -1)) return 0;
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->GetHorseLevel() > 0)
-		{
-			const char* pHorseName = lua_tostring(L, -1);
-
-			if (pHorseName == NULL || check_name(pHorseName) == 0)
-			{
-				lua_pushnumber(L, 1);
-			}
-			else
-			{
-				// Horse Name
-				int nHorseNameDuration = test_server ? 60 * 5 : 60 * 60 * 24 * 30; // The horse name will vanish in 5 minutes on the test server.
-
-				ch->SetQuestFlag("horse_name.valid_till", get_global_time() + nHorseNameDuration);
-				ch->AddAffect(AFFECT_HORSE_NAME, 0, 0, 0, PASSES_PER_SEC(nHorseNameDuration), 0, true);
-
-				CHorseNameManager::instance().UpdateHorseName(ch->GetPlayerID(), lua_tostring(L, -1), true);
-
-				ch->HorseSummon(false, true);
-				ch->HorseSummon(true, true);
-
-				lua_pushnumber(L, 2);
-			}
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int horse_get_name(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch != NULL)
-		{
-			const char* pHorseName = CHorseNameManager::instance().GetHorseName(ch->GetPlayerID());
-
-			if (pHorseName != NULL)
-			{
-				lua_pushstring(L, pHorseName);
-				return 1;
-			}
-		}
-
-		lua_pushstring(L, "");
-
-		return 1;
-	}
-
-	void RegisterHorseFunctionTable()
-	{
-		luaL_reg horse_functions[] =
-		{
-			{ "is_mine", horse_is_mine },
-			{ "is_riding", horse_is_riding },
-			{ "is_summon", horse_is_summon },
-			{ "ride", horse_ride },
-			{ "unride", horse_unride },
-			{ "summon", horse_summon },
-			{ "unsummon", horse_unsummon },
-			{ "advance", horse_advance },
-			{ "get_level", horse_get_level },
-			{ "set_level", horse_set_level },
-			{ "get_health", horse_get_health },
-			{ "get_health_pct", horse_get_health_pct },
-			{ "get_stamina", horse_get_stamina },
-			{ "get_stamina_pct", horse_get_stamina_pct },
-			{ "get_grade", horse_get_grade },
-			{ "is_dead", horse_is_dead },
-			{ "revive", horse_revive },
-			{ "feed", horse_feed },
-			{ "set_name", horse_set_name },
-			{ "get_name", horse_get_name },
-
-			{ NULL, NULL }
-		};
-
-		CQuestManager::instance().AddLuaFunctionTable("horse", horse_functions);
-	}
-}
+#include "stdafx.h"
+
+#include "questlua.h"
+#include "questmanager.h"
+#include "horsename_manager.h"
+#include "char.h"
+#include "affect.h"
+#include "config.h"
+#include "utils.h"
+
+#undef sys_err
+#ifndef __WIN32__
+#define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
+#else
+#define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
+#endif
+
+extern int (*check_name) (const char* str);
+
+namespace quest
+{
+	//
+	// "horse" Lua functions
+	//
+	int horse_is_riding(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->IsHorseRiding())
+			lua_pushnumber(L, 1);
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int horse_is_summon(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != ch)
+		{
+			lua_pushboolean(L, (ch->GetHorse() != NULL) ? true : false);
+		}
+		else
+		{
+			lua_pushboolean(L, false);
+		}
+
+		return 1;
+	}
+
+	int horse_ride(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->StartRiding();
+		return 0;
+	}
+
+	int horse_unride(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->StopRiding();
+		return 0;
+	}
+
+	int horse_summon(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		// 환玖 寧 玭 
+		bool bFromFar = lua_isboolean(L, 1) ? lua_toboolean(L, 1) : false;
+
+		// 환 vnum
+		DWORD horseVnum = lua_isnumber(L, 2) ? lua_tonumber(L, 2) : 0;
+
+		const char* name = lua_isstring(L, 3) ? lua_tostring(L, 3) : 0;
+		ch->HorseSummon(true, bFromFar, horseVnum, name);
+		return 0;
+	}
+
+	int horse_unsummon(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->HorseSummon(false);
+		return 0;
+	}
+
+	int horse_is_mine(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPCHARACTER horse = CQuestManager::instance().GetCurrentNPCCharacterPtr();
+
+		lua_pushboolean(L, horse && horse->GetRider() == ch);
+		return 1;
+	}
+
+	int horse_set_level(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+			return 0;
+
+		int newlevel = MINMAX(0, (int)lua_tonumber(L, 1), HORSE_MAX_LEVEL);
+		ch->SetHorseLevel(newlevel);
+		ch->ComputePoints();
+		ch->SkillLevelPacket();
+		return 0;
+	}
+
+	int horse_get_level(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetHorseLevel());
+		return 1;
+	}
+
+	int horse_advance(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->GetHorseLevel() >= HORSE_MAX_LEVEL)
+			return 0;
+
+		ch->SetHorseLevel(ch->GetHorseLevel() + 1);
+		ch->ComputePoints();
+		ch->SkillLevelPacket();
+		return 0;
+	}
+
+	int horse_get_health(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->GetHorseLevel())
+			lua_pushnumber(L, ch->GetHorseHealth());
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int horse_get_health_pct(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		int pct = MINMAX(0, ch->GetHorseHealth() * 100 / ch->GetHorseMaxHealth(), 100);
+		sys_log(1, "horse.get_health_pct %d", pct);
+
+		if (ch->GetHorseLevel())
+			lua_pushnumber(L, pct);
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int horse_get_stamina(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->GetHorseLevel())
+			lua_pushnumber(L, ch->GetHorseStamina());
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int horse_get_stamina_pct(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int pct = MINMAX(0, ch->GetHorseStamina() * 100 / ch->GetHorseMaxStamina(), 100);
+		sys_log(1, "horse.get_stamina_pct %d", pct);
+
+		if (ch->GetHorseLevel())
+			lua_pushnumber(L, pct);
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int horse_get_grade(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetHorseGrade());
+		return 1;
+	}
+
+	int horse_is_dead(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->GetHorseHealth() <= 0);
+		return 1;
+	}
+
+	int horse_revive(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch->GetHorseLevel() > 0 && ch->GetHorseHealth() <= 0)
+		{
+			ch->ReviveHorse();
+		}
+		return 0;
+	}
+
+	int horse_feed(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		//DWORD dwHorseFood = ch->GetHorseLevel() + ITEM_HORSE_FOOD_1 - 1;
+		if (ch->GetHorseLevel() > 0 && ch->GetHorseHealth() > 0)
+		{
+			ch->FeedHorse();
+		}
+		return 0;
+	}
+
+	int horse_set_name(lua_State* L)
+	{
+		// 構
+		// 0 :   
+		// 1 : 蔘 見甄
+		// 2 : 見 侮袂 
+
+		if (!lua_isstring(L, -1)) return 0;
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->GetHorseLevel() > 0)
+		{
+			const char* pHorseName = lua_tostring(L, -1);
+
+			// [Security] Prevent format-string / crash vectors (e.g. '%' sequences)
+			if (pHorseName && strchr(pHorseName, '%'))
+			{
+				lua_pushnumber(L, 1);
+				return 1;
+			}
+
+			if (pHorseName == NULL || check_name(pHorseName) == 0)
+			{
+				lua_pushnumber(L, 1);
+			}
+			else
+			{
+				// Horse Name
+				int nHorseNameDuration = test_server ? 60 * 5 : 60 * 60 * 24 * 30; // The horse name will vanish in 5 minutes on the test server.
+
+				ch->SetQuestFlag("horse_name.valid_till", get_global_time() + nHorseNameDuration);
+				ch->AddAffect(AFFECT_HORSE_NAME, 0, 0, 0, PASSES_PER_SEC(nHorseNameDuration), 0, true);
+
+				CHorseNameManager::instance().UpdateHorseName(ch->GetPlayerID(), lua_tostring(L, -1), true);
+
+				ch->HorseSummon(false, true);
+				ch->HorseSummon(true, true);
+
+				lua_pushnumber(L, 2);
+			}
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int horse_get_name(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch != NULL)
+		{
+			const char* pHorseName = CHorseNameManager::instance().GetHorseName(ch->GetPlayerID());
+
+			if (pHorseName != NULL)
+			{
+				lua_pushstring(L, pHorseName);
+				return 1;
+			}
+		}
+
+		lua_pushstring(L, "");
+
+		return 1;
+	}
+
+	void RegisterHorseFunctionTable()
+	{
+		luaL_reg horse_functions[] =
+		{
+			{ "is_mine", horse_is_mine },
+			{ "is_riding", horse_is_riding },
+			{ "is_summon", horse_is_summon },
+			{ "ride", horse_ride },
+			{ "unride", horse_unride },
+			{ "summon", horse_summon },
+			{ "unsummon", horse_unsummon },
+			{ "advance", horse_advance },
+			{ "get_level", horse_get_level },
+			{ "set_level", horse_set_level },
+			{ "get_health", horse_get_health },
+			{ "get_health_pct", horse_get_health_pct },
+			{ "get_stamina", horse_get_stamina },
+			{ "get_stamina_pct", horse_get_stamina_pct },
+			{ "get_grade", horse_get_grade },
+			{ "is_dead", horse_is_dead },
+			{ "revive", horse_revive },
+			{ "feed", horse_feed },
+			{ "set_name", horse_set_name },
+			{ "get_name", horse_get_name },
+
+			{ NULL, NULL }
+		};
+
+		CQuestManager::instance().AddLuaFunctionTable("horse", horse_functions);
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/questlua_pc.cpp b/server/metin2/Source/Server/game/src/questlua_pc.cpp
index ddac9fa..9d537df 100644
--- a/server/metin2/Source/Server/game/src/questlua_pc.cpp
+++ b/server/metin2/Source/Server/game/src/questlua_pc.cpp
@@ -1,4156 +1,4159 @@
-#include "stdafx.h"
-
-#include "config.h"
-#include "questmanager.h"
-#include "sectree_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "affect.h"
-#include "item.h"
-#include "item_manager.h"
-#include "guild_manager.h"
-#include "war_map.h"
-#include "start_position.h"
-#include "marriage.h"
-#include "mining.h"
-#include "p2p.h"
-#include "polymorph.h"
-#include "desc_client.h"
-#include "messenger_manager.h"
-#include "log.h"
-#include "utils.h"
-#include "unique_item.h"
-#include "mob_manager.h"
-
-#if defined(__DICE_SYSTEM__)
-#	include "party.h"
-#endif
-
-#include <cctype>
-
-#undef sys_err
-#ifndef __WIN32__
-#	define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
-#else
-#	define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
-#endif
-
-extern int g_nPortalLimitTime;
-extern LPCLIENT_DESC db_clientdesc;
-const int ITEM_BROKEN_METIN_VNUM = 28960;
-
-namespace quest
-{
-	//
-	// "pc" Lua functions
-	//
-	int pc_has_master_skill(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		bool bHasMasterSkill = false;
-		for (int i = 0; i < SKILL_MAX_NUM; i++)
-			if (ch->GetSkillMasterType(i) >= SKILL_MASTER && ch->GetSkillLevel(i) >= 21)
-			{
-				bHasMasterSkill = true;
-				break;
-			}
-
-		lua_pushboolean(L, bHasMasterSkill);
-		return 1;
-	}
-
-	int pc_remove_skill_book_no_delay(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
-		return 0;
-	}
-
-	int pc_is_skill_book_no_delay(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		lua_pushboolean(L, ch->FindAffect(AFFECT_SKILL_NO_BOOK_DELAY) ? true : false);
-		return 1;
-	}
-
-	int pc_learn_grand_master_skill(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong skill index");
-			return 0;
-		}
-
-		lua_pushboolean(L, ch->LearnGrandMasterSkill((long)lua_tonumber(L, 1)));
-		return 1;
-	}
-
-	int pc_set_warp_location(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong map index");
-			return 0;
-		}
-
-		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("wrong coodinate");
-			return 0;
-		}
-
-		ch->SetWarpLocation((long)lua_tonumber(L, 1), (long)lua_tonumber(L, 2), (long)lua_tonumber(L, 3));
-		return 0;
-	}
-
-	int pc_set_warp_location_local(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong map index");
-			return 0;
-		}
-
-		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("wrong coodinate");
-			return 0;
-		}
-
-		long lMapIndex = (long)lua_tonumber(L, 1);
-		const TMapRegion* region = SECTREE_MANAGER::instance().GetMapRegion(lMapIndex);
-
-		if (!region)
-		{
-			sys_err("invalid map index %d", lMapIndex);
-			return 0;
-		}
-
-		int x = (int)lua_tonumber(L, 2);
-		int y = (int)lua_tonumber(L, 3);
-
-		if (x > region->ex - region->sx)
-		{
-			sys_err("x coordinate overflow max: %d input: %d", region->ex - region->sx, x);
-			return 0;
-		}
-
-		if (y > region->ey - region->sy)
-		{
-			sys_err("y coordinate overflow max: %d input: %d", region->ey - region->sy, y);
-			return 0;
-		}
-
-		ch->SetWarpLocation(lMapIndex, x, y);
-		return 0;
-	}
-
-	int pc_get_start_location(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		lua_pushnumber(L, g_start_map[ch->GetEmpire()]);
-		lua_pushnumber(L, g_start_position[ch->GetEmpire()][0] / 100);
-		lua_pushnumber(L, g_start_position[ch->GetEmpire()][1] / 100);
-		return 3;
-	}
-
-#if defined(__DUNGEON_RENEWAL__)
-	int pc_jump(lua_State* L)
-	{
-		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-			return 0;
-
-		long x = (int)lua_tonumber(L, 1);
-		long y = (int)lua_tonumber(L, 2);
-		long lMapIndex = (int)lua_tonumber(L, 3);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (test_server)
-			ch->ChatPacket(CHAT_TYPE_INFO, "pc_jump %d %d %d", x, y, lMapIndex);
-
-		if (ch->GetMapIndex() == lMapIndex)
-		{
-			ch->Show(lMapIndex, x, y, 0);
-			ch->Stop();
-		}
-		else
-			ch->WarpSet(x, y, lMapIndex);
-
-		return 0;
-	}
-#endif
-
-	int pc_warp(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			lua_pushboolean(L, false);
-			return 1;
-		}
-
-		long map_index = 0;
-
-		if (lua_isnumber(L, 3))
-			map_index = (int)lua_tonumber(L, 3);
-
-		// PREVENT_HACK
-		if (ch->IsHack())
-		{
-			lua_pushboolean(L, false);
-			return 1;
-		}
-		// END_PREVENT_HACK
-
-		if (test_server)
-			ch->ChatPacket(CHAT_TYPE_INFO, "pc_warp %d %d %d", (int)lua_tonumber(L, 1),
-				(int)lua_tonumber(L, 2), map_index);
-		ch->WarpSet((int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2), map_index);
-
-		lua_pushboolean(L, true);
-
-		return 1;
-	}
-
-	int pc_warp_local(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("no map index argument");
-			return 0;
-		}
-
-		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("no coodinate argument");
-			return 0;
-		}
-
-		long lMapIndex = (long)lua_tonumber(L, 1);
-		const TMapRegion* region = SECTREE_MANAGER::instance().GetMapRegion(lMapIndex);
-
-		if (!region)
-		{
-			sys_err("invalid map index %d", lMapIndex);
-			return 0;
-		}
-
-		int x = (int)lua_tonumber(L, 2);
-		int y = (int)lua_tonumber(L, 3);
-
-		if (x > region->ex - region->sx)
-		{
-			sys_err("x coordinate overflow max: %d input: %d", region->ex - region->sx, x);
-			return 0;
-		}
-
-		if (y > region->ey - region->sy)
-		{
-			sys_err("y coordinate overflow max: %d input: %d", region->ey - region->sy, y);
-			return 0;
-		}
-
-		/*
-		int iPulse = thecore_pulse();
-		if ( pkChr->GetExchange() || pkChr->GetMyShop() || pkChr->GetShopOwner() || pkChr->IsOpenSafebox() )
-		{
-			pkChr->ChatPacket( CHAT_TYPE_INFO, LC_STRING("거래창,창고 등을 연 상태에서는 다른곳으로 이동할수 없습니다" ));
-
-			return;
-		}
-		//PREVENT_PORTAL_AFTER_EXCHANGE
-		//교환 후 시간체크
-		if ( iPulse - pkChr->GetExchangeTime() < PASSES_PER_SEC(60) )
-		{
-			pkChr->ChatPacket( CHAT_TYPE_INFO, LC_STRING("거래 후 1분 이내에는 다른지역으로 이동 할 수 없습니다." ) );
-			return;
-		}
-		//END_PREVENT_PORTAL_AFTER_EXCHANGE
-		//PREVENT_ITEM_COPY
-		{
-			if ( iPulse - pkChr->GetMyShopTime() < PASSES_PER_SEC(60) )
-			{
-				pkChr->ChatPacket( CHAT_TYPE_INFO, LC_STRING("거래 후 1분 이내에는 다른지역으로 이동 할 수 없습니다." ) );
-				return;
-			}
-
-		}
-		//END_PREVENT_ITEM_COPY
-		*/
-
-		CQuestManager::instance().GetCurrentCharacterPtr()->WarpSet(region->sx + x, region->sy + y);
-		return 0;
-	}
-
-	int pc_warp_exit(lua_State* L)
-	{
-		CQuestManager::instance().GetCurrentCharacterPtr()->ExitToSavedLocation();
-		return 0;
-	}
-
-	int pc_in_dungeon(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->GetDungeon() ? 1 : 0);
-		return 1;
-	}
-
-	int pc_hasguild(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->GetGuild() ? 1 : 0);
-		return 1;
-	}
-
-	int pc_getguild(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetGuild() ? ch->GetGuild()->GetID() : 0);
-		return 1;
-	}
-
-	int pc_is_guild_master(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		CGuild* g = ch->GetGuild();
-
-		if (g)
-			lua_pushboolean(L, (ch->GetPlayerID() == g->GetMasterPID()));
-		else
-			lua_pushboolean(L, 0);
-
-		return 1;
-	}
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__) //&& defined(__GUILD_RENEWAL__)
-	int pc_is_guild_general(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch && ch->GetGuild())
-			lua_pushboolean(L, ch->GetGuild()->IsGeneralMember(ch->GetPlayerID()) ? true : false);
-		else
-			lua_pushboolean(L, false);
-
-		return 1;
-	}
-#endif
-
-	int pc_destroy_guild(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		CGuild* g = ch->GetGuild();
-
-		if (g)
-			g->RequestDisband(ch->GetPlayerID());
-
-		return 0;
-	}
-
-	int pc_remove_from_guild(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		CGuild* g = ch->GetGuild();
-
-		if (g)
-			g->RequestRemoveMember(ch->GetPlayerID());
-
-		return 0;
-	}
-
-	int pc_give_gold(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("QUEST : wrong argument");
-			return 0;
-		}
-
-		int iAmount = (int)lua_tonumber(L, 1);
-
-		if (iAmount <= 0)
-		{
-			sys_err("QUEST : gold amount less then zero");
-			return 0;
-		}
-
-		DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), iAmount);
-		ch->PointChange(POINT_GOLD, iAmount, true);
-		return 0;
-	}
-
-#if defined(__CHEQUE_SYSTEM__)
-	int pc_give_cheque(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("QUEST : wrong argument");
-			return 0;
-		}
-
-		int iAmount = (int)lua_tonumber(L, 1);
-
-		if (iAmount <= 0)
-		{
-			sys_err("QUEST : gold amount less then zero");
-			return 0;
-		}
-
-		DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), iAmount);
-		ch->PointChange(POINT_CHEQUE, iAmount, true);
-		return 0;
-	}
-
-	// Syntax: pc.exchange_cheque(@arg1, arg2)
-	// @arg1: cheque amount
-	// @arg2: cheque value
-	// @desc: converts cheque to gold.
-	int pc_exchange_cheque(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			sys_err("QUEST: Invalid argument");
-			return 0;
-		}
-
-		int cheque = (int/*max datatype for cheque*/)lua_tonumber(L, 1);
-		int cheque_value = (int/*max datatype for gold*/)lua_tonumber(L, 2);
-		if (cheque <= 0 || cheque_value <= 0 || cheque > CHEQUE_MAX || cheque_value >= GOLD_MAX)
-			return 0;
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch == nullptr)
-			return 0;
-
-		if (ch->GetCheque() < cheque)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Won."));
-			return 0;
-		}
-
-		int64_t gold = cheque * cheque_value;
-		const int64_t max_gold = static_cast<int64_t>(ch->GetGold()) + gold;
-		if (max_gold >= GOLD_MAX)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Yang."));
-			return 0;
-		}
-
-		ch->PointChange(POINT_GOLD, gold);
-		ch->PointChange(POINT_CHEQUE, -cheque);
-
-		sys_log(0, "QUEST [CHEQUE EXCHANGE] %s exchanged %d Won for %d Yang.", ch->GetName(), cheque, gold);
-
-		return 0;
-	}
-
-	// Syntax: pc.exchange_cheque(@arg1, @arg2, @arg3)
-	// @arg1: cheque amount
-	// @arg2: cheque value
-	// @arg3: tax
-	// @desc: converts gold to cheque.
-	int pc_exchange_gold(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("QUEST: Invalid argument");
-			return 0;
-		}
-
-		int cheque = (int/*max datatype for cheque*/)lua_tonumber(L, 1);
-		int cheque_value = (int/*max datatype for gold*/)lua_tonumber(L, 2);
-		int tax_rate = lua_tonumber(L, 3);
-		if (cheque <= 0 || cheque_value <= 0 || cheque > CHEQUE_MAX || cheque_value >= GOLD_MAX)
-			return 0;
-
-		int64_t tax = (cheque * cheque_value * tax_rate / 100);
-		int64_t gold = cheque * cheque_value + tax;
-
-		if (gold <= 0 || gold >= GOLD_MAX)
-			return 0;
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch == nullptr)
-			return 0;
-
-		if (ch->GetGold() < gold)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang."));
-			return 0;
-		}
-
-		if (ch->GetCheque() + cheque > CHEQUE_MAX)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Won."));
-			return 0;
-		}
-
-		ch->PointChange(POINT_CHEQUE, cheque);
-		ch->PointChange(POINT_GOLD, -gold);
-
-		sys_log(0, "QUEST [GOLD EXCHANGE] %s exchanged %d Yang for %d Won.", ch->GetName(), gold, cheque);
-
-		return 0;
-	}
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	int pc_give_gem(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("QUEST : wrong argument");
-			return 0;
-		}
-
-		int iAmount = (int)lua_tonumber(L, 1);
-
-		if (iAmount <= 0)
-		{
-			sys_err("QUEST : gold amount less then zero");
-			return 0;
-		}
-
-		DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), iAmount);
-		ch->PointChange(POINT_GEM, iAmount, true);
-		return 0;
-	}
-#endif
-
-	int pc_warp_to_guild_war_observer_position(lua_State* L)
-	{
-		luaL_checknumber(L, 1);
-		luaL_checknumber(L, 2);
-
-		DWORD gid1 = (DWORD)lua_tonumber(L, 1);
-		DWORD gid2 = (DWORD)lua_tonumber(L, 2);
-
-		CGuild* g1 = CGuildManager::instance().FindGuild(gid1);
-		CGuild* g2 = CGuildManager::instance().FindGuild(gid2);
-
-		if (!g1 || !g2)
-		{
-			luaL_error(L, "no such guild with id %d %d", gid1, gid2);
-		}
-
-		PIXEL_POSITION pos;
-
-		DWORD dwMapIndex = g1->GetGuildWarMapIndex(gid2);
-
-		if (!CWarMapManager::instance().GetStartPosition(dwMapIndex, 2, pos))
-		{
-			luaL_error(L, "not under warp guild war between guild %d %d", gid1, gid2);
-			return 0;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		// PREVENT_HACK
-		if (ch->IsHack())
-			return 0;
-		// END_PREVENT_HACK
-
-		ch->SetQuestFlag("war.is_war_member", 0);
-		ch->SaveExitLocation();
-		ch->WarpSet(pos.x, pos.y, dwMapIndex);
-		return 0;
-	}
-
-#if defined(__DUNGEON_RENEWAL__)
-	// syntax in LUA: pc.remove_item_from_special_item_group(item_group_vnum, count)
-	int pc_has_item_from_special_item_group(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			lua_pushboolean(L, false);
-			return 1;
-		}
-
-		DWORD dwGroupNum = (DWORD)lua_tonumber(L, 1);
-		DWORD dwRemoveCount = lua_isnumber(L, 2) ? (DWORD)lua_tonumber(L, 2) : 0;
-
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (NULL == pChar)
-		{
-			sys_err("QUEST : null pc");
-			return 1;
-		}
-
-		const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
-		if (!pGroup)
-		{
-			sys_err("QUEST : cannot find special item group %d", dwGroupNum);
-			return 1;
-		}
-
-		bool bFound = false;
-		DWORD dwFoundCount = 0;
-
-		int iGroupSize = pGroup->GetGroupSize();
-		for (int iIdx = 0; iIdx < iGroupSize; iIdx++)
-		{
-			DWORD dwVnum = pGroup->GetVnum(iIdx);
-			DWORD dwCount = dwRemoveCount ? dwRemoveCount : pGroup->GetCount(iIdx);
-
-			dwFoundCount += pChar->CountSpecifyItem(dwVnum);
-			if (dwFoundCount >= dwCount)
-			{
-				bFound = true;
-				break;
-			}
-		}
-
-		lua_pushboolean(L, bFound);
-		return 1;
-	}
-
-	// NOTE : The removed item from the inventory will always be the first item found in the group.
-	// If you want to remove certain items first you must adjust the position.
-	// It's recommended to leave MALL items at the end.
-	// syntax in LUA: pc.remove_item_from_special_item_group(item_group_vnum, count)
-	int pc_remove_item_from_special_item_group(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			lua_pushboolean(L, false);
-			return 1;
-		}
-
-		DWORD dwGroupNum = (DWORD)lua_tonumber(L, 1);
-		DWORD dwRemoveCount = lua_isnumber(L, 2) ? (DWORD)lua_tonumber(L, 2) : 0;
-
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (NULL == pChar)
-		{
-			sys_err("QUEST : null pc");
-			return 1;
-		}
-
-		const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
-		if (!pGroup)
-		{
-			sys_err("QUEST : cannot find special item group %d", dwGroupNum);
-			return 1;
-		}
-
-		bool bRemoveItem = false;
-
-		DWORD dwFoundCount = 0;
-		DWORD dwSingleCount = 0;
-
-		int iGroupSize = pGroup->GetGroupSize();
-		for (int iIdx = 0; iIdx < iGroupSize; iIdx++)
-		{
-			DWORD dwVnum = pGroup->GetVnum(iIdx);
-			DWORD dwCount = dwRemoveCount ? dwRemoveCount : pGroup->GetCount(iIdx);
-
-			dwFoundCount += pChar->CountSpecifyItem(dwVnum);
-			if (dwFoundCount >= dwCount)
-			{
-				pChar->RemoveSpecifyItem(dwVnum, dwCount - dwSingleCount);
-				bRemoveItem = true;
-				break;
-			}
-			else
-			{
-				pChar->RemoveSpecifyItem(dwVnum, dwFoundCount);
-				dwSingleCount += dwFoundCount;
-				continue;
-			}
-		}
-
-		lua_pushboolean(L, bRemoveItem);
-		return 1;
-	}
-#endif
-
-	int pc_give_item_from_special_item_group(lua_State* L)
-	{
-		luaL_checknumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		DWORD dwGroupVnum = (DWORD)lua_tonumber(L, 1);
-		ch->GiveItemFromSpecialItemGroup(dwGroupVnum);
-
-		return 0;
-	}
-
-	int pc_enough_inventory(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (!lua_isnumber(L, 1))
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		DWORD item_vnum = (DWORD)lua_tonumber(L, 1);
-		TItemTable* pTable = ITEM_MANAGER::instance().GetTable(item_vnum);
-		if (!pTable)
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		bool bEnoughInventoryForItem = ch->GetEmptyInventory(pTable->bSize) != -1;
-		lua_pushboolean(L, bEnoughInventoryForItem);
-		return 1;
-	}
-
-	int pc_give_item(lua_State* L)
-	{
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isstring(L, 1) || !(lua_isstring(L, 2) || lua_isnumber(L, 2)))
-		{
-			sys_err("QUEST : wrong argument");
-			return 0;
-		}
-
-		DWORD dwVnum;
-
-		if (lua_isnumber(L, 2)) // 번호인경우 번호로 준다.
-			dwVnum = (int)lua_tonumber(L, 2);
-		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 2), dwVnum))
-		{
-			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
-			return 0;
-		}
-
-		int icount = 1;
-
-		if (lua_isnumber(L, 3) && lua_tonumber(L, 3) > 0)
-		{
-			icount = (int)rint(lua_tonumber(L, 3));
-
-			if (icount <= 0)
-			{
-				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
-				return 0;
-			}
-		}
-
-		pPC->GiveItem(lua_tostring(L, 1), dwVnum, icount);
-
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
-		return 0;
-	}
-
-	int pc_give_or_drop_item(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isstring(L, 1) && !lua_isnumber(L, 1))
-		{
-			sys_err("QUEST Make item call error : wrong argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		DWORD dwVnum;
-
-		if (lua_isnumber(L, 1)) // 번호인경우 번호로 준다.
-		{
-			dwVnum = (int)lua_tonumber(L, 1);
-		}
-		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), dwVnum))
-		{
-			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
-			lua_pushnumber(L, 0);
-
-			return 1;
-		}
-
-		int icount = 1;
-		if (lua_isnumber(L, 2) && lua_tonumber(L, 2) > 0)
-		{
-			icount = (int)rint(lua_tonumber(L, 2));
-			if (icount <= 0)
-			{
-				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
-				lua_pushnumber(L, 0);
-				return 1;
-			}
-		}
-
-		sys_log(0, "QUEST [REWARD] item %s to %s", lua_tostring(L, 1), ch->GetName());
-
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
-
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		LPITEM item = ch->AutoGiveItem(dwVnum, icount, -1, true, true);
-#else
-		LPITEM item = ch->AutoGiveItem(dwVnum, icount);
-#endif
-
-		if (dwVnum >= 80003 && dwVnum <= 80007)
-		{
-			LogManager::instance().GoldBarLog(ch->GetPlayerID(), item->GetID(), QUEST, "quest: give_item2");
-		}
-
-		if (NULL != item)
-		{
-			lua_pushnumber(L, item->GetID());
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-		return 1;
-	}
-
-#if defined(__DICE_SYSTEM__)
-	int pc_give_or_drop_item_with_dice(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) && !lua_isnumber(L, 1))
-		{
-			sys_err("QUEST Make item call error : wrong argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		DWORD dwVnum;
-
-		if (lua_isnumber(L, 1))
-		{
-			dwVnum = (int)lua_tonumber(L, 1);
-		}
-		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), dwVnum))
-		{
-			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
-			lua_pushnumber(L, 0);
-
-			return 1;
-		}
-
-		int icount = 1;
-		if (lua_isnumber(L, 2) && lua_tonumber(L, 2) > 0)
-		{
-			icount = (int)rint(lua_tonumber(L, 2));
-			if (icount <= 0)
-			{
-				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
-				lua_pushnumber(L, 0);
-				return 1;
-			}
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPITEM item = ITEM_MANAGER::instance().CreateItem(dwVnum, icount);
-		if (ch->GetParty())
-		{
-			FPartyDropDiceRoll f(item, ch);
-			f.Process(NULL);
-			f.GetItemOwner()->AutoGiveItem(item);
-		}
-		else
-			ch->AutoGiveItem(item);
-
-		sys_log(0, "QUEST [REWARD] item %s to %s", lua_tostring(L, 1), ch->GetName());
-
-		LogManager::instance().QuestRewardLog(CQuestManager::instance().GetCurrentPC()->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
-
-		lua_pushnumber(L, (item) ? item->GetID() : 0);
-		return 1;
-	}
-#endif
-
-	int pc_give_or_drop_item_and_select(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isstring(L, 1) && !lua_isnumber(L, 1))
-		{
-			sys_err("QUEST Make item call error : wrong argument");
-			return 0;
-		}
-
-		DWORD dwVnum;
-
-		if (lua_isnumber(L, 1)) // 번호인경우 번호로 준다.
-		{
-			dwVnum = (int)lua_tonumber(L, 1);
-		}
-		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), dwVnum))
-		{
-			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
-			return 0;
-		}
-
-		int icount = 1;
-		if (lua_isnumber(L, 2) && lua_tonumber(L, 2) > 0)
-		{
-			icount = (int)rint(lua_tonumber(L, 2));
-			if (icount <= 0)
-			{
-				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
-				return 0;
-			}
-		}
-
-		sys_log(0, "QUEST [REWARD] item %s to %s", lua_tostring(L, 1), ch->GetName());
-
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
-
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		LPITEM item = ch->AutoGiveItem(dwVnum, icount, -1, true, true);
-#else
-		LPITEM item = ch->AutoGiveItem(dwVnum, icount);
-#endif
-
-		if (NULL != item)
-			CQuestManager::Instance().SetCurrentItem(item);
-
-		if (dwVnum >= 80003 && dwVnum <= 80007)
-		{
-			LogManager::instance().GoldBarLog(ch->GetPlayerID(), item->GetID(), QUEST, "quest: give_item2");
-		}
-
-		return 0;
-	}
-
-	int pc_get_current_map_index(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetMapIndex());
-		return 1;
-	}
-
-	int pc_get_x(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetX() / 100);
-		return 1;
-	}
-
-	int pc_get_y(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetY() / 100);
-		return 1;
-	}
-
-	int pc_get_local_x(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
-
-		if (pMap)
-			lua_pushnumber(L, (ch->GetX() - pMap->m_setting.iBaseX) / 100);
-		else
-			lua_pushnumber(L, ch->GetX() / 100);
-
-		return 1;
-	}
-
-	int pc_get_local_y(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
-
-		if (pMap)
-			lua_pushnumber(L, (ch->GetY() - pMap->m_setting.iBaseY) / 100);
-		else
-			lua_pushnumber(L, ch->GetY() / 100);
-
-		return 1;
-	}
-
-	int pc_count_item(lua_State* L)
-	{
-		if (lua_isnumber(L, -1))
-			lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->CountSpecifyItem((DWORD)lua_tonumber(L, -1)));
-		else if (lua_isstring(L, -1))
-		{
-			DWORD item_vnum;
-
-			if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), item_vnum))
-			{
-				sys_err("QUEST count_item call error : wrong item name : %s", lua_tostring(L, 1));
-				lua_pushnumber(L, 0);
-			}
-			else
-			{
-				lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->CountSpecifyItem(item_vnum));
-			}
-		}
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int pc_remove_item(lua_State* L)
-	{
-		if (lua_gettop(L) == 1)
-		{
-			DWORD item_vnum;
-
-			if (lua_isnumber(L, 1))
-			{
-				item_vnum = (DWORD)lua_tonumber(L, 1);
-			}
-			else if (lua_isstring(L, 1))
-			{
-				if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), item_vnum))
-				{
-					sys_err("QUEST remove_item call error : wrong item name : %s", lua_tostring(L, 1));
-					return 0;
-				}
-			}
-			else
-			{
-				sys_err("QUEST remove_item wrong argument");
-				return 0;
-			}
-
-			sys_log(0, "QUEST remove a item vnum %d of %s[%d]", item_vnum, CQuestManager::instance().GetCurrentCharacterPtr()->GetName(), CQuestManager::instance().GetCurrentCharacterPtr()->GetPlayerID());
-			CQuestManager::instance().GetCurrentCharacterPtr()->RemoveSpecifyItem(item_vnum);
-		}
-		else if (lua_gettop(L) == 2)
-		{
-			DWORD item_vnum;
-
-			if (lua_isnumber(L, 1))
-			{
-				item_vnum = (DWORD)lua_tonumber(L, 1);
-			}
-			else if (lua_isstring(L, 1))
-			{
-				if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), item_vnum))
-				{
-					sys_err("QUEST remove_item call error : wrong item name : %s", lua_tostring(L, 1));
-					return 0;
-				}
-			}
-			else
-			{
-				sys_err("QUEST remove_item wrong argument");
-				return 0;
-			}
-
-			DWORD item_count = (DWORD)lua_tonumber(L, 2);
-			sys_log(0, "QUEST remove items(vnum %d) count %d of %s[%d]",
-				item_vnum,
-				item_count,
-				CQuestManager::instance().GetCurrentCharacterPtr()->GetName(),
-				CQuestManager::instance().GetCurrentCharacterPtr()->GetPlayerID());
-
-			CQuestManager::instance().GetCurrentCharacterPtr()->RemoveSpecifyItem(item_vnum, item_count);
-		}
-		return 0;
-	}
-
-	int pc_get_leadership(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetLeadershipSkillLevel());
-		return 1;
-	}
-
-	int pc_reset_point(lua_State* L)
-	{
-		CQuestManager::instance().GetCurrentCharacterPtr()->ResetPoint(CQuestManager::instance().GetCurrentCharacterPtr()->GetLevel());
-		return 0;
-	}
-
-	int pc_get_playtime(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetRealPoint(POINT_PLAYTIME));
-		return 1;
-	}
-
-	int pc_get_vid(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetVID());
-		return 1;
-	}
-	int pc_get_name(lua_State* L)
-	{
-		lua_pushstring(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetName());
-		return 1;
-	}
-
-	int pc_get_next_exp(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetNextExp());
-		return 1;
-	}
-
-	int pc_get_exp(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetExp());
-		return 1;
-	}
-
-	int pc_get_race(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetRaceNum());
-		return 1;
-	}
-
-	int pc_change_sex(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->ChangeSex());
-		return 1;
-	}
-
-	int pc_get_job(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetJob());
-		return 1;
-	}
-
-	int pc_get_max_sp(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetMaxSP());
-		return 1;
-	}
-
-	int pc_get_sp(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetSP());
-		return 1;
-	}
-
-	int pc_change_sp(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("invalid argument");
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		long val = (long)lua_tonumber(L, 1);
-
-		if (val == 0)
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (val > 0) // 증가시키는 것이므로 무조건 성공 리턴
-			ch->PointChange(POINT_SP, val);
-		else if (val < 0)
-		{
-			if (ch->GetSP() < -val)
-			{
-				lua_pushboolean(L, 0);
-				return 1;
-			}
-
-			ch->PointChange(POINT_SP, val);
-		}
-
-		lua_pushboolean(L, 1);
-		return 1;
-	}
-
-	int pc_get_max_hp(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetMaxHP());
-		return 1;
-	}
-
-	int pc_get_hp(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetHP());
-		return 1;
-	}
-
-	int pc_get_level(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetLevel());
-		return 1;
-	}
-
-	int pc_set_level(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("invalid argument");
-			return 0;
-		}
-		else
-		{
-			int newLevel = lua_tonumber(L, 1);
-			LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-			sys_log(0, "QUEST [LEVEL] %s jumpint to level %d", ch->GetName(), (int)rint(lua_tonumber(L, 1)));
-
-			PC* pPC = CQuestManager::instance().GetCurrentPC();
-			LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), newLevel, 0);
-
-			// 포인트 : 스킬, 서브스킬, 스탯
-			ch->PointChange(POINT_SKILL, newLevel - ch->GetLevel());
-			ch->PointChange(POINT_SUB_SKILL, newLevel < 10 ? 0 : newLevel - MAX(ch->GetLevel(), 9));
-			ch->PointChange(POINT_STAT, ((MINMAX(1, newLevel, gPlayerMaxLevel) - ch->GetLevel()) * 3) + ch->GetPoint(POINT_LEVEL_STEP));
-			//레벨
-			ch->PointChange(POINT_LEVEL, newLevel - ch->GetLevel(), false, true);
-			//HP, SP
-			ch->SetRandomHP((newLevel - 1) * number(JobInitialPoints[ch->GetJob()].hp_per_lv_begin, JobInitialPoints[ch->GetJob()].hp_per_lv_end));
-			ch->SetRandomSP((newLevel - 1) * number(JobInitialPoints[ch->GetJob()].sp_per_lv_begin, JobInitialPoints[ch->GetJob()].sp_per_lv_end));
-
-			// 회복
-			ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
-			ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
-
-			ch->ComputePoints();
-			ch->PointsPacket();
-			ch->SkillLevelPacket();
-
-			return 0;
-		}
-	}
-
-	int pc_get_weapon(lua_State* L)
-	{
-		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(WEAR_WEAPON);
-
-		if (!item)
-			lua_pushnumber(L, 0);
-		else
-			lua_pushnumber(L, item->GetVnum());
-
-		return 1;
-	}
-
-	int pc_get_armor(lua_State* L)
-	{
-		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(WEAR_BODY);
-
-		if (!item)
-			lua_pushnumber(L, 0);
-		else
-			lua_pushnumber(L, item->GetVnum());
-
-		return 1;
-	}
-
-	int pc_get_wear(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("QUEST wrong set flag");
-			return 0;
-		}
-
-		BYTE bCell = (BYTE)lua_tonumber(L, 1);
-
-		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(bCell);
-
-		if (!item)
-			lua_pushnil(L);
-		else
-			lua_pushnumber(L, item->GetVnum());
-
-		return 1;
-	}
-
-	int pc_get_money(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetGold());
-		return 1;
-	}
-
-#if defined(__CHEQUE_SYSTEM__)
-	int pc_get_cheque(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetCheque());
-		return 1;
-	}
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	int pc_get_gem(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetGem());
-		return 1;
-	}
-#endif
-
-	// 20050725.myevan.은둔의 망토 사용중 혼석 수련시 선악치가 두배 소모되는 버그가 발생해
-	// 실제 선악치를 이용해 계산을 하게 한다.
-	int pc_get_real_alignment(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetRealAlignment() / 10);
-		return 1;
-	}
-
-	int pc_get_alignment(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetAlignment() / 10);
-		return 1;
-	}
-
-	int pc_change_alignment(lua_State* L)
-	{
-		int alignment = (int)(lua_tonumber(L, 1) * 10);
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		ch->UpdateAlignment(alignment);
-		return 0;
-	}
-
-	int pc_change_money(lua_State* L)
-	{
-		int gold = (int)lua_tonumber(L, -1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (gold + ch->GetGold() < 0)
-			sys_err("QUEST wrong ChangeGold %d (now %d)", gold, ch->GetGold());
-		else
-		{
-			DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), gold);
-			ch->PointChange(POINT_GOLD, gold, true);
-		}
-
-		return 0;
-	}
-
-#if defined(__CHEQUE_SYSTEM__)
-	int pc_change_cheque(lua_State* L)
-	{
-		int cheque = (int)lua_tonumber(L, -1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (cheque + ch->GetCheque() < 0)
-			sys_err("QUEST wrong ChangeCheque %d (now %d)", cheque, ch->GetCheque());
-		else
-		{
-			DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), cheque);
-			ch->PointChange(POINT_CHEQUE, cheque, true);
-		}
-
-		return 0;
-	}
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	int pc_change_gem(lua_State* L)
-	{
-		int gem = (int)lua_tonumber(L, -1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (gem + ch->GetGem() < 0)
-			sys_err("QUEST wrong ChangeGem %d (now %d)", gem, ch->GetGem());
-		else
-		{
-			DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), gem);
-			ch->PointChange(POINT_GEM, gem, true);
-		}
-
-		return 0;
-	}
-#endif
-
-	int pc_set_another_quest_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3))
-		{
-			sys_err("QUEST wrong set flag");
-			return 0;
-		}
-		else
-		{
-			const char* sz = lua_tostring(L, 1);
-			const char* sz2 = lua_tostring(L, 2);
-			CQuestManager& q = CQuestManager::Instance();
-			PC* pPC = q.GetCurrentPC();
-			pPC->SetFlag(string(sz) + "." + sz2, int(rint(lua_tonumber(L, 3))));
-			return 0;
-		}
-	}
-
-	int pc_get_another_quest_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isstring(L, 2))
-		{
-			sys_err("QUEST wrong get flag");
-			return 0;
-		}
-		else
-		{
-			const char* sz = lua_tostring(L, 1);
-			const char* sz2 = lua_tostring(L, 2);
-			CQuestManager& q = CQuestManager::Instance();
-			PC* pPC = q.GetCurrentPC();
-			if (!pPC)
-			{
-				return 0;
-			}
-			lua_pushnumber(L, pPC->GetFlag(string(sz) + "." + sz2));
-			return 1;
-		}
-	}
-
-	int pc_get_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, -1))
-		{
-			sys_err("QUEST wrong get flag");
-			return 0;
-		}
-		else
-		{
-			const char* sz = lua_tostring(L, -1);
-			CQuestManager& q = CQuestManager::Instance();
-			PC* pPC = q.GetCurrentPC();
-			lua_pushnumber(L, pPC->GetFlag(sz));
-			return 1;
-		}
-	}
-
-	int pc_get_quest_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, -1))
-		{
-			sys_err("QUEST wrong get flag");
-			return 0;
-		}
-		else
-		{
-			const char* sz = lua_tostring(L, -1);
-			CQuestManager& q = CQuestManager::Instance();
-			PC* pPC = q.GetCurrentPC();
-			lua_pushnumber(L, pPC->GetFlag(pPC->GetCurrentQuestName() + "." + sz));
-			if (test_server)
-				sys_log(0, "GetQF ( %s . %s )", pPC->GetCurrentQuestName().c_str(), sz);
-		}
-		return 1;
-	}
-
-	int pc_set_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-		{
-			sys_err("QUEST wrong set flag");
-		}
-		else
-		{
-			const char* sz = lua_tostring(L, 1);
-			CQuestManager& q = CQuestManager::Instance();
-			PC* pPC = q.GetCurrentPC();
-			pPC->SetFlag(sz, int(rint(lua_tonumber(L, 2))));
-		}
-		return 0;
-	}
-
-	int pc_set_quest_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-		{
-			sys_err("QUEST wrong set flag");
-		}
-		else
-		{
-			const char* sz = lua_tostring(L, 1);
-			CQuestManager& q = CQuestManager::Instance();
-			PC* pPC = q.GetCurrentPC();
-			pPC->SetFlag(pPC->GetCurrentQuestName() + "." + sz, int(rint(lua_tonumber(L, 2))));
-		}
-		return 0;
-	}
-
-	int pc_del_quest_flag(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			sys_err("argument error");
-			return 0;
-		}
-
-		const char* sz = lua_tostring(L, 1);
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-		pPC->DeleteFlag(pPC->GetCurrentQuestName() + "." + sz);
-		return 0;
-	}
-
-	int pc_give_exp2(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-		if (!lua_isnumber(L, 1))
-			return 0;
-
-		sys_log(0, "QUEST [REWARD] %s give exp2 %d", ch->GetName(), (int)rint(lua_tonumber(L, 1)));
-
-		DWORD exp = (DWORD)rint(lua_tonumber(L, 1));
-
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
-		ch->PointChange(POINT_EXP, exp);
-		return 0;
-	}
-
-	int pc_give_exp(lua_State* L)
-	{
-		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
-			return 0;
-
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-
-		sys_log(0, "QUEST [REWARD] %s give exp %s %d", ch->GetName(), lua_tostring(L, 1), (int)rint(lua_tonumber(L, 2)));
-
-		DWORD exp = (DWORD)rint(lua_tonumber(L, 2));
-
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
-
-		pPC->GiveExp(lua_tostring(L, 1), exp);
-		return 0;
-	}
-
-	int pc_give_exp_perc(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-
-		if (!ch || !lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
-			return 0;
-
-		int lev = (int)rint(lua_tonumber(L, 2));
-		double proc = (lua_tonumber(L, 3));
-
-		sys_log(0, "QUEST [REWARD] %s give exp %s lev %d percent %g%%", ch->GetName(), lua_tostring(L, 1), lev, proc);
-
-		DWORD exp = (DWORD)((exp_table[MINMAX(0, lev, PLAYER_EXP_TABLE_MAX)] * proc) / 100);
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
-
-		pPC->GiveExp(lua_tostring(L, 1), exp);
-		return 0;
-	}
-
-	int pc_get_empire(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetEmpire());
-		return 1;
-	}
-
-	int pc_get_part(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-		if (!lua_isnumber(L, 1))
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-		int part_idx = (int)lua_tonumber(L, 1);
-		lua_pushnumber(L, ch->GetPart(part_idx));
-		return 1;
-	}
-
-	int pc_set_part(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			return 0;
-		}
-		int part_idx = (int)lua_tonumber(L, 1);
-		int part_value = (int)lua_tonumber(L, 2);
-		ch->SetPart(part_idx, part_value);
-		ch->UpdatePacket();
-		return 0;
-	}
-
-	int pc_get_skillgroup(lua_State* L)
-	{
-		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetSkillGroup());
-		return 1;
-	}
-
-	int pc_set_skillgroup(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-			sys_err("QUEST wrong skillgroup number");
-		else
-		{
-			CQuestManager& q = CQuestManager::Instance();
-			LPCHARACTER ch = q.GetCurrentCharacterPtr();
-
-			ch->SetSkillGroup((BYTE)rint(lua_tonumber(L, 1)));
-		}
-		return 0;
-	}
-
-	int pc_is_polymorphed(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->IsPolymorphed());
-		return 1;
-	}
-
-	int pc_remove_polymorph(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->RemoveAffect(AFFECT_POLYMORPH);
-		ch->SetPolymorph(0);
-		return 0;
-	}
-
-	int pc_polymorph(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
-		int iDuration = (int)lua_tonumber(L, 2);
-		ch->AddAffect(AFFECT_POLYMORPH, POINT_POLYMORPH, dwVnum, AFF_POLYMORPH, iDuration, 0, true);
-		return 0;
-	}
-
-	int pc_is_mount(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->GetMountVnum());
-		return 1;
-	}
-
-	int pc_mount(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-			return 0;
-
-		int length = 60;
-
-		if (lua_isnumber(L, 2))
-			length = (int)lua_tonumber(L, 2);
-
-		DWORD mount_vnum = (DWORD)lua_tonumber(L, 1);
-
-		if (length < 0)
-			length = 60;
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-		if (SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, ch->GetMapIndex()))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
-			return 0;
-		}
-#endif
-
-		if (ch->IsFishing())
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
-			return 0;
-		}
-
-		ch->RemoveAffect(AFFECT_MOUNT);
-		ch->RemoveAffect(AFFECT_MOUNT_BONUS);
-
-		// 말이 소환되어 따라다니는 상태라면 말부터 없앰
-		if (ch->GetHorse())
-			ch->HorseSummon(false);
-
-		if (mount_vnum)
-		{
-			ch->AddAffect(AFFECT_MOUNT, POINT_MOUNT, mount_vnum, AFF_NONE, length, 0, true);
-			switch (mount_vnum)
-			{
-				case 20201:
-				case 20202:
-				case 20203:
-				case 20204:
-				case 20213:
-				case 20216:
-					ch->AddAffect(AFFECT_MOUNT, POINT_MOV_SPEED, 30, AFF_NONE, length, 0, true, true);
-					break;
-
-				case 20205:
-				case 20206:
-				case 20207:
-				case 20208:
-				case 20214:
-				case 20217:
-					ch->AddAffect(AFFECT_MOUNT, POINT_MOV_SPEED, 40, AFF_NONE, length, 0, true, true);
-					break;
-
-				case 20209:
-				case 20210:
-				case 20211:
-				case 20212:
-				case 20215:
-				case 20218:
-					ch->AddAffect(AFFECT_MOUNT, POINT_MOV_SPEED, 50, AFF_NONE, length, 0, true, true);
-					break;
-			}
-		}
-
-		return 0;
-	}
-
-	int pc_mount_bonus(lua_State* L)
-	{
-		POINT_TYPE applyOn = static_cast<POINT_TYPE>(lua_tonumber(L, 1));
-		long value = static_cast<long>(lua_tonumber(L, 2));
-		long duration = static_cast<long>(lua_tonumber(L, 3));
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != ch)
-		{
-			if (!ch->GetMountVnum())
-				return 0;
-
-			ch->RemoveAffect(AFFECT_MOUNT_BONUS);
-			ch->AddAffect(AFFECT_MOUNT_BONUS, aApplyInfo[applyOn].wPointType, value, AFF_NONE, duration, 0, false);
-		}
-
-		return 0;
-	}
-
-	int pc_unmount(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->RemoveAffect(AFFECT_MOUNT);
-		ch->RemoveAffect(AFFECT_MOUNT_BONUS);
-		ch->PointsPacket();
-		if (ch->IsHorseRiding())
-			ch->StopRiding();
-		return 0;
-	}
-
-	int pc_get_horse(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->GetHorse() ? true : false);
-		return 1;
-	}
-
-	int pc_get_horse_level(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetHorseLevel());
-		return 1;
-	}
-
-	int pc_get_horse_hp(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch->GetHorseLevel())
-			lua_pushnumber(L, ch->GetHorseHealth());
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int pc_get_horse_stamina(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch->GetHorseLevel())
-			lua_pushnumber(L, ch->GetHorseStamina());
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int pc_is_horse_alive(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->GetHorseLevel() > 0 && ch->GetHorseHealth() > 0);
-		return 1;
-	}
-
-	int pc_revive_horse(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->ReviveHorse();
-		return 0;
-	}
-
-	int pc_have_map_scroll(lua_State* L)
-	{
-		if (!lua_isstring(L, 1))
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		const char* szMapName = lua_tostring(L, 1);
-		const TMapRegion* region = SECTREE_MANAGER::instance().FindRegionByPartialName(szMapName);
-
-		if (!region)
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		bool bFind = false;
-		for (int iCell = 0; iCell < INVENTORY_MAX_NUM; iCell++)
-		{
-			LPITEM item = ch->GetInventoryItem(iCell);
-			if (!item)
-				continue;
-
-			if (item->GetType() == ITEM_USE &&
-				item->GetSubType() == USE_TALISMAN &&
-				(item->GetValue(0) == 1 || item->GetValue(0) == 2))
-			{
-				int x = item->GetSocket(0);
-				int y = item->GetSocket(1);
-				//if ((x-item_x)*(x-item_x)+(y-item_y)*(y-item_y)<r*r)
-				if (region->sx <= x && region->sy <= y && x <= region->ex && y <= region->ey)
-				{
-					bFind = true;
-					break;
-				}
-			}
-		}
-
-		lua_pushboolean(L, bFind);
-		return 1;
-	}
-
-	int pc_get_war_map(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetWarMap() ? ch->GetWarMap()->GetMapIndex() : 0);
-		return 1;
-	}
-
-	int pc_have_pos_scroll(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			sys_err("invalid x y position");
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		if (!lua_isnumber(L, 2))
-		{
-			sys_err("invalid radius");
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		int x = (int)lua_tonumber(L, 1);
-		int y = (int)lua_tonumber(L, 2);
-		float r = (float)lua_tonumber(L, 3);
-
-		bool bFind = false;
-		for (int iCell = 0; iCell < INVENTORY_MAX_NUM; iCell++)
-		{
-			LPITEM item = ch->GetInventoryItem(iCell);
-			if (!item)
-				continue;
-
-			if (item->GetType() == ITEM_USE &&
-				item->GetSubType() == USE_TALISMAN &&
-				(item->GetValue(0) == 1 || item->GetValue(0) == 2))
-			{
-				int item_x = item->GetSocket(0);
-				int item_y = item->GetSocket(1);
-				if ((x - item_x) * (x - item_x) + (y - item_y) * (y - item_y) < r * r)
-				{
-					bFind = true;
-					break;
-				}
-			}
-		}
-
-		lua_pushboolean(L, bFind);
-		return 1;
-	}
-
-	int pc_get_equip_refine_level(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int cell = (int)lua_tonumber(L, 1);
-		if (cell < 0 || cell >= WEAR_MAX_NUM)
-		{
-			sys_err("invalid wear position %d", cell);
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		LPITEM item = ch->GetWear(cell);
-		if (!item)
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		lua_pushnumber(L, item->GetRefineLevel());
-		return 1;
-	}
-
-	int pc_refine_equip(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			sys_err("invalid argument");
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		int cell = (int)lua_tonumber(L, 1);
-		int level_limit = (int)lua_tonumber(L, 2);
-		int pct = lua_isnumber(L, 3) ? (int)lua_tonumber(L, 3) : 100;
-
-		LPITEM item = ch->GetWear(cell);
-		if (!item)
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		if (item->GetRefinedVnum() == 0)
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		if (item->GetRefineLevel() > level_limit)
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		if (pct == 100 || number(1, 100) <= pct)
-		{
-			// 개량 성공
-			lua_pushboolean(L, 1);
-
-			LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(item->GetRefinedVnum(), 1, 0, false);
-
-			if (pkNewItem)
-			{
-				for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-					if (!item->GetSocket(i))
-						break;
-					else
-						pkNewItem->SetSocket(i, 1);
-
-				int set = 0;
-				for (int i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
-				{
-					long socket = item->GetSocket(i);
-					if (socket > 2 && socket != 28960)
-					{
-						pkNewItem->SetSocket(set++, socket);
-					}
-				}
-
-				item->CopyAttributeTo(pkNewItem);
-
-				if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-					item->SetCount(item->GetCount() - 1);
-				else
-					ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-
-				// some tuits need here -_- pkNewItem->AddToCharacter(this, bCell);
-				pkNewItem->EquipTo(ch, cell);
-
-				ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
-
-				LogManager::instance().ItemLog(ch, pkNewItem, "REFINE SUCCESS (QUEST)", pkNewItem->GetName());
-			}
-		}
-		else
-		{
-			// 개량 실패
-			lua_pushboolean(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_get_skill_level(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("invalid argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
-		lua_pushnumber(L, ch->GetSkillLevel(dwVnum));
-
-		return 1;
-	}
-
-	int pc_give_lotto(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-
-		sys_log(0, "TRY GIVE LOTTO TO pid %u", ch->GetPlayerID());
-
-		DWORD* pdw = M2_NEW DWORD[3];
-
-		pdw[0] = 50001;
-		pdw[1] = 1;
-		pdw[2] = q.GetEventFlag("lotto_round");
-
-		// 추첨서는 소켓을 설정한다
-		DBManager::instance().ReturnQuery(QID_LOTTO, ch->GetPlayerID(), pdw,
-			"INSERT INTO lotto_list VALUES(0, 'server%s', %u, NOW())",
-			get_table_postfix(), ch->GetPlayerID());
-
-		return 0;
-	}
-
-	int pc_aggregate_monster(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->AggregateMonster();
-		return 0;
-	}
-
-	int pc_forget_my_attacker(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->ForgetMyAttacker();
-		return 0;
-	}
-
-	int pc_attract_ranger(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->AttractRanger();
-		return 0;
-	}
-
-	int pc_select_pid(lua_State* L)
-	{
-		DWORD pid = (DWORD)lua_tonumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPCHARACTER new_ch = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-		if (new_ch)
-		{
-			CQuestManager::instance().GetPC(new_ch->GetPlayerID());
-
-			lua_pushnumber(L, ch->GetPlayerID());
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_select_vid(lua_State* L)
-	{
-		DWORD vid = (DWORD)lua_tonumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPCHARACTER new_ch = CHARACTER_MANAGER::instance().Find(vid);
-
-		if (new_ch)
-		{
-			CQuestManager::instance().GetPC(new_ch->GetPlayerID());
-
-			lua_pushnumber(L, (DWORD)ch->GetVID());
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_get_sex(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, GET_SEX(ch)); /* 0 == MALE, 1 == FEMALE */
-		return 1;
-	}
-
-	int pc_is_engaged(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, marriage::CManager::instance().IsEngaged(ch->GetPlayerID()));
-		return 1;
-	}
-
-	int pc_is_married(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, marriage::CManager::instance().IsMarried(ch->GetPlayerID()));
-		return 1;
-	}
-
-	int pc_is_engaged_or_married(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, marriage::CManager::instance().IsEngagedOrMarried(ch->GetPlayerID()));
-		return 1;
-	}
-
-	int pc_is_gm(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushboolean(L, ch->GetGMLevel() >= GM_HIGH_WIZARD);
-		return 1;
-	}
-
-	int pc_get_gm_level(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetGMLevel());
-		return 1;
-	}
-
-	int pc_mining(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPCHARACTER npc = CQuestManager::instance().GetCurrentNPCCharacterPtr();
-		ch->mining(npc);
-		return 0;
-	}
-
-	int pc_diamond_refine(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		int cost = (int)lua_tonumber(L, 1);
-		int pct = (int)lua_tonumber(L, 2);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPCHARACTER npc = CQuestManager::instance().GetCurrentNPCCharacterPtr();
-		LPITEM item = CQuestManager::instance().GetCurrentItem();
-
-		if (item)
-			lua_pushboolean(L, mining::OreRefine(ch, npc, item, cost, pct, NULL));
-		else
-			lua_pushboolean(L, 0);
-
-		return 1;
-	}
-
-	int pc_ore_refine(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		int cost = (int)lua_tonumber(L, 1);
-		int pct = (int)lua_tonumber(L, 2);
-		int metinstone_cell = (int)lua_tonumber(L, 3);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPCHARACTER npc = CQuestManager::instance().GetCurrentNPCCharacterPtr();
-		LPITEM item = CQuestManager::instance().GetCurrentItem();
-
-		LPITEM metinstone_item = ch->GetInventoryItem(metinstone_cell);
-
-		if (item && metinstone_item)
-			lua_pushboolean(L, mining::OreRefine(ch, npc, item, cost, pct, metinstone_item));
-		else
-			lua_pushboolean(L, 0);
-
-		return 1;
-	}
-
-	int pc_clear_skill(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch == NULL) return 0;
-
-		ch->ClearSkill();
-
-		return 0;
-	}
-
-	int pc_clear_sub_skill(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch == NULL) return 0;
-
-		ch->ClearSubSkill();
-
-		return 0;
-	}
-
-	int pc_set_skill_point(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			return 0;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int newPoint = (int)lua_tonumber(L, 1);
-
-		ch->SetRealPoint(POINT_SKILL, newPoint);
-		ch->SetPoint(POINT_SKILL, ch->GetRealPoint(POINT_SKILL));
-		ch->PointChange(POINT_SKILL, 0);
-		ch->ComputePoints();
-		ch->PointsPacket();
-
-		return 0;
-	}
-
-	// RESET_ONE_SKILL
-	int pc_clear_one_skill(lua_State* L)
-	{
-		int vnum = (int)lua_tonumber(L, 1);
-		sys_log(0, "%d skill clear", vnum);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch == NULL)
-		{
-			sys_log(0, "skill clear fail");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		sys_log(0, "%d skill clear", vnum);
-
-		ch->ResetOneSkill(vnum);
-
-		return 0;
-	}
-	// END_RESET_ONE_SKILL
-
-	int pc_is_clear_skill_group(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		lua_pushboolean(L, ch->GetQuestFlag("skill_group_clear.clear") == 1);
-
-		return 1;
-	}
-
-	int pc_save_exit_location(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		ch->SaveExitLocation();
-
-		return 0;
-	}
-
-	//텔레포트
-	int pc_teleport(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int x = 0, y = 0;
-		if (lua_isnumber(L, 1))
-		{
-			// 지역명 워프
-			const int TOWN_NUM = 10;
-			struct warp_by_town_name
-			{
-				const char* name;
-				DWORD x;
-				DWORD y;
-			} ws[TOWN_NUM] =
-			{
-				{ "영안읍성", 4743, 9548 },
-				{ "임지곡", 3235, 9086 },
-				{ "자양현", 3531, 8829 },
-				{ "조안읍성", 638, 1664 },
-				{ "승룡곡", 1745, 1909 },
-				{ "복정현", 1455, 2400 },
-				{ "평무읍성", 9599, 2692 },
-				{ "방산곡", 8036, 2984 },
-				{ "박라현", 8639, 2460 },
-				{ "서한산", 4350, 2143 },
-			};
-			int idx = (int)lua_tonumber(L, 1);
-
-			x = ws[idx].x;
-			y = ws[idx].y;
-			goto teleport_area;
-		}
-		else
-		{
-			const char* arg1 = lua_tostring(L, 1);
-
-			LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-			if (!tch)
-			{
-				const CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
-
-				if (pkCCI)
-				{
-					if (pkCCI->bChannel != g_bChannel)
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
-					}
-					else
-					{
-
-						PIXEL_POSITION pos;
-
-						if (!SECTREE_MANAGER::instance().GetCenterPositionOfMap(pkCCI->lMapIndex, pos))
-						{
-							ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find map (index %d)", pkCCI->lMapIndex);
-						}
-						else
-						{
-							ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", pos.x, pos.y);
-							ch->WarpSet(pos.x, pos.y);
-							lua_pushnumber(L, 1);
-						}
-					}
-				}
-				else if (NULL == CHARACTER_MANAGER::instance().FindPC(arg1))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "There is no one by that name");
-				}
-
-				lua_pushnumber(L, 0);
-
-				return 1;
-			}
-			else
-			{
-				x = tch->GetX() / 100;
-				y = tch->GetY() / 100;
-			}
-		}
-
-	teleport_area:
-
-		x *= 100;
-		y *= 100;
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
-		ch->WarpSet(x, y);
-		ch->Stop();
-		lua_pushnumber(L, 1);
-		return 1;
-	}
-
-	int pc_set_skill_level(lua_State* L)
-	{
-		DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
-		BYTE byLev = (BYTE)lua_tonumber(L, 2);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		ch->SetSkillLevel(dwVnum, byLev);
-
-		ch->SkillLevelPacket();
-
-		return 0;
-	}
-
-	int pc_give_polymorph_book(lua_State* L)
-	{
-		if (lua_isnumber(L, 1) != 1 && lua_isnumber(L, 2) != 1 && lua_isnumber(L, 3) != 1 && lua_isnumber(L, 4) != 1)
-		{
-			sys_err("Wrong Quest Function Arguments: pc_give_polymorph_book");
-			return 0;
-		}
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		CPolymorphUtils::instance().GiveBook(ch, (DWORD)lua_tonumber(L, 1), (DWORD)lua_tonumber(L, 2), (BYTE)lua_tonumber(L, 3), (BYTE)lua_tonumber(L, 4));
-
-		return 0;
-	}
-
-	int pc_upgrade_polymorph_book(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPITEM pItem = CQuestManager::instance().GetCurrentItem();
-
-		bool ret = CPolymorphUtils::instance().BookUpgrade(ch, pItem);
-
-		lua_pushboolean(L, ret);
-
-		return 1;
-	}
-
-	int pc_get_premium_remain_sec(lua_State* L)
-	{
-		int remain_seconds = 0;
-		int premium_type = 0;
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong premium index (is not number)");
-			return 0;
-		}
-
-		premium_type = (int)lua_tonumber(L, 1);
-		switch (premium_type)
-		{
-			case PREMIUM_EXP:
-			case PREMIUM_ITEM:
-			case PREMIUM_SAFEBOX:
-			case PREMIUM_AUTOLOOT:
-			case PREMIUM_FISH_MIND:
-			case PREMIUM_MARRIAGE_FAST:
-			case PREMIUM_GOLD:
-#if defined(__CONQUEROR_LEVEL__)
-			case PREMIUM_SUNGMA:
-#endif
-				break;
-
-			default:
-				sys_err("wrong premium index %d", premium_type);
-				return 0;
-		}
-
-		remain_seconds = ch->GetPremiumRemainSeconds(premium_type);
-
-		lua_pushnumber(L, remain_seconds);
-		return 1;
-	}
-
-	int pc_send_block_mode(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		ch->SetBlockModeForce((BYTE)lua_tonumber(L, 1));
-
-		return 0;
-	}
-
-	int pc_change_empire(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->ChangeEmpire((unsigned char)lua_tonumber(L, 1)));
-		return 1;
-	}
-
-	int pc_get_change_empire_count(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		lua_pushnumber(L, ch->GetChangeEmpireCount());
-
-		return 1;
-	}
-
-	int pc_set_change_empire_count(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		ch->SetChangeEmpireCount();
-
-		return 0;
-	}
-
-	int pc_change_name(lua_State* L)
-	{
-		// 리턴값
-		// 0 : 새이름을 설정한 뒤 로그아웃을 안했음
-		// 1 : 스크립트에서 문자열이 넘어오지 않았음
-		// 2 : check_name 을 통과하지 못했음
-		// 3 : 이미 같은 이름이 사용중
-		// 4 : 성공
-		// 5 : 해당 기능 지원하지 않음
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch->GetNewName().size() != 0)
-		{
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		if (lua_isstring(L, 1) != 1)
-		{
-			lua_pushnumber(L, 1);
-			return 1;
-		}
-
-		const char* szName = lua_tostring(L, 1);
-
-		if (check_name(szName) == false)
-		{
-			lua_pushnumber(L, 2);
-			return 1;
-		}
-
-		char szQuery[1024];
-		snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM player%s WHERE name='%s'", get_table_postfix(), szName);
-		std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery(szQuery));
-
-		if (pmsg->Get()->uiNumRows > 0)
-		{
-			MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
-
-			int count = 0;
-			str_to_number(count, row[0]);
-
-			// 이미 해당 이름을 가진 캐릭터가 있음
-			if (count != 0)
-			{
-				lua_pushnumber(L, 3);
-				return 1;
-			}
-		}
-
-		ch->Save();
-		ch->SetExchangeTime();
-		//ch->GetDesc()->DelayedDisconnect(1);
-
-		/* delete messenger list */
-		CMessengerManager::instance().RemoveAllList(ch->GetName());
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		CMessengerManager::instance().RemoveAllBlockList(ch->GetName());
-#endif
-
-		DWORD pid = ch->GetPlayerID();
-
-		/* change_name_log */
-		LogManager::instance().ChangeNameLog(pid, ch->GetName(), szName, ch->GetDesc()->GetHostName());
-#ifdef __OFFLINE_SHOP__
-		snprintf(szQuery, sizeof(szQuery), "UPDATE offline_shop%s SET owner_name='%s' WHERE owner_pid=%u", get_table_postfix(), szName, pid);
-		std::unique_ptr<SQLMsg> pmsg3(DBManager::instance().DirectQuery(szQuery));
-
-#endif
-		snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET name='%s' WHERE id=%u", get_table_postfix(), szName, pid);
-		SQLMsg* msg = DBManager::instance().DirectQuery(szQuery);
-		M2_DELETE(msg);
-
-		ch->SetNewName(szName);
-		lua_pushnumber(L, 4);
-		return 1;
-	}
-
-	int pc_is_dead(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (ch != NULL)
-		{
-			lua_pushboolean(L, ch->IsDead());
-			return 1;
-		}
-
-		lua_pushboolean(L, true);
-
-		return 1;
-	}
-
-	int pc_reset_status(lua_State* L)
-	{
-		if (lua_isnumber(L, 1) != 0)
-		{
-			int idx = (int)lua_tonumber(L, 1);
-
-			if (idx >= 0 && idx < 4)
-			{
-				LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-				int point = POINT_NONE;
-				char buf[128];
-
-				switch (idx)
-				{
-					case 0: point = POINT_HT; break;
-					case 1: point = POINT_IQ; break;
-					case 2: point = POINT_ST; break;
-					case 3: point = POINT_DX; break;
-					default: lua_pushboolean(L, false); return 1;
-				}
-
-				int old_val = ch->GetRealPoint(point);
-				int old_stat = ch->GetRealPoint(POINT_STAT);
-
-				ch->SetRealPoint(point, 1);
-				ch->SetPoint(point, ch->GetRealPoint(point));
-
-				ch->PointChange(POINT_STAT, old_val);
-
-				if (point == POINT_HT)
-				{
-					BYTE job = ch->GetJob();
-					ch->SetRandomHP((ch->GetLevel() - 1) * number(JobInitialPoints[job].hp_per_lv_begin, JobInitialPoints[job].hp_per_lv_end));
-				}
-				else if (point == POINT_IQ)
-				{
-					BYTE job = ch->GetJob();
-					ch->SetRandomSP((ch->GetLevel() - 1) * number(JobInitialPoints[job].sp_per_lv_begin, JobInitialPoints[job].sp_per_lv_end));
-				}
-
-				ch->ComputePoints();
-				ch->PointsPacket();
-
-				if (point == POINT_HT)
-				{
-					ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
-				}
-				else if (point == POINT_IQ)
-				{
-					ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
-				}
-
-				switch (idx)
-				{
-					case 0:
-						snprintf(buf, sizeof(buf), "reset ht(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
-						break;
-					case 1:
-						snprintf(buf, sizeof(buf), "reset iq(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
-						break;
-					case 2:
-						snprintf(buf, sizeof(buf), "reset st(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
-						break;
-					case 3:
-						snprintf(buf, sizeof(buf), "reset dx(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
-						break;
-				}
-
-				LogManager::instance().CharLog(ch, 0, "RESET_ONE_STATUS", buf);
-
-				lua_pushboolean(L, true);
-				return 1;
-			}
-		}
-
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-#if defined(__CONQUEROR_LEVEL__)
-	int pc_reset_sungma_status(lua_State* L)
-	{
-		if (lua_isnumber(L, 1) != 0)
-		{
-			int idx = (int)lua_tonumber(L, 1);
-
-			if (idx >= 0 && idx < 4)
-			{
-				LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-				int point = POINT_NONE;
-				char buf[128];
-
-				switch (idx)
-				{
-				case 0: point = POINT_SUNGMA_STR; break;
-				case 1: point = POINT_SUNGMA_HP; break;
-				case 2: point = POINT_SUNGMA_MOVE; break;
-				case 3: point = POINT_SUNGMA_IMMUNE; break;
-				default: lua_pushboolean(L, false); return 1;
-				}
-
-				int old_val = ch->GetRealPoint(point);
-				int old_stat = ch->GetRealPoint(POINT_CONQUEROR_POINT);
-
-				ch->SetRealPoint(point, 0);
-				ch->SetPoint(point, ch->GetRealPoint(point));
-
-				ch->PointChange(POINT_CONQUEROR_POINT, old_val);
-
-				ch->ComputePoints();
-				ch->PointsPacket();
-
-				switch (idx)
-				{
-					case 0:
-						snprintf(buf, sizeof(buf), "reset sstr(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
-						break;
-					case 1:
-						snprintf(buf, sizeof(buf), "reset shp(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
-						break;
-					case 2:
-						snprintf(buf, sizeof(buf), "reset smove(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
-						break;
-					case 3:
-						snprintf(buf, sizeof(buf), "reset simmune(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
-						break;
-				}
-
-				LogManager::instance().CharLog(ch, 0, "RESET_ONE_SUNGMA_STATUS", buf);
-
-				lua_pushboolean(L, true);
-				return 1;
-			}
-		}
-
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	int pc_get_sungma_str(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_STR));
-		return 1;
-	}
-
-	int pc_get_sungma_vit(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_HP));
-		return 1;
-	}
-
-	int pc_get_sungma_res(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_MOVE));
-		return 1;
-	}
-
-	int pc_get_sungma_int(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_IMMUNE));
-		return 1;
-	}
-#endif
-
-	int pc_get_ht(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_HT));
-		return 1;
-	}
-
-	int pc_set_ht(lua_State* L)
-	{
-		if (lua_isnumber(L, 1) == false)
-			return 1;
-
-		int newPoint = (int)lua_tonumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int usedPoint = newPoint - ch->GetRealPoint(POINT_HT);
-		ch->SetRealPoint(POINT_HT, newPoint);
-		ch->PointChange(POINT_HT, 0);
-		ch->PointChange(POINT_STAT, -usedPoint);
-		ch->ComputePoints();
-		ch->PointsPacket();
-		return 1;
-	}
-
-	int pc_get_iq(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_IQ));
-		return 1;
-	}
-
-	int pc_set_iq(lua_State* L)
-	{
-		if (lua_isnumber(L, 1) == false)
-			return 1;
-
-		int newPoint = (int)lua_tonumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int usedPoint = newPoint - ch->GetRealPoint(POINT_IQ);
-		ch->SetRealPoint(POINT_IQ, newPoint);
-		ch->PointChange(POINT_IQ, 0);
-		ch->PointChange(POINT_STAT, -usedPoint);
-		ch->ComputePoints();
-		ch->PointsPacket();
-		return 1;
-	}
-
-	int pc_get_st(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_ST));
-		return 1;
-	}
-
-	int pc_set_st(lua_State* L)
-	{
-		if (lua_isnumber(L, 1) == false)
-			return 1;
-
-		int newPoint = (int)lua_tonumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int usedPoint = newPoint - ch->GetRealPoint(POINT_ST);
-		ch->SetRealPoint(POINT_ST, newPoint);
-		ch->PointChange(POINT_ST, 0);
-		ch->PointChange(POINT_STAT, -usedPoint);
-		ch->ComputePoints();
-		ch->PointsPacket();
-		return 1;
-	}
-
-	int pc_get_dx(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, ch->GetRealPoint(POINT_DX));
-		return 1;
-	}
-
-	int pc_set_dx(lua_State* L)
-	{
-		if (lua_isnumber(L, 1) == false)
-			return 1;
-
-		int newPoint = (int)lua_tonumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int usedPoint = newPoint - ch->GetRealPoint(POINT_DX);
-		ch->SetRealPoint(POINT_DX, newPoint);
-		ch->PointChange(POINT_DX, 0);
-		ch->PointChange(POINT_STAT, -usedPoint);
-		ch->ComputePoints();
-		ch->PointsPacket();
-		return 1;
-	}
-
-	int pc_is_near_vid(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
-		{
-			lua_pushboolean(L, false);
-		}
-		else
-		{
-			LPCHARACTER pMe = CQuestManager::instance().GetCurrentCharacterPtr();
-			LPCHARACTER pOther = CHARACTER_MANAGER::instance().Find((DWORD)lua_tonumber(L, 1));
-
-			if (pMe != NULL && pOther != NULL)
-			{
-				lua_pushboolean(L, (DISTANCE_APPROX(pMe->GetX() - pOther->GetX(), pMe->GetY() - pOther->GetY()) < (int)lua_tonumber(L, 2) * 100));
-			}
-			else
-			{
-				lua_pushboolean(L, false);
-			}
-		}
-
-		return 1;
-	}
-
-	int pc_get_socket_items(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		lua_newtable(L);
-
-		if (pChar == NULL) return 1;
-
-		int idx = 1;
-
-		// 용혼석 슬롯은 할 필요 없을 듯.
-		// 이 함수는 탈석서용 함수인 듯 하다.
-		for (int i = 0; i < WEAR_MAX_NUM; i++)
-		{
-			LPITEM pItem = pChar->GetInventoryItem(i);
-
-			if (pItem != NULL)
-			{
-				if (pItem->IsEquipped() == false)
-				{
-					int j = 0;
-					for (; j < ITEM_SOCKET_MAX_NUM; j++)
-					{
-						long socket = pItem->GetSocket(j);
-
-						if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
-						{
-							TItemTable* pItemInfo = ITEM_MANAGER::instance().GetTable(socket);
-							if (pItemInfo != NULL)
-							{
-								if (pItemInfo->bType == ITEM_METIN) break;
-							}
-						}
-					}
-
-					if (j >= ITEM_SOCKET_MAX_NUM) continue;
-
-					lua_newtable(L);
-
-					{
-						lua_pushstring(L, pItem->GetName());
-						lua_rawseti(L, -2, 1);
-
-						lua_pushnumber(L, i);
-						lua_rawseti(L, -2, 2);
-					}
-
-					lua_rawseti(L, -2, idx++);
-				}
-			}
-		}
-
-		return 1;
-	}
-
-	int pc_get_empty_inventory_count(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (pChar != NULL)
-		{
-			lua_pushnumber(L, pChar->CountEmptyInventory());
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_get_logoff_interval(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (pChar != NULL)
-		{
-			lua_pushnumber(L, pChar->GetLogOffInterval());
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_get_last_play(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (pChar != NULL)
-		{
-			lua_pushnumber(L, pChar->GetLastPlay());
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_get_player_id(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (pChar != NULL)
-		{
-			lua_pushnumber(L, pChar->GetPlayerID());
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_get_account_id(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (pChar != NULL)
-		{
-			if (pChar->GetDesc() != NULL)
-			{
-				lua_pushnumber(L, pChar->GetDesc()->GetAccountTable().id);
-				return 1;
-			}
-		}
-
-		lua_pushnumber(L, 0);
-		return 1;
-	}
-
-	int pc_get_account(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != pChar)
-		{
-			if (NULL != pChar->GetDesc())
-			{
-				lua_pushstring(L, pChar->GetDesc()->GetAccountTable().login);
-				return 1;
-			}
-		}
-
-		lua_pushstring(L, "");
-		return 1;
-	}
-
-	int pc_is_riding(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != pChar)
-		{
-			bool is_riding = pChar->IsRiding();
-
-			lua_pushboolean(L, is_riding);
-
-			return 1;
-		}
-
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	int pc_get_special_ride_vnum(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != pChar)
-		{
-			LPITEM Unique1 = pChar->GetWear(WEAR_UNIQUE1);
-			LPITEM Unique2 = pChar->GetWear(WEAR_UNIQUE2);
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			LPITEM MountCostume = pChar->GetWear(WEAR_COSTUME_MOUNT);
-#endif
-
-			if (NULL != Unique1)
-			{
-				if (UNIQUE_GROUP_SPECIAL_RIDE == Unique1->GetSpecialGroup())
-				{
-					lua_pushnumber(L, Unique1->GetVnum());
-					lua_pushnumber(L, Unique1->GetSocket(0));
-					return 2;
-				}
-			}
-
-			if (NULL != Unique2)
-			{
-				if (UNIQUE_GROUP_SPECIAL_RIDE == Unique2->GetSpecialGroup())
-				{
-					lua_pushnumber(L, Unique2->GetVnum());
-					lua_pushnumber(L, Unique2->GetSocket(0));
-					return 2;
-				}
-			}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			if (MountCostume)
-			{
-				lua_pushnumber(L, MountCostume->GetVnum());
-				lua_pushnumber(L, MountCostume->GetSocket(0));
-				return 2;
-			}
-#endif
-		}
-
-		lua_pushnumber(L, 0);
-		lua_pushnumber(L, 0);
-
-		return 2;
-	}
-
-	int pc_can_warp(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != pChar)
-		{
-			lua_pushboolean(L, pChar->CanWarp());
-		}
-		else
-		{
-			lua_pushboolean(L, false);
-		}
-
-		return 1;
-	}
-
-	int pc_dec_skill_point(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != pChar)
-		{
-			pChar->PointChange(POINT_SKILL, -1);
-		}
-
-		return 0;
-	}
-
-	int pc_get_skill_point(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL != pChar)
-		{
-			lua_pushnumber(L, pChar->GetPoint(POINT_SKILL));
-		}
-		else
-		{
-			lua_pushnumber(L, 0);
-		}
-
-		return 1;
-	}
-
-	int pc_get_channel_id(lua_State* L)
-	{
-		lua_pushnumber(L, g_bChannel);
-
-		return 1;
-	}
-
-	int pc_give_poly_marble(lua_State* L)
-	{
-		const int dwVnum = lua_tonumber(L, 1);
-
-		const CMob* MobInfo = CMobManager::instance().Get(dwVnum);
-
-		if (NULL == MobInfo)
-		{
-			lua_pushboolean(L, false);
-			return 1;
-		}
-
-		if (0 == MobInfo->m_table.dwPolymorphItemVnum)
-		{
-			lua_pushboolean(L, false);
-			return 1;
-		}
-
-		LPITEM item = ITEM_MANAGER::instance().CreateItem(MobInfo->m_table.dwPolymorphItemVnum);
-
-		if (NULL == item)
-		{
-			lua_pushboolean(L, false);
-			return 1;
-		}
-
-		item->SetSocket(0, dwVnum);
-
-		const LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		int iEmptyCell = ch->GetEmptyInventory(item->GetSize());
-
-		if (-1 == iEmptyCell)
-		{
-			M2_DESTROY_ITEM(item);
-			lua_pushboolean(L, false);
-			return 1;
-		}
-
-		item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyCell));
-
-		const PC* pPC = CQuestManager::instance().GetCurrentPC();
-
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), MobInfo->m_table.dwPolymorphItemVnum, dwVnum);
-
-		lua_pushboolean(L, true);
-
-		return 1;
-	}
-
-	int pc_get_sig_items(lua_State* L)
-	{
-		DWORD group_vnum = (DWORD)lua_tonumber(L, 1);
-		const LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		int count = 0;
-		for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-		{
-			if (ch->GetInventoryItem(i) != NULL && ch->GetInventoryItem(i)->GetSIGVnum() == group_vnum)
-			{
-				lua_pushnumber(L, ch->GetInventoryItem(i)->GetID());
-				count++;
-			}
-		}
-
-		return count;
-	}
-
-	int pc_charge_cash(lua_State* L)
-	{
-		TRequestChargeCash packet;
-
-		int amount = lua_isnumber(L, 1) ? (int)lua_tonumber(L, 1) : 0;
-		std::string strChargeType = lua_isstring(L, 2) ? lua_tostring(L, 2) : "";
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (NULL == ch || NULL == ch->GetDesc() || 1 > amount || 50000 < amount)
-		{
-			lua_pushboolean(L, 0);
-			return 1;
-		}
-
-		packet.dwAID = ch->GetDesc()->GetAccountTable().id;
-		packet.dwAmount = (DWORD)amount;
-		packet.eChargeType = ERequestCharge_Cash;
-
-		if (0 < strChargeType.length())
-			std::transform(strChargeType.begin(), strChargeType.end(), strChargeType.begin(), (int(*)(int))std::tolower);
-
-		if ("mileage" == strChargeType)
-			packet.eChargeType = ERequestCharge_Mileage;
-
-		db_clientdesc->DBPacketHeader(HEADER_GD_REQUEST_CHARGE_CASH, 0, sizeof(TRequestChargeCash));
-		db_clientdesc->Packet(&packet, sizeof(packet));
-
-		lua_pushboolean(L, 1);
-		return 1;
-	}
-
-	int pc_give_award(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3))
-		{
-			sys_err("QUEST give award call error : wrong argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		DWORD dwVnum = (int)lua_tonumber(L, 1);
-
-		int icount = (int)lua_tonumber(L, 2);
-
-		sys_log(0, "QUEST [award] item %d to login %s", dwVnum, ch->GetDesc()->GetAccountTable().login);
-
-		DBManager::instance().Query("INSERT INTO item_award (login, vnum, count, given_time, why, mall)select '%s', %d, %d, now(), '%s', 1 from DUAL where not exists (select login, why from item_award where login = '%s' and why = '%s') ;",
-			ch->GetDesc()->GetAccountTable().login,
-			dwVnum,
-			icount,
-			lua_tostring(L, 3),
-			ch->GetDesc()->GetAccountTable().login,
-			lua_tostring(L, 3));
-
-		lua_pushnumber(L, 0);
-		return 1;
-	}
-
-	int pc_give_award_socket(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3) || !lua_isstring(L, 4) || !lua_isstring(L, 5) || !lua_isstring(L, 6))
-		{
-			sys_err("QUEST give award call error : wrong argument");
-			lua_pushnumber(L, 0);
-			return 1;
-		}
-
-		DWORD dwVnum = (int)lua_tonumber(L, 1);
-
-		int icount = (int)lua_tonumber(L, 2);
-
-		sys_log(0, "QUEST [award] item %d to login %s", dwVnum, ch->GetDesc()->GetAccountTable().login);
-
-		DBManager::instance().Query("INSERT INTO item_award (login, vnum, count, given_time, why, mall, socket0, socket1, socket2)select '%s', %d, %d, now(), '%s', 1, %s, %s, %s from DUAL where not exists (select login, why from item_award where login = '%s' and why = '%s') ;",
-			ch->GetDesc()->GetAccountTable().login,
-			dwVnum,
-			icount,
-			lua_tostring(L, 3),
-			lua_tostring(L, 4),
-			lua_tostring(L, 5),
-			lua_tostring(L, 6),
-			ch->GetDesc()->GetAccountTable().login,
-			lua_tostring(L, 3));
-
-		lua_pushnumber(L, 0);
-		return 1;
-	}
-
-	int pc_get_informer_type(lua_State* L) // 독일 선물 기능
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (pChar != NULL)
-		{
-#if defined(_DEBUG)
-			// sys_err("quest cmd test %s", pChar->GetItemAward_cmd());
-#endif
-			lua_pushstring(L, pChar->GetItemAward_cmd());
-		}
-		else
-			lua_pushstring(L, "");
-
-		return 1;
-	}
-
-	int pc_get_informer_item(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (pChar != NULL)
-		{
-			lua_pushnumber(L, pChar->GetItemAward_vnum());
-		}
-		else
-			lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int pc_get_killee_drop_pct(lua_State* L)
-	{
-		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPCHARACTER pKillee = pChar->GetQuestNPC();
-
-		int iDeltaPercent, iRandRange;
-		if (NULL == pKillee || !ITEM_MANAGER::instance().GetDropPct(pKillee, pChar, iDeltaPercent, iRandRange))
-		{
-			sys_err("killee is null");
-			lua_pushnumber(L, -1);
-			lua_pushnumber(L, -1);
-
-			return 2;
-		}
-
-		lua_pushnumber(L, iDeltaPercent);
-		lua_pushnumber(L, iRandRange);
-
-		return 2;
-	}
-
-	int pc_get_ip(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (!ch) return 0;
-
-		lua_pushstring(L, ch->GetDesc()->GetHostName());
-		return 1;
-	}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	int pc_is_blocked(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong::pc_is_blocked");
-			return 0;
-		}
-
-		const char* arg1 = lua_tostring(L, 1);
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-		if (!tch || !tch->IsPC())
-		{
-			sys_err("wrong::pc_is_blocked-2");
-			return 0;
-		}
-
-		lua_pushboolean(L, CMessengerManager::instance().IsBlocked(ch->GetName(), tch->GetName()));
-		return 1;
-	}
-
-	int pc_is_friend(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("wrong::pc_is_blocked");
-			return 0;
-		}
-
-		const char* arg1 = lua_tostring(L, 1);
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-		if (!tch || !tch->IsPC())
-		{
-			sys_err("wrong::pc_is_blocked-2");
-			return 0;
-		}
-
-		lua_pushboolean(L, CMessengerManager::instance().IsInList(ch->GetName(), tch->GetName()));
-		return 1;
-	}
-#endif
-
-	int pc_change_race(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		if (!lua_isnumber(L, 1))
-		{
-			return 0;
-		}
-
-		ch->SetRace(lua_tonumber(L, 1));
-		ch->SetSkillGroup(0);
-		ch->ClearSkill();
-		ch->ClearSubSkill();
-		ch->SetPolymorph(101);
-		ch->SetPolymorph(0);
-		return 0;
-	}
-
-	int pc_unequip_select(lua_State* L)
-	{
-		if (!lua_isnumber(L, 1))
-		{
-			sys_err("QUEST wrong set flag");
-			return 0;
-		}
-
-		BYTE bCell = (BYTE)lua_tonumber(L, 1);
-
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(bCell);
-
-		if (!ch || !item)
-			lua_pushnil(L);
-		else
-			if (ch->UnequipItem(item))
-				lua_pushnumber(L, item->GetVnum());
-			else
-				lua_pushnumber(L, 0);
-
-		return 1;
-	}
-
-	int pc_equip_slot(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		LPITEM item = ch->GetInventoryItem(lua_tonumber(L, 1));
-		lua_pushboolean(L, (item) ? ch->EquipItem(item) : false);
-		return 1;
-	}
-
-	int pc_dead(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (!ch) return 0;
-
-		ch->Dead();
-		return 1;
-	}
-
-	int pc_exchanging(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (!ch) return 0;
-
-		if (ch->GetExchange())
-			return 1;
-		else
-			return 0;
-	}
-
-	int pc_give_full_set(lua_State* L)
-	{
-		// g_bStartWithFullSet
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (ch)
-		{
-			BYTE job = ch->GetJob();
-			LPITEM item;
-
-			for (int i = 0; i < 6; i++)
-			{
-				item = ch->GetWear(i);
-				if (item != NULL)
-					ch->UnequipItem(item);
-			}
-
-			item = ch->GetWear(WEAR_SHIELD);
-			if (item != NULL)
-				ch->UnequipItem(item);
-
-			// Create Item
-			switch (job)
-			{
-				case JOB_WARRIOR:
-				{
-					item = ITEM_MANAGER::instance().CreateItem(11209); // Armor
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(19); // Weapon
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(12209); // Helmet
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-				}
-				break;
-
-				case JOB_ASSASSIN:
-				{
-					item = ITEM_MANAGER::instance().CreateItem(11409); // Armor
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(1009); // Weapon
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(12349); // Helmet
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-				}
-				break;
-
-				case JOB_SURA:
-				{
-					item = ITEM_MANAGER::instance().CreateItem(11609); // Armor
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(19); // Weapon
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(12489); // Helmet
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-				}
-				break;
-
-				case JOB_SHAMAN:
-				{
-					item = ITEM_MANAGER::instance().CreateItem(11809); // Armor
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(7009); // Weapon
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(12629); // Helmet
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-				}
-				break;
-
-				case JOB_WOLFMAN:
-				{
-					item = ITEM_MANAGER::instance().CreateItem(21009); // Armor
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(6009); // Weapon
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(21509); // Helmet
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
-					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
-						M2_DESTROY_ITEM(item);
-				}
-				break;
-
-			}
-
-			// Set Attribute
-			switch (job)
-			{
-				case JOB_WARRIOR:
-				case JOB_ASSASSIN:
-				case JOB_SURA:
-				case JOB_SHAMAN:
-				case JOB_WOLFMAN:
-				{
-					// 무사 몸빵 셋팅.
-					// 이것만 나와 있어서 임시로 모든 직군 다 이런 속성 따름.
-					item = ch->GetWear(WEAR_HEAD);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_ATT_SPEED, 8);
-						item->SetForceAttribute(1, APPLY_HP_REGEN, 30);
-						item->SetForceAttribute(2, APPLY_SP_REGEN, 30);
-						item->SetForceAttribute(3, APPLY_DODGE, 15);
-						item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
-					}
-
-					item = ch->GetWear(WEAR_WEAPON);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_CAST_SPEED, 20);
-						item->SetForceAttribute(1, APPLY_CRITICAL_PCT, 10);
-						item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
-						item->SetForceAttribute(3, APPLY_ATTBONUS_DEVIL, 20);
-						item->SetForceAttribute(4, APPLY_STR, 12);
-					}
-
-					item = ch->GetWear(WEAR_SHIELD);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_CON, 12);
-						item->SetForceAttribute(1, APPLY_BLOCK, 15);
-						item->SetForceAttribute(2, APPLY_REFLECT_MELEE, 10);
-						item->SetForceAttribute(3, APPLY_IMMUNE_STUN, 1);
-						item->SetForceAttribute(4, APPLY_IMMUNE_SLOW, 1);
-					}
-
-					item = ch->GetWear(WEAR_BODY);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-						item->SetForceAttribute(1, APPLY_CAST_SPEED, 20);
-						item->SetForceAttribute(2, APPLY_STEAL_HP, 10);
-						item->SetForceAttribute(3, APPLY_REFLECT_MELEE, 10);
-						item->SetForceAttribute(4, APPLY_ATT_GRADE_BONUS, 50);
-					}
-
-					item = ch->GetWear(WEAR_FOOTS);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-						item->SetForceAttribute(1, APPLY_MAX_SP, 80);
-						item->SetForceAttribute(2, APPLY_MOV_SPEED, 8);
-						item->SetForceAttribute(3, APPLY_ATT_SPEED, 8);
-						item->SetForceAttribute(4, APPLY_CRITICAL_PCT, 10);
-					}
-
-					item = ch->GetWear(WEAR_WRIST);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-						item->SetForceAttribute(1, APPLY_MAX_SP, 80);
-						item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
-						item->SetForceAttribute(3, APPLY_STEAL_HP, 10);
-						item->SetForceAttribute(4, APPLY_MANA_BURN_PCT, 10);
-					}
-
-					item = ch->GetWear(WEAR_NECK);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-						item->SetForceAttribute(1, APPLY_MAX_SP, 80);
-						item->SetForceAttribute(2, APPLY_CRITICAL_PCT, 10);
-						item->SetForceAttribute(3, APPLY_PENETRATE_PCT, 10);
-						item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
-					}
-
-					item = ch->GetWear(WEAR_EAR);
-					if (item != NULL)
-					{
-						item->ClearAttribute();
-						item->SetForceAttribute(0, APPLY_MOV_SPEED, 20);
-						item->SetForceAttribute(1, APPLY_MANA_BURN_PCT, 10);
-						item->SetForceAttribute(2, APPLY_POISON_REDUCE, 5);
-						item->SetForceAttribute(3, APPLY_ATTBONUS_DEVIL, 20);
-						item->SetForceAttribute(4, APPLY_ATTBONUS_UNDEAD, 20);
-					}
-				}
-				break;
-			}
-		}
-
-		ch->ComputePoints();
-
-		return 1;
-	}
-
-#if defined(__CONQUEROR_LEVEL__)
-	int pc_give_conqueror_exp2(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-		if (!lua_isnumber(L, 1))
-			return 0;
-
-		if (ch->GetConquerorLevel() == 0)
-			return 0;
-
-		sys_log(0, "QUEST [REWARD] %s give conqueror_exp2 %d", ch->GetName(), (int)rint(lua_tonumber(L, 1)));
-
-		DWORD exp = (DWORD)rint(lua_tonumber(L, 1));
-
-		PC* pPC = CQuestManager::instance().GetCurrentPC();
-		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
-		ch->PointChange(POINT_CONQUEROR_EXP, exp);
-		return 0;
-	}
-
-	int pc_get_conqueror_exp(lua_State* L)
-	{
-		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, pkChar ? pkChar->GetConquerorExp() : 0);
-		return 1;
-	}
-
-	int pc_get_conqueror_next_exp(lua_State* L)
-	{
-		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, pkChar ? pkChar->GetNextConquerorExp() : 0);
-		return 1;
-	}
-
-	int pc_get_conqueror_level(lua_State* L)
-	{
-		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
-		lua_pushnumber(L, pkChar ? pkChar->GetConquerorLevel() : 0);
-		return 1;
-	}
-
-	int pc_set_conqueror(lua_State* L)
-	{
-		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (pkChar) pkChar->SetConqueror();
-		return 1;
-	}
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-	int pc_is_offline_shop_decoration(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-
-		bool decorationAffect = false;
-		
-		if (ch->IsAffectOfflineShopDecoration())
-			decorationAffect = true;
-
-		lua_pushboolean(L, decorationAffect);
-		return 1;
-	}
-
-	int pc_set_offline_shop_decoration(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-		
-		if (!lua_isnumber(L,1))
-			return 0;
-
-		int decorationRemain = lua_tonumber(L,1);
-		
-		bool success = false;
-
-		if(NULL == ch->FindAffect(AFFECT_OFFLINE_SHOP_DECORATION))
-		{
-			ch->AddAffect(AFFECT_OFFLINE_SHOP_DECORATION, APPLY_NONE, 0, AFF_NONE, decorationRemain, 0, false, false);
-			success = true;
-		}
-
-
-		lua_pushboolean(L, success);
-		return 1;
-	}
-	
-	int pc_unset_offline_shop_decoration(lua_State* L)
-	{
-		CQuestManager& q = CQuestManager::instance();
-		LPCHARACTER ch = q.GetCurrentCharacterPtr();
-		
-		ch->RemoveAffect(AFFECT_OFFLINE_SHOP_DECORATION);
-		
-		return 0;
-	}
-
-	int pc_send_unlock_shopdeco(lua_State* L)
-	{
-		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
-
-		ch->SetUnlockShopSkin((BYTE)lua_tonumber(L, 1));
-		ch->SetUnlockShopBanner((BYTE)lua_tonumber(L, 2));
-		ch->SendUnlockedShopDeco();
-
-		return 0;
-	}
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	int pc_select_item_ex(lua_State* L)
-	{
-		const LPCHARACTER c_lpCh = CQuestManager::instance().GetCurrentCharacterPtr();
-		if (c_lpCh == nullptr)
-			return 0;
-
-		c_lpCh->ChatPacket(CHAT_TYPE_COMMAND, "BINARY_OpenSelectItemWindowEx");
-		return 0;
-	}
-#endif
-
-	void RegisterPCFunctionTable()
-	{
-		luaL_reg pc_functions[] =
-		{
-			{ "get_wear", pc_get_wear },
-			{ "get_player_id", pc_get_player_id },
-			{ "get_account_id", pc_get_account_id },
-			{ "get_account", pc_get_account },
-			{ "get_level", pc_get_level },
-			{ "set_level", pc_set_level },
-			{ "get_next_exp", pc_get_next_exp },
-			{ "get_exp", pc_get_exp },
-			{ "get_job", pc_get_job },
-			{ "get_race", pc_get_race },
-			{ "change_sex", pc_change_sex },
-			{ "gethp", pc_get_hp },
-			{ "get_hp", pc_get_hp },
-			{ "getmaxhp", pc_get_max_hp },
-			{ "get_max_hp", pc_get_max_hp },
-			{ "getsp", pc_get_sp },
-			{ "get_sp", pc_get_sp },
-			{ "getmaxsp", pc_get_max_sp },
-			{ "get_max_sp", pc_get_max_sp },
-			{ "change_sp", pc_change_sp },
-			{ "getmoney", pc_get_money },
-			{ "get_money", pc_get_money },
-			{ "get_real_alignment", pc_get_real_alignment },
-			{ "get_alignment", pc_get_alignment },
-			{ "getweapon", pc_get_weapon },
-			{ "get_weapon", pc_get_weapon },
-			{ "getarmor", pc_get_armor },
-			{ "get_armor", pc_get_armor },
-			{ "getgold", pc_get_money },
-			{ "get_gold", pc_get_money },
-			{ "changegold", pc_change_money },
-			{ "changemoney", pc_change_money },
-			{ "changealignment", pc_change_alignment },
-			{ "change_gold", pc_change_money },
-			{ "change_money", pc_change_money },
-			{ "change_alignment", pc_change_alignment },
-			{ "getname", pc_get_name },
-			{ "get_name", pc_get_name },
-			{ "get_vid", pc_get_vid },
-			{ "getplaytime", pc_get_playtime },
-			{ "get_playtime", pc_get_playtime },
-			{ "getleadership", pc_get_leadership },
-			{ "get_leadership", pc_get_leadership },
-			{ "getqf", pc_get_quest_flag },
-			{ "setqf", pc_set_quest_flag },
-			{ "delqf", pc_del_quest_flag },
-			{ "getf", pc_get_another_quest_flag },
-			{ "setf", pc_set_another_quest_flag },
-			{ "get_x", pc_get_x },
-			{ "get_y", pc_get_y },
-			{ "getx", pc_get_x },
-			{ "gety", pc_get_y },
-			{ "get_local_x", pc_get_local_x },
-			{ "get_local_y", pc_get_local_y },
-			{ "getcurrentmapindex", pc_get_current_map_index },
-			{ "get_map_index", pc_get_current_map_index },
-			{ "give_exp", pc_give_exp },
-			{ "give_exp_perc", pc_give_exp_perc },
-			{ "give_exp2", pc_give_exp2 },
-			{ "give_item", pc_give_item },
-			{ "give_item2", pc_give_or_drop_item },
-			{ "give_item2_select", pc_give_or_drop_item_and_select },
-			{ "give_gold", pc_give_gold },
-			{ "count_item", pc_count_item },
-			{ "remove_item", pc_remove_item },
-			{ "countitem", pc_count_item },
-			{ "removeitem", pc_remove_item },
-			{ "reset_point", pc_reset_point },
-			{ "has_guild", pc_hasguild },
-			{ "hasguild", pc_hasguild },
-			{ "get_guild", pc_getguild },
-			{ "getguild", pc_getguild },
-			{ "isguildmaster", pc_is_guild_master },
-			{ "is_guild_master", pc_is_guild_master },
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__) //&& defined(__GUILD_RENEWAL__)
-			{ "isguildgeneral", pc_is_guild_general },
-			{ "is_guild_general", pc_is_guild_general },
-#endif
-			{ "destroy_guild", pc_destroy_guild },
-			{ "remove_from_guild", pc_remove_from_guild },
-			{ "in_dungeon", pc_in_dungeon },
-			{ "getempire", pc_get_empire },
-			{ "get_empire", pc_get_empire },
-			{ "get_skill_group", pc_get_skillgroup },
-			{ "set_skill_group", pc_set_skillgroup },
-#if defined(__DUNGEON_RENEWAL__)
-			{ "jump", pc_jump },
-#endif
-			{ "warp", pc_warp },
-			{ "warp_local", pc_warp_local },
-			{ "warp_exit", pc_warp_exit },
-			{ "set_warp_location", pc_set_warp_location },
-			{ "set_warp_location_local", pc_set_warp_location_local },
-			{ "get_start_location", pc_get_start_location },
-			{ "has_master_skill", pc_has_master_skill },
-			{ "set_part", pc_set_part },
-			{ "get_part", pc_get_part },
-			{ "is_polymorphed", pc_is_polymorphed },
-			{ "remove_polymorph", pc_remove_polymorph },
-			{ "is_mount", pc_is_mount },
-			{ "polymorph", pc_polymorph },
-			{ "mount", pc_mount },
-			{ "mount_bonus", pc_mount_bonus },
-			{ "unmount", pc_unmount },
-			{ "warp_to_guild_war_observer_position", pc_warp_to_guild_war_observer_position },
-#if defined(__DUNGEON_RENEWAL__)
-			{ "has_item_from_special_item_group", pc_has_item_from_special_item_group },
-			{ "remove_item_from_special_item_group", pc_remove_item_from_special_item_group },
-#endif
-			{ "give_item_from_special_item_group", pc_give_item_from_special_item_group },
-			{ "learn_grand_master_skill", pc_learn_grand_master_skill },
-			{ "is_skill_book_no_delay", pc_is_skill_book_no_delay },
-			{ "remove_skill_book_no_delay", pc_remove_skill_book_no_delay },
-
-			{ "enough_inventory", pc_enough_inventory },
-			{ "get_horse", pc_get_horse }, // TO BE DELETED XXX
-			{ "get_horse_level", pc_get_horse_level }, // TO BE DELETED XXX
-			{ "is_horse_alive", pc_is_horse_alive }, // TO BE DELETED XXX
-			{ "revive_horse", pc_revive_horse }, // TO BE DELETED XXX
-			{ "have_pos_scroll", pc_have_pos_scroll },
-			{ "have_map_scroll", pc_have_map_scroll },
-			{ "get_war_map", pc_get_war_map },
-			{ "get_equip_refine_level", pc_get_equip_refine_level },
-			{ "refine_equip", pc_refine_equip },
-			{ "get_skill_level", pc_get_skill_level },
-			{ "give_lotto", pc_give_lotto },
-			{ "aggregate_monster", pc_aggregate_monster },
-			{ "forget_my_attacker", pc_forget_my_attacker },
-			{ "attract_ranger", pc_attract_ranger },
-			{ "select", pc_select_vid },
-			{ "get_sex", pc_get_sex },
-			{ "is_married", pc_is_married },
-			{ "is_engaged", pc_is_engaged },
-			{ "is_engaged_or_married", pc_is_engaged_or_married },
-			{ "is_gm", pc_is_gm },
-			{ "get_gm_level", pc_get_gm_level },
-			{ "mining", pc_mining },
-			{ "ore_refine", pc_ore_refine },
-			{ "diamond_refine", pc_diamond_refine },
-
-			// RESET_ONE_SKILL
-			{ "clear_one_skill", pc_clear_one_skill },
-			// END_RESET_ONE_SKILL
-
-			{ "clear_skill", pc_clear_skill },
-			{ "clear_sub_skill", pc_clear_sub_skill },
-			{ "set_skill_point", pc_set_skill_point },
-
-			{ "is_clear_skill_group", pc_is_clear_skill_group },
-
-			{ "save_exit_location", pc_save_exit_location },
-			{ "teleport", pc_teleport },
-
-			{ "set_skill_level", pc_set_skill_level },
-
-			{ "give_polymorph_book", pc_give_polymorph_book },
-			{ "upgrade_polymorph_book", pc_upgrade_polymorph_book },
-			{ "get_premium_remain_sec", pc_get_premium_remain_sec },
-
-			{ "send_block_mode", pc_send_block_mode },
-
-			{ "change_empire", pc_change_empire },
-			{ "get_change_empire_count", pc_get_change_empire_count },
-			{ "set_change_empire_count", pc_set_change_empire_count },
-
-			{ "change_name", pc_change_name },
-
-			{ "is_dead", pc_is_dead },
-
-			{ "reset_status", pc_reset_status },
-			{ "get_ht", pc_get_ht },
-			{ "set_ht", pc_set_ht },
-			{ "get_iq", pc_get_iq },
-			{ "set_iq", pc_set_iq },
-			{ "get_st", pc_get_st },
-			{ "set_st", pc_set_st },
-			{ "get_dx", pc_get_dx },
-			{ "set_dx", pc_set_dx },
-
-#if defined(__CONQUEROR_LEVEL__)
-			{ "reset_sungma_status", pc_reset_sungma_status },
-			{ "get_sungma_str", pc_get_sungma_str }, // sstr
-			{ "get_sungma_vit", pc_get_sungma_vit }, // shp
-			{ "get_sungma_res", pc_get_sungma_res }, // smove
-			{ "get_sungma_int", pc_get_sungma_int }, // simmune
-#endif
-
-			{ "is_near_vid", pc_is_near_vid },
-
-			{ "get_socket_items", pc_get_socket_items },
-			{ "get_empty_inventory_count", pc_get_empty_inventory_count },
-
-			{ "get_logoff_interval", pc_get_logoff_interval },
-			{ "get_last_play", pc_get_last_play },
-
-			{ "is_riding", pc_is_riding },
-			{ "get_special_ride_vnum", pc_get_special_ride_vnum },
-
-			{ "can_warp", pc_can_warp },
-
-			{ "dec_skill_point", pc_dec_skill_point },
-			{ "get_skill_point", pc_get_skill_point },
-
-			{ "get_channel_id", pc_get_channel_id },
-
-			{ "give_poly_marble", pc_give_poly_marble },
-			{ "get_sig_items", pc_get_sig_items },
-
-			{ "charge_cash", pc_charge_cash },
-
-			{ "get_informer_type", pc_get_informer_type }, // 독일 선물 기능
-			{ "get_informer_item", pc_get_informer_item },
-
-			{ "give_award", pc_give_award }, // 일본 계정당 한번씩 금괴 지급
-			{ "give_award_socket", pc_give_award_socket }, // 몰 인벤토리에 아이템 지급. 소켓 설정을 위한 함수.
-
-			{ "get_killee_drop_pct", pc_get_killee_drop_pct }, /* mob_vnum.kill 이벤트에서 killee와 pc와의 level 차이, pc의 프리미엄 드랍률 등등을 고려한 아이템 드랍 확률.
-			* return 값은 (분자, 분모).
-			* (말이 복잡한데, CreateDropItem의 GetDropPct의 iDeltaPercent, iRandRange를 return한다고 보면 됨.)
-			* (이 말이 더 어려울라나 ㅠㅠ)
-			* 주의사항 : kill event에서만 사용할 것!
-			*/
-
-#if defined(__DICE_SYSTEM__)
-			{ "give_item2_with_dice", pc_give_or_drop_item_with_dice },
-#endif
-
-#if defined(__CHEQUE_SYSTEM__)
-			{ "get_cheque", pc_get_cheque },
-			{ "change_cheque", pc_change_cheque },
-			{ "give_cheque", pc_give_cheque },
-			{ "exchange_cheque", pc_exchange_cheque },
-			{ "exchange_gold", pc_exchange_gold },
-#endif
-
-#if defined(__GEM_SYSTEM__)
-			{ "get_gem", pc_get_gem },
-			{ "change_gem", pc_change_gem },
-			{ "give_gem", pc_give_gem },
-#endif
-
-			{ "get_ip", pc_get_ip },
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-			{ "is_blocked", pc_is_blocked },
-			{ "is_friend", pc_is_friend },
-#endif
-
-			{ "change_race", pc_change_race },
-			{ "change_job", pc_change_race },
-			{ "unequip_select", pc_unequip_select },
-			{ "equip_slot", pc_equip_slot },
-
-			{ "dead", pc_dead },
-			{ "exchanging", pc_exchanging },
-
-			{ "give_full_set", pc_give_full_set },
-
-#if defined(__CONQUEROR_LEVEL__)
-			{ "give_conqueror_exp2", pc_give_conqueror_exp2 },
-			{ "get_conqueror_exp", pc_get_conqueror_exp },
-			{ "get_conqueror_next_exp", pc_get_conqueror_next_exp },
-			{ "get_conqueror_level", pc_get_conqueror_level },
-			{ "set_conqueror", pc_set_conqueror },
-#endif
-
-#if defined(__GEM_SYSTEM__)
-			{ "select_item_ex", pc_select_item_ex },
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-			{ "is_offline_shop_decoration", 	pc_is_offline_shop_decoration },
-			{ "set_offline_shop_decoration", 	pc_set_offline_shop_decoration },
-			{ "unset_offline_shop_decoration", 	pc_unset_offline_shop_decoration },
-			{ "send_unlock_shopdeco", pc_send_unlock_shopdeco },
-#endif
-
-			{ NULL, NULL }
-		};
-
-		CQuestManager::instance().AddLuaFunctionTable("pc", pc_functions);
-	}
-};
+#include "stdafx.h"
+
+#include "config.h"
+#include "questmanager.h"
+#include "sectree_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "affect.h"
+#include "item.h"
+#include "item_manager.h"
+#include "guild_manager.h"
+#include "war_map.h"
+#include "start_position.h"
+#include "marriage.h"
+#include "mining.h"
+#include "p2p.h"
+#include "polymorph.h"
+#include "desc_client.h"
+#include "messenger_manager.h"
+#include "log.h"
+#include "utils.h"
+#include "unique_item.h"
+#include "mob_manager.h"
+
+#if defined(__DICE_SYSTEM__)
+#	include "party.h"
+#endif
+
+#include <cctype>
+
+#undef sys_err
+#ifndef __WIN32__
+#	define sys_err(fmt, args...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, ##args)
+#else
+#	define sys_err(fmt, ...) quest::CQuestManager::instance().QuestError(__FUNCTION__, __LINE__, fmt, __VA_ARGS__)
+#endif
+
+extern int g_nPortalLimitTime;
+extern LPCLIENT_DESC db_clientdesc;
+const int ITEM_BROKEN_METIN_VNUM = 28960;
+
+namespace quest
+{
+	//
+	// "pc" Lua functions
+	//
+	int pc_has_master_skill(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		bool bHasMasterSkill = false;
+		for (int i = 0; i < SKILL_MAX_NUM; i++)
+			if (ch->GetSkillMasterType(i) >= SKILL_MASTER && ch->GetSkillLevel(i) >= 21)
+			{
+				bHasMasterSkill = true;
+				break;
+			}
+
+		lua_pushboolean(L, bHasMasterSkill);
+		return 1;
+	}
+
+	int pc_remove_skill_book_no_delay(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
+		return 0;
+	}
+
+	int pc_is_skill_book_no_delay(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		lua_pushboolean(L, ch->FindAffect(AFFECT_SKILL_NO_BOOK_DELAY) ? true : false);
+		return 1;
+	}
+
+	int pc_learn_grand_master_skill(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong skill index");
+			return 0;
+		}
+
+		lua_pushboolean(L, ch->LearnGrandMasterSkill((long)lua_tonumber(L, 1)));
+		return 1;
+	}
+
+	int pc_set_warp_location(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong map index");
+			return 0;
+		}
+
+		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("wrong coodinate");
+			return 0;
+		}
+
+		ch->SetWarpLocation((long)lua_tonumber(L, 1), (long)lua_tonumber(L, 2), (long)lua_tonumber(L, 3));
+		return 0;
+	}
+
+	int pc_set_warp_location_local(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong map index");
+			return 0;
+		}
+
+		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("wrong coodinate");
+			return 0;
+		}
+
+		long lMapIndex = (long)lua_tonumber(L, 1);
+		const TMapRegion* region = SECTREE_MANAGER::instance().GetMapRegion(lMapIndex);
+
+		if (!region)
+		{
+			sys_err("invalid map index %d", lMapIndex);
+			return 0;
+		}
+
+		int x = (int)lua_tonumber(L, 2);
+		int y = (int)lua_tonumber(L, 3);
+
+		if (x > region->ex - region->sx)
+		{
+			sys_err("x coordinate overflow max: %d input: %d", region->ex - region->sx, x);
+			return 0;
+		}
+
+		if (y > region->ey - region->sy)
+		{
+			sys_err("y coordinate overflow max: %d input: %d", region->ey - region->sy, y);
+			return 0;
+		}
+
+		ch->SetWarpLocation(lMapIndex, x, y);
+		return 0;
+	}
+
+	int pc_get_start_location(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		lua_pushnumber(L, g_start_map[ch->GetEmpire()]);
+		lua_pushnumber(L, g_start_position[ch->GetEmpire()][0] / 100);
+		lua_pushnumber(L, g_start_position[ch->GetEmpire()][1] / 100);
+		return 3;
+	}
+
+#if defined(__DUNGEON_RENEWAL__)
+	int pc_jump(lua_State* L)
+	{
+		if (lua_gettop(L) < 3 || !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+			return 0;
+
+		long x = (int)lua_tonumber(L, 1);
+		long y = (int)lua_tonumber(L, 2);
+		long lMapIndex = (int)lua_tonumber(L, 3);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (test_server)
+			ch->ChatPacket(CHAT_TYPE_INFO, "pc_jump %d %d %d", x, y, lMapIndex);
+
+		if (ch->GetMapIndex() == lMapIndex)
+		{
+			ch->Show(lMapIndex, x, y, 0);
+			ch->Stop();
+		}
+		else
+			ch->WarpSet(x, y, lMapIndex);
+
+		return 0;
+	}
+#endif
+
+	int pc_warp(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			lua_pushboolean(L, false);
+			return 1;
+		}
+
+		long map_index = 0;
+
+		if (lua_isnumber(L, 3))
+			map_index = (int)lua_tonumber(L, 3);
+
+		// PREVENT_HACK
+		if (ch->IsHack())
+		{
+			lua_pushboolean(L, false);
+			return 1;
+		}
+		// END_PREVENT_HACK
+
+		if (test_server)
+			ch->ChatPacket(CHAT_TYPE_INFO, "pc_warp %d %d %d", (int)lua_tonumber(L, 1),
+				(int)lua_tonumber(L, 2), map_index);
+		ch->WarpSet((int)lua_tonumber(L, 1), (int)lua_tonumber(L, 2), map_index);
+
+		lua_pushboolean(L, true);
+
+		return 1;
+	}
+
+	int pc_warp_local(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("no map index argument");
+			return 0;
+		}
+
+		if (!lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("no coodinate argument");
+			return 0;
+		}
+
+		long lMapIndex = (long)lua_tonumber(L, 1);
+		const TMapRegion* region = SECTREE_MANAGER::instance().GetMapRegion(lMapIndex);
+
+		if (!region)
+		{
+			sys_err("invalid map index %d", lMapIndex);
+			return 0;
+		}
+
+		int x = (int)lua_tonumber(L, 2);
+		int y = (int)lua_tonumber(L, 3);
+
+		if (x > region->ex - region->sx)
+		{
+			sys_err("x coordinate overflow max: %d input: %d", region->ex - region->sx, x);
+			return 0;
+		}
+
+		if (y > region->ey - region->sy)
+		{
+			sys_err("y coordinate overflow max: %d input: %d", region->ey - region->sy, y);
+			return 0;
+		}
+
+		/*
+		int iPulse = thecore_pulse();
+		if ( pkChr->GetExchange() || pkChr->GetMyShop() || pkChr->GetShopOwner() || pkChr->IsOpenSafebox() )
+		{
+			pkChr->ChatPacket( CHAT_TYPE_INFO, LC_STRING("킹창,창   쩔 摸 絹寗 求" ));
+
+			return;
+		}
+		//PREVENT_PORTAL_AFTER_EXCHANGE
+		//환  챨체크
+		if ( iPulse - pkChr->GetExchangeTime() < PASSES_PER_SEC(60) )
+		{
+			pkChr->ChatPacket( CHAT_TYPE_INFO, LC_STRING("킹  1 犬 摸 絹   求." ) );
+			return;
+		}
+		//END_PREVENT_PORTAL_AFTER_EXCHANGE
+		//PREVENT_ITEM_COPY
+		{
+			if ( iPulse - pkChr->GetMyShopTime() < PASSES_PER_SEC(60) )
+			{
+				pkChr->ChatPacket( CHAT_TYPE_INFO, LC_STRING("킹  1 犬 摸 絹   求." ) );
+				return;
+			}
+
+		}
+		//END_PREVENT_ITEM_COPY
+		*/
+
+		CQuestManager::instance().GetCurrentCharacterPtr()->WarpSet(region->sx + x, region->sy + y);
+		return 0;
+	}
+
+	int pc_warp_exit(lua_State* L)
+	{
+		CQuestManager::instance().GetCurrentCharacterPtr()->ExitToSavedLocation();
+		return 0;
+	}
+
+	int pc_in_dungeon(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->GetDungeon() ? 1 : 0);
+		return 1;
+	}
+
+	int pc_hasguild(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->GetGuild() ? 1 : 0);
+		return 1;
+	}
+
+	int pc_getguild(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetGuild() ? ch->GetGuild()->GetID() : 0);
+		return 1;
+	}
+
+	int pc_is_guild_master(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		CGuild* g = ch->GetGuild();
+
+		if (g)
+			lua_pushboolean(L, (ch->GetPlayerID() == g->GetMasterPID()));
+		else
+			lua_pushboolean(L, 0);
+
+		return 1;
+	}
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__) //&& defined(__GUILD_RENEWAL__)
+	int pc_is_guild_general(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch && ch->GetGuild())
+			lua_pushboolean(L, ch->GetGuild()->IsGeneralMember(ch->GetPlayerID()) ? true : false);
+		else
+			lua_pushboolean(L, false);
+
+		return 1;
+	}
+#endif
+
+	int pc_destroy_guild(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		CGuild* g = ch->GetGuild();
+
+		if (g)
+			g->RequestDisband(ch->GetPlayerID());
+
+		return 0;
+	}
+
+	int pc_remove_from_guild(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		CGuild* g = ch->GetGuild();
+
+		if (g)
+			g->RequestRemoveMember(ch->GetPlayerID());
+
+		return 0;
+	}
+
+	int pc_give_gold(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("QUEST : wrong argument");
+			return 0;
+		}
+
+		int iAmount = (int)lua_tonumber(L, 1);
+
+		if (iAmount <= 0)
+		{
+			sys_err("QUEST : gold amount less then zero");
+			return 0;
+		}
+
+		DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), iAmount);
+		ch->PointChange(POINT_GOLD, iAmount, true);
+		return 0;
+	}
+
+#if defined(__CHEQUE_SYSTEM__)
+	int pc_give_cheque(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("QUEST : wrong argument");
+			return 0;
+		}
+
+		int iAmount = (int)lua_tonumber(L, 1);
+
+		if (iAmount <= 0)
+		{
+			sys_err("QUEST : gold amount less then zero");
+			return 0;
+		}
+
+		DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), iAmount);
+		ch->PointChange(POINT_CHEQUE, iAmount, true);
+		return 0;
+	}
+
+	// Syntax: pc.exchange_cheque(@arg1, arg2)
+	// @arg1: cheque amount
+	// @arg2: cheque value
+	// @desc: converts cheque to gold.
+	int pc_exchange_cheque(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			sys_err("QUEST: Invalid argument");
+			return 0;
+		}
+
+		int cheque = (int/*max datatype for cheque*/)lua_tonumber(L, 1);
+		int cheque_value = (int/*max datatype for gold*/)lua_tonumber(L, 2);
+		if (cheque <= 0 || cheque_value <= 0 || cheque > CHEQUE_MAX || cheque_value >= GOLD_MAX)
+			return 0;
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch == nullptr)
+			return 0;
+
+		if (ch->GetCheque() < cheque)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Won."));
+			return 0;
+		}
+
+		int64_t gold = cheque * cheque_value;
+		const int64_t max_gold = static_cast<int64_t>(ch->GetGold()) + gold;
+		if (max_gold >= GOLD_MAX)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Yang."));
+			return 0;
+		}
+
+		ch->PointChange(POINT_GOLD, gold);
+		ch->PointChange(POINT_CHEQUE, -cheque);
+
+		sys_log(0, "QUEST [CHEQUE EXCHANGE] %s exchanged %d Won for %d Yang.", ch->GetName(), cheque, gold);
+
+		return 0;
+	}
+
+	// Syntax: pc.exchange_cheque(@arg1, @arg2, @arg3)
+	// @arg1: cheque amount
+	// @arg2: cheque value
+	// @arg3: tax
+	// @desc: converts gold to cheque.
+	int pc_exchange_gold(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("QUEST: Invalid argument");
+			return 0;
+		}
+
+		int cheque = (int/*max datatype for cheque*/)lua_tonumber(L, 1);
+		int cheque_value = (int/*max datatype for gold*/)lua_tonumber(L, 2);
+		int tax_rate = lua_tonumber(L, 3);
+		if (cheque <= 0 || cheque_value <= 0 || cheque > CHEQUE_MAX || cheque_value >= GOLD_MAX)
+			return 0;
+
+		int64_t tax = (cheque * cheque_value * tax_rate / 100);
+		int64_t gold = cheque * cheque_value + tax;
+
+		if (gold <= 0 || gold >= GOLD_MAX)
+			return 0;
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch == nullptr)
+			return 0;
+
+		if (ch->GetGold() < gold)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang."));
+			return 0;
+		}
+
+		if (ch->GetCheque() + cheque > CHEQUE_MAX)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Won."));
+			return 0;
+		}
+
+		ch->PointChange(POINT_CHEQUE, cheque);
+		ch->PointChange(POINT_GOLD, -gold);
+
+		sys_log(0, "QUEST [GOLD EXCHANGE] %s exchanged %d Yang for %d Won.", ch->GetName(), gold, cheque);
+
+		return 0;
+	}
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	int pc_give_gem(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("QUEST : wrong argument");
+			return 0;
+		}
+
+		int iAmount = (int)lua_tonumber(L, 1);
+
+		if (iAmount <= 0)
+		{
+			sys_err("QUEST : gold amount less then zero");
+			return 0;
+		}
+
+		DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), iAmount);
+		ch->PointChange(POINT_GEM, iAmount, true);
+		return 0;
+	}
+#endif
+
+	int pc_warp_to_guild_war_observer_position(lua_State* L)
+	{
+		luaL_checknumber(L, 1);
+		luaL_checknumber(L, 2);
+
+		DWORD gid1 = (DWORD)lua_tonumber(L, 1);
+		DWORD gid2 = (DWORD)lua_tonumber(L, 2);
+
+		CGuild* g1 = CGuildManager::instance().FindGuild(gid1);
+		CGuild* g2 = CGuildManager::instance().FindGuild(gid2);
+
+		if (!g1 || !g2)
+		{
+			luaL_error(L, "no such guild with id %d %d", gid1, gid2);
+		}
+
+		PIXEL_POSITION pos;
+
+		DWORD dwMapIndex = g1->GetGuildWarMapIndex(gid2);
+
+		if (!CWarMapManager::instance().GetStartPosition(dwMapIndex, 2, pos))
+		{
+			luaL_error(L, "not under warp guild war between guild %d %d", gid1, gid2);
+			return 0;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		// PREVENT_HACK
+		if (ch->IsHack())
+			return 0;
+		// END_PREVENT_HACK
+
+		ch->SetQuestFlag("war.is_war_member", 0);
+		ch->SaveExitLocation();
+		ch->WarpSet(pos.x, pos.y, dwMapIndex);
+		return 0;
+	}
+
+#if defined(__DUNGEON_RENEWAL__)
+	// syntax in LUA: pc.remove_item_from_special_item_group(item_group_vnum, count)
+	int pc_has_item_from_special_item_group(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			lua_pushboolean(L, false);
+			return 1;
+		}
+
+		DWORD dwGroupNum = (DWORD)lua_tonumber(L, 1);
+		DWORD dwRemoveCount = lua_isnumber(L, 2) ? (DWORD)lua_tonumber(L, 2) : 0;
+
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (NULL == pChar)
+		{
+			sys_err("QUEST : null pc");
+			return 1;
+		}
+
+		const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
+		if (!pGroup)
+		{
+			sys_err("QUEST : cannot find special item group %d", dwGroupNum);
+			return 1;
+		}
+
+		bool bFound = false;
+		DWORD dwFoundCount = 0;
+
+		int iGroupSize = pGroup->GetGroupSize();
+		for (int iIdx = 0; iIdx < iGroupSize; iIdx++)
+		{
+			DWORD dwVnum = pGroup->GetVnum(iIdx);
+			DWORD dwCount = dwRemoveCount ? dwRemoveCount : pGroup->GetCount(iIdx);
+
+			dwFoundCount += pChar->CountSpecifyItem(dwVnum);
+			if (dwFoundCount >= dwCount)
+			{
+				bFound = true;
+				break;
+			}
+		}
+
+		lua_pushboolean(L, bFound);
+		return 1;
+	}
+
+	// NOTE : The removed item from the inventory will always be the first item found in the group.
+	// If you want to remove certain items first you must adjust the position.
+	// It's recommended to leave MALL items at the end.
+	// syntax in LUA: pc.remove_item_from_special_item_group(item_group_vnum, count)
+	int pc_remove_item_from_special_item_group(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			lua_pushboolean(L, false);
+			return 1;
+		}
+
+		DWORD dwGroupNum = (DWORD)lua_tonumber(L, 1);
+		DWORD dwRemoveCount = lua_isnumber(L, 2) ? (DWORD)lua_tonumber(L, 2) : 0;
+
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (NULL == pChar)
+		{
+			sys_err("QUEST : null pc");
+			return 1;
+		}
+
+		const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
+		if (!pGroup)
+		{
+			sys_err("QUEST : cannot find special item group %d", dwGroupNum);
+			return 1;
+		}
+
+		bool bRemoveItem = false;
+
+		DWORD dwFoundCount = 0;
+		DWORD dwSingleCount = 0;
+
+		int iGroupSize = pGroup->GetGroupSize();
+		for (int iIdx = 0; iIdx < iGroupSize; iIdx++)
+		{
+			DWORD dwVnum = pGroup->GetVnum(iIdx);
+			DWORD dwCount = dwRemoveCount ? dwRemoveCount : pGroup->GetCount(iIdx);
+
+			dwFoundCount += pChar->CountSpecifyItem(dwVnum);
+			if (dwFoundCount >= dwCount)
+			{
+				pChar->RemoveSpecifyItem(dwVnum, dwCount - dwSingleCount);
+				bRemoveItem = true;
+				break;
+			}
+			else
+			{
+				pChar->RemoveSpecifyItem(dwVnum, dwFoundCount);
+				dwSingleCount += dwFoundCount;
+				continue;
+			}
+		}
+
+		lua_pushboolean(L, bRemoveItem);
+		return 1;
+	}
+#endif
+
+	int pc_give_item_from_special_item_group(lua_State* L)
+	{
+		luaL_checknumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		DWORD dwGroupVnum = (DWORD)lua_tonumber(L, 1);
+		ch->GiveItemFromSpecialItemGroup(dwGroupVnum);
+
+		return 0;
+	}
+
+	int pc_enough_inventory(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (!lua_isnumber(L, 1))
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		DWORD item_vnum = (DWORD)lua_tonumber(L, 1);
+		TItemTable* pTable = ITEM_MANAGER::instance().GetTable(item_vnum);
+		if (!pTable)
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		bool bEnoughInventoryForItem = ch->GetEmptyInventory(pTable->bSize) != -1;
+		lua_pushboolean(L, bEnoughInventoryForItem);
+		return 1;
+	}
+
+	int pc_give_item(lua_State* L)
+	{
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isstring(L, 1) || !(lua_isstring(L, 2) || lua_isnumber(L, 2)))
+		{
+			sys_err("QUEST : wrong argument");
+			return 0;
+		}
+
+		DWORD dwVnum;
+
+		if (lua_isnumber(L, 2)) // 호寬 호 娩.
+			dwVnum = (int)lua_tonumber(L, 2);
+		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 2), dwVnum))
+		{
+			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
+			return 0;
+		}
+
+		int icount = 1;
+
+		if (lua_isnumber(L, 3) && lua_tonumber(L, 3) > 0)
+		{
+			icount = (int)rint(lua_tonumber(L, 3));
+
+			if (icount <= 0)
+			{
+				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
+				return 0;
+			}
+		}
+
+		pPC->GiveItem(lua_tostring(L, 1), dwVnum, icount);
+
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
+		return 0;
+	}
+
+	int pc_give_or_drop_item(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isstring(L, 1) && !lua_isnumber(L, 1))
+		{
+			sys_err("QUEST Make item call error : wrong argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		DWORD dwVnum;
+
+		if (lua_isnumber(L, 1)) // 호寬 호 娩.
+		{
+			dwVnum = (int)lua_tonumber(L, 1);
+		}
+		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), dwVnum))
+		{
+			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
+			lua_pushnumber(L, 0);
+
+			return 1;
+		}
+
+		int icount = 1;
+		if (lua_isnumber(L, 2) && lua_tonumber(L, 2) > 0)
+		{
+			icount = (int)rint(lua_tonumber(L, 2));
+			if (icount <= 0)
+			{
+				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
+				lua_pushnumber(L, 0);
+				return 1;
+			}
+		}
+
+		sys_log(0, "QUEST [REWARD] item %s to %s", lua_tostring(L, 1), ch->GetName());
+
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
+
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		LPITEM item = ch->AutoGiveItem(dwVnum, icount, -1, true, true);
+#else
+		LPITEM item = ch->AutoGiveItem(dwVnum, icount);
+#endif
+
+		if (dwVnum >= 80003 && dwVnum <= 80007)
+		{
+			LogManager::instance().GoldBarLog(ch->GetPlayerID(), item->GetID(), QUEST, "quest: give_item2");
+		}
+
+		if (NULL != item)
+		{
+			lua_pushnumber(L, item->GetID());
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+		return 1;
+	}
+
+#if defined(__DICE_SYSTEM__)
+	int pc_give_or_drop_item_with_dice(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) && !lua_isnumber(L, 1))
+		{
+			sys_err("QUEST Make item call error : wrong argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		DWORD dwVnum;
+
+		if (lua_isnumber(L, 1))
+		{
+			dwVnum = (int)lua_tonumber(L, 1);
+		}
+		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), dwVnum))
+		{
+			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
+			lua_pushnumber(L, 0);
+
+			return 1;
+		}
+
+		int icount = 1;
+		if (lua_isnumber(L, 2) && lua_tonumber(L, 2) > 0)
+		{
+			icount = (int)rint(lua_tonumber(L, 2));
+			if (icount <= 0)
+			{
+				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
+				lua_pushnumber(L, 0);
+				return 1;
+			}
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPITEM item = ITEM_MANAGER::instance().CreateItem(dwVnum, icount);
+		if (ch->GetParty())
+		{
+			FPartyDropDiceRoll f(item, ch);
+			f.Process(NULL);
+			f.GetItemOwner()->AutoGiveItem(item);
+		}
+		else
+			ch->AutoGiveItem(item);
+
+		sys_log(0, "QUEST [REWARD] item %s to %s", lua_tostring(L, 1), ch->GetName());
+
+		LogManager::instance().QuestRewardLog(CQuestManager::instance().GetCurrentPC()->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
+
+		lua_pushnumber(L, (item) ? item->GetID() : 0);
+		return 1;
+	}
+#endif
+
+	int pc_give_or_drop_item_and_select(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isstring(L, 1) && !lua_isnumber(L, 1))
+		{
+			sys_err("QUEST Make item call error : wrong argument");
+			return 0;
+		}
+
+		DWORD dwVnum;
+
+		if (lua_isnumber(L, 1)) // 호寬 호 娩.
+		{
+			dwVnum = (int)lua_tonumber(L, 1);
+		}
+		else if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), dwVnum))
+		{
+			sys_err("QUEST Make item call error : wrong item name : %s", lua_tostring(L, 1));
+			return 0;
+		}
+
+		int icount = 1;
+		if (lua_isnumber(L, 2) && lua_tonumber(L, 2) > 0)
+		{
+			icount = (int)rint(lua_tonumber(L, 2));
+			if (icount <= 0)
+			{
+				sys_err("QUEST Make item call error : wrong item count : %g", lua_tonumber(L, 2));
+				return 0;
+			}
+		}
+
+		sys_log(0, "QUEST [REWARD] item %s to %s", lua_tostring(L, 1), ch->GetName());
+
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), dwVnum, icount);
+
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		LPITEM item = ch->AutoGiveItem(dwVnum, icount, -1, true, true);
+#else
+		LPITEM item = ch->AutoGiveItem(dwVnum, icount);
+#endif
+
+		if (NULL != item)
+			CQuestManager::Instance().SetCurrentItem(item);
+
+		if (dwVnum >= 80003 && dwVnum <= 80007)
+		{
+			LogManager::instance().GoldBarLog(ch->GetPlayerID(), item->GetID(), QUEST, "quest: give_item2");
+		}
+
+		return 0;
+	}
+
+	int pc_get_current_map_index(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetMapIndex());
+		return 1;
+	}
+
+	int pc_get_x(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetX() / 100);
+		return 1;
+	}
+
+	int pc_get_y(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetY() / 100);
+		return 1;
+	}
+
+	int pc_get_local_x(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
+
+		if (pMap)
+			lua_pushnumber(L, (ch->GetX() - pMap->m_setting.iBaseX) / 100);
+		else
+			lua_pushnumber(L, ch->GetX() / 100);
+
+		return 1;
+	}
+
+	int pc_get_local_y(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
+
+		if (pMap)
+			lua_pushnumber(L, (ch->GetY() - pMap->m_setting.iBaseY) / 100);
+		else
+			lua_pushnumber(L, ch->GetY() / 100);
+
+		return 1;
+	}
+
+	int pc_count_item(lua_State* L)
+	{
+		if (lua_isnumber(L, -1))
+			lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->CountSpecifyItem((DWORD)lua_tonumber(L, -1)));
+		else if (lua_isstring(L, -1))
+		{
+			DWORD item_vnum;
+
+			if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), item_vnum))
+			{
+				sys_err("QUEST count_item call error : wrong item name : %s", lua_tostring(L, 1));
+				lua_pushnumber(L, 0);
+			}
+			else
+			{
+				lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->CountSpecifyItem(item_vnum));
+			}
+		}
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int pc_remove_item(lua_State* L)
+	{
+		if (lua_gettop(L) == 1)
+		{
+			DWORD item_vnum;
+
+			if (lua_isnumber(L, 1))
+			{
+				item_vnum = (DWORD)lua_tonumber(L, 1);
+			}
+			else if (lua_isstring(L, 1))
+			{
+				if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), item_vnum))
+				{
+					sys_err("QUEST remove_item call error : wrong item name : %s", lua_tostring(L, 1));
+					return 0;
+				}
+			}
+			else
+			{
+				sys_err("QUEST remove_item wrong argument");
+				return 0;
+			}
+
+			sys_log(0, "QUEST remove a item vnum %d of %s[%d]", item_vnum, CQuestManager::instance().GetCurrentCharacterPtr()->GetName(), CQuestManager::instance().GetCurrentCharacterPtr()->GetPlayerID());
+			CQuestManager::instance().GetCurrentCharacterPtr()->RemoveSpecifyItem(item_vnum);
+		}
+		else if (lua_gettop(L) == 2)
+		{
+			DWORD item_vnum;
+
+			if (lua_isnumber(L, 1))
+			{
+				item_vnum = (DWORD)lua_tonumber(L, 1);
+			}
+			else if (lua_isstring(L, 1))
+			{
+				if (!ITEM_MANAGER::instance().GetVnum(lua_tostring(L, 1), item_vnum))
+				{
+					sys_err("QUEST remove_item call error : wrong item name : %s", lua_tostring(L, 1));
+					return 0;
+				}
+			}
+			else
+			{
+				sys_err("QUEST remove_item wrong argument");
+				return 0;
+			}
+
+			DWORD item_count = (DWORD)lua_tonumber(L, 2);
+			sys_log(0, "QUEST remove items(vnum %d) count %d of %s[%d]",
+				item_vnum,
+				item_count,
+				CQuestManager::instance().GetCurrentCharacterPtr()->GetName(),
+				CQuestManager::instance().GetCurrentCharacterPtr()->GetPlayerID());
+
+			CQuestManager::instance().GetCurrentCharacterPtr()->RemoveSpecifyItem(item_vnum, item_count);
+		}
+		return 0;
+	}
+
+	int pc_get_leadership(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetLeadershipSkillLevel());
+		return 1;
+	}
+
+	int pc_reset_point(lua_State* L)
+	{
+		CQuestManager::instance().GetCurrentCharacterPtr()->ResetPoint(CQuestManager::instance().GetCurrentCharacterPtr()->GetLevel());
+		return 0;
+	}
+
+	int pc_get_playtime(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetRealPoint(POINT_PLAYTIME));
+		return 1;
+	}
+
+	int pc_get_vid(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetVID());
+		return 1;
+	}
+	int pc_get_name(lua_State* L)
+	{
+		lua_pushstring(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetName());
+		return 1;
+	}
+
+	int pc_get_next_exp(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetNextExp());
+		return 1;
+	}
+
+	int pc_get_exp(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetExp());
+		return 1;
+	}
+
+	int pc_get_race(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetRaceNum());
+		return 1;
+	}
+
+	int pc_change_sex(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->ChangeSex());
+		return 1;
+	}
+
+	int pc_get_job(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetJob());
+		return 1;
+	}
+
+	int pc_get_max_sp(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetMaxSP());
+		return 1;
+	}
+
+	int pc_get_sp(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetSP());
+		return 1;
+	}
+
+	int pc_change_sp(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("invalid argument");
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		long val = (long)lua_tonumber(L, 1);
+
+		if (val == 0)
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (val > 0) // 키 譴퓐   
+			ch->PointChange(POINT_SP, val);
+		else if (val < 0)
+		{
+			if (ch->GetSP() < -val)
+			{
+				lua_pushboolean(L, 0);
+				return 1;
+			}
+
+			ch->PointChange(POINT_SP, val);
+		}
+
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+
+	int pc_get_max_hp(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetMaxHP());
+		return 1;
+	}
+
+	int pc_get_hp(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetHP());
+		return 1;
+	}
+
+	int pc_get_level(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetLevel());
+		return 1;
+	}
+
+	int pc_set_level(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("invalid argument");
+			return 0;
+		}
+		else
+		{
+			int newLevel = lua_tonumber(L, 1);
+			LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+			sys_log(0, "QUEST [LEVEL] %s jumpint to level %d", ch->GetName(), (int)rint(lua_tonumber(L, 1)));
+
+			PC* pPC = CQuestManager::instance().GetCurrentPC();
+			LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), newLevel, 0);
+
+			// 트 : 킬, 苑뵀, 
+			ch->PointChange(POINT_SKILL, newLevel - ch->GetLevel());
+			ch->PointChange(POINT_SUB_SKILL, newLevel < 10 ? 0 : newLevel - MAX(ch->GetLevel(), 9));
+			ch->PointChange(POINT_STAT, ((MINMAX(1, newLevel, gPlayerMaxLevel) - ch->GetLevel()) * 3) + ch->GetPoint(POINT_LEVEL_STEP));
+			//
+			ch->PointChange(POINT_LEVEL, newLevel - ch->GetLevel(), false, true);
+			//HP, SP
+			ch->SetRandomHP((newLevel - 1) * number(JobInitialPoints[ch->GetJob()].hp_per_lv_begin, JobInitialPoints[ch->GetJob()].hp_per_lv_end));
+			ch->SetRandomSP((newLevel - 1) * number(JobInitialPoints[ch->GetJob()].sp_per_lv_begin, JobInitialPoints[ch->GetJob()].sp_per_lv_end));
+
+			// 회
+			ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
+			ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
+
+			ch->ComputePoints();
+			ch->PointsPacket();
+			ch->SkillLevelPacket();
+
+			return 0;
+		}
+	}
+
+	int pc_get_weapon(lua_State* L)
+	{
+		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(WEAR_WEAPON);
+
+		if (!item)
+			lua_pushnumber(L, 0);
+		else
+			lua_pushnumber(L, item->GetVnum());
+
+		return 1;
+	}
+
+	int pc_get_armor(lua_State* L)
+	{
+		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(WEAR_BODY);
+
+		if (!item)
+			lua_pushnumber(L, 0);
+		else
+			lua_pushnumber(L, item->GetVnum());
+
+		return 1;
+	}
+
+	int pc_get_wear(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("QUEST wrong set flag");
+			return 0;
+		}
+
+		BYTE bCell = (BYTE)lua_tonumber(L, 1);
+
+		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(bCell);
+
+		if (!item)
+			lua_pushnil(L);
+		else
+			lua_pushnumber(L, item->GetVnum());
+
+		return 1;
+	}
+
+	int pc_get_money(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetGold());
+		return 1;
+	}
+
+#if defined(__CHEQUE_SYSTEM__)
+	int pc_get_cheque(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetCheque());
+		return 1;
+	}
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	int pc_get_gem(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetGem());
+		return 1;
+	}
+#endif
+
+	// 20050725.myevan.   혼 첵 치 菅 恬풔 陋 澁
+	//  치 結  構 磯.
+	int pc_get_real_alignment(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetRealAlignment() / 10);
+		return 1;
+	}
+
+	int pc_get_alignment(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetAlignment() / 10);
+		return 1;
+	}
+
+	int pc_change_alignment(lua_State* L)
+	{
+		int alignment = (int)(lua_tonumber(L, 1) * 10);
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		ch->UpdateAlignment(alignment);
+		return 0;
+	}
+
+	int pc_change_money(lua_State* L)
+	{
+		int gold = (int)lua_tonumber(L, -1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (gold + ch->GetGold() < 0)
+			sys_err("QUEST wrong ChangeGold %d (now %d)", gold, ch->GetGold());
+		else
+		{
+			DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), gold);
+			ch->PointChange(POINT_GOLD, gold, true);
+		}
+
+		return 0;
+	}
+
+#if defined(__CHEQUE_SYSTEM__)
+	int pc_change_cheque(lua_State* L)
+	{
+		int cheque = (int)lua_tonumber(L, -1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (cheque + ch->GetCheque() < 0)
+			sys_err("QUEST wrong ChangeCheque %d (now %d)", cheque, ch->GetCheque());
+		else
+		{
+			DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), cheque);
+			ch->PointChange(POINT_CHEQUE, cheque, true);
+		}
+
+		return 0;
+	}
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	int pc_change_gem(lua_State* L)
+	{
+		int gem = (int)lua_tonumber(L, -1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (gem + ch->GetGem() < 0)
+			sys_err("QUEST wrong ChangeGem %d (now %d)", gem, ch->GetGem());
+		else
+		{
+			DBManager::instance().SendMoneyLog(MONEY_LOG_QUEST, ch->GetPlayerID(), gem);
+			ch->PointChange(POINT_GEM, gem, true);
+		}
+
+		return 0;
+	}
+#endif
+
+	int pc_set_another_quest_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isstring(L, 2) || !lua_isnumber(L, 3))
+		{
+			sys_err("QUEST wrong set flag");
+			return 0;
+		}
+		else
+		{
+			const char* sz = lua_tostring(L, 1);
+			const char* sz2 = lua_tostring(L, 2);
+			CQuestManager& q = CQuestManager::Instance();
+			PC* pPC = q.GetCurrentPC();
+			pPC->SetFlag(string(sz) + "." + sz2, int(rint(lua_tonumber(L, 3))));
+			return 0;
+		}
+	}
+
+	int pc_get_another_quest_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isstring(L, 2))
+		{
+			sys_err("QUEST wrong get flag");
+			return 0;
+		}
+		else
+		{
+			const char* sz = lua_tostring(L, 1);
+			const char* sz2 = lua_tostring(L, 2);
+			CQuestManager& q = CQuestManager::Instance();
+			PC* pPC = q.GetCurrentPC();
+			if (!pPC)
+			{
+				return 0;
+			}
+			lua_pushnumber(L, pPC->GetFlag(string(sz) + "." + sz2));
+			return 1;
+		}
+	}
+
+	int pc_get_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, -1))
+		{
+			sys_err("QUEST wrong get flag");
+			return 0;
+		}
+		else
+		{
+			const char* sz = lua_tostring(L, -1);
+			CQuestManager& q = CQuestManager::Instance();
+			PC* pPC = q.GetCurrentPC();
+			lua_pushnumber(L, pPC->GetFlag(sz));
+			return 1;
+		}
+	}
+
+	int pc_get_quest_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, -1))
+		{
+			sys_err("QUEST wrong get flag");
+			return 0;
+		}
+		else
+		{
+			const char* sz = lua_tostring(L, -1);
+			CQuestManager& q = CQuestManager::Instance();
+			PC* pPC = q.GetCurrentPC();
+			lua_pushnumber(L, pPC->GetFlag(pPC->GetCurrentQuestName() + "." + sz));
+			if (test_server)
+				sys_log(0, "GetQF ( %s . %s )", pPC->GetCurrentQuestName().c_str(), sz);
+		}
+		return 1;
+	}
+
+	int pc_set_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+		{
+			sys_err("QUEST wrong set flag");
+		}
+		else
+		{
+			const char* sz = lua_tostring(L, 1);
+			CQuestManager& q = CQuestManager::Instance();
+			PC* pPC = q.GetCurrentPC();
+			pPC->SetFlag(sz, int(rint(lua_tonumber(L, 2))));
+		}
+		return 0;
+	}
+
+	int pc_set_quest_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+		{
+			sys_err("QUEST wrong set flag");
+		}
+		else
+		{
+			const char* sz = lua_tostring(L, 1);
+			CQuestManager& q = CQuestManager::Instance();
+			PC* pPC = q.GetCurrentPC();
+			pPC->SetFlag(pPC->GetCurrentQuestName() + "." + sz, int(rint(lua_tonumber(L, 2))));
+		}
+		return 0;
+	}
+
+	int pc_del_quest_flag(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			sys_err("argument error");
+			return 0;
+		}
+
+		const char* sz = lua_tostring(L, 1);
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+		pPC->DeleteFlag(pPC->GetCurrentQuestName() + "." + sz);
+		return 0;
+	}
+
+	int pc_give_exp2(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+		if (!lua_isnumber(L, 1))
+			return 0;
+
+		sys_log(0, "QUEST [REWARD] %s give exp2 %d", ch->GetName(), (int)rint(lua_tonumber(L, 1)));
+
+		DWORD exp = (DWORD)rint(lua_tonumber(L, 1));
+
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
+		ch->PointChange(POINT_EXP, exp);
+		return 0;
+	}
+
+	int pc_give_exp(lua_State* L)
+	{
+		if (!lua_isstring(L, 1) || !lua_isnumber(L, 2))
+			return 0;
+
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+
+		sys_log(0, "QUEST [REWARD] %s give exp %s %d", ch->GetName(), lua_tostring(L, 1), (int)rint(lua_tonumber(L, 2)));
+
+		DWORD exp = (DWORD)rint(lua_tonumber(L, 2));
+
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
+
+		pPC->GiveExp(lua_tostring(L, 1), exp);
+		return 0;
+	}
+
+	int pc_give_exp_perc(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+
+		if (!ch || !lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3))
+			return 0;
+
+		int lev = (int)rint(lua_tonumber(L, 2));
+		double proc = (lua_tonumber(L, 3));
+
+		sys_log(0, "QUEST [REWARD] %s give exp %s lev %d percent %g%%", ch->GetName(), lua_tostring(L, 1), lev, proc);
+
+		DWORD exp = (DWORD)((exp_table[MINMAX(0, lev, PLAYER_EXP_TABLE_MAX)] * proc) / 100);
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
+
+		pPC->GiveExp(lua_tostring(L, 1), exp);
+		return 0;
+	}
+
+	int pc_get_empire(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetEmpire());
+		return 1;
+	}
+
+	int pc_get_part(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+		if (!lua_isnumber(L, 1))
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+		int part_idx = (int)lua_tonumber(L, 1);
+		lua_pushnumber(L, ch->GetPart(part_idx));
+		return 1;
+	}
+
+	int pc_set_part(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			return 0;
+		}
+		int part_idx = (int)lua_tonumber(L, 1);
+		int part_value = (int)lua_tonumber(L, 2);
+		ch->SetPart(part_idx, part_value);
+		ch->UpdatePacket();
+		return 0;
+	}
+
+	int pc_get_skillgroup(lua_State* L)
+	{
+		lua_pushnumber(L, CQuestManager::instance().GetCurrentCharacterPtr()->GetSkillGroup());
+		return 1;
+	}
+
+	int pc_set_skillgroup(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+			sys_err("QUEST wrong skillgroup number");
+		else
+		{
+			CQuestManager& q = CQuestManager::Instance();
+			LPCHARACTER ch = q.GetCurrentCharacterPtr();
+
+			ch->SetSkillGroup((BYTE)rint(lua_tonumber(L, 1)));
+		}
+		return 0;
+	}
+
+	int pc_is_polymorphed(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->IsPolymorphed());
+		return 1;
+	}
+
+	int pc_remove_polymorph(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->RemoveAffect(AFFECT_POLYMORPH);
+		ch->SetPolymorph(0);
+		return 0;
+	}
+
+	int pc_polymorph(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
+		int iDuration = (int)lua_tonumber(L, 2);
+		ch->AddAffect(AFFECT_POLYMORPH, POINT_POLYMORPH, dwVnum, AFF_POLYMORPH, iDuration, 0, true);
+		return 0;
+	}
+
+	int pc_is_mount(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->GetMountVnum());
+		return 1;
+	}
+
+	int pc_mount(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+			return 0;
+
+		int length = 60;
+
+		if (lua_isnumber(L, 2))
+			length = (int)lua_tonumber(L, 2);
+
+		DWORD mount_vnum = (DWORD)lua_tonumber(L, 1);
+
+		if (length < 0)
+			length = 60;
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+		if (SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, ch->GetMapIndex()))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
+			return 0;
+		}
+#endif
+
+		if (ch->IsFishing())
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
+			return 0;
+		}
+
+		ch->RemoveAffect(AFFECT_MOUNT);
+		ch->RemoveAffect(AFFECT_MOUNT_BONUS);
+
+		//  환퓸 募求 쨋  
+		if (ch->GetHorse())
+			ch->HorseSummon(false);
+
+		if (mount_vnum)
+		{
+			ch->AddAffect(AFFECT_MOUNT, POINT_MOUNT, mount_vnum, AFF_NONE, length, 0, true);
+			switch (mount_vnum)
+			{
+				case 20201:
+				case 20202:
+				case 20203:
+				case 20204:
+				case 20213:
+				case 20216:
+					ch->AddAffect(AFFECT_MOUNT, POINT_MOV_SPEED, 30, AFF_NONE, length, 0, true, true);
+					break;
+
+				case 20205:
+				case 20206:
+				case 20207:
+				case 20208:
+				case 20214:
+				case 20217:
+					ch->AddAffect(AFFECT_MOUNT, POINT_MOV_SPEED, 40, AFF_NONE, length, 0, true, true);
+					break;
+
+				case 20209:
+				case 20210:
+				case 20211:
+				case 20212:
+				case 20215:
+				case 20218:
+					ch->AddAffect(AFFECT_MOUNT, POINT_MOV_SPEED, 50, AFF_NONE, length, 0, true, true);
+					break;
+			}
+		}
+
+		return 0;
+	}
+
+	int pc_mount_bonus(lua_State* L)
+	{
+		POINT_TYPE applyOn = static_cast<POINT_TYPE>(lua_tonumber(L, 1));
+		long value = static_cast<long>(lua_tonumber(L, 2));
+		long duration = static_cast<long>(lua_tonumber(L, 3));
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != ch)
+		{
+			if (!ch->GetMountVnum())
+				return 0;
+
+			ch->RemoveAffect(AFFECT_MOUNT_BONUS);
+			ch->AddAffect(AFFECT_MOUNT_BONUS, aApplyInfo[applyOn].wPointType, value, AFF_NONE, duration, 0, false);
+		}
+
+		return 0;
+	}
+
+	int pc_unmount(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->RemoveAffect(AFFECT_MOUNT);
+		ch->RemoveAffect(AFFECT_MOUNT_BONUS);
+		ch->PointsPacket();
+		if (ch->IsHorseRiding())
+			ch->StopRiding();
+		return 0;
+	}
+
+	int pc_get_horse(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->GetHorse() ? true : false);
+		return 1;
+	}
+
+	int pc_get_horse_level(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetHorseLevel());
+		return 1;
+	}
+
+	int pc_get_horse_hp(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch->GetHorseLevel())
+			lua_pushnumber(L, ch->GetHorseHealth());
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int pc_get_horse_stamina(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch->GetHorseLevel())
+			lua_pushnumber(L, ch->GetHorseStamina());
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int pc_is_horse_alive(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->GetHorseLevel() > 0 && ch->GetHorseHealth() > 0);
+		return 1;
+	}
+
+	int pc_revive_horse(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->ReviveHorse();
+		return 0;
+	}
+
+	int pc_have_map_scroll(lua_State* L)
+	{
+		if (!lua_isstring(L, 1))
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		const char* szMapName = lua_tostring(L, 1);
+		const TMapRegion* region = SECTREE_MANAGER::instance().FindRegionByPartialName(szMapName);
+
+		if (!region)
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		bool bFind = false;
+		for (int iCell = 0; iCell < INVENTORY_MAX_NUM; iCell++)
+		{
+			LPITEM item = ch->GetInventoryItem(iCell);
+			if (!item)
+				continue;
+
+			if (item->GetType() == ITEM_USE &&
+				item->GetSubType() == USE_TALISMAN &&
+				(item->GetValue(0) == 1 || item->GetValue(0) == 2))
+			{
+				int x = item->GetSocket(0);
+				int y = item->GetSocket(1);
+				//if ((x-item_x)*(x-item_x)+(y-item_y)*(y-item_y)<r*r)
+				if (region->sx <= x && region->sy <= y && x <= region->ex && y <= region->ey)
+				{
+					bFind = true;
+					break;
+				}
+			}
+		}
+
+		lua_pushboolean(L, bFind);
+		return 1;
+	}
+
+	int pc_get_war_map(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetWarMap() ? ch->GetWarMap()->GetMapIndex() : 0);
+		return 1;
+	}
+
+	int pc_have_pos_scroll(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			sys_err("invalid x y position");
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		if (!lua_isnumber(L, 2))
+		{
+			sys_err("invalid radius");
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		int x = (int)lua_tonumber(L, 1);
+		int y = (int)lua_tonumber(L, 2);
+		float r = (float)lua_tonumber(L, 3);
+
+		bool bFind = false;
+		for (int iCell = 0; iCell < INVENTORY_MAX_NUM; iCell++)
+		{
+			LPITEM item = ch->GetInventoryItem(iCell);
+			if (!item)
+				continue;
+
+			if (item->GetType() == ITEM_USE &&
+				item->GetSubType() == USE_TALISMAN &&
+				(item->GetValue(0) == 1 || item->GetValue(0) == 2))
+			{
+				int item_x = item->GetSocket(0);
+				int item_y = item->GetSocket(1);
+				if ((x - item_x) * (x - item_x) + (y - item_y) * (y - item_y) < r * r)
+				{
+					bFind = true;
+					break;
+				}
+			}
+		}
+
+		lua_pushboolean(L, bFind);
+		return 1;
+	}
+
+	int pc_get_equip_refine_level(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int cell = (int)lua_tonumber(L, 1);
+		if (cell < 0 || cell >= WEAR_MAX_NUM)
+		{
+			sys_err("invalid wear position %d", cell);
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		LPITEM item = ch->GetWear(cell);
+		if (!item)
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		lua_pushnumber(L, item->GetRefineLevel());
+		return 1;
+	}
+
+	int pc_refine_equip(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			sys_err("invalid argument");
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		int cell = (int)lua_tonumber(L, 1);
+		int level_limit = (int)lua_tonumber(L, 2);
+		int pct = lua_isnumber(L, 3) ? (int)lua_tonumber(L, 3) : 100;
+
+		LPITEM item = ch->GetWear(cell);
+		if (!item)
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		if (item->GetRefinedVnum() == 0)
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		if (item->GetRefineLevel() > level_limit)
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		if (pct == 100 || number(1, 100) <= pct)
+		{
+			//  
+			lua_pushboolean(L, 1);
+
+			LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(item->GetRefinedVnum(), 1, 0, false);
+
+			if (pkNewItem)
+			{
+				for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+					if (!item->GetSocket(i))
+						break;
+					else
+						pkNewItem->SetSocket(i, 1);
+
+				int set = 0;
+				for (int i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
+				{
+					long socket = item->GetSocket(i);
+					if (socket > 2 && socket != 28960)
+					{
+						pkNewItem->SetSocket(set++, socket);
+					}
+				}
+
+				item->CopyAttributeTo(pkNewItem);
+
+				if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+					item->SetCount(item->GetCount() - 1);
+				else
+					ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+
+				// some tuits need here -_- pkNewItem->AddToCharacter(this, bCell);
+				pkNewItem->EquipTo(ch, cell);
+
+				ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
+
+				LogManager::instance().ItemLog(ch, pkNewItem, "REFINE SUCCESS (QUEST)", pkNewItem->GetName());
+			}
+		}
+		else
+		{
+			//  
+			lua_pushboolean(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_get_skill_level(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("invalid argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
+		lua_pushnumber(L, ch->GetSkillLevel(dwVnum));
+
+		return 1;
+	}
+
+	int pc_give_lotto(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+
+		sys_log(0, "TRY GIVE LOTTO TO pid %u", ch->GetPlayerID());
+
+		DWORD* pdw = M2_NEW DWORD[3];
+
+		pdw[0] = 50001;
+		pdw[1] = 1;
+		pdw[2] = q.GetEventFlag("lotto_round");
+
+		// 첨  磯
+		DBManager::instance().ReturnQuery(QID_LOTTO, ch->GetPlayerID(), pdw,
+			"INSERT INTO lotto_list VALUES(0, 'server%s', %u, NOW())",
+			get_table_postfix(), ch->GetPlayerID());
+
+		return 0;
+	}
+
+	int pc_aggregate_monster(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->AggregateMonster();
+		return 0;
+	}
+
+	int pc_forget_my_attacker(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->ForgetMyAttacker();
+		return 0;
+	}
+
+	int pc_attract_ranger(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->AttractRanger();
+		return 0;
+	}
+
+	int pc_select_pid(lua_State* L)
+	{
+		DWORD pid = (DWORD)lua_tonumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPCHARACTER new_ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+		if (new_ch)
+		{
+			CQuestManager::instance().GetPC(new_ch->GetPlayerID());
+
+			lua_pushnumber(L, ch->GetPlayerID());
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_select_vid(lua_State* L)
+	{
+		DWORD vid = (DWORD)lua_tonumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPCHARACTER new_ch = CHARACTER_MANAGER::instance().Find(vid);
+
+		if (new_ch)
+		{
+			CQuestManager::instance().GetPC(new_ch->GetPlayerID());
+
+			lua_pushnumber(L, (DWORD)ch->GetVID());
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_get_sex(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, GET_SEX(ch)); /* 0 == MALE, 1 == FEMALE */
+		return 1;
+	}
+
+	int pc_is_engaged(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, marriage::CManager::instance().IsEngaged(ch->GetPlayerID()));
+		return 1;
+	}
+
+	int pc_is_married(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, marriage::CManager::instance().IsMarried(ch->GetPlayerID()));
+		return 1;
+	}
+
+	int pc_is_engaged_or_married(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, marriage::CManager::instance().IsEngagedOrMarried(ch->GetPlayerID()));
+		return 1;
+	}
+
+	int pc_is_gm(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushboolean(L, ch->GetGMLevel() >= GM_HIGH_WIZARD);
+		return 1;
+	}
+
+	int pc_get_gm_level(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetGMLevel());
+		return 1;
+	}
+
+	int pc_mining(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPCHARACTER npc = CQuestManager::instance().GetCurrentNPCCharacterPtr();
+		ch->mining(npc);
+		return 0;
+	}
+
+	int pc_diamond_refine(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		int cost = (int)lua_tonumber(L, 1);
+		int pct = (int)lua_tonumber(L, 2);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPCHARACTER npc = CQuestManager::instance().GetCurrentNPCCharacterPtr();
+		LPITEM item = CQuestManager::instance().GetCurrentItem();
+
+		if (item)
+			lua_pushboolean(L, mining::OreRefine(ch, npc, item, cost, pct, NULL));
+		else
+			lua_pushboolean(L, 0);
+
+		return 1;
+	}
+
+	int pc_ore_refine(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		int cost = (int)lua_tonumber(L, 1);
+		int pct = (int)lua_tonumber(L, 2);
+		int metinstone_cell = (int)lua_tonumber(L, 3);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPCHARACTER npc = CQuestManager::instance().GetCurrentNPCCharacterPtr();
+		LPITEM item = CQuestManager::instance().GetCurrentItem();
+
+		LPITEM metinstone_item = ch->GetInventoryItem(metinstone_cell);
+
+		if (item && metinstone_item)
+			lua_pushboolean(L, mining::OreRefine(ch, npc, item, cost, pct, metinstone_item));
+		else
+			lua_pushboolean(L, 0);
+
+		return 1;
+	}
+
+	int pc_clear_skill(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch == NULL) return 0;
+
+		ch->ClearSkill();
+
+		return 0;
+	}
+
+	int pc_clear_sub_skill(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch == NULL) return 0;
+
+		ch->ClearSubSkill();
+
+		return 0;
+	}
+
+	int pc_set_skill_point(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			return 0;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int newPoint = (int)lua_tonumber(L, 1);
+
+		ch->SetRealPoint(POINT_SKILL, newPoint);
+		ch->SetPoint(POINT_SKILL, ch->GetRealPoint(POINT_SKILL));
+		ch->PointChange(POINT_SKILL, 0);
+		ch->ComputePoints();
+		ch->PointsPacket();
+
+		return 0;
+	}
+
+	// RESET_ONE_SKILL
+	int pc_clear_one_skill(lua_State* L)
+	{
+		int vnum = (int)lua_tonumber(L, 1);
+		sys_log(0, "%d skill clear", vnum);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch == NULL)
+		{
+			sys_log(0, "skill clear fail");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		sys_log(0, "%d skill clear", vnum);
+
+		ch->ResetOneSkill(vnum);
+
+		return 0;
+	}
+	// END_RESET_ONE_SKILL
+
+	int pc_is_clear_skill_group(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		lua_pushboolean(L, ch->GetQuestFlag("skill_group_clear.clear") == 1);
+
+		return 1;
+	}
+
+	int pc_save_exit_location(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		ch->SaveExitLocation();
+
+		return 0;
+	}
+
+	//米트
+	int pc_teleport(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int x = 0, y = 0;
+		if (lua_isnumber(L, 1))
+		{
+			//  
+			const int TOWN_NUM = 10;
+			struct warp_by_town_name
+			{
+				const char* name;
+				DWORD x;
+				DWORD y;
+			} ws[TOWN_NUM] =
+			{
+				{ "", 4743, 9548 },
+				{ "", 3235, 9086 },
+				{ "岷", 3531, 8829 },
+				{ "", 638, 1664 },
+				{ "쨌", 1745, 1909 },
+				{ "", 1455, 2400 },
+				{ "", 9599, 2692 },
+				{ "", 8036, 2984 },
+				{ "眉", 8639, 2460 },
+				{ "綺", 4350, 2143 },
+			};
+			int idx = (int)lua_tonumber(L, 1);
+
+			x = ws[idx].x;
+			y = ws[idx].y;
+			goto teleport_area;
+		}
+		else
+		{
+			const char* arg1 = lua_tostring(L, 1);
+
+			LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+			if (!tch)
+			{
+				const CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
+
+				if (pkCCI)
+				{
+					if (pkCCI->bChannel != g_bChannel)
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
+					}
+					else
+					{
+
+						PIXEL_POSITION pos;
+
+						if (!SECTREE_MANAGER::instance().GetCenterPositionOfMap(pkCCI->lMapIndex, pos))
+						{
+							ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find map (index %d)", pkCCI->lMapIndex);
+						}
+						else
+						{
+							ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", pos.x, pos.y);
+							ch->WarpSet(pos.x, pos.y);
+							lua_pushnumber(L, 1);
+						}
+					}
+				}
+				else if (NULL == CHARACTER_MANAGER::instance().FindPC(arg1))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, "There is no one by that name");
+				}
+
+				lua_pushnumber(L, 0);
+
+				return 1;
+			}
+			else
+			{
+				x = tch->GetX() / 100;
+				y = tch->GetY() / 100;
+			}
+		}
+
+	teleport_area:
+
+		x *= 100;
+		y *= 100;
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
+		ch->WarpSet(x, y);
+		ch->Stop();
+		lua_pushnumber(L, 1);
+		return 1;
+	}
+
+	int pc_set_skill_level(lua_State* L)
+	{
+		DWORD dwVnum = (DWORD)lua_tonumber(L, 1);
+		BYTE byLev = (BYTE)lua_tonumber(L, 2);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		ch->SetSkillLevel(dwVnum, byLev);
+
+		ch->SkillLevelPacket();
+
+		return 0;
+	}
+
+	int pc_give_polymorph_book(lua_State* L)
+	{
+		if (lua_isnumber(L, 1) != 1 && lua_isnumber(L, 2) != 1 && lua_isnumber(L, 3) != 1 && lua_isnumber(L, 4) != 1)
+		{
+			sys_err("Wrong Quest Function Arguments: pc_give_polymorph_book");
+			return 0;
+		}
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		CPolymorphUtils::instance().GiveBook(ch, (DWORD)lua_tonumber(L, 1), (DWORD)lua_tonumber(L, 2), (BYTE)lua_tonumber(L, 3), (BYTE)lua_tonumber(L, 4));
+
+		return 0;
+	}
+
+	int pc_upgrade_polymorph_book(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPITEM pItem = CQuestManager::instance().GetCurrentItem();
+
+		bool ret = CPolymorphUtils::instance().BookUpgrade(ch, pItem);
+
+		lua_pushboolean(L, ret);
+
+		return 1;
+	}
+
+	int pc_get_premium_remain_sec(lua_State* L)
+	{
+		int remain_seconds = 0;
+		int premium_type = 0;
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong premium index (is not number)");
+			return 0;
+		}
+
+		premium_type = (int)lua_tonumber(L, 1);
+		switch (premium_type)
+		{
+			case PREMIUM_EXP:
+			case PREMIUM_ITEM:
+			case PREMIUM_SAFEBOX:
+			case PREMIUM_AUTOLOOT:
+			case PREMIUM_FISH_MIND:
+			case PREMIUM_MARRIAGE_FAST:
+			case PREMIUM_GOLD:
+#if defined(__CONQUEROR_LEVEL__)
+			case PREMIUM_SUNGMA:
+#endif
+				break;
+
+			default:
+				sys_err("wrong premium index %d", premium_type);
+				return 0;
+		}
+
+		remain_seconds = ch->GetPremiumRemainSeconds(premium_type);
+
+		lua_pushnumber(L, remain_seconds);
+		return 1;
+	}
+
+	int pc_send_block_mode(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		ch->SetBlockModeForce((BYTE)lua_tonumber(L, 1));
+
+		return 0;
+	}
+
+	int pc_change_empire(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->ChangeEmpire((unsigned char)lua_tonumber(L, 1)));
+		return 1;
+	}
+
+	int pc_get_change_empire_count(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		lua_pushnumber(L, ch->GetChangeEmpireCount());
+
+		return 1;
+	}
+
+	int pc_set_change_empire_count(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		ch->SetChangeEmpireCount();
+
+		return 0;
+	}
+
+	int pc_change_name(lua_State* L)
+	{
+		// 構
+		// 0 : 見   慣類틸 
+		// 1 : 크트 悶 耭 刻
+		// 2 : check_name   
+		// 3 : 譴  見 
+		// 4 : 
+		// 5 : 娩   
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch->GetNewName().size() != 0)
+		{
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		if (lua_isstring(L, 1) != 1)
+		{
+			lua_pushnumber(L, 1);
+			return 1;
+		}
+
+		const char* szName = lua_tostring(L, 1);
+
+	char szNameEsc[(CHARACTER_NAME_MAX_LEN + 1) * 2 + 1];
+	DBManager::instance().EscapeString(szNameEsc, sizeof(szNameEsc), szName ? szName : "", szName ? strlen(szName) : 0);
+
+		if (check_name(szName) == false)
+		{
+			lua_pushnumber(L, 2);
+			return 1;
+		}
+
+		char szQuery[1024];
+		snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM player%s WHERE name='%s'", get_table_postfix(), szNameEsc);
+		std::unique_ptr<SQLMsg> pmsg(DBManager::instance().DirectQuery(szQuery));
+
+		if (pmsg->Get()->uiNumRows > 0)
+		{
+			MYSQL_ROW row = mysql_fetch_row(pmsg->Get()->pSQLResult);
+
+			int count = 0;
+			str_to_number(count, row[0]);
+
+			// 譴 娩 見  캐叩 
+			if (count != 0)
+			{
+				lua_pushnumber(L, 3);
+				return 1;
+			}
+		}
+
+		ch->Save();
+		ch->SetExchangeTime();
+		//ch->GetDesc()->DelayedDisconnect(1);
+
+		/* delete messenger list */
+		CMessengerManager::instance().RemoveAllList(ch->GetName());
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		CMessengerManager::instance().RemoveAllBlockList(ch->GetName());
+#endif
+
+		DWORD pid = ch->GetPlayerID();
+
+		/* change_name_log */
+		LogManager::instance().ChangeNameLog(pid, ch->GetName(), szName, ch->GetDesc()->GetHostName());
+#ifdef __OFFLINE_SHOP__
+		snprintf(szQuery, sizeof(szQuery), "UPDATE offline_shop%s SET owner_name='%s' WHERE owner_pid=%u", get_table_postfix(), szName, pid);
+		std::unique_ptr<SQLMsg> pmsg3(DBManager::instance().DirectQuery(szQuery));
+
+#endif
+		snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET name='%s' WHERE id=%u", get_table_postfix(), szName, pid);
+		SQLMsg* msg = DBManager::instance().DirectQuery(szQuery);
+		M2_DELETE(msg);
+
+		ch->SetNewName(szName);
+		lua_pushnumber(L, 4);
+		return 1;
+	}
+
+	int pc_is_dead(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (ch != NULL)
+		{
+			lua_pushboolean(L, ch->IsDead());
+			return 1;
+		}
+
+		lua_pushboolean(L, true);
+
+		return 1;
+	}
+
+	int pc_reset_status(lua_State* L)
+	{
+		if (lua_isnumber(L, 1) != 0)
+		{
+			int idx = (int)lua_tonumber(L, 1);
+
+			if (idx >= 0 && idx < 4)
+			{
+				LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+				int point = POINT_NONE;
+				char buf[128];
+
+				switch (idx)
+				{
+					case 0: point = POINT_HT; break;
+					case 1: point = POINT_IQ; break;
+					case 2: point = POINT_ST; break;
+					case 3: point = POINT_DX; break;
+					default: lua_pushboolean(L, false); return 1;
+				}
+
+				int old_val = ch->GetRealPoint(point);
+				int old_stat = ch->GetRealPoint(POINT_STAT);
+
+				ch->SetRealPoint(point, 1);
+				ch->SetPoint(point, ch->GetRealPoint(point));
+
+				ch->PointChange(POINT_STAT, old_val);
+
+				if (point == POINT_HT)
+				{
+					BYTE job = ch->GetJob();
+					ch->SetRandomHP((ch->GetLevel() - 1) * number(JobInitialPoints[job].hp_per_lv_begin, JobInitialPoints[job].hp_per_lv_end));
+				}
+				else if (point == POINT_IQ)
+				{
+					BYTE job = ch->GetJob();
+					ch->SetRandomSP((ch->GetLevel() - 1) * number(JobInitialPoints[job].sp_per_lv_begin, JobInitialPoints[job].sp_per_lv_end));
+				}
+
+				ch->ComputePoints();
+				ch->PointsPacket();
+
+				if (point == POINT_HT)
+				{
+					ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
+				}
+				else if (point == POINT_IQ)
+				{
+					ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
+				}
+
+				switch (idx)
+				{
+					case 0:
+						snprintf(buf, sizeof(buf), "reset ht(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
+						break;
+					case 1:
+						snprintf(buf, sizeof(buf), "reset iq(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
+						break;
+					case 2:
+						snprintf(buf, sizeof(buf), "reset st(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
+						break;
+					case 3:
+						snprintf(buf, sizeof(buf), "reset dx(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_STAT));
+						break;
+				}
+
+				LogManager::instance().CharLog(ch, 0, "RESET_ONE_STATUS", buf);
+
+				lua_pushboolean(L, true);
+				return 1;
+			}
+		}
+
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+#if defined(__CONQUEROR_LEVEL__)
+	int pc_reset_sungma_status(lua_State* L)
+	{
+		if (lua_isnumber(L, 1) != 0)
+		{
+			int idx = (int)lua_tonumber(L, 1);
+
+			if (idx >= 0 && idx < 4)
+			{
+				LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+				int point = POINT_NONE;
+				char buf[128];
+
+				switch (idx)
+				{
+				case 0: point = POINT_SUNGMA_STR; break;
+				case 1: point = POINT_SUNGMA_HP; break;
+				case 2: point = POINT_SUNGMA_MOVE; break;
+				case 3: point = POINT_SUNGMA_IMMUNE; break;
+				default: lua_pushboolean(L, false); return 1;
+				}
+
+				int old_val = ch->GetRealPoint(point);
+				int old_stat = ch->GetRealPoint(POINT_CONQUEROR_POINT);
+
+				ch->SetRealPoint(point, 0);
+				ch->SetPoint(point, ch->GetRealPoint(point));
+
+				ch->PointChange(POINT_CONQUEROR_POINT, old_val);
+
+				ch->ComputePoints();
+				ch->PointsPacket();
+
+				switch (idx)
+				{
+					case 0:
+						snprintf(buf, sizeof(buf), "reset sstr(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
+						break;
+					case 1:
+						snprintf(buf, sizeof(buf), "reset shp(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
+						break;
+					case 2:
+						snprintf(buf, sizeof(buf), "reset smove(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
+						break;
+					case 3:
+						snprintf(buf, sizeof(buf), "reset simmune(%d)->1 stat_point(%d)->(%ld)", old_val, old_stat, ch->GetRealPoint(POINT_CONQUEROR_POINT));
+						break;
+				}
+
+				LogManager::instance().CharLog(ch, 0, "RESET_ONE_SUNGMA_STATUS", buf);
+
+				lua_pushboolean(L, true);
+				return 1;
+			}
+		}
+
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	int pc_get_sungma_str(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_STR));
+		return 1;
+	}
+
+	int pc_get_sungma_vit(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_HP));
+		return 1;
+	}
+
+	int pc_get_sungma_res(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_MOVE));
+		return 1;
+	}
+
+	int pc_get_sungma_int(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_SUNGMA_IMMUNE));
+		return 1;
+	}
+#endif
+
+	int pc_get_ht(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_HT));
+		return 1;
+	}
+
+	int pc_set_ht(lua_State* L)
+	{
+		if (lua_isnumber(L, 1) == false)
+			return 1;
+
+		int newPoint = (int)lua_tonumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int usedPoint = newPoint - ch->GetRealPoint(POINT_HT);
+		ch->SetRealPoint(POINT_HT, newPoint);
+		ch->PointChange(POINT_HT, 0);
+		ch->PointChange(POINT_STAT, -usedPoint);
+		ch->ComputePoints();
+		ch->PointsPacket();
+		return 1;
+	}
+
+	int pc_get_iq(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_IQ));
+		return 1;
+	}
+
+	int pc_set_iq(lua_State* L)
+	{
+		if (lua_isnumber(L, 1) == false)
+			return 1;
+
+		int newPoint = (int)lua_tonumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int usedPoint = newPoint - ch->GetRealPoint(POINT_IQ);
+		ch->SetRealPoint(POINT_IQ, newPoint);
+		ch->PointChange(POINT_IQ, 0);
+		ch->PointChange(POINT_STAT, -usedPoint);
+		ch->ComputePoints();
+		ch->PointsPacket();
+		return 1;
+	}
+
+	int pc_get_st(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_ST));
+		return 1;
+	}
+
+	int pc_set_st(lua_State* L)
+	{
+		if (lua_isnumber(L, 1) == false)
+			return 1;
+
+		int newPoint = (int)lua_tonumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int usedPoint = newPoint - ch->GetRealPoint(POINT_ST);
+		ch->SetRealPoint(POINT_ST, newPoint);
+		ch->PointChange(POINT_ST, 0);
+		ch->PointChange(POINT_STAT, -usedPoint);
+		ch->ComputePoints();
+		ch->PointsPacket();
+		return 1;
+	}
+
+	int pc_get_dx(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, ch->GetRealPoint(POINT_DX));
+		return 1;
+	}
+
+	int pc_set_dx(lua_State* L)
+	{
+		if (lua_isnumber(L, 1) == false)
+			return 1;
+
+		int newPoint = (int)lua_tonumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int usedPoint = newPoint - ch->GetRealPoint(POINT_DX);
+		ch->SetRealPoint(POINT_DX, newPoint);
+		ch->PointChange(POINT_DX, 0);
+		ch->PointChange(POINT_STAT, -usedPoint);
+		ch->ComputePoints();
+		ch->PointsPacket();
+		return 1;
+	}
+
+	int pc_is_near_vid(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2))
+		{
+			lua_pushboolean(L, false);
+		}
+		else
+		{
+			LPCHARACTER pMe = CQuestManager::instance().GetCurrentCharacterPtr();
+			LPCHARACTER pOther = CHARACTER_MANAGER::instance().Find((DWORD)lua_tonumber(L, 1));
+
+			if (pMe != NULL && pOther != NULL)
+			{
+				lua_pushboolean(L, (DISTANCE_APPROX(pMe->GetX() - pOther->GetX(), pMe->GetY() - pOther->GetY()) < (int)lua_tonumber(L, 2) * 100));
+			}
+			else
+			{
+				lua_pushboolean(L, false);
+			}
+		}
+
+		return 1;
+	}
+
+	int pc_get_socket_items(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		lua_newtable(L);
+
+		if (pChar == NULL) return 1;
+
+		int idx = 1;
+
+		// 혼   却  .
+		//  獨 탈 獨  求.
+		for (int i = 0; i < WEAR_MAX_NUM; i++)
+		{
+			LPITEM pItem = pChar->GetInventoryItem(i);
+
+			if (pItem != NULL)
+			{
+				if (pItem->IsEquipped() == false)
+				{
+					int j = 0;
+					for (; j < ITEM_SOCKET_MAX_NUM; j++)
+					{
+						long socket = pItem->GetSocket(j);
+
+						if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
+						{
+							TItemTable* pItemInfo = ITEM_MANAGER::instance().GetTable(socket);
+							if (pItemInfo != NULL)
+							{
+								if (pItemInfo->bType == ITEM_METIN) break;
+							}
+						}
+					}
+
+					if (j >= ITEM_SOCKET_MAX_NUM) continue;
+
+					lua_newtable(L);
+
+					{
+						lua_pushstring(L, pItem->GetName());
+						lua_rawseti(L, -2, 1);
+
+						lua_pushnumber(L, i);
+						lua_rawseti(L, -2, 2);
+					}
+
+					lua_rawseti(L, -2, idx++);
+				}
+			}
+		}
+
+		return 1;
+	}
+
+	int pc_get_empty_inventory_count(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (pChar != NULL)
+		{
+			lua_pushnumber(L, pChar->CountEmptyInventory());
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_get_logoff_interval(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (pChar != NULL)
+		{
+			lua_pushnumber(L, pChar->GetLogOffInterval());
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_get_last_play(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (pChar != NULL)
+		{
+			lua_pushnumber(L, pChar->GetLastPlay());
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_get_player_id(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (pChar != NULL)
+		{
+			lua_pushnumber(L, pChar->GetPlayerID());
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_get_account_id(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (pChar != NULL)
+		{
+			if (pChar->GetDesc() != NULL)
+			{
+				lua_pushnumber(L, pChar->GetDesc()->GetAccountTable().id);
+				return 1;
+			}
+		}
+
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+
+	int pc_get_account(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != pChar)
+		{
+			if (NULL != pChar->GetDesc())
+			{
+				lua_pushstring(L, pChar->GetDesc()->GetAccountTable().login);
+				return 1;
+			}
+		}
+
+		lua_pushstring(L, "");
+		return 1;
+	}
+
+	int pc_is_riding(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != pChar)
+		{
+			bool is_riding = pChar->IsRiding();
+
+			lua_pushboolean(L, is_riding);
+
+			return 1;
+		}
+
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	int pc_get_special_ride_vnum(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != pChar)
+		{
+			LPITEM Unique1 = pChar->GetWear(WEAR_UNIQUE1);
+			LPITEM Unique2 = pChar->GetWear(WEAR_UNIQUE2);
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			LPITEM MountCostume = pChar->GetWear(WEAR_COSTUME_MOUNT);
+#endif
+
+			if (NULL != Unique1)
+			{
+				if (UNIQUE_GROUP_SPECIAL_RIDE == Unique1->GetSpecialGroup())
+				{
+					lua_pushnumber(L, Unique1->GetVnum());
+					lua_pushnumber(L, Unique1->GetSocket(0));
+					return 2;
+				}
+			}
+
+			if (NULL != Unique2)
+			{
+				if (UNIQUE_GROUP_SPECIAL_RIDE == Unique2->GetSpecialGroup())
+				{
+					lua_pushnumber(L, Unique2->GetVnum());
+					lua_pushnumber(L, Unique2->GetSocket(0));
+					return 2;
+				}
+			}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			if (MountCostume)
+			{
+				lua_pushnumber(L, MountCostume->GetVnum());
+				lua_pushnumber(L, MountCostume->GetSocket(0));
+				return 2;
+			}
+#endif
+		}
+
+		lua_pushnumber(L, 0);
+		lua_pushnumber(L, 0);
+
+		return 2;
+	}
+
+	int pc_can_warp(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != pChar)
+		{
+			lua_pushboolean(L, pChar->CanWarp());
+		}
+		else
+		{
+			lua_pushboolean(L, false);
+		}
+
+		return 1;
+	}
+
+	int pc_dec_skill_point(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != pChar)
+		{
+			pChar->PointChange(POINT_SKILL, -1);
+		}
+
+		return 0;
+	}
+
+	int pc_get_skill_point(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL != pChar)
+		{
+			lua_pushnumber(L, pChar->GetPoint(POINT_SKILL));
+		}
+		else
+		{
+			lua_pushnumber(L, 0);
+		}
+
+		return 1;
+	}
+
+	int pc_get_channel_id(lua_State* L)
+	{
+		lua_pushnumber(L, g_bChannel);
+
+		return 1;
+	}
+
+	int pc_give_poly_marble(lua_State* L)
+	{
+		const int dwVnum = lua_tonumber(L, 1);
+
+		const CMob* MobInfo = CMobManager::instance().Get(dwVnum);
+
+		if (NULL == MobInfo)
+		{
+			lua_pushboolean(L, false);
+			return 1;
+		}
+
+		if (0 == MobInfo->m_table.dwPolymorphItemVnum)
+		{
+			lua_pushboolean(L, false);
+			return 1;
+		}
+
+		LPITEM item = ITEM_MANAGER::instance().CreateItem(MobInfo->m_table.dwPolymorphItemVnum);
+
+		if (NULL == item)
+		{
+			lua_pushboolean(L, false);
+			return 1;
+		}
+
+		item->SetSocket(0, dwVnum);
+
+		const LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		int iEmptyCell = ch->GetEmptyInventory(item->GetSize());
+
+		if (-1 == iEmptyCell)
+		{
+			M2_DESTROY_ITEM(item);
+			lua_pushboolean(L, false);
+			return 1;
+		}
+
+		item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyCell));
+
+		const PC* pPC = CQuestManager::instance().GetCurrentPC();
+
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), MobInfo->m_table.dwPolymorphItemVnum, dwVnum);
+
+		lua_pushboolean(L, true);
+
+		return 1;
+	}
+
+	int pc_get_sig_items(lua_State* L)
+	{
+		DWORD group_vnum = (DWORD)lua_tonumber(L, 1);
+		const LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		int count = 0;
+		for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+		{
+			if (ch->GetInventoryItem(i) != NULL && ch->GetInventoryItem(i)->GetSIGVnum() == group_vnum)
+			{
+				lua_pushnumber(L, ch->GetInventoryItem(i)->GetID());
+				count++;
+			}
+		}
+
+		return count;
+	}
+
+	int pc_charge_cash(lua_State* L)
+	{
+		TRequestChargeCash packet;
+
+		int amount = lua_isnumber(L, 1) ? (int)lua_tonumber(L, 1) : 0;
+		std::string strChargeType = lua_isstring(L, 2) ? lua_tostring(L, 2) : "";
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (NULL == ch || NULL == ch->GetDesc() || 1 > amount || 50000 < amount)
+		{
+			lua_pushboolean(L, 0);
+			return 1;
+		}
+
+		packet.dwAID = ch->GetDesc()->GetAccountTable().id;
+		packet.dwAmount = (DWORD)amount;
+		packet.eChargeType = ERequestCharge_Cash;
+
+		if (0 < strChargeType.length())
+			std::transform(strChargeType.begin(), strChargeType.end(), strChargeType.begin(), (int(*)(int))std::tolower);
+
+		if ("mileage" == strChargeType)
+			packet.eChargeType = ERequestCharge_Mileage;
+
+		db_clientdesc->DBPacketHeader(HEADER_GD_REQUEST_CHARGE_CASH, 0, sizeof(TRequestChargeCash));
+		db_clientdesc->Packet(&packet, sizeof(packet));
+
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+
+	int pc_give_award(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3))
+		{
+			sys_err("QUEST give award call error : wrong argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		DWORD dwVnum = (int)lua_tonumber(L, 1);
+
+		int icount = (int)lua_tonumber(L, 2);
+
+		sys_log(0, "QUEST [award] item %d to login %s", dwVnum, ch->GetDesc()->GetAccountTable().login);
+
+		DBManager::instance().Query("INSERT INTO item_award (login, vnum, count, given_time, why, mall)select '%s', %d, %d, now(), '%s', 1 from DUAL where not exists (select login, why from item_award where login = '%s' and why = '%s') ;",
+			ch->GetDesc()->GetAccountTable().login,
+			dwVnum,
+			icount,
+			lua_tostring(L, 3),
+			ch->GetDesc()->GetAccountTable().login,
+			lua_tostring(L, 3));
+
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+
+	int pc_give_award_socket(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isstring(L, 3) || !lua_isstring(L, 4) || !lua_isstring(L, 5) || !lua_isstring(L, 6))
+		{
+			sys_err("QUEST give award call error : wrong argument");
+			lua_pushnumber(L, 0);
+			return 1;
+		}
+
+		DWORD dwVnum = (int)lua_tonumber(L, 1);
+
+		int icount = (int)lua_tonumber(L, 2);
+
+		sys_log(0, "QUEST [award] item %d to login %s", dwVnum, ch->GetDesc()->GetAccountTable().login);
+
+		DBManager::instance().Query("INSERT INTO item_award (login, vnum, count, given_time, why, mall, socket0, socket1, socket2)select '%s', %d, %d, now(), '%s', 1, %s, %s, %s from DUAL where not exists (select login, why from item_award where login = '%s' and why = '%s') ;",
+			ch->GetDesc()->GetAccountTable().login,
+			dwVnum,
+			icount,
+			lua_tostring(L, 3),
+			lua_tostring(L, 4),
+			lua_tostring(L, 5),
+			lua_tostring(L, 6),
+			ch->GetDesc()->GetAccountTable().login,
+			lua_tostring(L, 3));
+
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+
+	int pc_get_informer_type(lua_State* L) //   
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (pChar != NULL)
+		{
+#if defined(_DEBUG)
+			// sys_err("quest cmd test %s", pChar->GetItemAward_cmd());
+#endif
+			lua_pushstring(L, pChar->GetItemAward_cmd());
+		}
+		else
+			lua_pushstring(L, "");
+
+		return 1;
+	}
+
+	int pc_get_informer_item(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (pChar != NULL)
+		{
+			lua_pushnumber(L, pChar->GetItemAward_vnum());
+		}
+		else
+			lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int pc_get_killee_drop_pct(lua_State* L)
+	{
+		LPCHARACTER pChar = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPCHARACTER pKillee = pChar->GetQuestNPC();
+
+		int iDeltaPercent, iRandRange;
+		if (NULL == pKillee || !ITEM_MANAGER::instance().GetDropPct(pKillee, pChar, iDeltaPercent, iRandRange))
+		{
+			sys_err("killee is null");
+			lua_pushnumber(L, -1);
+			lua_pushnumber(L, -1);
+
+			return 2;
+		}
+
+		lua_pushnumber(L, iDeltaPercent);
+		lua_pushnumber(L, iRandRange);
+
+		return 2;
+	}
+
+	int pc_get_ip(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (!ch) return 0;
+
+		lua_pushstring(L, ch->GetDesc()->GetHostName());
+		return 1;
+	}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	int pc_is_blocked(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong::pc_is_blocked");
+			return 0;
+		}
+
+		const char* arg1 = lua_tostring(L, 1);
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+		if (!tch || !tch->IsPC())
+		{
+			sys_err("wrong::pc_is_blocked-2");
+			return 0;
+		}
+
+		lua_pushboolean(L, CMessengerManager::instance().IsBlocked(ch->GetName(), tch->GetName()));
+		return 1;
+	}
+
+	int pc_is_friend(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("wrong::pc_is_blocked");
+			return 0;
+		}
+
+		const char* arg1 = lua_tostring(L, 1);
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+		if (!tch || !tch->IsPC())
+		{
+			sys_err("wrong::pc_is_blocked-2");
+			return 0;
+		}
+
+		lua_pushboolean(L, CMessengerManager::instance().IsInList(ch->GetName(), tch->GetName()));
+		return 1;
+	}
+#endif
+
+	int pc_change_race(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		if (!lua_isnumber(L, 1))
+		{
+			return 0;
+		}
+
+		ch->SetRace(lua_tonumber(L, 1));
+		ch->SetSkillGroup(0);
+		ch->ClearSkill();
+		ch->ClearSubSkill();
+		ch->SetPolymorph(101);
+		ch->SetPolymorph(0);
+		return 0;
+	}
+
+	int pc_unequip_select(lua_State* L)
+	{
+		if (!lua_isnumber(L, 1))
+		{
+			sys_err("QUEST wrong set flag");
+			return 0;
+		}
+
+		BYTE bCell = (BYTE)lua_tonumber(L, 1);
+
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		LPITEM item = CQuestManager::instance().GetCurrentCharacterPtr()->GetWear(bCell);
+
+		if (!ch || !item)
+			lua_pushnil(L);
+		else
+			if (ch->UnequipItem(item))
+				lua_pushnumber(L, item->GetVnum());
+			else
+				lua_pushnumber(L, 0);
+
+		return 1;
+	}
+
+	int pc_equip_slot(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		LPITEM item = ch->GetInventoryItem(lua_tonumber(L, 1));
+		lua_pushboolean(L, (item) ? ch->EquipItem(item) : false);
+		return 1;
+	}
+
+	int pc_dead(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (!ch) return 0;
+
+		ch->Dead();
+		return 1;
+	}
+
+	int pc_exchanging(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (!ch) return 0;
+
+		if (ch->GetExchange())
+			return 1;
+		else
+			return 0;
+	}
+
+	int pc_give_full_set(lua_State* L)
+	{
+		// g_bStartWithFullSet
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (ch)
+		{
+			BYTE job = ch->GetJob();
+			LPITEM item;
+
+			for (int i = 0; i < 6; i++)
+			{
+				item = ch->GetWear(i);
+				if (item != NULL)
+					ch->UnequipItem(item);
+			}
+
+			item = ch->GetWear(WEAR_SHIELD);
+			if (item != NULL)
+				ch->UnequipItem(item);
+
+			// Create Item
+			switch (job)
+			{
+				case JOB_WARRIOR:
+				{
+					item = ITEM_MANAGER::instance().CreateItem(11209); // Armor
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(19); // Weapon
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(12209); // Helmet
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+				}
+				break;
+
+				case JOB_ASSASSIN:
+				{
+					item = ITEM_MANAGER::instance().CreateItem(11409); // Armor
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(1009); // Weapon
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(12349); // Helmet
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+				}
+				break;
+
+				case JOB_SURA:
+				{
+					item = ITEM_MANAGER::instance().CreateItem(11609); // Armor
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(19); // Weapon
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(12489); // Helmet
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+				}
+				break;
+
+				case JOB_SHAMAN:
+				{
+					item = ITEM_MANAGER::instance().CreateItem(11809); // Armor
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(7009); // Weapon
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(12629); // Helmet
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+				}
+				break;
+
+				case JOB_WOLFMAN:
+				{
+					item = ITEM_MANAGER::instance().CreateItem(21009); // Armor
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(13009); // Shield
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(15009); // Shoes
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(6009); // Weapon
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(21509); // Helmet
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(14009); // Wrist
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(17009); // Eearings
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+					item = ITEM_MANAGER::instance().CreateItem(16009); // Necklace
+					if (!item || !item->EquipTo(ch, item->FindEquipCell(ch)))
+						M2_DESTROY_ITEM(item);
+				}
+				break;
+
+			}
+
+			// Set Attribute
+			switch (job)
+			{
+				case JOB_WARRIOR:
+				case JOB_ASSASSIN:
+				case JOB_SURA:
+				case JOB_SHAMAN:
+				case JOB_WOLFMAN:
+				{
+					//   .
+					// 隔拷  羚底 擔첨    肩 憺 .
+					item = ch->GetWear(WEAR_HEAD);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_ATT_SPEED, 8);
+						item->SetForceAttribute(1, APPLY_HP_REGEN, 30);
+						item->SetForceAttribute(2, APPLY_SP_REGEN, 30);
+						item->SetForceAttribute(3, APPLY_DODGE, 15);
+						item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
+					}
+
+					item = ch->GetWear(WEAR_WEAPON);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_CAST_SPEED, 20);
+						item->SetForceAttribute(1, APPLY_CRITICAL_PCT, 10);
+						item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
+						item->SetForceAttribute(3, APPLY_ATTBONUS_DEVIL, 20);
+						item->SetForceAttribute(4, APPLY_STR, 12);
+					}
+
+					item = ch->GetWear(WEAR_SHIELD);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_CON, 12);
+						item->SetForceAttribute(1, APPLY_BLOCK, 15);
+						item->SetForceAttribute(2, APPLY_REFLECT_MELEE, 10);
+						item->SetForceAttribute(3, APPLY_IMMUNE_STUN, 1);
+						item->SetForceAttribute(4, APPLY_IMMUNE_SLOW, 1);
+					}
+
+					item = ch->GetWear(WEAR_BODY);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+						item->SetForceAttribute(1, APPLY_CAST_SPEED, 20);
+						item->SetForceAttribute(2, APPLY_STEAL_HP, 10);
+						item->SetForceAttribute(3, APPLY_REFLECT_MELEE, 10);
+						item->SetForceAttribute(4, APPLY_ATT_GRADE_BONUS, 50);
+					}
+
+					item = ch->GetWear(WEAR_FOOTS);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+						item->SetForceAttribute(1, APPLY_MAX_SP, 80);
+						item->SetForceAttribute(2, APPLY_MOV_SPEED, 8);
+						item->SetForceAttribute(3, APPLY_ATT_SPEED, 8);
+						item->SetForceAttribute(4, APPLY_CRITICAL_PCT, 10);
+					}
+
+					item = ch->GetWear(WEAR_WRIST);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+						item->SetForceAttribute(1, APPLY_MAX_SP, 80);
+						item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
+						item->SetForceAttribute(3, APPLY_STEAL_HP, 10);
+						item->SetForceAttribute(4, APPLY_MANA_BURN_PCT, 10);
+					}
+
+					item = ch->GetWear(WEAR_NECK);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+						item->SetForceAttribute(1, APPLY_MAX_SP, 80);
+						item->SetForceAttribute(2, APPLY_CRITICAL_PCT, 10);
+						item->SetForceAttribute(3, APPLY_PENETRATE_PCT, 10);
+						item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
+					}
+
+					item = ch->GetWear(WEAR_EAR);
+					if (item != NULL)
+					{
+						item->ClearAttribute();
+						item->SetForceAttribute(0, APPLY_MOV_SPEED, 20);
+						item->SetForceAttribute(1, APPLY_MANA_BURN_PCT, 10);
+						item->SetForceAttribute(2, APPLY_POISON_REDUCE, 5);
+						item->SetForceAttribute(3, APPLY_ATTBONUS_DEVIL, 20);
+						item->SetForceAttribute(4, APPLY_ATTBONUS_UNDEAD, 20);
+					}
+				}
+				break;
+			}
+		}
+
+		ch->ComputePoints();
+
+		return 1;
+	}
+
+#if defined(__CONQUEROR_LEVEL__)
+	int pc_give_conqueror_exp2(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+		if (!lua_isnumber(L, 1))
+			return 0;
+
+		if (ch->GetConquerorLevel() == 0)
+			return 0;
+
+		sys_log(0, "QUEST [REWARD] %s give conqueror_exp2 %d", ch->GetName(), (int)rint(lua_tonumber(L, 1)));
+
+		DWORD exp = (DWORD)rint(lua_tonumber(L, 1));
+
+		PC* pPC = CQuestManager::instance().GetCurrentPC();
+		LogManager::instance().QuestRewardLog(pPC->GetCurrentQuestName().c_str(), ch->GetPlayerID(), ch->GetLevel(), exp, 0);
+		ch->PointChange(POINT_CONQUEROR_EXP, exp);
+		return 0;
+	}
+
+	int pc_get_conqueror_exp(lua_State* L)
+	{
+		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, pkChar ? pkChar->GetConquerorExp() : 0);
+		return 1;
+	}
+
+	int pc_get_conqueror_next_exp(lua_State* L)
+	{
+		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, pkChar ? pkChar->GetNextConquerorExp() : 0);
+		return 1;
+	}
+
+	int pc_get_conqueror_level(lua_State* L)
+	{
+		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
+		lua_pushnumber(L, pkChar ? pkChar->GetConquerorLevel() : 0);
+		return 1;
+	}
+
+	int pc_set_conqueror(lua_State* L)
+	{
+		LPCHARACTER pkChar = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (pkChar) pkChar->SetConqueror();
+		return 1;
+	}
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+	int pc_is_offline_shop_decoration(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+
+		bool decorationAffect = false;
+		
+		if (ch->IsAffectOfflineShopDecoration())
+			decorationAffect = true;
+
+		lua_pushboolean(L, decorationAffect);
+		return 1;
+	}
+
+	int pc_set_offline_shop_decoration(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+		
+		if (!lua_isnumber(L,1))
+			return 0;
+
+		int decorationRemain = lua_tonumber(L,1);
+		
+		bool success = false;
+
+		if(NULL == ch->FindAffect(AFFECT_OFFLINE_SHOP_DECORATION))
+		{
+			ch->AddAffect(AFFECT_OFFLINE_SHOP_DECORATION, APPLY_NONE, 0, AFF_NONE, decorationRemain, 0, false, false);
+			success = true;
+		}
+
+
+		lua_pushboolean(L, success);
+		return 1;
+	}
+	
+	int pc_unset_offline_shop_decoration(lua_State* L)
+	{
+		CQuestManager& q = CQuestManager::instance();
+		LPCHARACTER ch = q.GetCurrentCharacterPtr();
+		
+		ch->RemoveAffect(AFFECT_OFFLINE_SHOP_DECORATION);
+		
+		return 0;
+	}
+
+	int pc_send_unlock_shopdeco(lua_State* L)
+	{
+		LPCHARACTER ch = CQuestManager::instance().GetCurrentCharacterPtr();
+
+		ch->SetUnlockShopSkin((BYTE)lua_tonumber(L, 1));
+		ch->SetUnlockShopBanner((BYTE)lua_tonumber(L, 2));
+		ch->SendUnlockedShopDeco();
+
+		return 0;
+	}
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	int pc_select_item_ex(lua_State* L)
+	{
+		const LPCHARACTER c_lpCh = CQuestManager::instance().GetCurrentCharacterPtr();
+		if (c_lpCh == nullptr)
+			return 0;
+
+		c_lpCh->ChatPacket(CHAT_TYPE_COMMAND, "BINARY_OpenSelectItemWindowEx");
+		return 0;
+	}
+#endif
+
+	void RegisterPCFunctionTable()
+	{
+		luaL_reg pc_functions[] =
+		{
+			{ "get_wear", pc_get_wear },
+			{ "get_player_id", pc_get_player_id },
+			{ "get_account_id", pc_get_account_id },
+			{ "get_account", pc_get_account },
+			{ "get_level", pc_get_level },
+			{ "set_level", pc_set_level },
+			{ "get_next_exp", pc_get_next_exp },
+			{ "get_exp", pc_get_exp },
+			{ "get_job", pc_get_job },
+			{ "get_race", pc_get_race },
+			{ "change_sex", pc_change_sex },
+			{ "gethp", pc_get_hp },
+			{ "get_hp", pc_get_hp },
+			{ "getmaxhp", pc_get_max_hp },
+			{ "get_max_hp", pc_get_max_hp },
+			{ "getsp", pc_get_sp },
+			{ "get_sp", pc_get_sp },
+			{ "getmaxsp", pc_get_max_sp },
+			{ "get_max_sp", pc_get_max_sp },
+			{ "change_sp", pc_change_sp },
+			{ "getmoney", pc_get_money },
+			{ "get_money", pc_get_money },
+			{ "get_real_alignment", pc_get_real_alignment },
+			{ "get_alignment", pc_get_alignment },
+			{ "getweapon", pc_get_weapon },
+			{ "get_weapon", pc_get_weapon },
+			{ "getarmor", pc_get_armor },
+			{ "get_armor", pc_get_armor },
+			{ "getgold", pc_get_money },
+			{ "get_gold", pc_get_money },
+			{ "changegold", pc_change_money },
+			{ "changemoney", pc_change_money },
+			{ "changealignment", pc_change_alignment },
+			{ "change_gold", pc_change_money },
+			{ "change_money", pc_change_money },
+			{ "change_alignment", pc_change_alignment },
+			{ "getname", pc_get_name },
+			{ "get_name", pc_get_name },
+			{ "get_vid", pc_get_vid },
+			{ "getplaytime", pc_get_playtime },
+			{ "get_playtime", pc_get_playtime },
+			{ "getleadership", pc_get_leadership },
+			{ "get_leadership", pc_get_leadership },
+			{ "getqf", pc_get_quest_flag },
+			{ "setqf", pc_set_quest_flag },
+			{ "delqf", pc_del_quest_flag },
+			{ "getf", pc_get_another_quest_flag },
+			{ "setf", pc_set_another_quest_flag },
+			{ "get_x", pc_get_x },
+			{ "get_y", pc_get_y },
+			{ "getx", pc_get_x },
+			{ "gety", pc_get_y },
+			{ "get_local_x", pc_get_local_x },
+			{ "get_local_y", pc_get_local_y },
+			{ "getcurrentmapindex", pc_get_current_map_index },
+			{ "get_map_index", pc_get_current_map_index },
+			{ "give_exp", pc_give_exp },
+			{ "give_exp_perc", pc_give_exp_perc },
+			{ "give_exp2", pc_give_exp2 },
+			{ "give_item", pc_give_item },
+			{ "give_item2", pc_give_or_drop_item },
+			{ "give_item2_select", pc_give_or_drop_item_and_select },
+			{ "give_gold", pc_give_gold },
+			{ "count_item", pc_count_item },
+			{ "remove_item", pc_remove_item },
+			{ "countitem", pc_count_item },
+			{ "removeitem", pc_remove_item },
+			{ "reset_point", pc_reset_point },
+			{ "has_guild", pc_hasguild },
+			{ "hasguild", pc_hasguild },
+			{ "get_guild", pc_getguild },
+			{ "getguild", pc_getguild },
+			{ "isguildmaster", pc_is_guild_master },
+			{ "is_guild_master", pc_is_guild_master },
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__) //&& defined(__GUILD_RENEWAL__)
+			{ "isguildgeneral", pc_is_guild_general },
+			{ "is_guild_general", pc_is_guild_general },
+#endif
+			{ "destroy_guild", pc_destroy_guild },
+			{ "remove_from_guild", pc_remove_from_guild },
+			{ "in_dungeon", pc_in_dungeon },
+			{ "getempire", pc_get_empire },
+			{ "get_empire", pc_get_empire },
+			{ "get_skill_group", pc_get_skillgroup },
+			{ "set_skill_group", pc_set_skillgroup },
+#if defined(__DUNGEON_RENEWAL__)
+			{ "jump", pc_jump },
+#endif
+			{ "warp", pc_warp },
+			{ "warp_local", pc_warp_local },
+			{ "warp_exit", pc_warp_exit },
+			{ "set_warp_location", pc_set_warp_location },
+			{ "set_warp_location_local", pc_set_warp_location_local },
+			{ "get_start_location", pc_get_start_location },
+			{ "has_master_skill", pc_has_master_skill },
+			{ "set_part", pc_set_part },
+			{ "get_part", pc_get_part },
+			{ "is_polymorphed", pc_is_polymorphed },
+			{ "remove_polymorph", pc_remove_polymorph },
+			{ "is_mount", pc_is_mount },
+			{ "polymorph", pc_polymorph },
+			{ "mount", pc_mount },
+			{ "mount_bonus", pc_mount_bonus },
+			{ "unmount", pc_unmount },
+			{ "warp_to_guild_war_observer_position", pc_warp_to_guild_war_observer_position },
+#if defined(__DUNGEON_RENEWAL__)
+			{ "has_item_from_special_item_group", pc_has_item_from_special_item_group },
+			{ "remove_item_from_special_item_group", pc_remove_item_from_special_item_group },
+#endif
+			{ "give_item_from_special_item_group", pc_give_item_from_special_item_group },
+			{ "learn_grand_master_skill", pc_learn_grand_master_skill },
+			{ "is_skill_book_no_delay", pc_is_skill_book_no_delay },
+			{ "remove_skill_book_no_delay", pc_remove_skill_book_no_delay },
+
+			{ "enough_inventory", pc_enough_inventory },
+			{ "get_horse", pc_get_horse }, // TO BE DELETED XXX
+			{ "get_horse_level", pc_get_horse_level }, // TO BE DELETED XXX
+			{ "is_horse_alive", pc_is_horse_alive }, // TO BE DELETED XXX
+			{ "revive_horse", pc_revive_horse }, // TO BE DELETED XXX
+			{ "have_pos_scroll", pc_have_pos_scroll },
+			{ "have_map_scroll", pc_have_map_scroll },
+			{ "get_war_map", pc_get_war_map },
+			{ "get_equip_refine_level", pc_get_equip_refine_level },
+			{ "refine_equip", pc_refine_equip },
+			{ "get_skill_level", pc_get_skill_level },
+			{ "give_lotto", pc_give_lotto },
+			{ "aggregate_monster", pc_aggregate_monster },
+			{ "forget_my_attacker", pc_forget_my_attacker },
+			{ "attract_ranger", pc_attract_ranger },
+			{ "select", pc_select_vid },
+			{ "get_sex", pc_get_sex },
+			{ "is_married", pc_is_married },
+			{ "is_engaged", pc_is_engaged },
+			{ "is_engaged_or_married", pc_is_engaged_or_married },
+			{ "is_gm", pc_is_gm },
+			{ "get_gm_level", pc_get_gm_level },
+			{ "mining", pc_mining },
+			{ "ore_refine", pc_ore_refine },
+			{ "diamond_refine", pc_diamond_refine },
+
+			// RESET_ONE_SKILL
+			{ "clear_one_skill", pc_clear_one_skill },
+			// END_RESET_ONE_SKILL
+
+			{ "clear_skill", pc_clear_skill },
+			{ "clear_sub_skill", pc_clear_sub_skill },
+			{ "set_skill_point", pc_set_skill_point },
+
+			{ "is_clear_skill_group", pc_is_clear_skill_group },
+
+			{ "save_exit_location", pc_save_exit_location },
+			{ "teleport", pc_teleport },
+
+			{ "set_skill_level", pc_set_skill_level },
+
+			{ "give_polymorph_book", pc_give_polymorph_book },
+			{ "upgrade_polymorph_book", pc_upgrade_polymorph_book },
+			{ "get_premium_remain_sec", pc_get_premium_remain_sec },
+
+			{ "send_block_mode", pc_send_block_mode },
+
+			{ "change_empire", pc_change_empire },
+			{ "get_change_empire_count", pc_get_change_empire_count },
+			{ "set_change_empire_count", pc_set_change_empire_count },
+
+			{ "change_name", pc_change_name },
+
+			{ "is_dead", pc_is_dead },
+
+			{ "reset_status", pc_reset_status },
+			{ "get_ht", pc_get_ht },
+			{ "set_ht", pc_set_ht },
+			{ "get_iq", pc_get_iq },
+			{ "set_iq", pc_set_iq },
+			{ "get_st", pc_get_st },
+			{ "set_st", pc_set_st },
+			{ "get_dx", pc_get_dx },
+			{ "set_dx", pc_set_dx },
+
+#if defined(__CONQUEROR_LEVEL__)
+			{ "reset_sungma_status", pc_reset_sungma_status },
+			{ "get_sungma_str", pc_get_sungma_str }, // sstr
+			{ "get_sungma_vit", pc_get_sungma_vit }, // shp
+			{ "get_sungma_res", pc_get_sungma_res }, // smove
+			{ "get_sungma_int", pc_get_sungma_int }, // simmune
+#endif
+
+			{ "is_near_vid", pc_is_near_vid },
+
+			{ "get_socket_items", pc_get_socket_items },
+			{ "get_empty_inventory_count", pc_get_empty_inventory_count },
+
+			{ "get_logoff_interval", pc_get_logoff_interval },
+			{ "get_last_play", pc_get_last_play },
+
+			{ "is_riding", pc_is_riding },
+			{ "get_special_ride_vnum", pc_get_special_ride_vnum },
+
+			{ "can_warp", pc_can_warp },
+
+			{ "dec_skill_point", pc_dec_skill_point },
+			{ "get_skill_point", pc_get_skill_point },
+
+			{ "get_channel_id", pc_get_channel_id },
+
+			{ "give_poly_marble", pc_give_poly_marble },
+			{ "get_sig_items", pc_get_sig_items },
+
+			{ "charge_cash", pc_charge_cash },
+
+			{ "get_informer_type", pc_get_informer_type }, //   
+			{ "get_informer_item", pc_get_informer_item },
+
+			{ "give_award", pc_give_award }, // 瞿  箕 膚 
+			{ "give_award_socket", pc_give_award_socket }, //  觀訝  .    獨.
+
+			{ "get_killee_drop_pct", pc_get_killee_drop_pct }, /* mob_vnum.kill 遣트 killee pc level , pc 潔      확.
+			* return  (, 龜).
+			* ( 祁, CreateDropItem GetDropPct iDeltaPercent, iRandRange return磯鳴  .)
+			* (    圭)
+			* 퓨 : kill event  !
+			*/
+
+#if defined(__DICE_SYSTEM__)
+			{ "give_item2_with_dice", pc_give_or_drop_item_with_dice },
+#endif
+
+#if defined(__CHEQUE_SYSTEM__)
+			{ "get_cheque", pc_get_cheque },
+			{ "change_cheque", pc_change_cheque },
+			{ "give_cheque", pc_give_cheque },
+			{ "exchange_cheque", pc_exchange_cheque },
+			{ "exchange_gold", pc_exchange_gold },
+#endif
+
+#if defined(__GEM_SYSTEM__)
+			{ "get_gem", pc_get_gem },
+			{ "change_gem", pc_change_gem },
+			{ "give_gem", pc_give_gem },
+#endif
+
+			{ "get_ip", pc_get_ip },
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+			{ "is_blocked", pc_is_blocked },
+			{ "is_friend", pc_is_friend },
+#endif
+
+			{ "change_race", pc_change_race },
+			{ "change_job", pc_change_race },
+			{ "unequip_select", pc_unequip_select },
+			{ "equip_slot", pc_equip_slot },
+
+			{ "dead", pc_dead },
+			{ "exchanging", pc_exchanging },
+
+			{ "give_full_set", pc_give_full_set },
+
+#if defined(__CONQUEROR_LEVEL__)
+			{ "give_conqueror_exp2", pc_give_conqueror_exp2 },
+			{ "get_conqueror_exp", pc_get_conqueror_exp },
+			{ "get_conqueror_next_exp", pc_get_conqueror_next_exp },
+			{ "get_conqueror_level", pc_get_conqueror_level },
+			{ "set_conqueror", pc_set_conqueror },
+#endif
+
+#if defined(__GEM_SYSTEM__)
+			{ "select_item_ex", pc_select_item_ex },
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+			{ "is_offline_shop_decoration", 	pc_is_offline_shop_decoration },
+			{ "set_offline_shop_decoration", 	pc_set_offline_shop_decoration },
+			{ "unset_offline_shop_decoration", 	pc_unset_offline_shop_decoration },
+			{ "send_unlock_shopdeco", pc_send_unlock_shopdeco },
+#endif
+
+			{ NULL, NULL }
+		};
+
+		CQuestManager::instance().AddLuaFunctionTable("pc", pc_functions);
+	}
+};
diff --git a/server/metin2/Source/Server/game/src/shop_manager.cpp b/server/metin2/Source/Server/game/src/shop_manager.cpp
index b1c6c08..fc02cee 100644
--- a/server/metin2/Source/Server/game/src/shop_manager.cpp
+++ b/server/metin2/Source/Server/game/src/shop_manager.cpp
@@ -1,707 +1,726 @@
-#include "stdafx.h"
-#include "../../libgame/include/grid.h"
-#include "constants.h"
-#include "utils.h"
-#include "config.h"
-#include "shop.h"
-#include "desc.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item.h"
-#include "item_manager.h"
-#include "buffer_manager.h"
-#include "packet.h"
-#include "log.h"
-#include "db.h"
-#include "questmanager.h"
-#include "monarch.h"
-#include "mob_manager.h"
-#include "locale_service.h"
-#include "desc_client.h"
-#include "shop_manager.h"
-#include "group_text_parse_tree.h"
-#include "shopEx.h"
-#include "shop_manager.h"
-#include <cctype>
-
-CShopManager::CShopManager()
-{
-}
-
-CShopManager::~CShopManager()
-{
-	Destroy();
-}
-
-bool CShopManager::Initialize(TShopTable* table, int size)
-{
-	if (!m_map_pkShop.empty())
-		return false;
-
-	int i;
-
-	for (i = 0; i < size; ++i, ++table)
-	{
-		LPSHOP shop = M2_NEW CShop;
-
-		if (!shop->Create(table->dwVnum, table->dwNPCVnum, table->items))
-		{
-			M2_DELETE(shop);
-			continue;
-		}
-
-		m_map_pkShop.insert(TShopMap::value_type(table->dwVnum, shop));
-		m_map_pkShopByNPCVnum.insert(TShopMap::value_type(table->dwNPCVnum, shop));
-	}
-
-	char szShopTableExFileName[256];
-	snprintf(szShopTableExFileName, sizeof(szShopTableExFileName),
-		"%s/shop_table_ex.txt", LocaleService_GetBasePath().c_str());
-
-	return ReadShopTableEx(szShopTableExFileName);
-}
-
-void CShopManager::Destroy()
-{
-	TShopMap::iterator it = m_map_pkShop.begin();
-	std::unordered_set<decltype(m_map_pkShop)::value_type::second_type> collector; // avoid delete duplicate objects(unique key)
-	while (it != m_map_pkShop.end())
-	{
-		//delete it->second;
-		collector.insert(it->second);
-		++it;
-	}
-	for (auto& v : collector)
-		delete v;
-
-	m_map_pkShop.clear();
-}
-
-LPSHOP CShopManager::Get(DWORD dwVnum)
-{
-	TShopMap::const_iterator it = m_map_pkShop.find(dwVnum);
-
-	if (it == m_map_pkShop.end())
-		return NULL;
-
-	return (it->second);
-}
-
-LPSHOP CShopManager::GetByNPCVnum(DWORD dwVnum)
-{
-	TShopMap::const_iterator it = m_map_pkShopByNPCVnum.find(dwVnum);
-
-	if (it == m_map_pkShopByNPCVnum.end())
-		return NULL;
-
-	return (it->second);
-}
-
-/*
-* 인터페이스 함수들
-*/
-
-// 상점 거래를 시작
-bool CShopManager::StartShopping(LPCHARACTER pkChr, LPCHARACTER pkChrShopKeeper, int iShopVnum)
-{
-#if defined(__QUEST_EVENT_BUY_SELL__)
-	if (pkChr->GetShop())
-		return false;
-#endif
-
-	if (pkChr->GetShopOwner() == pkChrShopKeeper)
-		return false;
-
-	// this method is only for NPC
-	if (pkChrShopKeeper->IsPC())
-		return false;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	/*
-	if (pkChr->GetActiveGrowthPet())
-	{
-		pkChr->ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
-		return false;
-	}
-	*/
-	
-	if (pkChr->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || pkChr->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		pkChr->ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
-		return false;
-	}
-#endif
-
-	// PREVENT_TRADE_WINDOW
-	if (pkChr->PreventTradeWindow(WND_SHOPOWNER, true/*except*/))
-	{
-		pkChr->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래창이 열린상태에서는 상점거래를 할수 가 없습니다."));
-		return false;
-	}
-	// END_PREVENT_TRADE_WINDOW
-
-	long distance = DISTANCE_APPROX(pkChr->GetX() - pkChrShopKeeper->GetX(), pkChr->GetY() - pkChrShopKeeper->GetY());
-
-	if (distance >= SHOP_MAX_DISTANCE)
-	{
-		sys_log(1, "SHOP: TOO_FAR: %s distance %d", pkChr->GetName(), distance);
-		return false;
-	}
-
-	LPSHOP pkShop;
-
-	if (iShopVnum)
-		pkShop = Get(iShopVnum);
-	else
-		pkShop = GetByNPCVnum(pkChrShopKeeper->GetRaceNum());
-
-	if (!pkShop)
-	{
-		sys_log(1, "SHOP: NO SHOP");
-		return false;
-	}
-
-	bool bOtherEmpire = false;
-
-	if (pkChr->GetEmpire() != pkChrShopKeeper->GetEmpire())
-		bOtherEmpire = true;
-
-	pkShop->AddGuest(pkChr, pkChrShopKeeper->GetVID(), bOtherEmpire);
-	pkChr->SetShopOwner(pkChrShopKeeper);
-	sys_log(0, "SHOP: START: %s", pkChr->GetName());
-	return true;
-}
-
-LPSHOP CShopManager::FindPCShop(DWORD dwVID)
-{
-	TShopMap::iterator it = m_map_pkShopByPC.find(dwVID);
-
-	if (it == m_map_pkShopByPC.end())
-		return NULL;
-
-	return it->second;
-}
-
-LPSHOP CShopManager::CreatePCShop(LPCHARACTER ch, TShopItemTable* pTable, BYTE bItemCount)
-{
-	if (FindPCShop(ch->GetVID()))
-		return NULL;
-
-	LPSHOP pkShop = M2_NEW CShop;
-	pkShop->SetPCShop(ch);
-	pkShop->SetShopItems(pTable, bItemCount);
-
-	m_map_pkShopByPC.insert(TShopMap::value_type(ch->GetVID(), pkShop));
-	return pkShop;
-}
-
-void CShopManager::DestroyPCShop(LPCHARACTER ch)
-{
-	LPSHOP pkShop = FindPCShop(ch->GetVID());
-
-	if (!pkShop)
-		return;
-
-	// PREVENT_ITEM_COPY;
-	ch->SetMyShopTime();
-	// END_PREVENT_ITEM_COPY
-
-	m_map_pkShopByPC.erase(ch->GetVID());
-	M2_DELETE(pkShop);
-}
-
-// 상점 거래를 종료
-void CShopManager::StopShopping(LPCHARACTER ch)
-{
-	LPSHOP shop;
-
-	if (!(shop = ch->GetShop()))
-		return;
-
-	// PREVENT_ITEM_COPY;
-	ch->SetMyShopTime();
-	// END_PREVENT_ITEM_COPY
-
-	shop->RemoveGuest(ch);
-	sys_log(0, "SHOP: END: %s", ch->GetName());
-}
-
-// 아이템 구입
-void CShopManager::Buy(LPCHARACTER ch, BYTE pos)
-{
-	if (!ch->GetShop())
-		return;
-
-	if (!ch->GetShopOwner())
-		return;
-
-	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상점과의 거리가 너무 멀어 물건을 살 수 없습니다."));
-		return;
-	}
-
-	CShop* pkShop = ch->GetShop();
-	if (!pkShop)
-		return;
-
-	// PREVENT_ITEM_COPY
-	ch->SetMyShopTime();
-	// END_PREVENT_ITEM_COPY
-
-	int ret = pkShop->Buy(ch, pos);
-
-	if (SHOP_SUBHEADER_GC_OK != ret) // 문제가 있었으면 보낸다.
-	{
-		TPacketGCShop pack;
-
-		pack.header = HEADER_GC_SHOP;
-		pack.subheader = ret;
-		pack.size = sizeof(TPacketGCShop);
-
-		ch->GetDesc()->Packet(&pack, sizeof(pack));
-	}
-}
-
-void CShopManager::Sell(LPCHARACTER ch, WORD wCell, WORD wCount, BYTE bType)
-{
-	if (!ch->GetShop())
-		return;
-
-	if (!ch->GetShopOwner())
-		return;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	if (ch->GetShop()->IsPCShop())
-		return;
-
-	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상점과의 거리가 너무 멀어 물건을 팔 수 없습니다."));
-		return;
-	}
-
-	LPITEM item = ch->GetInventoryItem(wCell);
-
-	if (!item)
-		return;
-
-	if (item->IsEquipped() == true)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("착용 중인 아이템은 판매할 수 없습니다."));
-		return;
-	}
-
-	if (true == item->isLocked())
-		return;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (item->IsPet())
-		return;
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot sell a soulbound item."));
-		return;
-	}
-#endif
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_SELL))
-		return;
-
-	DWORD dwPrice;
-
-	if (wCount == 0 || wCount > item->GetCount())
-		wCount = item->GetCount();
-
-	dwPrice = item->GetShopSellPrice();
-
-	if (IS_SET(item->GetFlag(), ITEM_FLAG_COUNT_PER_1GOLD))
-	{
-		if (dwPrice == 0)
-			dwPrice = wCount;
-		else
-			dwPrice = wCount / dwPrice;
-	}
-	else
-		dwPrice *= wCount;
-
-	dwPrice /= 5;
-
-	// 세금 계산
-	DWORD dwTax = 0;
-	int iVal = 3;
-
-	dwTax = dwPrice * iVal / 100;
-	dwPrice -= dwTax;
-
-	if (test_server)
-		sys_log(0, "Sell Item price id %d %s itemid %d", ch->GetPlayerID(), ch->GetName(), item->GetID());
-
-	const int64_t nTotalMoney = static_cast<int64_t>(ch->GetGold()) + static_cast<int64_t>(dwPrice);
-	if (GOLD_MAX <= nTotalMoney)
-	{
-		sys_err("[OVERFLOW_GOLD] id %u name %s gold %d", ch->GetPlayerID(), ch->GetName(), ch->GetGold());
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("20억냥이 초과하여 물품을 팔수 없습니다."));
-		return;
-	}
-
-	// 20050802.myevan.상점 판매 로그에 아이템 ID 추가
-	sys_log(0, "SHOP: SELL: %s item name: %s(x%d):%u price: %u", ch->GetName(), item->GetName(), wCount, item->GetID(), dwPrice);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	ch->UpdateExtBattlePassMissionProgress(BP_ITEM_SELL, wCount, item->GetVnum());
-#endif
-
-	if (iVal > 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("판매금액의 %d %% 가 세금으로 나가게됩니다", iVal));
-
-	DBManager::instance().SendMoneyLog(MONEY_LOG_SHOP, item->GetVnum(), dwPrice);
-
-#if defined(__QUEST_EVENT_BUY_SELL__)
-	CShop* pkShop = ch->GetShop();
-	if (pkShop)
-	{
-		ch->SetQuestNPCID(ch->GetShopOwner() ? ch->GetShopOwner()->GetVID() : 0);
-		quest::CQuestManager::instance().SellItem(ch->GetPlayerID(), pkShop->GetNPCVnum(), item);
-	}
-#endif
-
-	if (wCount == item->GetCount())
-		ITEM_MANAGER::instance().RemoveItem(item, "SELL");
-	else
-		item->SetCount(item->GetCount() - wCount);
-
-	// 군주 시스템 : 세금 징수
-	CMonarch::instance().SendtoDBAddMoney(dwTax, ch->GetEmpire(), ch);
-
-	ch->PointChange(POINT_GOLD, dwPrice, false);
-}
-
-bool CompareShopItemName(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
-	TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
-	if (lItem && rItem)
-		return strcmp(lItem->szLocaleName, rItem->szLocaleName) < 0;
-	else
-		return true;
-}
-
-#if defined(__SHOPEX_RENEWAL__)
-bool CompareShopItemVnum(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	return lhs.vnum > rhs.vnum;
-}
-
-bool CompareShopItemPrice(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	return lhs.price > rhs.price;
-}
-
-bool CompareShopItemType(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	const TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
-	const TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
-	return (lItem && rItem) ? lItem->bType > rItem->bType : true;
-}
-#endif
-
-static bool iequals(const std::string& a, const std::string& b)
-{
-	return std::equal(a.begin(), a.end(),
-		b.begin(), b.end(),
-		[](char a, char b) {
-			return tolower(a) == tolower(b);
-		});
-}
-
-bool ConvertToShopItemTable(IN CGroupNode* pNode, OUT TShopTableEx& shopTable)
-{
-	if (!pNode->GetValue("vnum", 0, shopTable.dwVnum))
-	{
-		sys_err("Group %s does not have vnum.", pNode->GetNodeName().c_str());
-		return false;
-	}
-
-	if (!pNode->GetValue("name", 0, shopTable.name))
-	{
-		sys_err("Group %s does not have name.", pNode->GetNodeName().c_str());
-		return false;
-	}
-
-	if (shopTable.name.length() >= SHOP_TAB_NAME_MAX)
-	{
-		sys_err("Shop name length must be less than %d. Error in Group %s, name %s", SHOP_TAB_NAME_MAX, pNode->GetNodeName().c_str(), shopTable.name.c_str());
-		return false;
-	}
-
-	std::string stCoinType;
-	if (!pNode->GetValue("cointype", 0, stCoinType))
-	{
-		stCoinType = "Gold";
-	}
-
-	if (iequals(stCoinType, "Gold"))
-	{
-		shopTable.coinType = SHOP_COIN_TYPE_GOLD;
-	}
-	else if (iequals(stCoinType, "SecondaryCoin"))
-	{
-		shopTable.coinType = SHOP_COIN_TYPE_SECONDARY_COIN;
-	}
-	else
-	{
-		sys_err("Group %s has undefine cointype(%s).", pNode->GetNodeName().c_str(), stCoinType.c_str());
-		return false;
-	}
-
-	CGroupNode* pItemGroup = pNode->GetChildNode("items");
-	if (!pItemGroup)
-	{
-		sys_err("Group %s does not have 'group items'.", pNode->GetNodeName().c_str());
-		return false;
-	}
-
-	size_t itemGroupSize = pItemGroup->GetRowCount();
-	std::vector<TShopItemTable> shopItems(itemGroupSize);
-	if (itemGroupSize >= SHOP_HOST_ITEM_MAX_NUM)
-	{
-		sys_err("count(%d) of rows of group items of group %s must be smaller than %d", itemGroupSize, pNode->GetNodeName().c_str(), SHOP_HOST_ITEM_MAX_NUM);
-		return false;
-	}
-
-	for (size_t i = 0; i < itemGroupSize; i++)
-	{
-		if (!pItemGroup->GetValue(i, "vnum", shopItems[i].vnum))
-		{
-			sys_err("row(%d) of group items of group %s does not have vnum column", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		if (!pItemGroup->GetValue(i, "count", shopItems[i].count))
-		{
-			sys_err("row(%d) of group items of group %s does not have count column", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		if (!pItemGroup->GetValue(i, "price", shopItems[i].price))
-		{
-			sys_err("row(%d) of group items of group %s does not have price column", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		// NOTE : Set the item price to the default item proto shop buy price.
-		if (shopItems[i].price == 0)
-		{
-			TItemTable* itemTable = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
-			if (itemTable != NULL)
-				shopItems[i].price = itemTable->dwShopBuyPrice * shopItems[i].count;
-		}
-
-#if defined(__SHOPEX_RENEWAL__)
-		if (shopItems[i].bPriceType >= SHOP_COIN_MAX_TYPE)
-		{
-			sys_err("row(%d) of group items of group %s price_type is wrong!", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		char getval[20];
-		for (int j = 0; j < ITEM_SOCKET_MAX_NUM; j++)
-		{
-			snprintf(getval, sizeof(getval), "socket%d", j);
-			if (!pItemGroup->GetValue(i, getval, shopItems[i].alSockets[j]))
-			{
-				sys_err("row(%d) stage %d of group items of group %s does not have socket column", i, j, pNode->GetNodeName().c_str());
-				return false;
-			}
-		}
-
-		if (pItemGroup->GetValue(i, "price_type", shopItems[i].bPriceType) &&
-			pItemGroup->GetValue(i, "price_vnum", shopItems[i].dwPriceVnum) &&
-			shopItems[i].bPriceType == SHOP_COIN_TYPE_ITEM)
-		{
-			if (!ITEM_MANAGER::instance().GetTable(shopItems[i].dwPriceVnum))
-			{
-				sys_err("CANNOT GET ITEM PROTO %d", shopItems[i].dwPriceVnum);
-				return false;
-			}
-		}
-#endif
-	}
-
-	std::string stSort;
-	if (!pNode->GetValue("sort", 0, stSort))
-		stSort = "None";
-
-	if (iequals(stSort, "Asc"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
-	else if (iequals(stSort, "Desc"))
-		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemName);
-#if defined(__SHOPEX_RENEWAL__)
-	else if (iequals(stSort, "Vnum"))
-		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemVnum);
-	else if (iequals(stSort, "Price"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemPrice);
-	else if (iequals(stSort, "Name"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
-	else if (iequals(stSort, "Type"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemType);
-#endif
-
-	CGrid grid = CGrid(CShop::SHOP_GRID_WIDTH, CShop::SHOP_GRID_HEIGHT);
-	int iPos;
-
-	memset(&shopTable.items[0], 0, sizeof(shopTable.items));
-
-	for (size_t i = 0; i < shopItems.size(); i++)
-	{
-		TItemTable* item_table = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
-		if (!item_table)
-		{
-			sys_err("vnum(%d) of group items of group %s does not exist", shopItems[i].vnum, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		iPos = grid.FindBlank(1, item_table->bSize);
-
-		grid.Put(iPos, 1, item_table->bSize);
-		shopTable.items[iPos] = shopItems[i];
-	}
-
-	shopTable.bItemCount = shopItems.size();
-	return true;
-}
-
-bool CShopManager::ReadShopTableEx(const char* stFileName)
-{
-	// file 유무 체크.
-	// 없는 경우는 에러로 처리하지 않는다.
-	FILE* fp = fopen(stFileName, "rb");
-	if (NULL == fp)
-		return true;
-	fclose(fp);
-
-	CGroupTextParseTreeLoader loader;
-	if (!loader.Load(stFileName))
-	{
-		sys_err("%s Load fail.", stFileName);
-		return false;
-	}
-
-	CGroupNode* pShopNPCGroup = loader.GetGroup("shopnpc");
-	if (NULL == pShopNPCGroup)
-	{
-		sys_err("Group ShopNPC is not exist.");
-		return false;
-	}
-
-	typedef std::multimap <DWORD, TShopTableEx> TMapNPCshop;
-	TMapNPCshop map_npcShop;
-
-#if defined(__SHOPEX_RENEWAL__)
-	{
-		std::unordered_set<CShop*> v;
-		// include unordered_set
-		auto ExDelete = [&v](TShopMap& c)
-		{
-			for (auto it = c.begin(); !c.empty() && it != c.end();)
-			{
-				const auto shop = it->second;
-				if (shop && shop->IsShopEx())
-				{
-					it = c.erase(it);
-					v.insert(shop);
-				}
-				else
-					++it;
-			}
-		};
-		ExDelete(m_map_pkShopByNPCVnum);
-		ExDelete(m_map_pkShop);
-		for (const auto& del : v)
-			delete del;
-	}
-#endif
-
-	for (size_t i = 0; i < pShopNPCGroup->GetRowCount(); i++)
-	{
-		DWORD npcVnum;
-		std::string shopName;
-		if (!pShopNPCGroup->GetValue(i, "npc", npcVnum) || !pShopNPCGroup->GetValue(i, "group", shopName))
-		{
-			sys_err("Invalid row(%d). Group ShopNPC rows must have 'npc', 'group' columns", i);
-			return false;
-		}
-		std::transform(shopName.begin(), shopName.end(), shopName.begin(), (int(*)(int))std::tolower);
-		CGroupNode* pShopGroup = loader.GetGroup(shopName.c_str());
-		if (!pShopGroup)
-		{
-			sys_err("Group %s is not exist.", shopName.c_str());
-			return false;
-		}
-		TShopTableEx table;
-		if (!ConvertToShopItemTable(pShopGroup, table))
-		{
-			sys_err("Cannot read Group %s.", shopName.c_str());
-			return false;
-		}
-		if (m_map_pkShopByNPCVnum.find(npcVnum) != m_map_pkShopByNPCVnum.end())
-		{
-			sys_err("%d cannot have both original shop and extended shop", npcVnum);
-			return false;
-		}
-
-		map_npcShop.insert(TMapNPCshop::value_type(npcVnum, table));
-	}
-
-	for (TMapNPCshop::iterator it = map_npcShop.begin(); it != map_npcShop.end(); ++it)
-	{
-		DWORD npcVnum = it->first;
-		TShopTableEx& table = it->second;
-		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
-		{
-			sys_err("Shop vnum(%d) already exists", table.dwVnum);
-			return false;
-		}
-		TShopMap::iterator shop_it = m_map_pkShopByNPCVnum.find(npcVnum);
-
-		LPSHOPEX pkShopEx = NULL;
-		if (m_map_pkShopByNPCVnum.end() == shop_it)
-		{
-			pkShopEx = M2_NEW CShopEx;
-			pkShopEx->Create(0, npcVnum);
-			m_map_pkShopByNPCVnum.insert(TShopMap::value_type(npcVnum, pkShopEx));
-		}
-		else
-		{
-			pkShopEx = dynamic_cast <CShopEx*> (shop_it->second);
-			if (NULL == pkShopEx)
-			{
-				sys_err("WTF!!! It can't be happend. NPC(%d) Shop is not extended version.", shop_it->first);
-				return false;
-			}
-		}
-
-		if (pkShopEx->GetTabCount() >= SHOP_TAB_COUNT_MAX)
-		{
-			sys_err("ShopEx cannot have tab more than %d", SHOP_TAB_COUNT_MAX);
-			return false;
-		}
-
-		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
-		{
-			sys_err("Shop vnum(%d) already exist.", table.dwVnum);
-			return false;
-		}
-		m_map_pkShop.insert(TShopMap::value_type(table.dwVnum, pkShopEx));
-		pkShopEx->AddShopTable(table);
-	}
-
-	return true;
-}
+#include "stdafx.h"
+#include "../../libgame/include/grid.h"
+#include "constants.h"
+#include "utils.h"
+#include "config.h"
+#include "shop.h"
+#include "desc.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item.h"
+#include "item_manager.h"
+#include "buffer_manager.h"
+#include "packet.h"
+#include "log.h"
+#include "db.h"
+#include "questmanager.h"
+#include "monarch.h"
+#include "mob_manager.h"
+#include "locale_service.h"
+#include "desc_client.h"
+#include "shop_manager.h"
+#include "group_text_parse_tree.h"
+#include "shopEx.h"
+#include "shop_manager.h"
+#include <cctype>
+
+CShopManager::CShopManager()
+{
+}
+
+CShopManager::~CShopManager()
+{
+	Destroy();
+}
+
+bool CShopManager::Initialize(TShopTable* table, int size)
+{
+	if (!m_map_pkShop.empty())
+		return false;
+
+	int i;
+
+	for (i = 0; i < size; ++i, ++table)
+	{
+		LPSHOP shop = M2_NEW CShop;
+
+		if (!shop->Create(table->dwVnum, table->dwNPCVnum, table->items))
+		{
+			M2_DELETE(shop);
+			continue;
+		}
+
+		m_map_pkShop.insert(TShopMap::value_type(table->dwVnum, shop));
+		m_map_pkShopByNPCVnum.insert(TShopMap::value_type(table->dwNPCVnum, shop));
+	}
+
+	char szShopTableExFileName[256];
+	snprintf(szShopTableExFileName, sizeof(szShopTableExFileName),
+		"%s/shop_table_ex.txt", LocaleService_GetBasePath().c_str());
+
+	return ReadShopTableEx(szShopTableExFileName);
+}
+
+void CShopManager::Destroy()
+{
+	TShopMap::iterator it = m_map_pkShop.begin();
+	std::unordered_set<decltype(m_map_pkShop)::value_type::second_type> collector; // avoid delete duplicate objects(unique key)
+	while (it != m_map_pkShop.end())
+	{
+		//delete it->second;
+		collector.insert(it->second);
+		++it;
+	}
+	for (auto& v : collector)
+		delete v;
+
+	m_map_pkShop.clear();
+	m_map_pkShopByNPCVnum.clear(); // avoid dangling pointers
+
+	// also free PC shops on shutdown
+	{
+		TShopMap::iterator itPC = m_map_pkShopByPC.begin();
+		while (itPC != m_map_pkShopByPC.end())
+		{
+			delete itPC->second;
+			++itPC;
+		}
+		m_map_pkShopByPC.clear();
+	}
+}
+
+LPSHOP CShopManager::Get(DWORD dwVnum)
+{
+	TShopMap::const_iterator it = m_map_pkShop.find(dwVnum);
+
+	if (it == m_map_pkShop.end())
+		return NULL;
+
+	return (it->second);
+}
+
+LPSHOP CShopManager::GetByNPCVnum(DWORD dwVnum)
+{
+	TShopMap::const_iterator it = m_map_pkShopByNPCVnum.find(dwVnum);
+
+	if (it == m_map_pkShopByNPCVnum.end())
+		return NULL;
+
+	return (it->second);
+}
+
+/*
+* 決 獨
+*/
+
+//  킹 
+bool CShopManager::StartShopping(LPCHARACTER pkChr, LPCHARACTER pkChrShopKeeper, int iShopVnum)
+{
+#if defined(__QUEST_EVENT_BUY_SELL__)
+	if (pkChr->GetShop())
+		return false;
+#endif
+
+	if (pkChr->GetShopOwner() == pkChrShopKeeper)
+		return false;
+
+	// this method is only for NPC
+	if (pkChrShopKeeper->IsPC())
+		return false;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	/*
+	if (pkChr->GetActiveGrowthPet())
+	{
+		pkChr->ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
+		return false;
+	}
+	*/
+	
+	if (pkChr->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || pkChr->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		pkChr->ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
+		return false;
+	}
+#endif
+
+	// PREVENT_TRADE_WINDOW
+	if (pkChr->PreventTradeWindow(WND_SHOPOWNER, true/*except*/))
+	{
+		pkChr->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹창 쩔 킹 寗  求."));
+		return false;
+	}
+	// END_PREVENT_TRADE_WINDOW
+
+	long distance = DISTANCE_APPROX(pkChr->GetX() - pkChrShopKeeper->GetX(), pkChr->GetY() - pkChrShopKeeper->GetY());
+
+	if (distance >= SHOP_MAX_DISTANCE)
+	{
+		sys_log(1, "SHOP: TOO_FAR: %s distance %d", pkChr->GetName(), distance);
+		return false;
+	}
+
+	LPSHOP pkShop;
+
+	if (iShopVnum)
+		pkShop = Get(iShopVnum);
+	else
+		pkShop = GetByNPCVnum(pkChrShopKeeper->GetRaceNum());
+
+	if (!pkShop)
+	{
+		sys_log(1, "SHOP: NO SHOP");
+		return false;
+	}
+
+	bool bOtherEmpire = false;
+
+	if (pkChr->GetEmpire() != pkChrShopKeeper->GetEmpire())
+		bOtherEmpire = true;
+
+	if (!pkShop->AddGuest(pkChr, pkChrShopKeeper->GetVID(), bOtherEmpire))
+		return false;
+
+	pkChr->SetShopOwner(pkChrShopKeeper);
+	sys_log(0, "SHOP: START: %s", pkChr->GetName());
+	return true;
+}
+
+LPSHOP CShopManager::FindPCShop(DWORD dwVID)
+{
+	TShopMap::iterator it = m_map_pkShopByPC.find(dwVID);
+
+	if (it == m_map_pkShopByPC.end())
+		return NULL;
+
+	return it->second;
+}
+
+LPSHOP CShopManager::CreatePCShop(LPCHARACTER ch, TShopItemTable* pTable, BYTE bItemCount)
+{
+	if (FindPCShop(ch->GetVID()))
+		return NULL;
+
+	LPSHOP pkShop = M2_NEW CShop;
+	pkShop->SetPCShop(ch);
+	pkShop->SetShopItems(pTable, bItemCount);
+
+	m_map_pkShopByPC.insert(TShopMap::value_type(ch->GetVID(), pkShop));
+	return pkShop;
+}
+
+void CShopManager::DestroyPCShop(LPCHARACTER ch)
+{
+	LPSHOP pkShop = FindPCShop(ch->GetVID());
+
+	if (!pkShop)
+		return;
+
+	// PREVENT_ITEM_COPY;
+	ch->SetMyShopTime();
+	// END_PREVENT_ITEM_COPY
+
+	m_map_pkShopByPC.erase(ch->GetVID());
+	M2_DELETE(pkShop);
+}
+
+//  킹 
+void CShopManager::StopShopping(LPCHARACTER ch)
+{
+	LPSHOP shop;
+
+	if (!(shop = ch->GetShop()))
+		return;
+
+	// PREVENT_ITEM_COPY;
+	ch->SetMyShopTime();
+	// END_PREVENT_ITEM_COPY
+
+	shop->RemoveGuest(ch);
+	sys_log(0, "SHOP: END: %s", ch->GetName());
+}
+
+//  
+void CShopManager::Buy(LPCHARACTER ch, BYTE pos)
+{
+	if (!ch->GetShop())
+		return;
+
+	if (!ch->GetShopOwner())
+		return;
+
+	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 타 賈 羚    求."));
+		return;
+	}
+
+	CShop* pkShop = ch->GetShop();
+	if (!pkShop)
+		return;
+
+	// PREVENT_ITEM_COPY
+	ch->SetMyShopTime();
+	// END_PREVENT_ITEM_COPY
+
+	int ret = pkShop->Buy(ch, pos);
+
+	if (SHOP_SUBHEADER_GC_OK != ret) // 臾몄媛 留 蹂대몃.
+	{
+		TPacketGCShop pack{};
+
+		pack.header = HEADER_GC_SHOP;
+		pack.subheader = ret;
+		pack.size = sizeof(TPacketGCShop);
+
+		LPDESC d = ch->GetDesc();
+		if (!d)
+			return;
+
+		d->Packet(&pack, sizeof(pack));
+	}
+}
+}
+
+void CShopManager::Sell(LPCHARACTER ch, WORD wCell, WORD wCount, BYTE bType)
+{
+	if (!ch->GetShop())
+		return;
+
+	if (!ch->GetShopOwner())
+		return;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	if (ch->GetShop()->IsPCShop())
+		return;
+
+	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 타 賈 羚    求."));
+		return;
+	}
+
+	LPITEM item = ch->GetInventoryItem(wCell);
+
+	if (!item)
+		return;
+
+	if (item->IsEquipped() == true)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   퓔  求."));
+		return;
+	}
+
+	if (true == item->isLocked())
+		return;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (item->IsPet())
+		return;
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot sell a soulbound item."));
+		return;
+	}
+#endif
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_SELL))
+		return;
+
+	DWORD dwPrice;
+
+	if (wCount == 0 || wCount > item->GetCount())
+		wCount = item->GetCount();
+
+	dwPrice = item->GetShopSellPrice();
+
+	if (IS_SET(item->GetFlag(), ITEM_FLAG_COUNT_PER_1GOLD))
+	{
+		if (dwPrice == 0)
+			dwPrice = wCount;
+		else
+			dwPrice = wCount / dwPrice;
+	}
+	else
+		dwPrice *= wCount;
+
+	dwPrice /= 5;
+
+	//  
+	DWORD dwTax = 0;
+	int iVal = 3;
+
+	dwTax = dwPrice * iVal / 100;
+	dwPrice -= dwTax;
+
+	if (test_server)
+		sys_log(0, "Sell Item price id %d %s itemid %d", ch->GetPlayerID(), ch->GetName(), item->GetID());
+
+	const int64_t nTotalMoney = static_cast<int64_t>(ch->GetGold()) + static_cast<int64_t>(dwPrice);
+	if (GOLD_MAX <= nTotalMoney)
+	{
+		sys_err("[OVERFLOW_GOLD] id %u name %s gold %d", ch->GetPlayerID(), ch->GetName(), ch->GetGold());
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("20 歌臼 품 횝 求."));
+		return;
+	}
+
+	// 20050802.myevan. 퓔 慣六  ID 煞
+	sys_log(0, "SHOP: SELL: %s item name: %s(x%d):%u price: %u", ch->GetName(), item->GetName(), wCount, item->GetID(), dwPrice);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	ch->UpdateExtBattlePassMissionProgress(BP_ITEM_SELL, wCount, item->GetVnum());
+#endif
+
+	if (iVal > 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("퓔킥附 %d %%   鍍絳求", iVal));
+
+	DBManager::instance().SendMoneyLog(MONEY_LOG_SHOP, item->GetVnum(), dwPrice);
+
+#if defined(__QUEST_EVENT_BUY_SELL__)
+	CShop* pkShop = ch->GetShop();
+	if (pkShop)
+	{
+		ch->SetQuestNPCID(ch->GetShopOwner() ? ch->GetShopOwner()->GetVID() : 0);
+		quest::CQuestManager::instance().SellItem(ch->GetPlayerID(), pkShop->GetNPCVnum(), item);
+	}
+#endif
+
+	if (wCount == item->GetCount())
+		ITEM_MANAGER::instance().RemoveItem(item, "SELL");
+	else
+		item->SetCount(item->GetCount() - wCount);
+
+	//  첵 :  징
+	CMonarch::instance().SendtoDBAddMoney(dwTax, ch->GetEmpire(), ch);
+
+	ch->PointChange(POINT_GOLD, dwPrice, false);
+}
+
+bool CompareShopItemName(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
+	TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
+	if (lItem && rItem)
+		return strcmp(lItem->szLocaleName, rItem->szLocaleName) < 0;
+	else
+		return true;
+}
+
+#if defined(__SHOPEX_RENEWAL__)
+bool CompareShopItemVnum(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	return lhs.vnum > rhs.vnum;
+}
+
+bool CompareShopItemPrice(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	return lhs.price > rhs.price;
+}
+
+bool CompareShopItemType(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	const TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
+	const TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
+	return (lItem && rItem) ? lItem->bType > rItem->bType : true;
+}
+#endif
+
+static bool iequals(const std::string& a, const std::string& b)
+{
+	return std::equal(a.begin(), a.end(),
+		b.begin(), b.end(),
+		[](char a, char b) {
+			return tolower(a) == tolower(b);
+		});
+}
+
+bool ConvertToShopItemTable(IN CGroupNode* pNode, OUT TShopTableEx& shopTable)
+{
+	if (!pNode->GetValue("vnum", 0, shopTable.dwVnum))
+	{
+		sys_err("Group %s does not have vnum.", pNode->GetNodeName().c_str());
+		return false;
+	}
+
+	if (!pNode->GetValue("name", 0, shopTable.name))
+	{
+		sys_err("Group %s does not have name.", pNode->GetNodeName().c_str());
+		return false;
+	}
+
+	if (shopTable.name.length() >= SHOP_TAB_NAME_MAX)
+	{
+		sys_err("Shop name length must be less than %d. Error in Group %s, name %s", SHOP_TAB_NAME_MAX, pNode->GetNodeName().c_str(), shopTable.name.c_str());
+		return false;
+	}
+
+	std::string stCoinType;
+	if (!pNode->GetValue("cointype", 0, stCoinType))
+	{
+		stCoinType = "Gold";
+	}
+
+	if (iequals(stCoinType, "Gold"))
+	{
+		shopTable.coinType = SHOP_COIN_TYPE_GOLD;
+	}
+	else if (iequals(stCoinType, "SecondaryCoin"))
+	{
+		shopTable.coinType = SHOP_COIN_TYPE_SECONDARY_COIN;
+	}
+	else
+	{
+		sys_err("Group %s has undefine cointype(%s).", pNode->GetNodeName().c_str(), stCoinType.c_str());
+		return false;
+	}
+
+	CGroupNode* pItemGroup = pNode->GetChildNode("items");
+	if (!pItemGroup)
+	{
+		sys_err("Group %s does not have 'group items'.", pNode->GetNodeName().c_str());
+		return false;
+	}
+
+	size_t itemGroupSize = pItemGroup->GetRowCount();
+	std::vector<TShopItemTable> shopItems(itemGroupSize);
+	if (itemGroupSize >= SHOP_HOST_ITEM_MAX_NUM)
+	{
+		sys_err("count(%d) of rows of group items of group %s must be smaller than %d", itemGroupSize, pNode->GetNodeName().c_str(), SHOP_HOST_ITEM_MAX_NUM);
+		return false;
+	}
+
+	for (size_t i = 0; i < itemGroupSize; i++)
+	{
+		if (!pItemGroup->GetValue(i, "vnum", shopItems[i].vnum))
+		{
+			sys_err("row(%d) of group items of group %s does not have vnum column", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		if (!pItemGroup->GetValue(i, "count", shopItems[i].count))
+		{
+			sys_err("row(%d) of group items of group %s does not have count column", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		if (!pItemGroup->GetValue(i, "price", shopItems[i].price))
+		{
+			sys_err("row(%d) of group items of group %s does not have price column", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		// NOTE : Set the item price to the default item proto shop buy price.
+		if (shopItems[i].price == 0)
+		{
+			TItemTable* itemTable = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
+			if (itemTable != NULL)
+				shopItems[i].price = itemTable->dwShopBuyPrice * shopItems[i].count;
+		}
+
+#if defined(__SHOPEX_RENEWAL__)
+		if (shopItems[i].bPriceType >= SHOP_COIN_MAX_TYPE)
+		{
+			sys_err("row(%d) of group items of group %s price_type is wrong!", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		char getval[20];
+		for (int j = 0; j < ITEM_SOCKET_MAX_NUM; j++)
+		{
+			snprintf(getval, sizeof(getval), "socket%d", j);
+			if (!pItemGroup->GetValue(i, getval, shopItems[i].alSockets[j]))
+			{
+				sys_err("row(%d) stage %d of group items of group %s does not have socket column", i, j, pNode->GetNodeName().c_str());
+				return false;
+			}
+		}
+
+		if (pItemGroup->GetValue(i, "price_type", shopItems[i].bPriceType) &&
+			pItemGroup->GetValue(i, "price_vnum", shopItems[i].dwPriceVnum) &&
+			shopItems[i].bPriceType == SHOP_COIN_TYPE_ITEM)
+		{
+			if (!ITEM_MANAGER::instance().GetTable(shopItems[i].dwPriceVnum))
+			{
+				sys_err("CANNOT GET ITEM PROTO %d", shopItems[i].dwPriceVnum);
+				return false;
+			}
+		}
+#endif
+	}
+
+	std::string stSort;
+	if (!pNode->GetValue("sort", 0, stSort))
+		stSort = "None";
+
+	if (iequals(stSort, "Asc"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
+	else if (iequals(stSort, "Desc"))
+		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemName);
+#if defined(__SHOPEX_RENEWAL__)
+	else if (iequals(stSort, "Vnum"))
+		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemVnum);
+	else if (iequals(stSort, "Price"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemPrice);
+	else if (iequals(stSort, "Name"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
+	else if (iequals(stSort, "Type"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemType);
+#endif
+
+	CGrid grid = CGrid(CShop::SHOP_GRID_WIDTH, CShop::SHOP_GRID_HEIGHT);
+	int iPos;
+
+	memset(&shopTable.items[0], 0, sizeof(shopTable.items));
+
+	for (size_t i = 0; i < shopItems.size(); i++)
+	{
+		TItemTable* item_table = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
+		if (!item_table)
+		{
+			sys_err("vnum(%d) of group items of group %s does not exist", shopItems[i].vnum, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		iPos = grid.FindBlank(1, item_table->bSize);
+
+		grid.Put(iPos, 1, item_table->bSize);
+		shopTable.items[iPos] = shopItems[i];
+	}
+
+	shopTable.bItemCount = shopItems.size();
+	return true;
+}
+
+bool CShopManager::ReadShopTableEx(const char* stFileName)
+{
+	// file  체크.
+	//    처 苛쨈.
+	FILE* fp = fopen(stFileName, "rb");
+	if (NULL == fp)
+		return true;
+	fclose(fp);
+
+	CGroupTextParseTreeLoader loader;
+	if (!loader.Load(stFileName))
+	{
+		sys_err("%s Load fail.", stFileName);
+		return false;
+	}
+
+	CGroupNode* pShopNPCGroup = loader.GetGroup("shopnpc");
+	if (NULL == pShopNPCGroup)
+	{
+		sys_err("Group ShopNPC is not exist.");
+		return false;
+	}
+
+	typedef std::multimap <DWORD, TShopTableEx> TMapNPCshop;
+	TMapNPCshop map_npcShop;
+
+#if defined(__SHOPEX_RENEWAL__)
+	{
+		std::unordered_set<CShop*> v;
+		// include unordered_set
+		auto ExDelete = [&v](TShopMap& c)
+		{
+			for (auto it = c.begin(); !c.empty() && it != c.end();)
+			{
+				const auto shop = it->second;
+				if (shop && shop->IsShopEx())
+				{
+					it = c.erase(it);
+					v.insert(shop);
+				}
+				else
+					++it;
+			}
+		};
+		ExDelete(m_map_pkShopByNPCVnum);
+		ExDelete(m_map_pkShop);
+		for (const auto& del : v)
+			delete del;
+	}
+#endif
+
+	for (size_t i = 0; i < pShopNPCGroup->GetRowCount(); i++)
+	{
+		DWORD npcVnum;
+		std::string shopName;
+		if (!pShopNPCGroup->GetValue(i, "npc", npcVnum) || !pShopNPCGroup->GetValue(i, "group", shopName))
+		{
+			sys_err("Invalid row(%d). Group ShopNPC rows must have 'npc', 'group' columns", i);
+			return false;
+		}
+		std::transform(shopName.begin(), shopName.end(), shopName.begin(), (int(*)(int))std::tolower);
+		CGroupNode* pShopGroup = loader.GetGroup(shopName.c_str());
+		if (!pShopGroup)
+		{
+			sys_err("Group %s is not exist.", shopName.c_str());
+			return false;
+		}
+		TShopTableEx table;
+		if (!ConvertToShopItemTable(pShopGroup, table))
+		{
+			sys_err("Cannot read Group %s.", shopName.c_str());
+			return false;
+		}
+		if (m_map_pkShopByNPCVnum.find(npcVnum) != m_map_pkShopByNPCVnum.end())
+		{
+			sys_err("%d cannot have both original shop and extended shop", npcVnum);
+			return false;
+		}
+
+		map_npcShop.insert(TMapNPCshop::value_type(npcVnum, table));
+	}
+
+	for (TMapNPCshop::iterator it = map_npcShop.begin(); it != map_npcShop.end(); ++it)
+	{
+		DWORD npcVnum = it->first;
+		TShopTableEx& table = it->second;
+		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
+		{
+			sys_err("Shop vnum(%d) already exists", table.dwVnum);
+			return false;
+		}
+		TShopMap::iterator shop_it = m_map_pkShopByNPCVnum.find(npcVnum);
+
+		LPSHOPEX pkShopEx = NULL;
+		if (m_map_pkShopByNPCVnum.end() == shop_it)
+		{
+			pkShopEx = M2_NEW CShopEx;
+			pkShopEx->Create(0, npcVnum);
+			m_map_pkShopByNPCVnum.insert(TShopMap::value_type(npcVnum, pkShopEx));
+		}
+		else
+		{
+			pkShopEx = dynamic_cast <CShopEx*> (shop_it->second);
+			if (NULL == pkShopEx)
+			{
+				sys_err("WTF!!! It can't be happend. NPC(%d) Shop is not extended version.", shop_it->first);
+				return false;
+			}
+		}
+
+		if (pkShopEx->GetTabCount() >= SHOP_TAB_COUNT_MAX)
+		{
+			sys_err("ShopEx cannot have tab more than %d", SHOP_TAB_COUNT_MAX);
+			return false;
+		}
+
+		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
+		{
+			sys_err("Shop vnum(%d) already exist.", table.dwVnum);
+			return false;
+		}
+		m_map_pkShop.insert(TShopMap::value_type(table.dwVnum, pkShopEx));
+		pkShopEx->AddShopTable(table);
+	}
+
+	return true;
+}
diff --git a/server/metin2/Source/Server/game/src/skill.cpp b/server/metin2/Source/Server/game/src/skill.cpp
index c987cc4..7a409b8 100644
--- a/server/metin2/Source/Server/game/src/skill.cpp
+++ b/server/metin2/Source/Server/game/src/skill.cpp
@@ -1,387 +1,395 @@
-#include "stdafx.h"
-#include "../../common/stl.h"
-
-#include "constants.h"
-#include "skill.h"
-#include "char.h"
-
-void CSkillProto::SetPointVar(const std::string& strName, double dVar)
-{
-	kPointPoly.SetVar(strName, dVar);
-	kPointPoly2.SetVar(strName, dVar);
-	kPointPoly3.SetVar(strName, dVar);
-	kMasterBonusPoly.SetVar(strName, dVar);
-}
-
-void CSkillProto::SetDurationVar(const std::string& strName, double dVar)
-{
-	kDurationPoly.SetVar(strName, dVar);
-	kDurationPoly2.SetVar(strName, dVar);
-	kDurationPoly3.SetVar(strName, dVar);
-}
-
-void CSkillProto::SetSPCostVar(const std::string& strName, double dVar)
-{
-	kSPCostPoly.SetVar(strName, dVar);
-	kGrandMasterAddSPCostPoly.SetVar(strName, dVar);
-}
-
-CSkillManager::CSkillManager()
-{
-}
-
-CSkillManager::~CSkillManager()
-{
-	auto it = m_map_pkSkillProto.begin();
-	for (; it != m_map_pkSkillProto.end(); ++it)
-	{
-		M2_DELETE(it->second);
-	}
-}
-
-struct SPointOnType
-{
-	const char* c_pszName;
-	int iPointOn;
-} kPointOnTypes[] = {
-	{ "NONE", POINT_NONE },
-	{ "MAX_HP", POINT_MAX_HP },
-	{ "MAX_SP", POINT_MAX_SP },
-	{ "HP_REGEN", POINT_HP_REGEN },
-	{ "SP_REGEN", POINT_SP_REGEN },
-	{ "BLOCK", POINT_BLOCK },
-	{ "HP", POINT_HP },
-	{ "SP", POINT_SP },
-	{ "ATT_GRADE", POINT_ATT_GRADE_BONUS },
-	{ "DEF_GRADE", POINT_DEF_GRADE_BONUS },
-	{ "MAGIC_ATT_GRADE",POINT_MAGIC_ATT_GRADE_BONUS },
-	{ "MAGIC_DEF_GRADE",POINT_MAGIC_DEF_GRADE_BONUS },
-	{ "BOW_DISTANCE", POINT_BOW_DISTANCE },
-	{ "MOV_SPEED", POINT_MOV_SPEED },
-	{ "ATT_SPEED", POINT_ATT_SPEED },
-	{ "POISON_PCT", POINT_POISON_PCT },
-	{ "RESIST_RANGE", POINT_RESIST_BOW },
-	//{ "RESIST_MELEE", POINT_RESIST_MELEE },
-	{ "CASTING_SPEED", POINT_CASTING_SPEED },
-	{ "REFLECT_MELEE", POINT_REFLECT_MELEE },
-	{ "ATT_BONUS", POINT_ATT_BONUS },
-	{ "DEF_BONUS", POINT_DEF_BONUS },
-	{ "RESIST_NORMAL", POINT_RESIST_NORMAL_DAMAGE },
-	{ "DODGE", POINT_DODGE },
-	{ "KILL_HP_RECOVER",POINT_KILL_HP_RECOVERY },
-	{ "KILL_SP_RECOVER",POINT_KILL_SP_RECOVER },
-	{ "HIT_HP_RECOVER", POINT_HIT_HP_RECOVERY },
-	{ "HIT_SP_RECOVER", POINT_HIT_SP_RECOVERY },
-	{ "CRITICAL", POINT_CRITICAL_PCT },
-	{ "PENETRATE", POINT_PENETRATE_PCT },
-	{ "MANASHIELD", POINT_MANASHIELD },
-	{ "SKILL_DAMAGE_BONUS", POINT_SKILL_DAMAGE_BONUS },
-	{ "NORMAL_HIT_DAMAGE_BONUS", POINT_NORMAL_HIT_DAMAGE_BONUS },
-	{ "BLEEDING_PCT", POINT_BLEEDING_PCT },
-	{ "MALL_EXPBONUS", POINT_MALL_EXPBONUS },
-
-	{ "ATTBONUS_HUMAN", POINT_ATTBONUS_HUMAN },
-	{ "ATTBONUS_ANIMAL", POINT_ATTBONUS_ANIMAL },
-	{ "ATTBONUS_ORC", POINT_ATTBONUS_ORC },
-	{ "ATTBONUS_MILGYO", POINT_ATTBONUS_MILGYO },
-	{ "ATTBONUS_UNDEAD", POINT_ATTBONUS_UNDEAD },
-	{ "ATTBONUS_DEVIL", POINT_ATTBONUS_DEVIL },
-	{ "ATTBONUS_CZ", POINT_ATTBONUS_CZ },
-	{ "ATTBONUS_DESERT", POINT_ATTBONUS_DESERT },
-	{ "ATTBONUS_INSECT", POINT_ATTBONUS_INSECT },
-	{ "ATTBONUS_MONSTER", POINT_ATTBONUS_MONSTER },
-
-	{ "ATTBONUS_WARRIOR", POINT_ATTBONUS_WARRIOR },
-	{ "ATTBONUS_ASSASSIN", POINT_ATTBONUS_ASSASSIN },
-	{ "ATTBONUS_SURA", POINT_ATTBONUS_SURA },
-	{ "ATTBONUS_SHAMAN", POINT_ATTBONUS_SHAMAN },
-	{ "ATTBONUS_WOLF", POINT_ATTBONUS_WOLFMAN },
-	
-	{ "SUNGMA_STR", POINT_SUNGMA_STR },
-	{ "SUNGMA_HP", POINT_SUNGMA_HP },
-	{ "SUNGMA_MOVE", POINT_SUNGMA_MOVE },
-	{ "SUNGMA_IMMUNE", POINT_SUNGMA_IMMUNE },
-	{ "HIT_PCT", POINT_HIT_PCT },
-
-	{ "MOUNT_UPGRADE_SPEED", POINT_NONE },
-	{ "MOUNT_UPGRADE_NIMBLE", POINT_NONE },
-	{ "MOUNT_UPGRADE_NO_KNOCKBACK", POINT_NONE },
-	{ "MOUNT_UPGRADE_SUNGMA_STR", POINT_NONE },
-	{ "MOUNT_UPGRADE_SUNGMA_HP", POINT_NONE },
-	{ "MOUNT_UPGRADE_SUNGMA_MOVE", POINT_NONE },
-	{ "MOUNT_UPGRADE_SUNGMA_IMMUNE", POINT_NONE },
-
-	// { "SPLASH", POINT_SPLASH },
-	{ "\n", POINT_NONE },
-};
-
-int FindPointType(const char* c_sz)
-{
-	for (int i = 0; *kPointOnTypes[i].c_pszName != '\n'; ++i)
-	{
-		if (!strcasecmp(c_sz, kPointOnTypes[i].c_pszName))
-			return kPointOnTypes[i].iPointOn;
-	}
-	return -1;
-}
-
-bool CSkillManager::Initialize(TSkillTable* pTab, int iSize)
-{
-	char buf[1024];
-	std::map<DWORD, CSkillProto*> map_pkSkillProto;
-
-	TSkillTable* t = pTab;
-	bool bError = false;
-
-	for (int i = 0; i < iSize; ++i, ++t)
-	{
-		CSkillProto* pkProto = M2_NEW CSkillProto;
-
-		pkProto->dwVnum = t->dwVnum;
-		strlcpy(pkProto->szName, t->szName, sizeof(pkProto->szName));
-		pkProto->dwType = t->bType;
-		pkProto->bMaxLevel = t->bMaxLevel;
-		pkProto->dwFlag = t->dwFlag;
-		pkProto->dwAffectFlag = t->dwAffectFlag;
-		pkProto->dwAffectFlag2 = t->dwAffectFlag2;
-
-		pkProto->bLevelStep = t->bLevelStep;
-		pkProto->bLevelLimit = t->bLevelLimit;
-		pkProto->iSplashRange = t->dwSplashRange;
-		pkProto->dwTargetRange = t->dwTargetRange;
-		pkProto->preSkillVnum = t->preSkillVnum;
-		pkProto->preSkillLevel = t->preSkillLevel;
-
-		pkProto->lMaxHit = t->lMaxHit;
-
-		pkProto->bSkillAttrType = t->bSkillAttrType;
-
-		int iIdx = FindPointType(t->szPointOn);
-
-		if (iIdx < 0)
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : cannot find point type on skill: %s szPointOn: %s", t->szName, t->szPointOn);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		pkProto->wPointOn = iIdx;
-
-		int iIdx2 = FindPointType(t->szPointOn2);
-
-		if (iIdx2 < 0)
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : cannot find point type on skill: %s szPointOn2: %s", t->szName, t->szPointOn2);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		pkProto->wPointOn2 = iIdx2;
-
-		int iIdx3 = FindPointType(t->szPointOn3);
-
-		if (iIdx3 < 0)
-		{
-			if (t->szPointOn3[0] == 0)
-			{
-				iIdx3 = POINT_NONE;
-			}
-			else
-			{
-				snprintf(buf, sizeof(buf), "SkillManager::Initialize : cannot find point type on skill: %s szPointOn3: %s", t->szName, t->szPointOn3);
-				sys_err("%s", buf);
-				SendLog(buf);
-				bError = true;
-				M2_DELETE(pkProto);
-				continue;
-			}
-		}
-
-		pkProto->wPointOn3 = iIdx3;
-
-		if (!pkProto->kSplashAroundDamageAdjustPoly.Analyze(t->szSplashAroundDamageAdjustPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szSplashAroundDamageAdjustPoly: %s", t->szName, t->szSplashAroundDamageAdjustPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kPointPoly.Analyze(t->szPointPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szPointPoly: %s", t->szName, t->szPointPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kPointPoly2.Analyze(t->szPointPoly2))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szPointPoly2: %s", t->szName, t->szPointPoly2);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kPointPoly3.Analyze(t->szPointPoly3))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szPointPoly3: %s", t->szName, t->szPointPoly3);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kSPCostPoly.Analyze(t->szSPCostPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szSPCostPoly: %s", t->szName, t->szSPCostPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kGrandMasterAddSPCostPoly.Analyze(t->szGrandMasterAddSPCostPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szGrandMasterAddSPCostPoly: %s", t->szName, t->szGrandMasterAddSPCostPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kDurationPoly.Analyze(t->szDurationPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationPoly: %s", t->szName, t->szDurationPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kDurationPoly2.Analyze(t->szDurationPoly2))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationPoly2: %s", t->szName, t->szDurationPoly2);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kDurationPoly3.Analyze(t->szDurationPoly3))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationPoly3: %s", t->szName, t->szDurationPoly3);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kDurationSPCostPoly.Analyze(t->szDurationSPCostPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationSPCostPoly: %s", t->szName, t->szDurationSPCostPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		if (!pkProto->kCooldownPoly.Analyze(t->szCooldownPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szCooldownPoly: %s", t->szName, t->szCooldownPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		sys_log(0, "Master %s", t->szMasterBonusPoly);
-		if (!pkProto->kMasterBonusPoly.Analyze(t->szMasterBonusPoly))
-		{
-			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szMasterBonusPoly: %s", t->szName, t->szMasterBonusPoly);
-			sys_err("%s", buf);
-			SendLog(buf);
-			bError = true;
-			M2_DELETE(pkProto);
-			continue;
-		}
-
-		sys_log(0, "#%-3d %-24s type %u flag %u affect %u point_poly: %s",
-			pkProto->dwVnum, pkProto->szName, pkProto->dwType, pkProto->dwFlag, pkProto->dwAffectFlag, t->szPointPoly);
-
-		map_pkSkillProto.insert(std::map<DWORD, CSkillProto*>::value_type(pkProto->dwVnum, pkProto));
-	}
-
-	if (!bError)
-	{
-		// 기존 테이블의 내용을 지운다.
-		auto it = m_map_pkSkillProto.begin();
-		while (it != m_map_pkSkillProto.end())
-		{
-			M2_DELETE(it->second);
-			++it;
-		}
-
-		m_map_pkSkillProto.clear();
-
-		// 새로운 내용을 삽입
-		it = map_pkSkillProto.begin();
-
-		while (it != map_pkSkillProto.end())
-		{
-			m_map_pkSkillProto.insert(std::map<DWORD, CSkillProto*>::value_type(it->first, it->second));
-			++it;
-		}
-
-		SendLog("Skill Prototype reloaded!");
-	}
-	else
-		SendLog("There were erros when loading skill table");
-
-	return !bError;
-}
-
-CSkillProto* CSkillManager::Get(DWORD dwVnum)
-{
-	std::map<DWORD, CSkillProto*>::iterator it = m_map_pkSkillProto.find(dwVnum);
-
-	if (it == m_map_pkSkillProto.end())
-		return NULL;
-
-	return it->second;
-}
-
-CSkillProto* CSkillManager::Get(const char* c_pszSkillName)
-{
-	std::map<DWORD, CSkillProto*>::iterator it = m_map_pkSkillProto.begin();
-
-	while (it != m_map_pkSkillProto.end())
-	{
-		if (!strcasecmp(it->second->szName, c_pszSkillName))
-			return it->second;
-
-		++it;
-	}
-
-	return NULL;
-}
+#include "stdafx.h"
+#include "../../common/stl.h"
+
+#include "constants.h"
+#include "skill.h"
+#include "char.h"
+
+void CSkillProto::SetPointVar(const std::string& strName, double dVar)
+{
+	kPointPoly.SetVar(strName, dVar);
+	kPointPoly2.SetVar(strName, dVar);
+	kPointPoly3.SetVar(strName, dVar);
+	kMasterBonusPoly.SetVar(strName, dVar);
+}
+
+void CSkillProto::SetDurationVar(const std::string& strName, double dVar)
+{
+	kDurationPoly.SetVar(strName, dVar);
+	kDurationPoly2.SetVar(strName, dVar);
+	kDurationPoly3.SetVar(strName, dVar);
+}
+
+void CSkillProto::SetSPCostVar(const std::string& strName, double dVar)
+{
+	kSPCostPoly.SetVar(strName, dVar);
+	kGrandMasterAddSPCostPoly.SetVar(strName, dVar);
+}
+
+CSkillManager::CSkillManager()
+{
+}
+
+CSkillManager::~CSkillManager()
+{
+	auto it = m_map_pkSkillProto.begin();
+	for (; it != m_map_pkSkillProto.end(); ++it)
+	{
+		M2_DELETE(it->second);
+	}
+}
+
+struct SPointOnType
+{
+	const char* c_pszName;
+	int iPointOn;
+} kPointOnTypes[] = {
+	{ "NONE", POINT_NONE },
+	{ "MAX_HP", POINT_MAX_HP },
+	{ "MAX_SP", POINT_MAX_SP },
+	{ "HP_REGEN", POINT_HP_REGEN },
+	{ "SP_REGEN", POINT_SP_REGEN },
+	{ "BLOCK", POINT_BLOCK },
+	{ "HP", POINT_HP },
+	{ "SP", POINT_SP },
+	{ "ATT_GRADE", POINT_ATT_GRADE_BONUS },
+	{ "DEF_GRADE", POINT_DEF_GRADE_BONUS },
+	{ "MAGIC_ATT_GRADE",POINT_MAGIC_ATT_GRADE_BONUS },
+	{ "MAGIC_DEF_GRADE",POINT_MAGIC_DEF_GRADE_BONUS },
+	{ "BOW_DISTANCE", POINT_BOW_DISTANCE },
+	{ "MOV_SPEED", POINT_MOV_SPEED },
+	{ "ATT_SPEED", POINT_ATT_SPEED },
+	{ "POISON_PCT", POINT_POISON_PCT },
+	{ "RESIST_RANGE", POINT_RESIST_BOW },
+	//{ "RESIST_MELEE", POINT_RESIST_MELEE },
+	{ "CASTING_SPEED", POINT_CASTING_SPEED },
+	{ "REFLECT_MELEE", POINT_REFLECT_MELEE },
+	{ "ATT_BONUS", POINT_ATT_BONUS },
+	{ "DEF_BONUS", POINT_DEF_BONUS },
+	{ "RESIST_NORMAL", POINT_RESIST_NORMAL_DAMAGE },
+	{ "DODGE", POINT_DODGE },
+	{ "KILL_HP_RECOVER",POINT_KILL_HP_RECOVERY },
+	{ "KILL_SP_RECOVER",POINT_KILL_SP_RECOVER },
+	{ "HIT_HP_RECOVER", POINT_HIT_HP_RECOVERY },
+	{ "HIT_SP_RECOVER", POINT_HIT_SP_RECOVERY },
+	{ "CRITICAL", POINT_CRITICAL_PCT },
+	{ "PENETRATE", POINT_PENETRATE_PCT },
+	{ "MANASHIELD", POINT_MANASHIELD },
+	{ "SKILL_DAMAGE_BONUS", POINT_SKILL_DAMAGE_BONUS },
+	{ "NORMAL_HIT_DAMAGE_BONUS", POINT_NORMAL_HIT_DAMAGE_BONUS },
+	{ "BLEEDING_PCT", POINT_BLEEDING_PCT },
+	{ "MALL_EXPBONUS", POINT_MALL_EXPBONUS },
+
+	{ "ATTBONUS_HUMAN", POINT_ATTBONUS_HUMAN },
+	{ "ATTBONUS_ANIMAL", POINT_ATTBONUS_ANIMAL },
+	{ "ATTBONUS_ORC", POINT_ATTBONUS_ORC },
+	{ "ATTBONUS_MILGYO", POINT_ATTBONUS_MILGYO },
+	{ "ATTBONUS_UNDEAD", POINT_ATTBONUS_UNDEAD },
+	{ "ATTBONUS_DEVIL", POINT_ATTBONUS_DEVIL },
+	{ "ATTBONUS_CZ", POINT_ATTBONUS_CZ },
+	{ "ATTBONUS_DESERT", POINT_ATTBONUS_DESERT },
+	{ "ATTBONUS_INSECT", POINT_ATTBONUS_INSECT },
+	{ "ATTBONUS_MONSTER", POINT_ATTBONUS_MONSTER },
+
+	{ "ATTBONUS_WARRIOR", POINT_ATTBONUS_WARRIOR },
+	{ "ATTBONUS_ASSASSIN", POINT_ATTBONUS_ASSASSIN },
+	{ "ATTBONUS_SURA", POINT_ATTBONUS_SURA },
+	{ "ATTBONUS_SHAMAN", POINT_ATTBONUS_SHAMAN },
+	{ "ATTBONUS_WOLF", POINT_ATTBONUS_WOLFMAN },
+	
+	{ "SUNGMA_STR", POINT_SUNGMA_STR },
+	{ "SUNGMA_HP", POINT_SUNGMA_HP },
+	{ "SUNGMA_MOVE", POINT_SUNGMA_MOVE },
+	{ "SUNGMA_IMMUNE", POINT_SUNGMA_IMMUNE },
+	{ "HIT_PCT", POINT_HIT_PCT },
+
+	{ "MOUNT_UPGRADE_SPEED", POINT_NONE },
+	{ "MOUNT_UPGRADE_NIMBLE", POINT_NONE },
+	{ "MOUNT_UPGRADE_NO_KNOCKBACK", POINT_NONE },
+	{ "MOUNT_UPGRADE_SUNGMA_STR", POINT_NONE },
+	{ "MOUNT_UPGRADE_SUNGMA_HP", POINT_NONE },
+	{ "MOUNT_UPGRADE_SUNGMA_MOVE", POINT_NONE },
+	{ "MOUNT_UPGRADE_SUNGMA_IMMUNE", POINT_NONE },
+
+	// { "SPLASH", POINT_SPLASH },
+	{ "\n", POINT_NONE },
+};
+
+int FindPointType(const char* c_sz)
+{
+	for (int i = 0; *kPointOnTypes[i].c_pszName != '\n'; ++i)
+	{
+		if (!strcasecmp(c_sz, kPointOnTypes[i].c_pszName))
+			return kPointOnTypes[i].iPointOn;
+	}
+	return -1;
+}
+
+bool CSkillManager::Initialize(TSkillTable* pTab, int iSize)
+{
+	char buf[1024];
+	std::map<DWORD, CSkillProto*> map_pkSkillProto;
+
+	TSkillTable* t = pTab;
+	bool bError = false;
+
+	for (int i = 0; i < iSize; ++i, ++t)
+	{
+		CSkillProto* pkProto = M2_NEW CSkillProto;
+
+		pkProto->dwVnum = t->dwVnum;
+		strlcpy(pkProto->szName, t->szName, sizeof(pkProto->szName));
+		pkProto->dwType = t->bType;
+		pkProto->bMaxLevel = t->bMaxLevel;
+		pkProto->dwFlag = t->dwFlag;
+		pkProto->dwAffectFlag = t->dwAffectFlag;
+		pkProto->dwAffectFlag2 = t->dwAffectFlag2;
+
+		pkProto->bLevelStep = t->bLevelStep;
+		pkProto->bLevelLimit = t->bLevelLimit;
+		pkProto->iSplashRange = t->dwSplashRange;
+		pkProto->dwTargetRange = t->dwTargetRange;
+		pkProto->preSkillVnum = t->preSkillVnum;
+		pkProto->preSkillLevel = t->preSkillLevel;
+
+		pkProto->lMaxHit = t->lMaxHit;
+
+		pkProto->bSkillAttrType = t->bSkillAttrType;
+
+		int iIdx = FindPointType(t->szPointOn);
+
+		if (iIdx < 0)
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : cannot find point type on skill: %s szPointOn: %s", t->szName, t->szPointOn);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		pkProto->wPointOn = iIdx;
+
+		int iIdx2 = FindPointType(t->szPointOn2);
+
+		if (iIdx2 < 0)
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : cannot find point type on skill: %s szPointOn2: %s", t->szName, t->szPointOn2);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		pkProto->wPointOn2 = iIdx2;
+
+		int iIdx3 = FindPointType(t->szPointOn3);
+
+		if (iIdx3 < 0)
+		{
+			if (t->szPointOn3[0] == 0)
+			{
+				iIdx3 = POINT_NONE;
+			}
+			else
+			{
+				snprintf(buf, sizeof(buf), "SkillManager::Initialize : cannot find point type on skill: %s szPointOn3: %s", t->szName, t->szPointOn3);
+				sys_err("%s", buf);
+				SendLog(buf);
+				bError = true;
+				M2_DELETE(pkProto);
+				continue;
+			}
+		}
+
+		pkProto->wPointOn3 = iIdx3;
+
+		if (!pkProto->kSplashAroundDamageAdjustPoly.Analyze(t->szSplashAroundDamageAdjustPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szSplashAroundDamageAdjustPoly: %s", t->szName, t->szSplashAroundDamageAdjustPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kPointPoly.Analyze(t->szPointPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szPointPoly: %s", t->szName, t->szPointPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kPointPoly2.Analyze(t->szPointPoly2))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szPointPoly2: %s", t->szName, t->szPointPoly2);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kPointPoly3.Analyze(t->szPointPoly3))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szPointPoly3: %s", t->szName, t->szPointPoly3);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kSPCostPoly.Analyze(t->szSPCostPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szSPCostPoly: %s", t->szName, t->szSPCostPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kGrandMasterAddSPCostPoly.Analyze(t->szGrandMasterAddSPCostPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szGrandMasterAddSPCostPoly: %s", t->szName, t->szGrandMasterAddSPCostPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kDurationPoly.Analyze(t->szDurationPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationPoly: %s", t->szName, t->szDurationPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kDurationPoly2.Analyze(t->szDurationPoly2))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationPoly2: %s", t->szName, t->szDurationPoly2);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kDurationPoly3.Analyze(t->szDurationPoly3))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationPoly3: %s", t->szName, t->szDurationPoly3);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kDurationSPCostPoly.Analyze(t->szDurationSPCostPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szDurationSPCostPoly: %s", t->szName, t->szDurationSPCostPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		if (!pkProto->kCooldownPoly.Analyze(t->szCooldownPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szCooldownPoly: %s", t->szName, t->szCooldownPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		sys_log(0, "Master %s", t->szMasterBonusPoly);
+		if (!pkProto->kMasterBonusPoly.Analyze(t->szMasterBonusPoly))
+		{
+			snprintf(buf, sizeof(buf), "SkillManager::Initialize : syntax error skill: %s szMasterBonusPoly: %s", t->szName, t->szMasterBonusPoly);
+			sys_err("%s", buf);
+			SendLog(buf);
+			bError = true;
+			M2_DELETE(pkProto);
+			continue;
+		}
+
+		sys_log(0, "#%-3d %-24s type %u flag %u affect %u point_poly: %s",
+			pkProto->dwVnum, pkProto->szName, pkProto->dwType, pkProto->dwFlag, pkProto->dwAffectFlag, t->szPointPoly);
+
+		map_pkSkillProto.insert(std::map<DWORD, CSkillProto*>::value_type(pkProto->dwVnum, pkProto));
+	}
+
+	if (!bError)
+	{
+		//  遣  .
+		auto it = m_map_pkSkillProto.begin();
+		while (it != m_map_pkSkillProto.end())
+		{
+			M2_DELETE(it->second);
+			++it;
+		}
+
+		m_map_pkSkillProto.clear();
+
+		// 恝  
+		it = map_pkSkillProto.begin();
+
+		while (it != map_pkSkillProto.end())
+		{
+			m_map_pkSkillProto.insert(std::map<DWORD, CSkillProto*>::value_type(it->first, it->second));
+			++it;
+		}
+
+		SendLog("Skill Prototype reloaded!");
+		return true;
+	}
+	else
+	{
+		SendLog("There were errors when loading skill table");
+
+		// On error, avoid leaking newly allocated prototypes.
+		for (auto& kv : map_pkSkillProto)
+			M2_DELETE(kv.second);
+		map_pkSkillProto.clear();
+	}
+
+	return false;
+}
+
+CSkillProto* CSkillManager::Get(DWORD dwVnum)
+{
+	std::map<DWORD, CSkillProto*>::iterator it = m_map_pkSkillProto.find(dwVnum);
+
+	if (it == m_map_pkSkillProto.end())
+		return NULL;
+
+	return it->second;
+}
+
+CSkillProto* CSkillManager::Get(const char* c_pszSkillName)
+{
+	std::map<DWORD, CSkillProto*>::iterator it = m_map_pkSkillProto.begin();
+
+	while (it != m_map_pkSkillProto.end())
+	{
+		if (!strcasecmp(it->second->szName, c_pszSkillName))
+			return it->second;
+
+		++it;
+	}
+
+	return NULL;
+}
diff --git a/server/metin2/Source/Server/game/src/threeway_war.cpp b/server/metin2/Source/Server/game/src/threeway_war.cpp
index a86793a..2249b4e 100644
--- a/server/metin2/Source/Server/game/src/threeway_war.cpp
+++ b/server/metin2/Source/Server/game/src/threeway_war.cpp
@@ -1,674 +1,674 @@
-#include "stdafx.h"
-
-#include "threeway_war.h"
-
-#include "../../common/length.h"
-#include "../../common/tables.h"
-#include "p2p.h"
-#include "locale_service.h"
-#include "packet.h"
-#include "char.h"
-#include "questmanager.h"
-#include "questlua.h"
-#include "start_position.h"
-#include "char_manager.h"
-#include "sectree_manager.h"
-#include "regen.h"
-#include "log.h"
-#include "config.h"
-
-extern int test_server;
-extern int passes_per_sec;
-
-EVENTINFO(regen_mob_event_info)
-{
-	DWORD dwMapIndex;
-
-	regen_mob_event_info()
-		: dwMapIndex(0)
-	{
-	}
-};
-
-EVENTFUNC(regen_mob_event)
-{
-	regen_mob_event_info* info = dynamic_cast<regen_mob_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("regen_mob_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	int iMapIndex = info->dwMapIndex;
-
-	char filename[128];
-	std::string szFilename(GetSungziMapPath());
-
-	int choice = quest::CQuestManager::instance().GetEventFlag("threeway_war_choice");
-	if (0 == choice)
-		sprintf(filename, "%sregen00.txt", GetSungziMapPath());
-	else
-	{
-		sprintf(filename, "%sregen00_%d.txt", GetSungziMapPath(), choice);
-	}
-
-	LPSECTREE_MAP pkMap = SECTREE_MANAGER::instance().GetMap(iMapIndex);
-
-	if (NULL != pkMap)
-	{
-		if (0 != choice)
-			if (regen_load_in_file(filename, iMapIndex, pkMap->m_setting.iBaseX, pkMap->m_setting.iBaseY))
-			{
-				sprintf(filename, "%sregen00.txt", GetSungziMapPath());
-				regen_load_in_file(filename, iMapIndex, pkMap->m_setting.iBaseX, pkMap->m_setting.iBaseY);
-			}
-	}
-
-	return 0;
-}
-
-CThreeWayWar::CThreeWayWar()
-{
-	Initialize();
-}
-
-CThreeWayWar::~CThreeWayWar()
-{
-	RegisterUserMap_.clear();
-	ReviveTokenMap_.clear();
-}
-
-void CThreeWayWar::Initialize()
-{
-	RegenFlag_ = 0;
-
-	memset(KillScore_, 0, sizeof(KillScore_));
-
-	RegisterUserMap_.clear();
-	ReviveTokenMap_.clear();
-}
-
-int CThreeWayWar::GetKillScore(BYTE empire) const
-{
-	if (empire <= 0 || empire >= EMPIRE_MAX_NUM)
-	{
-		sys_err("ThreeWayWar::GetKillScore Wrong Empire variable");
-		return 0;
-	}
-
-	return KillScore_[empire - 1];
-}
-
-void CThreeWayWar::SetKillScore(BYTE empire, int count)
-{
-	if (empire <= 0 || empire >= EMPIRE_MAX_NUM)
-	{
-		sys_err("ThreeWayWar::SetKillScore Wrong Empire variable");
-		return;
-	}
-
-	KillScore_[empire - 1] = count;
-}
-
-void CThreeWayWar::SetReviveTokenForPlayer(DWORD PlayerID, int count)
-{
-	if (0 == PlayerID)
-		return;
-
-	ReviveTokenMap_[PlayerID] = count;
-}
-
-int CThreeWayWar::GetReviveTokenForPlayer(DWORD PlayerID)
-{
-	if (0 == PlayerID)
-		return 0;
-
-	return ReviveTokenMap_[PlayerID];
-}
-
-void CThreeWayWar::DecreaseReviveTokenForPlayer(DWORD PlayerID)
-{
-	if (0 == PlayerID)
-		return;
-
-	ReviveTokenMap_[PlayerID] = ReviveTokenMap_[PlayerID] - 1;
-}
-
-bool CThreeWayWar::LoadSetting(const char* szFileName)
-{
-	char szPath[1024];
-	snprintf(szPath, sizeof(szPath), "%s/%s", LocaleService_GetBasePath().c_str(), szFileName);
-
-	FILE* pf = fopen(szPath, "r");
-
-	if (NULL == pf)
-	{
-		sys_err("[INIT_FORKED] Do not open file (%s)", szPath);
-		return false;
-	}
-
-	char szLine[256];
-	char szSungziName[128];
-	char szPassName[3][128];
-
-	while (NULL != fgets(szLine, 256, pf))
-	{
-		if (0 == strncmp(szLine, "sungzi:", 7))
-		{
-			struct ForkedSungziMapInfo sungziinfo;
-
-			sscanf(szLine + 7, "%d %d %d %d %d %d %d %s %d",
-				&sungziinfo.m_iForkedSung,
-				&sungziinfo.m_iForkedSungziStartPosition[0][0], &sungziinfo.m_iForkedSungziStartPosition[0][1],
-				&sungziinfo.m_iForkedSungziStartPosition[1][0], &sungziinfo.m_iForkedSungziStartPosition[1][1],
-				&sungziinfo.m_iForkedSungziStartPosition[2][0], &sungziinfo.m_iForkedSungziStartPosition[2][1],
-				szSungziName, &sungziinfo.m_iBossMobVnum);
-
-			sungziinfo.m_stMapName = static_cast<std::string>(szSungziName);
-
-			SungZiInfoMap_.push_back(sungziinfo);
-
-			MapIndexSet_.insert(sungziinfo.m_iForkedSung);
-		}
-		else if (0 == strncmp(szLine, "pass:", 5))
-		{
-			struct ForkedPassMapInfo passinfo;
-
-			sscanf(szLine + 5, "%d %d %d %s %d %d %d %s %d %d %d %s",
-				&passinfo.m_iForkedPass[0],
-				&passinfo.m_iForkedPassStartPosition[0][0], &passinfo.m_iForkedPassStartPosition[0][1], szPassName[0],
-				&passinfo.m_iForkedPass[1],
-				&passinfo.m_iForkedPassStartPosition[1][0], &passinfo.m_iForkedPassStartPosition[1][1], szPassName[1],
-				&passinfo.m_iForkedPass[2],
-				&passinfo.m_iForkedPassStartPosition[2][0], &passinfo.m_iForkedPassStartPosition[2][1], szPassName[2]);
-
-			passinfo.m_stMapName[0] = static_cast<std::string>(szPassName[0]);
-			passinfo.m_stMapName[1] = static_cast<std::string>(szPassName[1]);
-			passinfo.m_stMapName[2] = static_cast<std::string>(szPassName[2]);
-
-			PassInfoMap_.push_back(passinfo);
-
-			MapIndexSet_.insert(passinfo.m_iForkedPass[0]);
-			MapIndexSet_.insert(passinfo.m_iForkedPass[1]);
-			MapIndexSet_.insert(passinfo.m_iForkedPass[2]);
-		}
-	}
-
-	fclose(pf);
-
-	return true;
-}
-
-const ForkedPassMapInfo& CThreeWayWar::GetEventPassMapInfo() const
-{
-	const size_t idx = quest::CQuestManager::instance().GetEventFlag("threeway_war_pass_idx");
-
-	return PassInfoMap_[idx];
-}
-
-const ForkedSungziMapInfo& CThreeWayWar::GetEventSungZiMapInfo() const
-{
-	const size_t idx = quest::CQuestManager::instance().GetEventFlag("threeway_war_sungzi_idx");
-
-	return SungZiInfoMap_[idx];
-}
-
-bool CThreeWayWar::IsThreeWayWarMapIndex(int iMapIndex) const
-{
-	return MapIndexSet_.find(iMapIndex) != MapIndexSet_.end();
-}
-
-bool CThreeWayWar::IsSungZiMapIndex(int iMapIndex) const
-{
-	std::vector<ForkedSungziMapInfo>::const_iterator it = SungZiInfoMap_.begin();
-
-	for (; it != SungZiInfoMap_.end(); ++it)
-	{
-		if (iMapIndex == it->m_iForkedSung)
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-void CThreeWayWar::RandomEventMapSet()
-{
-	const size_t pass_idx = number(0, PassInfoMap_.size() - 1);
-	const size_t sung_idx = number(0, SungZiInfoMap_.size() - 1);
-
-	quest::CQuestManager::instance().RequestSetEventFlag("threeway_war_sungzi_idx", sung_idx);
-	quest::CQuestManager::instance().RequestSetEventFlag("threeway_war_pass_idx", pass_idx);
-}
-
-bool CThreeWayWar::IsRegisteredUser(DWORD PlayerID) const
-{
-	auto iter = RegisterUserMap_.find(PlayerID);
-	if (iter == RegisterUserMap_.end())
-		return false;
-
-	return true;
-}
-
-void CThreeWayWar::RegisterUser(DWORD PlayerID)
-{
-	if (0 == PlayerID)
-		return;
-
-	RegisterUserMap_.insert(std::make_pair(PlayerID, PlayerID));
-}
-
-int GetKillValue(int level)
-{
-	int iMinLevelFor1Point, iMaxLevelFor1Point;
-	int iMinLevelFor2Point, iMaxLevelFor2Point;
-	int iMinLevelFor3Point, iMaxLevelFor3Point;
-	int iMinLevelFor4Point, iMaxLevelFor4Point;
-
-	iMinLevelFor1Point = 30; iMaxLevelFor1Point = 39;
-	iMinLevelFor2Point = 40; iMaxLevelFor2Point = 49;
-	iMinLevelFor3Point = 50; iMaxLevelFor3Point = 99;
-	iMinLevelFor4Point = 100; iMaxLevelFor4Point = gPlayerMaxLevel;
-
-	if (iMinLevelFor1Point <= level && level <= iMaxLevelFor1Point)
-	{
-		return 1;
-	}
-	else if (iMinLevelFor2Point <= level && level <= iMaxLevelFor2Point)
-	{
-		return 2;
-	}
-	else if (iMinLevelFor3Point <= level && level <= iMaxLevelFor3Point)
-	{
-		return 3;
-	}
-	else if (iMinLevelFor4Point <= level && level <= iMaxLevelFor4Point)
-	{
-		return 4;
-	}
-
-	return 0;
-}
-
-void CThreeWayWar::onDead(LPCHARACTER pChar, LPCHARACTER pkKiller)
-{
-	if (false == pChar->IsPC())
-		return;
-
-	if (GM_PLAYER != pChar->GetGMLevel() && false == test_server)
-		return;
-
-	if (-1 == GetRegenFlag())
-		return;
-
-	DecreaseReviveTokenForPlayer(pChar->GetPlayerID());
-
-	if (false == IsSungZiMapIndex(pChar->GetMapIndex()))
-		return;
-
-	if (NULL == pkKiller || true != pkKiller->IsPC())
-		return;
-
-	// 같은 제국은 계산하지 않음
-	if (pChar->GetEmpire() == pkKiller->GetEmpire())
-		return;
-
-	int nKillScore = GetKillScore(pkKiller->GetEmpire());
-
-	// 제국 킬 스코어가 -1일경우는 탈락국가이기때문에 점수 체크를 하면 안된다.
-	if (nKillScore >= 0)
-	{
-		nKillScore += GetKillValue(pChar->GetLevel());
-		SetKillScore(pkKiller->GetEmpire(), nKillScore);
-	}
-
-	if (nKillScore != 0 && (test_server || (nKillScore % 5) == 0))
-	{
-		char szBuf[64 + 1];
-		snprintf(szBuf, sizeof(szBuf), LC_STRING("현재 스코어 신수국:%d 천조국:%d 진노국:%d",
-			GetKillScore(1), GetKillScore(2), GetKillScore(3)));
-
-		SendNoticeMap(szBuf, GetSungziMapIndex(), false);
-	}
-
-	const int nVictoryScore = quest::CQuestManager::instance().GetEventFlag("threeway_war_kill_count");
-
-	if (0 == GetRegenFlag())
-	{
-		int nEliminatedEmpireCount = 0;
-		BYTE bLoseEmpire = 0;
-
-		for (int n = 1; n < 4; ++n)
-		{
-			if (nVictoryScore > GetKillScore(n))
-			{
-				++nEliminatedEmpireCount;
-				bLoseEmpire = n;
-			}
-		}
-
-		if (1 != nEliminatedEmpireCount)
-			return;
-
-		// ---------------------------------------------------
-		// 카운트 초기화
-		// ---------------------------------------------------
-		SetKillScore(1, 0);
-		SetKillScore(2, 0);
-		SetKillScore(3, 0);
-		SetKillScore(bLoseEmpire, -1);
-
-		quest::warp_all_to_map_my_empire_event_info* info;
-
-		// ---------------------------------------------------
-		// 탈락국가 퇴장 시키기 : 성지에서
-		// ---------------------------------------------------
-		info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
-
-		info->m_lMapIndexFrom = GetSungziMapIndex();
-		info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
-		info->m_x = EMPIRE_START_X(bLoseEmpire);
-		info->m_y = EMPIRE_START_Y(bLoseEmpire);
-		info->m_bEmpire = bLoseEmpire;
-
-		event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(10));
-
-		// ---------------------------------------------------
-		//탈락국가 퇴장 시키기 : 통로에서
-		// ---------------------------------------------------
-		info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
-
-		info->m_lMapIndexFrom = GetPassMapIndex(bLoseEmpire);
-		info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
-		info->m_x = EMPIRE_START_X(bLoseEmpire);
-		info->m_y = EMPIRE_START_Y(bLoseEmpire);
-		info->m_bEmpire = bLoseEmpire;
-
-		event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(10));
-
-		// ---------------------------------------------------
-		//성지에 팅기는 국가에 대한 이야기를 마왕이 함!
-		// ---------------------------------------------------
-		const std::string Nation(EMPIRE_NAME(bLoseEmpire));
-		const std::string Script(
-			LC_STRING("성지의 마왕: 너희 ") +
-			Nation +
-			LC_STRING("녀석들은 이곳 성지에 있을 자격을 잃었다. 모두 성지에서 물러나거라~~[ENTER][ENTER] 10초 후에 모두 마을로 이동하게 됩니다. ") +
-			"[ENTER][DONE]"
-		);
-
-		CHARACTER_MANAGER::instance().SendScriptToMap(pChar->GetMapIndex(), Script);
-
-		// ---------------------------------------------------
-		// 공지 한방 날려줌.
-		// ---------------------------------------------------
-		char szNotice[512 + 1];
-		snprintf(szNotice, sizeof(szNotice), LC_STRING("삼거리 전투에서 %s 국가가 가장먼저 탈락을 하였습니다", Nation.c_str()));
-		BroadcastNotice(szNotice);
-
-		snprintf(szNotice, sizeof(szNotice), "First Step: %s exclusion", Nation.c_str());
-		LogManager::instance().CharLog(0, 0, 0, 0, "THREEWAY", szNotice, NULL);
-
-		// ---------------------------------------------------
-		// 몹을 리젠한다.
-		// ---------------------------------------------------
-		regen_mob_event_info* regen_info = AllocEventInfo<regen_mob_event_info>();
-
-		regen_info->dwMapIndex = pChar->GetMapIndex();
-
-		event_create(regen_mob_event, regen_info, PASSES_PER_SEC(10));
-
-		SetRegenFlag(1);
-	}
-	else if (1 == GetRegenFlag())
-	{
-		int nVictoryEmpireIndex = 0;
-
-		for (int n = 1; n < 4; ++n)
-		{
-			nKillScore = GetKillScore(n);
-
-			if (nKillScore == -1)
-				continue;
-
-			if (nVictoryScore <= nKillScore)
-			{
-				nVictoryEmpireIndex = n;
-				break;
-			}
-		}
-
-		if (0 == nVictoryEmpireIndex)
-			return;
-
-		for (int n = 1; n < 4; ++n)
-		{
-			if (n != nVictoryEmpireIndex)
-			{
-				BYTE bLoseEmpire = n;
-				quest::warp_all_to_map_my_empire_event_info* info;
-
-				// ---------------------------------------------------
-				// 탈락국가 퇴장 시키기 : 성지에서
-				// ---------------------------------------------------
-				info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
-
-				info->m_lMapIndexFrom = GetSungziMapIndex();
-				info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
-				info->m_x = EMPIRE_START_X(bLoseEmpire);
-				info->m_y = EMPIRE_START_Y(bLoseEmpire);
-				info->m_bEmpire = bLoseEmpire;
-
-				event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(5));
-
-				// ---------------------------------------------------
-				//탈락국가 퇴장 시키기 : 통로에서
-				// ---------------------------------------------------
-				info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
-
-				info->m_lMapIndexFrom = GetPassMapIndex(bLoseEmpire);
-				info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
-				info->m_x = EMPIRE_START_X(bLoseEmpire);
-				info->m_y = EMPIRE_START_Y(bLoseEmpire);
-				info->m_bEmpire = bLoseEmpire;
-
-				event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(5));
-			}
-		}
-
-		// ---------------------------------------------------
-		// 최종 스코어 표시 
-		// ---------------------------------------------------
-		{
-			char szBuf[64 + 1];
-			snprintf(szBuf, sizeof(szBuf), LC_STRING("현재 스코어 신수국:%d 천조국:%d 진노국:%d",
-				GetKillScore(1), GetKillScore(2), GetKillScore(3)));
-
-			SendNoticeMap(szBuf, GetSungziMapIndex(), false);
-		}
-
-		// 메세지를 띄워준다.
-		LPSECTREE_MAP pSecMap = SECTREE_MANAGER::instance().GetMap(pChar->GetMapIndex());
-
-		if (NULL != pSecMap)
-		{
-			const std::string EmpireName(EMPIRE_NAME(nVictoryEmpireIndex));
-			const std::string Script(
-				EmpireName +
-				LC_STRING(". 너희가 성지의 수호자를 잡게 된다면 너희는 성지의 주인이 된다.[ENTER][ENTER] ") +
-				"[ENTER][DONE]");
-
-			struct packet_script pack_script;
-
-			pack_script.header = HEADER_GC_SCRIPT;
-			pack_script.skin = 1;
-			pack_script.src_size = Script.size();
-
-			quest::FSendPacketToEmpire fSend;
-			fSend.bEmpire = nVictoryEmpireIndex;
-
-			pack_script.size = pack_script.src_size + sizeof(struct packet_script);
-			fSend.buf.write(&pack_script, sizeof(struct packet_script));
-			fSend.buf.write(&Script[0], Script.size());
-
-			pSecMap->for_each(fSend);
-
-			char szBuf[512];
-			snprintf(szBuf, sizeof(szBuf), "Second Step: %s remain", EMPIRE_NAME(nVictoryEmpireIndex));
-			LogManager::instance().CharLog(0, 0, 0, 0, "THREEWAY", szBuf, NULL);
-		}
-
-		// ---------------------------------------------------
-		// 마지막 보상 : 진구미호 소환
-		// ---------------------------------------------------
-		for (int n = 0; n < quest::CQuestManager::instance().GetEventFlag("threeway_war_boss_count");)
-		{
-			int x = pChar->GetX();
-			int y = pChar->GetY();
-
-			x = (thecore_random() & 1) ? x - number(200, 1000) : x + number(200, 1000);
-			y = (thecore_random() & 1) ? y - number(200, 1000) : y + number(200, 1000);
-
-			if (x < 0)
-				x = pChar->GetX();
-
-			if (y < 0)
-				y = pChar->GetY();
-
-			LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(
-				GetEventSungZiMapInfo().m_iBossMobVnum,
-				pChar->GetMapIndex(),
-				x, y, 0, false);
-
-			if (NULL != ch)
-			{
-				ch->SetAggressive();
-				++n;
-			}
-		}
-
-		SetRegenFlag(-1);
-	}
-}
-
-struct FDestroyAllEntity
-{
-	void operator() (LPENTITY ent)
-	{
-		if (true == ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = static_cast<LPCHARACTER>(ent);
-
-			if (false == ch->IsPC())
-			{
-				ch->Dead();
-			}
-		}
-	}
-};
-
-void CThreeWayWar::RemoveAllMonstersInThreeWay() const
-{
-	std::set<int>::const_iterator iter = MapIndexSet_.begin();
-
-	while (iter != MapIndexSet_.end())
-	{
-		LPSECTREE_MAP pSecMap = SECTREE_MANAGER::instance().GetMap(*iter);
-
-		if (NULL != pSecMap)
-		{
-			FDestroyAllEntity f;
-
-			pSecMap->for_each(f);
-		}
-
-		++iter;
-	}
-}
-
-//
-// C functions
-//
-const char* GetSungziMapPath()
-{
-	static char s_szMapPath[128];
-
-	snprintf(s_szMapPath, sizeof(s_szMapPath), "%s/map/%s/",
-		LocaleService_GetBasePath().c_str(),
-		CThreeWayWar::instance().GetEventSungZiMapInfo().m_stMapName.c_str());
-
-	return s_szMapPath;
-}
-
-const char* GetPassMapPath(BYTE bEmpire)
-{
-	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
-	{
-		static char s_szMapPath[128];
-
-		snprintf(s_szMapPath, sizeof(s_szMapPath), "%s/map/%s/",
-			LocaleService_GetBasePath().c_str(),
-			CThreeWayWar::instance().GetEventPassMapInfo().m_stMapName[bEmpire - 1].c_str());
-
-		return s_szMapPath;
-	}
-
-	return NULL;
-}
-
-int GetPassMapIndex(BYTE bEmpire)
-{
-	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
-	{
-		return CThreeWayWar::instance().GetEventPassMapInfo().m_iForkedPass[bEmpire - 1];
-	}
-
-	return 0;
-}
-
-int GetPassStartX(BYTE bEmpire)
-{
-	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
-	{
-		return CThreeWayWar::instance().GetEventPassMapInfo().m_iForkedPassStartPosition[bEmpire - 1][0];
-	}
-
-	return 0;
-}
-
-int GetPassStartY(BYTE bEmpire)
-{
-	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
-	{
-		return CThreeWayWar::instance().GetEventPassMapInfo().m_iForkedPassStartPosition[bEmpire - 1][1];
-	}
-
-	return 0;
-}
-
-int GetSungziMapIndex()
-{
-	return CThreeWayWar::instance().GetEventSungZiMapInfo().m_iForkedSung;
-}
-
-int GetSungziStartX(BYTE bEmpire)
-{
-	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
-	{
-		return CThreeWayWar::instance().GetEventSungZiMapInfo().m_iForkedSungziStartPosition[bEmpire - 1][0];
-	}
-
-	return 0;
-}
-
-int GetSungziStartY(BYTE bEmpire)
-{
-	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
-	{
-		return CThreeWayWar::instance().GetEventSungZiMapInfo().m_iForkedSungziStartPosition[bEmpire - 1][1];
-	}
-
-	return 0;
-}
+#include "stdafx.h"
+
+#include "threeway_war.h"
+
+#include "../../common/length.h"
+#include "../../common/tables.h"
+#include "p2p.h"
+#include "locale_service.h"
+#include "packet.h"
+#include "char.h"
+#include "questmanager.h"
+#include "questlua.h"
+#include "start_position.h"
+#include "char_manager.h"
+#include "sectree_manager.h"
+#include "regen.h"
+#include "log.h"
+#include "config.h"
+
+extern int test_server;
+extern int passes_per_sec;
+
+EVENTINFO(regen_mob_event_info)
+{
+	DWORD dwMapIndex;
+
+	regen_mob_event_info()
+		: dwMapIndex(0)
+	{
+	}
+};
+
+EVENTFUNC(regen_mob_event)
+{
+	regen_mob_event_info* info = dynamic_cast<regen_mob_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("regen_mob_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	int iMapIndex = info->dwMapIndex;
+
+	char filename[128];
+	std::string szFilename(GetSungziMapPath());
+
+	int choice = quest::CQuestManager::instance().GetEventFlag("threeway_war_choice");
+	if (0 == choice)
+		snprintf(filename, sizeof(filename), "%sregen00.txt", GetSungziMapPath());
+	else
+	{
+		snprintf(filename, sizeof(filename), "%sregen00_%d.txt", GetSungziMapPath(), choice);
+	}
+
+	LPSECTREE_MAP pkMap = SECTREE_MANAGER::instance().GetMap(iMapIndex);
+
+	if (NULL != pkMap)
+	{
+		if (0 != choice)
+			if (regen_load_in_file(filename, iMapIndex, pkMap->m_setting.iBaseX, pkMap->m_setting.iBaseY))
+			{
+				snprintf(filename, sizeof(filename), "%sregen00.txt", GetSungziMapPath());
+				regen_load_in_file(filename, iMapIndex, pkMap->m_setting.iBaseX, pkMap->m_setting.iBaseY);
+			}
+	}
+
+	return 0;
+}
+
+CThreeWayWar::CThreeWayWar()
+{
+	Initialize();
+}
+
+CThreeWayWar::~CThreeWayWar()
+{
+	RegisterUserMap_.clear();
+	ReviveTokenMap_.clear();
+}
+
+void CThreeWayWar::Initialize()
+{
+	RegenFlag_ = 0;
+
+	memset(KillScore_, 0, sizeof(KillScore_));
+
+	RegisterUserMap_.clear();
+	ReviveTokenMap_.clear();
+}
+
+int CThreeWayWar::GetKillScore(BYTE empire) const
+{
+	if (empire <= 0 || empire >= EMPIRE_MAX_NUM)
+	{
+		sys_err("ThreeWayWar::GetKillScore Wrong Empire variable");
+		return 0;
+	}
+
+	return KillScore_[empire - 1];
+}
+
+void CThreeWayWar::SetKillScore(BYTE empire, int count)
+{
+	if (empire <= 0 || empire >= EMPIRE_MAX_NUM)
+	{
+		sys_err("ThreeWayWar::SetKillScore Wrong Empire variable");
+		return;
+	}
+
+	KillScore_[empire - 1] = count;
+}
+
+void CThreeWayWar::SetReviveTokenForPlayer(DWORD PlayerID, int count)
+{
+	if (0 == PlayerID)
+		return;
+
+	ReviveTokenMap_[PlayerID] = count;
+}
+
+int CThreeWayWar::GetReviveTokenForPlayer(DWORD PlayerID)
+{
+	if (0 == PlayerID)
+		return 0;
+
+	return ReviveTokenMap_[PlayerID];
+}
+
+void CThreeWayWar::DecreaseReviveTokenForPlayer(DWORD PlayerID)
+{
+	if (0 == PlayerID)
+		return;
+
+	ReviveTokenMap_[PlayerID] = ReviveTokenMap_[PlayerID] - 1;
+}
+
+bool CThreeWayWar::LoadSetting(const char* szFileName)
+{
+	char szPath[1024];
+	snprintf(szPath, sizeof(szPath), "%s/%s", LocaleService_GetBasePath().c_str(), szFileName);
+
+	FILE* pf = fopen(szPath, "r");
+
+	if (NULL == pf)
+	{
+		sys_err("[INIT_FORKED] Do not open file (%s)", szPath);
+		return false;
+	}
+
+	char szLine[256];
+	char szSungziName[128];
+	char szPassName[3][128];
+
+	while (NULL != fgets(szLine, 256, pf))
+	{
+		if (0 == strncmp(szLine, "sungzi:", 7))
+		{
+			struct ForkedSungziMapInfo sungziinfo;
+
+			sscanf(szLine + 7, "%d %d %d %d %d %d %d %s %d",
+				&sungziinfo.m_iForkedSung,
+				&sungziinfo.m_iForkedSungziStartPosition[0][0], &sungziinfo.m_iForkedSungziStartPosition[0][1],
+				&sungziinfo.m_iForkedSungziStartPosition[1][0], &sungziinfo.m_iForkedSungziStartPosition[1][1],
+				&sungziinfo.m_iForkedSungziStartPosition[2][0], &sungziinfo.m_iForkedSungziStartPosition[2][1],
+				szSungziName, &sungziinfo.m_iBossMobVnum);
+
+			sungziinfo.m_stMapName = static_cast<std::string>(szSungziName);
+
+			SungZiInfoMap_.push_back(sungziinfo);
+
+			MapIndexSet_.insert(sungziinfo.m_iForkedSung);
+		}
+		else if (0 == strncmp(szLine, "pass:", 5))
+		{
+			struct ForkedPassMapInfo passinfo;
+
+			sscanf(szLine + 5, "%d %d %d %s %d %d %d %s %d %d %d %s",
+				&passinfo.m_iForkedPass[0],
+				&passinfo.m_iForkedPassStartPosition[0][0], &passinfo.m_iForkedPassStartPosition[0][1], szPassName[0],
+				&passinfo.m_iForkedPass[1],
+				&passinfo.m_iForkedPassStartPosition[1][0], &passinfo.m_iForkedPassStartPosition[1][1], szPassName[1],
+				&passinfo.m_iForkedPass[2],
+				&passinfo.m_iForkedPassStartPosition[2][0], &passinfo.m_iForkedPassStartPosition[2][1], szPassName[2]);
+
+			passinfo.m_stMapName[0] = static_cast<std::string>(szPassName[0]);
+			passinfo.m_stMapName[1] = static_cast<std::string>(szPassName[1]);
+			passinfo.m_stMapName[2] = static_cast<std::string>(szPassName[2]);
+
+			PassInfoMap_.push_back(passinfo);
+
+			MapIndexSet_.insert(passinfo.m_iForkedPass[0]);
+			MapIndexSet_.insert(passinfo.m_iForkedPass[1]);
+			MapIndexSet_.insert(passinfo.m_iForkedPass[2]);
+		}
+	}
+
+	fclose(pf);
+
+	return true;
+}
+
+const ForkedPassMapInfo& CThreeWayWar::GetEventPassMapInfo() const
+{
+	const size_t idx = quest::CQuestManager::instance().GetEventFlag("threeway_war_pass_idx");
+
+	return PassInfoMap_[idx];
+}
+
+const ForkedSungziMapInfo& CThreeWayWar::GetEventSungZiMapInfo() const
+{
+	const size_t idx = quest::CQuestManager::instance().GetEventFlag("threeway_war_sungzi_idx");
+
+	return SungZiInfoMap_[idx];
+}
+
+bool CThreeWayWar::IsThreeWayWarMapIndex(int iMapIndex) const
+{
+	return MapIndexSet_.find(iMapIndex) != MapIndexSet_.end();
+}
+
+bool CThreeWayWar::IsSungZiMapIndex(int iMapIndex) const
+{
+	std::vector<ForkedSungziMapInfo>::const_iterator it = SungZiInfoMap_.begin();
+
+	for (; it != SungZiInfoMap_.end(); ++it)
+	{
+		if (iMapIndex == it->m_iForkedSung)
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void CThreeWayWar::RandomEventMapSet()
+{
+	const size_t pass_idx = number(0, PassInfoMap_.size() - 1);
+	const size_t sung_idx = number(0, SungZiInfoMap_.size() - 1);
+
+	quest::CQuestManager::instance().RequestSetEventFlag("threeway_war_sungzi_idx", sung_idx);
+	quest::CQuestManager::instance().RequestSetEventFlag("threeway_war_pass_idx", pass_idx);
+}
+
+bool CThreeWayWar::IsRegisteredUser(DWORD PlayerID) const
+{
+	auto iter = RegisterUserMap_.find(PlayerID);
+	if (iter == RegisterUserMap_.end())
+		return false;
+
+	return true;
+}
+
+void CThreeWayWar::RegisterUser(DWORD PlayerID)
+{
+	if (0 == PlayerID)
+		return;
+
+	RegisterUserMap_.insert(std::make_pair(PlayerID, PlayerID));
+}
+
+int GetKillValue(int level)
+{
+	int iMinLevelFor1Point, iMaxLevelFor1Point;
+	int iMinLevelFor2Point, iMaxLevelFor2Point;
+	int iMinLevelFor3Point, iMaxLevelFor3Point;
+	int iMinLevelFor4Point, iMaxLevelFor4Point;
+
+	iMinLevelFor1Point = 30; iMaxLevelFor1Point = 39;
+	iMinLevelFor2Point = 40; iMaxLevelFor2Point = 49;
+	iMinLevelFor3Point = 50; iMaxLevelFor3Point = 99;
+	iMinLevelFor4Point = 100; iMaxLevelFor4Point = gPlayerMaxLevel;
+
+	if (iMinLevelFor1Point <= level && level <= iMaxLevelFor1Point)
+	{
+		return 1;
+	}
+	else if (iMinLevelFor2Point <= level && level <= iMaxLevelFor2Point)
+	{
+		return 2;
+	}
+	else if (iMinLevelFor3Point <= level && level <= iMaxLevelFor3Point)
+	{
+		return 3;
+	}
+	else if (iMinLevelFor4Point <= level && level <= iMaxLevelFor4Point)
+	{
+		return 4;
+	}
+
+	return 0;
+}
+
+void CThreeWayWar::onDead(LPCHARACTER pChar, LPCHARACTER pkKiller)
+{
+	if (false == pChar->IsPC())
+		return;
+
+	if (GM_PLAYER != pChar->GetGMLevel() && false == test_server)
+		return;
+
+	if (-1 == GetRegenFlag())
+		return;
+
+	DecreaseReviveTokenForPlayer(pChar->GetPlayerID());
+
+	if (false == IsSungZiMapIndex(pChar->GetMapIndex()))
+		return;
+
+	if (NULL == pkKiller || true != pkKiller->IsPC())
+		return;
+
+	//    
+	if (pChar->GetEmpire() == pkKiller->GetEmpire())
+		return;
+
+	int nKillScore = GetKillScore(pkKiller->GetEmpire());
+
+	//  킬 岷載 -1構 탈堅粹  체크 玖 홴홱.
+	if (nKillScore >= 0)
+	{
+		nKillScore += GetKillValue(pChar->GetLevel());
+		SetKillScore(pkKiller->GetEmpire(), nKillScore);
+	}
+
+	if (nKillScore != 0 && (test_server || (nKillScore % 5) == 0))
+	{
+		char szBuf[64 + 1];
+		snprintf(szBuf, sizeof(szBuf), LC_STRING(" 岷 탉:%d 천:%d 諭:%d",
+			GetKillScore(1), GetKillScore(2), GetKillScore(3)));
+
+		SendNoticeMap(szBuf, GetSungziMapIndex(), false);
+	}
+
+	const int nVictoryScore = quest::CQuestManager::instance().GetEventFlag("threeway_war_kill_count");
+
+	if (0 == GetRegenFlag())
+	{
+		int nEliminatedEmpireCount = 0;
+		BYTE bLoseEmpire = 0;
+
+		for (int n = 1; n < 4; ++n)
+		{
+			if (nVictoryScore > GetKillScore(n))
+			{
+				++nEliminatedEmpireCount;
+				bLoseEmpire = n;
+			}
+		}
+
+		if (1 != nEliminatedEmpireCount)
+			return;
+
+		// ---------------------------------------------------
+		// 카트 珂화
+		// ---------------------------------------------------
+		SetKillScore(1, 0);
+		SetKillScore(2, 0);
+		SetKillScore(3, 0);
+		SetKillScore(bLoseEmpire, -1);
+
+		quest::warp_all_to_map_my_empire_event_info* info;
+
+		// ---------------------------------------------------
+		// 탈  키 : 
+		// ---------------------------------------------------
+		info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
+
+		info->m_lMapIndexFrom = GetSungziMapIndex();
+		info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
+		info->m_x = EMPIRE_START_X(bLoseEmpire);
+		info->m_y = EMPIRE_START_Y(bLoseEmpire);
+		info->m_bEmpire = bLoseEmpire;
+
+		event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(10));
+
+		// ---------------------------------------------------
+		//탈  키 : 恝
+		// ---------------------------------------------------
+		info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
+
+		info->m_lMapIndexFrom = GetPassMapIndex(bLoseEmpire);
+		info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
+		info->m_x = EMPIRE_START_X(bLoseEmpire);
+		info->m_y = EMPIRE_START_Y(bLoseEmpire);
+		info->m_bEmpire = bLoseEmpire;
+
+		event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(10));
+
+		// ---------------------------------------------------
+		// 챰   潔薩綬  !
+		// ---------------------------------------------------
+		const std::string Nation(EMPIRE_NAME(bLoseEmpire));
+		const std::string Script(
+			LC_STRING(" :  ") +
+			Nation +
+			LC_STRING("善 隔   微 勞.   킷~~[ENTER][ENTER] 10 커   絹構 絳求. ") +
+			"[ENTER][DONE]"
+		);
+
+		CHARACTER_MANAGER::instance().SendScriptToMap(pChar->GetMapIndex(), Script);
+
+		// ---------------------------------------------------
+		//  箕 .
+		// ---------------------------------------------------
+		char szNotice[512 + 1];
+		snprintf(szNotice, sizeof(szNotice), LC_STRING("타  %s   탈 臼求", Nation.c_str()));
+		BroadcastNotice(szNotice);
+
+		snprintf(szNotice, sizeof(szNotice), "First Step: %s exclusion", Nation.c_str());
+		LogManager::instance().CharLog(0, 0, 0, 0, "THREEWAY", szNotice, NULL);
+
+		// ---------------------------------------------------
+		//  磯.
+		// ---------------------------------------------------
+		regen_mob_event_info* regen_info = AllocEventInfo<regen_mob_event_info>();
+
+		regen_info->dwMapIndex = pChar->GetMapIndex();
+
+		event_create(regen_mob_event, regen_info, PASSES_PER_SEC(10));
+
+		SetRegenFlag(1);
+	}
+	else if (1 == GetRegenFlag())
+	{
+		int nVictoryEmpireIndex = 0;
+
+		for (int n = 1; n < 4; ++n)
+		{
+			nKillScore = GetKillScore(n);
+
+			if (nKillScore == -1)
+				continue;
+
+			if (nVictoryScore <= nKillScore)
+			{
+				nVictoryEmpireIndex = n;
+				break;
+			}
+		}
+
+		if (0 == nVictoryEmpireIndex)
+			return;
+
+		for (int n = 1; n < 4; ++n)
+		{
+			if (n != nVictoryEmpireIndex)
+			{
+				BYTE bLoseEmpire = n;
+				quest::warp_all_to_map_my_empire_event_info* info;
+
+				// ---------------------------------------------------
+				// 탈  키 : 
+				// ---------------------------------------------------
+				info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
+
+				info->m_lMapIndexFrom = GetSungziMapIndex();
+				info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
+				info->m_x = EMPIRE_START_X(bLoseEmpire);
+				info->m_y = EMPIRE_START_Y(bLoseEmpire);
+				info->m_bEmpire = bLoseEmpire;
+
+				event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(5));
+
+				// ---------------------------------------------------
+				//탈  키 : 恝
+				// ---------------------------------------------------
+				info = AllocEventInfo<quest::warp_all_to_map_my_empire_event_info>();
+
+				info->m_lMapIndexFrom = GetPassMapIndex(bLoseEmpire);
+				info->m_lMapIndexTo = EMPIRE_START_MAP(bLoseEmpire);
+				info->m_x = EMPIRE_START_X(bLoseEmpire);
+				info->m_y = EMPIRE_START_Y(bLoseEmpire);
+				info->m_bEmpire = bLoseEmpire;
+
+				event_create(quest::warp_all_to_map_my_empire_event, info, PASSES_PER_SEC(5));
+			}
+		}
+
+		// ---------------------------------------------------
+		//  岷 표 
+		// ---------------------------------------------------
+		{
+			char szBuf[64 + 1];
+			snprintf(szBuf, sizeof(szBuf), LC_STRING(" 岷 탉:%d 천:%d 諭:%d",
+				GetKillScore(1), GetKillScore(2), GetKillScore(3)));
+
+			SendNoticeMap(szBuf, GetSungziMapIndex(), false);
+		}
+
+		// 氷 娩.
+		LPSECTREE_MAP pSecMap = SECTREE_MANAGER::instance().GetMap(pChar->GetMapIndex());
+
+		if (NULL != pSecMap)
+		{
+			const std::string EmpireName(EMPIRE_NAME(nVictoryEmpireIndex));
+			const std::string Script(
+				EmpireName +
+				LC_STRING(".   호美  홱摸    홱.[ENTER][ENTER] ") +
+				"[ENTER][DONE]");
+
+			struct packet_script pack_script;
+
+			pack_script.header = HEADER_GC_SCRIPT;
+			pack_script.skin = 1;
+			pack_script.src_size = Script.size();
+
+			quest::FSendPacketToEmpire fSend;
+			fSend.bEmpire = nVictoryEmpireIndex;
+
+			pack_script.size = pack_script.src_size + sizeof(struct packet_script);
+			fSend.buf.write(&pack_script, sizeof(struct packet_script));
+			fSend.buf.write(&Script[0], Script.size());
+
+			pSecMap->for_each(fSend);
+
+			char szBuf[512];
+			snprintf(szBuf, sizeof(szBuf), "Second Step: %s remain", EMPIRE_NAME(nVictoryEmpireIndex));
+			LogManager::instance().CharLog(0, 0, 0, 0, "THREEWAY", szBuf, NULL);
+		}
+
+		// ---------------------------------------------------
+		//   : 호 환
+		// ---------------------------------------------------
+		for (int n = 0; n < quest::CQuestManager::instance().GetEventFlag("threeway_war_boss_count");)
+		{
+			int x = pChar->GetX();
+			int y = pChar->GetY();
+
+			x = (thecore_random() & 1) ? x - number(200, 1000) : x + number(200, 1000);
+			y = (thecore_random() & 1) ? y - number(200, 1000) : y + number(200, 1000);
+
+			if (x < 0)
+				x = pChar->GetX();
+
+			if (y < 0)
+				y = pChar->GetY();
+
+			LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(
+				GetEventSungZiMapInfo().m_iBossMobVnum,
+				pChar->GetMapIndex(),
+				x, y, 0, false);
+
+			if (NULL != ch)
+			{
+				ch->SetAggressive();
+				++n;
+			}
+		}
+
+		SetRegenFlag(-1);
+	}
+}
+
+struct FDestroyAllEntity
+{
+	void operator() (LPENTITY ent)
+	{
+		if (true == ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = static_cast<LPCHARACTER>(ent);
+
+			if (false == ch->IsPC())
+			{
+				ch->Dead();
+			}
+		}
+	}
+};
+
+void CThreeWayWar::RemoveAllMonstersInThreeWay() const
+{
+	std::set<int>::const_iterator iter = MapIndexSet_.begin();
+
+	while (iter != MapIndexSet_.end())
+	{
+		LPSECTREE_MAP pSecMap = SECTREE_MANAGER::instance().GetMap(*iter);
+
+		if (NULL != pSecMap)
+		{
+			FDestroyAllEntity f;
+
+			pSecMap->for_each(f);
+		}
+
+		++iter;
+	}
+}
+
+//
+// C functions
+//
+const char* GetSungziMapPath()
+{
+	static char s_szMapPath[128];
+
+	snprintf(s_szMapPath, sizeof(s_szMapPath), "%s/map/%s/",
+		LocaleService_GetBasePath().c_str(),
+		CThreeWayWar::instance().GetEventSungZiMapInfo().m_stMapName.c_str());
+
+	return s_szMapPath;
+}
+
+const char* GetPassMapPath(BYTE bEmpire)
+{
+	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
+	{
+		static char s_szMapPath[128];
+
+		snprintf(s_szMapPath, sizeof(s_szMapPath), "%s/map/%s/",
+			LocaleService_GetBasePath().c_str(),
+			CThreeWayWar::instance().GetEventPassMapInfo().m_stMapName[bEmpire - 1].c_str());
+
+		return s_szMapPath;
+	}
+
+	return NULL;
+}
+
+int GetPassMapIndex(BYTE bEmpire)
+{
+	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
+	{
+		return CThreeWayWar::instance().GetEventPassMapInfo().m_iForkedPass[bEmpire - 1];
+	}
+
+	return 0;
+}
+
+int GetPassStartX(BYTE bEmpire)
+{
+	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
+	{
+		return CThreeWayWar::instance().GetEventPassMapInfo().m_iForkedPassStartPosition[bEmpire - 1][0];
+	}
+
+	return 0;
+}
+
+int GetPassStartY(BYTE bEmpire)
+{
+	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
+	{
+		return CThreeWayWar::instance().GetEventPassMapInfo().m_iForkedPassStartPosition[bEmpire - 1][1];
+	}
+
+	return 0;
+}
+
+int GetSungziMapIndex()
+{
+	return CThreeWayWar::instance().GetEventSungZiMapInfo().m_iForkedSung;
+}
+
+int GetSungziStartX(BYTE bEmpire)
+{
+	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
+	{
+		return CThreeWayWar::instance().GetEventSungZiMapInfo().m_iForkedSungziStartPosition[bEmpire - 1][0];
+	}
+
+	return 0;
+}
+
+int GetSungziStartY(BYTE bEmpire)
+{
+	if (bEmpire > 0 && bEmpire < EMPIRE_MAX_NUM)
+	{
+		return CThreeWayWar::instance().GetEventSungZiMapInfo().m_iForkedSungziStartPosition[bEmpire - 1][1];
+	}
+
+	return 0;
+}
diff --git a/server/metin2/Source/Server/game/src/war_map.cpp b/server/metin2/Source/Server/game/src/war_map.cpp
index 03b5330..57a9b8b 100644
--- a/server/metin2/Source/Server/game/src/war_map.cpp
+++ b/server/metin2/Source/Server/game/src/war_map.cpp
@@ -1,1105 +1,1180 @@
-#include "stdafx.h"
-#include "war_map.h"
-#include "sectree_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "affect.h"
-#include "item.h"
-#include "config.h"
-#include "desc.h"
-#include "desc_manager.h"
-#include "guild_manager.h"
-#include "buffer_manager.h"
-#include "db.h"
-#include "packet.h"
-#include "locale_service.h"
-
-EVENTINFO(war_map_info)
-{
-	int iStep;
-	CWarMap* pWarMap;
-
-	war_map_info()
-		: iStep(0)
-		, pWarMap(0)
-	{
-	}
-};
-
-EVENTFUNC(war_begin_event)
-{
-	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("war_begin_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	CWarMap* pMap = info->pWarMap;
-	pMap->CheckWarEnd();
-	return PASSES_PER_SEC(10);
-}
-
-EVENTFUNC(war_end_event)
-{
-	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("war_end_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	CWarMap* pMap = info->pWarMap;
-
-	if (info->iStep == 0)
-	{
-		++info->iStep;
-		pMap->ExitAll();
-		return PASSES_PER_SEC(5);
-	}
-	else
-	{
-		pMap->SetEndEvent(NULL);
-		CWarMapManager::instance().DestroyWarMap(pMap);
-		return 0;
-	}
-}
-
-EVENTFUNC(war_timeout_event)
-{
-	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("war_timeout_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	CWarMap* pMap = info->pWarMap;
-	pMap->Timeout();
-	return 0;
-}
-
-void CWarMap::STeamData::Initialize()
-{
-	dwID = 0;
-	pkGuild = NULL;
-	iMemberCount = 0;
-	iUsePotionPrice = 0;
-	iScore = 0;
-	pkChrFlag = NULL;
-	pkChrFlagBase = NULL;
-
-	set_pidJoiner.clear();
-}
-
-CWarMap::CWarMap(long lMapIndex, const TGuildWarInfo& r_info, TWarMapInfo* pkWarMapInfo, DWORD dwGuildID1, DWORD dwGuildID2)
-{
-	m_kMapInfo = *pkWarMapInfo;
-	m_kMapInfo.lMapIndex = lMapIndex;
-
-	memcpy(&m_WarInfo, &r_info, sizeof(TGuildWarInfo));
-
-	m_TeamData[0].Initialize();
-	m_TeamData[0].dwID = dwGuildID1;
-	m_TeamData[0].pkGuild = CGuildManager::instance().TouchGuild(dwGuildID1);
-
-	m_TeamData[1].Initialize();
-	m_TeamData[1].dwID = dwGuildID2;
-	m_TeamData[1].pkGuild = CGuildManager::instance().TouchGuild(dwGuildID2);
-	m_iObserverCount = 0;
-
-	war_map_info* info = AllocEventInfo<war_map_info>();
-	info->pWarMap = this;
-
-	SetBeginEvent(event_create(war_begin_event, info, PASSES_PER_SEC(60)));
-	m_pkEndEvent = NULL;
-	m_pkTimeoutEvent = NULL;
-	m_pkResetFlagEvent = NULL;
-	m_bTimeout = false;
-	m_dwStartTime = get_dword_time();
-	m_bEnded = false;
-
-	if (GetType() == WAR_MAP_TYPE_FLAG)
-	{
-		AddFlagBase(0);
-		AddFlagBase(1);
-		AddFlag(0);
-		AddFlag(1);
-	}
-}
-
-CWarMap::~CWarMap()
-{
-	event_cancel(&m_pkBeginEvent);
-	event_cancel(&m_pkEndEvent);
-	event_cancel(&m_pkTimeoutEvent);
-	event_cancel(&m_pkResetFlagEvent);
-
-	sys_log(0, "WarMap::~WarMap : map index %d", GetMapIndex());
-
-	auto it = m_set_pkChr.begin();
-	while (it != m_set_pkChr.end())
-	{
-		LPCHARACTER ch = *(it++);
-
-		if (ch->GetDesc())
-		{
-			sys_log(0, "WarMap::~WarMap : disconnecting %s", ch->GetName());
-			DESC_MANAGER::instance().DestroyDesc(ch->GetDesc());
-		}
-	}
-
-	m_set_pkChr.clear();
-}
-
-void CWarMap::SetBeginEvent(LPEVENT pkEv)
-{
-	if (m_pkBeginEvent != NULL)
-	{
-		event_cancel(&m_pkBeginEvent);
-	}
-	if (pkEv != NULL)
-	{
-		m_pkBeginEvent = pkEv;
-	}
-}
-
-void CWarMap::SetEndEvent(LPEVENT pkEv)
-{
-	if (m_pkEndEvent != NULL)
-	{
-		event_cancel(&m_pkEndEvent);
-	}
-	if (pkEv != NULL)
-	{
-		m_pkEndEvent = pkEv;
-	}
-}
-
-void CWarMap::SetTimeoutEvent(LPEVENT pkEv)
-{
-	if (m_pkTimeoutEvent != NULL)
-	{
-		event_cancel(&m_pkTimeoutEvent);
-	}
-	if (pkEv != NULL)
-	{
-		m_pkTimeoutEvent = pkEv;
-	}
-}
-
-void CWarMap::SetResetFlagEvent(LPEVENT pkEv)
-{
-	if (m_pkResetFlagEvent != NULL)
-	{
-		event_cancel(&m_pkResetFlagEvent);
-	}
-	if (pkEv != NULL)
-	{
-		m_pkResetFlagEvent = pkEv;
-	}
-}
-
-bool CWarMap::GetTeamIndex(DWORD dwGuildID, BYTE& bIdx)
-{
-	if (m_TeamData[0].dwID == dwGuildID)
-	{
-		bIdx = 0;
-		return true;
-	}
-	else if (m_TeamData[1].dwID == dwGuildID)
-	{
-		bIdx = 1;
-		return true;
-	}
-
-	return false;
-}
-
-DWORD CWarMap::GetGuildID(BYTE bIdx)
-{
-	assert(bIdx < 2);
-	return m_TeamData[bIdx].dwID;
-}
-
-CGuild* CWarMap::GetGuild(BYTE bIdx)
-{
-	return m_TeamData[bIdx].pkGuild;
-}
-
-long CWarMap::GetMapIndex()
-{
-	return m_kMapInfo.lMapIndex;
-}
-
-BYTE CWarMap::GetType()
-{
-	return m_kMapInfo.bType;
-}
-
-DWORD CWarMap::GetGuildOpponent(LPCHARACTER ch)
-{
-	if (ch->GetGuild())
-	{
-		DWORD gid = ch->GetGuild()->GetID();
-		BYTE idx;
-
-		if (GetTeamIndex(gid, idx))
-			return m_TeamData[!idx].dwID;
-	}
-	return 0;
-}
-
-DWORD CWarMap::GetWinnerGuild()
-{
-	DWORD win_gid = 0;
-
-	if (m_TeamData[1].iScore > m_TeamData[0].iScore)
-	{
-		win_gid = m_TeamData[1].dwID;
-	}
-	else if (m_TeamData[0].iScore > m_TeamData[1].iScore)
-	{
-		win_gid = m_TeamData[0].dwID;
-	}
-
-	return (win_gid);
-}
-
-void CWarMap::UsePotion(LPCHARACTER ch, LPITEM item)
-{
-	if (m_pkEndEvent)
-		return;
-
-	if (ch->IsObserverMode())
-		return;
-
-	if (!ch->GetGuild())
-		return;
-
-	if (!item->GetProto())
-		return;
-
-	int iPrice = item->GetProto()->dwShopBuyPrice;
-
-	DWORD gid = ch->GetGuild()->GetID();
-
-	if (gid == m_TeamData[0].dwID)
-		m_TeamData[0].iUsePotionPrice += iPrice;
-	else if (gid == m_TeamData[1].dwID)
-		m_TeamData[1].iUsePotionPrice += iPrice;
-}
-
-int CWarMap::STeamData::GetAccumulatedJoinerCount()
-{
-	return set_pidJoiner.size();
-}
-
-int CWarMap::STeamData::GetCurJointerCount()
-{
-	return iMemberCount;
-}
-
-void CWarMap::STeamData::AppendMember(LPCHARACTER ch)
-{
-	set_pidJoiner.insert(ch->GetPlayerID());
-	++iMemberCount;
-}
-
-void CWarMap::STeamData::RemoveMember(LPCHARACTER ch)
-{
-	// set_pidJoiner 는 누적 인원을 계산하기 때문에 제거하지 않는다
-	--iMemberCount;
-}
-
-struct FSendUserCount
-{
-	char buf1[30];
-	char buf2[128];
-
-	FSendUserCount(DWORD g1, int g1_count, DWORD g2, int g2_count, int observer)
-	{
-		snprintf(buf1, sizeof(buf1), "ObserverCount %d", observer);
-		snprintf(buf2, sizeof(buf2), "WarUC %u %d %u %d %d", g1, g1_count, g2, g2_count, observer);
-	}
-
-	void operator() (LPCHARACTER ch)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, buf1);
-		ch->ChatPacket(CHAT_TYPE_COMMAND, buf2);
-	}
-};
-
-void CWarMap::UpdateUserCount()
-{
-	FSendUserCount f(
-		m_TeamData[0].dwID,
-		m_TeamData[0].GetAccumulatedJoinerCount(),
-		m_TeamData[1].dwID,
-		m_TeamData[1].GetAccumulatedJoinerCount(),
-		m_iObserverCount);
-
-	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
-}
-
-void CWarMap::IncMember(LPCHARACTER ch)
-{
-	if (!ch->IsPC())
-		return;
-
-	sys_log(0, "WarMap::IncMember");
-	DWORD gid = 0;
-
-	if (ch->GetGuild())
-		gid = ch->GetGuild()->GetID();
-
-	bool isWarMember = ch->GetQuestFlag("war.is_war_member") > 0 ? true : false;
-
-	if (isWarMember && gid != m_TeamData[0].dwID && gid != m_TeamData[1].dwID)
-	{
-		ch->SetQuestFlag("war.is_war_member", 0);
-		isWarMember = false;
-	}
-
-	if (isWarMember)
-	{
-		if (gid == m_TeamData[0].dwID)
-		{
-			m_TeamData[0].AppendMember(ch);
-
-		}
-		else if (gid == m_TeamData[1].dwID)
-		{
-			m_TeamData[1].AppendMember(ch);
-
-		}
-
-		event_cancel(&m_pkTimeoutEvent);
-
-		sys_log(0, "WarMap +m %u(cur:%d, acc:%d) vs %u(cur:%d, acc:%d)",
-			m_TeamData[0].dwID, m_TeamData[0].GetCurJointerCount(), m_TeamData[0].GetAccumulatedJoinerCount(),
-			m_TeamData[1].dwID, m_TeamData[1].GetCurJointerCount(), m_TeamData[1].GetAccumulatedJoinerCount());
-	}
-	else
-	{
-		++m_iObserverCount;
-		sys_log(0, "WarMap +o %d", m_iObserverCount);
-		ch->SetObserverMode(true);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("관전 모드로 길드전에 참가하셨습니다."));
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("자신을 선택하시면 밖으로 나갈 수 있는 <관람 종료> 버튼이 나옵니다."));
-	}
-
-	UpdateUserCount();
-
-	m_set_pkChr.insert(ch);
-
-	LPDESC d = ch->GetDesc();
-
-	SendWarPacket(d);
-	SendScorePacket(0, d);
-	SendScorePacket(1, d);
-}
-
-void CWarMap::DecMember(LPCHARACTER ch)
-{
-	if (!ch->IsPC())
-		return;
-
-	sys_log(0, "WarMap::DecMember");
-	DWORD gid = 0;
-
-	if (ch->GetGuild())
-		gid = ch->GetGuild()->GetID();
-
-	if (!ch->IsObserverMode())
-	{
-		if (gid == m_TeamData[0].dwID)
-			m_TeamData[0].RemoveMember(ch);
-		else if (gid == m_TeamData[1].dwID)
-			m_TeamData[1].RemoveMember(ch);
-
-		if (m_kMapInfo.bType == WAR_MAP_TYPE_FLAG)
-		{
-			CAffect* pkAff = ch->FindAffect(AFFECT_WAR_FLAG);
-
-			if (pkAff)
-			{
-				BYTE idx;
-
-				if (GetTeamIndex(pkAff->lApplyValue, idx))
-					AddFlag(idx, ch->GetX(), ch->GetY());
-
-				ch->RemoveAffect(AFFECT_WAR_FLAG);
-			}
-		}
-
-		sys_log(0, "WarMap -m %u(cur:%d, acc:%d) vs %u(cur:%d, acc:%d)",
-			m_TeamData[0].dwID, m_TeamData[0].GetCurJointerCount(), m_TeamData[0].GetAccumulatedJoinerCount(),
-			m_TeamData[1].dwID, m_TeamData[1].GetCurJointerCount(), m_TeamData[1].GetAccumulatedJoinerCount());
-
-		CheckWarEnd();
-		ch->SetQuestFlag("war.is_war_member", 0);
-	}
-	else
-	{
-		--m_iObserverCount;
-
-		sys_log(0, "WarMap -o %d", m_iObserverCount);
-		ch->SetObserverMode(false);
-	}
-
-	UpdateUserCount();
-
-	m_set_pkChr.erase(ch);
-}
-
-struct FExitGuildWar
-{
-	void operator() (LPCHARACTER ch)
-	{
-		if (ch->IsPC())
-		{
-			ch->ExitToSavedLocation();
-		}
-	}
-};
-
-void CWarMap::ExitAll()
-{
-	FExitGuildWar f;
-	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
-}
-
-void CWarMap::CheckWarEnd()
-{
-	if (m_bEnded)
-		return;
-
-	if (m_TeamData[0].iMemberCount == 0 || m_TeamData[1].iMemberCount == 0)
-	{
-		if (m_bTimeout)
-			return;
-
-		if (m_pkTimeoutEvent)
-			return;
-
-		Notice("길드전에 참가한 상대방 길드원이 아무도 없습니다.");
-		Notice("1분 이내에 아무도 접속하지 않으면 길드전이 자동 종료됩니다.");
-
-		sys_log(0, "CheckWarEnd: Timeout begin %u vs %u", m_TeamData[0].dwID, m_TeamData[1].dwID);
-
-		war_map_info* info = AllocEventInfo<war_map_info>();
-		info->pWarMap = this;
-
-		SetTimeoutEvent(event_create(war_timeout_event, info, PASSES_PER_SEC(60)));
-	}
-	else
-		CheckScore();
-}
-
-int CWarMap::GetRewardGold(BYTE bWinnerIdx)
-{
-	int iRewardGold = m_WarInfo.iWarPrice;
-	iRewardGold += (m_TeamData[bWinnerIdx].iUsePotionPrice * m_WarInfo.iWinnerPotionRewardPctToWinner) / 100;
-	iRewardGold += (m_TeamData[bWinnerIdx ? 0 : 1].iUsePotionPrice * m_WarInfo.iLoserPotionRewardPctToWinner) / 100;
-	return iRewardGold;
-}
-
-void CWarMap::Draw()
-{
-	CGuildManager::instance().RequestWarOver(m_TeamData[0].dwID, m_TeamData[1].dwID, 0, 0);
-}
-
-void CWarMap::Timeout()
-{
-	SetTimeoutEvent(NULL);
-
-	if (m_bTimeout)
-		return;
-
-	if (m_bEnded)
-		return;
-
-	DWORD dwWinner = 0;
-	DWORD dwLoser = 0;
-	int iRewardGold = 0;
-
-	if (get_dword_time() - m_dwStartTime < 60000 * 5)
-	{
-		Notice("길드전이 일찍 종료되어 무승부로 판정 되었습니다. (5분이 지나지 않음)");
-		dwWinner = 0;
-		dwLoser = 0;
-	}
-	else
-	{
-		BYTE iWinnerIdx = -1;
-
-		if (m_TeamData[0].iMemberCount == 0)
-			iWinnerIdx = 1;
-		else if (m_TeamData[1].iMemberCount == 0)
-			iWinnerIdx = 0;
-
-		if (iWinnerIdx == -1)
-		{
-			dwWinner = GetWinnerGuild();
-
-			if (dwWinner == m_TeamData[0].dwID)
-			{
-				iRewardGold = GetRewardGold(0);
-				dwLoser = m_TeamData[1].dwID;
-			}
-			else if (dwWinner == m_TeamData[1].dwID)
-			{
-				iRewardGold = GetRewardGold(1);
-				dwLoser = m_TeamData[0].dwID;
-			}
-
-			sys_err("WarMap: member count is not zero, guild1 %u %d guild2 %u %d, winner %u",
-				m_TeamData[0].dwID, m_TeamData[0].iMemberCount,
-				m_TeamData[1].dwID, m_TeamData[1].iMemberCount,
-				dwWinner);
-		}
-		else
-		{
-			dwWinner = m_TeamData[iWinnerIdx].dwID;
-			dwLoser = m_TeamData[iWinnerIdx == 0 ? 1 : 0].dwID;
-
-			iRewardGold = GetRewardGold(iWinnerIdx);
-		}
-	}
-
-	sys_log(0, "WarMap: Timeout %u %u winner %u loser %u reward %d map %d",
-		m_TeamData[0].dwID, m_TeamData[1].dwID, dwWinner, dwLoser, iRewardGold, m_kMapInfo.lMapIndex);
-
-	if (dwWinner)
-		CGuildManager::instance().RequestWarOver(dwWinner, dwLoser, dwWinner, iRewardGold);
-	else
-		CGuildManager::instance().RequestWarOver(m_TeamData[0].dwID, m_TeamData[1].dwID, dwWinner, iRewardGold);
-
-	m_bTimeout = true;
-}
-
-namespace
-{
-	struct FPacket
-	{
-		FPacket(const void* p, int size) : m_pvData(p), m_iSize(size)
-		{
-		}
-
-		void operator () (LPCHARACTER ch)
-		{
-			ch->GetDesc()->Packet(m_pvData, m_iSize);
-		}
-
-		const void* m_pvData;
-		int m_iSize;
-	};
-
-	struct FNotice
-	{
-		FNotice(const char* psz) : m_psz(psz)
-		{
-		}
-
-		void operator() (LPCHARACTER ch)
-		{
-			ch->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_psz);
-		}
-
-		const char* m_psz;
-	};
-};
-
-void CWarMap::Notice(const char* psz)
-{
-	FNotice f(psz);
-	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
-}
-
-void CWarMap::Packet(const void* p, int size)
-{
-	FPacket f(p, size);
-	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
-}
-
-void CWarMap::SendWarPacket(LPDESC d)
-{
-	TPacketGCGuild pack;
-	TPacketGCGuildWar pack2;
-
-	pack.header = HEADER_GC_GUILD;
-	pack.subheader = GUILD_SUBHEADER_GC_WAR;
-	pack.size = sizeof(pack) + sizeof(pack2);
-
-	pack2.dwGuildSelf = m_TeamData[0].dwID;
-	pack2.dwGuildOpp = m_TeamData[1].dwID;
-	pack2.bType = CGuildManager::instance().TouchGuild(m_TeamData[0].dwID)->GetGuildWarType(m_TeamData[1].dwID);
-	pack2.bWarState = CGuildManager::instance().TouchGuild(m_TeamData[0].dwID)->GetGuildWarState(m_TeamData[1].dwID);
-
-	d->BufferedPacket(&pack, sizeof(pack));
-	d->Packet(&pack2, sizeof(pack2));
-}
-
-void CWarMap::SendScorePacket(BYTE bIdx, LPDESC d)
-{
-	TPacketGCGuild p;
-
-	p.header = HEADER_GC_GUILD;
-	p.subheader = GUILD_SUBHEADER_GC_WAR_SCORE;
-	p.size = sizeof(p) + sizeof(DWORD) + sizeof(DWORD) + sizeof(long);
-
-	TEMP_BUFFER buf;
-	buf.write(&p, sizeof(p));
-	buf.write(&m_TeamData[bIdx].dwID, sizeof(DWORD));
-	buf.write(&m_TeamData[bIdx ? 0 : 1].dwID, sizeof(DWORD));
-	buf.write(&m_TeamData[bIdx].iScore, sizeof(long));
-
-	if (d)
-		d->Packet(buf.read_peek(), buf.size());
-	else
-		Packet(buf.read_peek(), buf.size());
-}
-
-void CWarMap::UpdateScore(DWORD g1, int score1, DWORD g2, int score2)
-{
-	BYTE idx;
-
-	if (GetTeamIndex(g1, idx))
-	{
-		if (m_TeamData[idx].iScore != score1)
-		{
-			m_TeamData[idx].iScore = score1;
-			SendScorePacket(idx);
-		}
-	}
-
-	if (GetTeamIndex(g2, idx))
-	{
-		if (m_TeamData[idx].iScore != score2)
-		{
-			m_TeamData[idx].iScore = score2;
-			SendScorePacket(idx);
-		}
-	}
-
-	CheckScore();
-}
-
-bool CWarMap::CheckScore()
-{
-	if (m_bEnded)
-		return true;
-
-	// 30초 이후 부터 확인한다.
-	if (get_dword_time() - m_dwStartTime < 30000)
-		return false;
-
-	// 점수가 같으면 체크하지 않는다.
-	if (m_TeamData[0].iScore == m_TeamData[1].iScore)
-		return false;
-
-	int iEndScore = m_WarInfo.iEndScore;
-
-	if (test_server) iEndScore /= 10;
-
-	DWORD dwWinner;
-	DWORD dwLoser;
-
-	if (m_TeamData[0].iScore >= iEndScore)
-	{
-		dwWinner = m_TeamData[0].dwID;
-		dwLoser = m_TeamData[1].dwID;
-	}
-	else if (m_TeamData[1].iScore >= iEndScore)
-	{
-		dwWinner = m_TeamData[1].dwID;
-		dwLoser = m_TeamData[0].dwID;
-	}
-	else
-		return false;
-
-	int iRewardGold = 0;
-
-	if (dwWinner == m_TeamData[0].dwID)
-		iRewardGold = GetRewardGold(0);
-	else if (dwWinner == m_TeamData[1].dwID)
-		iRewardGold = GetRewardGold(1);
-
-	sys_log(0, "WarMap::CheckScore end score %d guild1 %u score guild2 %d %u score %d winner %u reward %d",
-		iEndScore,
-		m_TeamData[0].dwID,
-		m_TeamData[0].iScore,
-		m_TeamData[1].dwID,
-		m_TeamData[1].iScore,
-		dwWinner,
-		iRewardGold);
-
-	CGuildManager::instance().RequestWarOver(dwWinner, dwLoser, dwWinner, iRewardGold);
-	return true;
-}
-
-bool CWarMap::SetEnded()
-{
-	sys_log(0, "WarMap::SetEnded %d", m_kMapInfo.lMapIndex);
-
-	if (m_pkEndEvent)
-		return false;
-
-	if (m_TeamData[0].pkChrFlag)
-	{
-		M2_DESTROY_CHARACTER(m_TeamData[0].pkChrFlag);
-		m_TeamData[0].pkChrFlag = NULL;
-	}
-
-	if (m_TeamData[0].pkChrFlagBase)
-	{
-		M2_DESTROY_CHARACTER(m_TeamData[0].pkChrFlagBase);
-		m_TeamData[0].pkChrFlagBase = NULL;
-	}
-
-	if (m_TeamData[1].pkChrFlag)
-	{
-		M2_DESTROY_CHARACTER(m_TeamData[1].pkChrFlag);
-		m_TeamData[1].pkChrFlag = NULL;
-	}
-
-	if (m_TeamData[1].pkChrFlagBase)
-	{
-		M2_DESTROY_CHARACTER(m_TeamData[1].pkChrFlagBase);
-		m_TeamData[1].pkChrFlagBase = NULL;
-	}
-
-	event_cancel(&m_pkResetFlagEvent);
-	m_bEnded = true;
-
-	war_map_info* info = AllocEventInfo<war_map_info>();
-
-	info->pWarMap = this;
-	info->iStep = 0;
-	SetEndEvent(event_create(war_end_event, info, PASSES_PER_SEC(10)));
-	return true;
-}
-
-void CWarMap::OnKill(LPCHARACTER killer, LPCHARACTER ch)
-{
-	if (m_bEnded)
-		return;
-
-	DWORD dwKillerGuild = 0;
-	DWORD dwDeadGuild = 0;
-
-	if (killer->GetGuild())
-		dwKillerGuild = killer->GetGuild()->GetID();
-
-	if (ch->GetGuild())
-		dwDeadGuild = ch->GetGuild()->GetID();
-
-	BYTE idx;
-
-	sys_log(0, "WarMap::OnKill %u %u", dwKillerGuild, dwDeadGuild);
-
-	if (!GetTeamIndex(dwKillerGuild, idx))
-		return;
-
-	if (!GetTeamIndex(dwDeadGuild, idx))
-		return;
-
-	switch (m_kMapInfo.bType)
-	{
-	case WAR_MAP_TYPE_NORMAL:
-		SendGuildWarScore(dwKillerGuild, dwDeadGuild, 1, ch->GetLevel());
-		break;
-
-	case WAR_MAP_TYPE_FLAG:
-	{
-		CAffect* pkAff = ch->FindAffect(AFFECT_WAR_FLAG);
-
-		if (pkAff)
-		{
-			if (GetTeamIndex(pkAff->lApplyValue, idx))
-				AddFlag(idx, ch->GetX(), ch->GetY());
-
-			ch->RemoveAffect(AFFECT_WAR_FLAG);
-		}
-	}
-	break;
-
-	default:
-		sys_err("unknown war map type %u index %d", m_kMapInfo.bType, m_kMapInfo.lMapIndex);
-		break;
-	}
-}
-
-void CWarMap::AddFlagBase(BYTE bIdx, DWORD x, DWORD y)
-{
-	if (m_bEnded)
-		return;
-
-	assert(bIdx < 2);
-
-	TeamData& r = m_TeamData[bIdx];
-
-	if (r.pkChrFlagBase)
-		return;
-
-	if (x == 0)
-	{
-		x = m_kMapInfo.posStart[bIdx].x;
-		y = m_kMapInfo.posStart[bIdx].y;
-	}
-
-	r.pkChrFlagBase = CHARACTER_MANAGER::instance().SpawnMob(warmap::WAR_FLAG_BASE_VNUM, m_kMapInfo.lMapIndex, x, y, 0);
-	sys_log(0, "WarMap::AddFlagBase %u %p id %u", bIdx, get_pointer(r.pkChrFlagBase), r.dwID);
-
-	r.pkChrFlagBase->SetPoint(POINT_STAT, r.dwID);
-	r.pkChrFlagBase->SetWarMap(this);
-}
-
-void CWarMap::AddFlag(BYTE bIdx, DWORD x, DWORD y)
-{
-	if (m_bEnded)
-		return;
-
-	assert(bIdx < 2);
-
-	TeamData& r = m_TeamData[bIdx];
-
-	if (r.pkChrFlag)
-		return;
-
-	if (x == 0)
-	{
-		x = m_kMapInfo.posStart[bIdx].x;
-		y = m_kMapInfo.posStart[bIdx].y;
-	}
-
-	r.pkChrFlag = CHARACTER_MANAGER::instance().SpawnMob(bIdx == 0 ? warmap::WAR_FLAG_VNUM0 : warmap::WAR_FLAG_VNUM1, m_kMapInfo.lMapIndex, x, y, 0);
-	sys_log(0, "WarMap::AddFlag %u %p id %u", bIdx, get_pointer(r.pkChrFlag), r.dwID);
-
-	r.pkChrFlag->SetPoint(POINT_STAT, r.dwID);
-	r.pkChrFlag->SetWarMap(this);
-}
-
-void CWarMap::RemoveFlag(BYTE bIdx)
-{
-	assert(bIdx < 2);
-
-	TeamData& r = m_TeamData[bIdx];
-
-	if (!r.pkChrFlag)
-		return;
-
-	sys_log(0, "WarMap::RemoveFlag %u %p", bIdx, get_pointer(r.pkChrFlag));
-
-	r.pkChrFlag->Dead(NULL, true);
-	r.pkChrFlag = NULL;
-}
-
-bool CWarMap::IsFlagOnBase(BYTE bIdx)
-{
-	assert(bIdx < 2);
-
-	TeamData& r = m_TeamData[bIdx];
-
-	if (!r.pkChrFlag)
-		return false;
-
-	const PIXEL_POSITION& pos = r.pkChrFlag->GetXYZ();
-
-	if (pos.x == m_kMapInfo.posStart[bIdx].x && pos.y == m_kMapInfo.posStart[bIdx].y)
-		return true;
-
-	return false;
-}
-
-EVENTFUNC(war_reset_flag_event)
-{
-	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("war_reset_flag_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	CWarMap* pMap = info->pWarMap;
-
-	pMap->AddFlag(0);
-	pMap->AddFlag(1);
-
-	pMap->SetResetFlagEvent(NULL);
-	return 0;
-}
-
-struct FRemoveFlagAffect
-{
-	void operator() (LPCHARACTER ch)
-	{
-		if (ch->FindAffect(AFFECT_WAR_FLAG))
-			ch->RemoveAffect(AFFECT_WAR_FLAG);
-	}
-};
-
-void CWarMap::ResetFlag()
-{
-	if (m_kMapInfo.bType != WAR_MAP_TYPE_FLAG)
-		return;
-
-	if (m_pkResetFlagEvent)
-		return;
-
-	if (m_bEnded)
-		return;
-
-	FRemoveFlagAffect f;
-	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
-
-	RemoveFlag(0);
-	RemoveFlag(1);
-
-	war_map_info* info = AllocEventInfo<war_map_info>();
-
-	info->pWarMap = this;
-	info->iStep = 0;
-	SetResetFlagEvent(event_create(war_reset_flag_event, info, PASSES_PER_SEC(10)));
-}
-
-/////////////////////////////////////////////////////////////////////////////////
-// WarMapManager
-/////////////////////////////////////////////////////////////////////////////////
-CWarMapManager::CWarMapManager()
-{
-}
-
-CWarMapManager::~CWarMapManager()
-{
-	for (std::map<long, TWarMapInfo*>::const_iterator iter = m_map_kWarMapInfo.begin(); iter != m_map_kWarMapInfo.end(); ++iter)
-	{
-		M2_DELETE(iter->second);
-	}
-
-	m_map_kWarMapInfo.clear();
-}
-
-bool CWarMapManager::LoadWarMapInfo(const char* c_pszFileName)
-{
-	TWarMapInfo* k;
-
-	k = M2_NEW TWarMapInfo;
-	k->bType = WAR_MAP_TYPE_NORMAL;
-
-	k->lMapIndex = WAR_MAP_INDEX_NORMAL;
-	k->posStart[0].x = 48 * 100 + 32000;
-	k->posStart[0].y = 52 * 100 + 0;
-	k->posStart[1].x = 183 * 100 + 32000;
-	k->posStart[1].y = 206 * 100 + 0;
-	k->posStart[2].x = 141 * 100 + 32000;
-	k->posStart[2].y = 117 * 100 + 0;
-
-	m_map_kWarMapInfo.insert(std::make_pair(k->lMapIndex, k));
-
-	k = M2_NEW TWarMapInfo;
-	k->bType = WAR_MAP_TYPE_FLAG;
-
-	k->lMapIndex = WAR_MAP_INDEX_FLAG;
-	k->posStart[0].x = 68 * 100 + 57600;
-	k->posStart[0].y = 69 * 100 + 0;
-	k->posStart[1].x = 171 * 100 + 57600;
-	k->posStart[1].y = 182 * 100 + 0;
-	k->posStart[2].x = 122 * 100 + 57600;
-	k->posStart[2].y = 131 * 100 + 0;
-
-	m_map_kWarMapInfo.insert(std::make_pair(k->lMapIndex, k));
-	return true;
-}
-
-bool CWarMapManager::IsWarMap(long lMapIndex)
-{
-	return GetWarMapInfo(lMapIndex) ? true : false;
-}
-
-bool CWarMapManager::GetStartPosition(long lMapIndex, BYTE bIdx, PIXEL_POSITION& pos)
-{
-	assert(bIdx < 3);
-
-	TWarMapInfo* pi = GetWarMapInfo(lMapIndex);
-
-	if (!pi)
-	{
-		sys_log(0, "GetStartPosition FAILED [%d] WarMapInfoSize(%d)", lMapIndex, m_map_kWarMapInfo.size());
-
-		auto it = m_map_kWarMapInfo.begin();
-		for (; it != m_map_kWarMapInfo.end(); ++it)
-		{
-			PIXEL_POSITION& cur = it->second->posStart[bIdx];
-			sys_log(0, "WarMap[%d]=Pos(%d, %d)", it->first, cur.x, cur.y);
-		}
-		return false;
-	}
-
-	pos = pi->posStart[bIdx];
-	return true;
-}
-
-long CWarMapManager::CreateWarMap(const TGuildWarInfo& guildWarInfo, DWORD dwGuildID1, DWORD dwGuildID2)
-{
-	TWarMapInfo* pkInfo = GetWarMapInfo(guildWarInfo.lMapIndex);
-	if (!pkInfo)
-	{
-		sys_err("GuildWar.CreateWarMap.NOT_FOUND_MAPINFO[%d]", guildWarInfo.lMapIndex);
-		return 0;
-	}
-
-	DWORD lMapIndex = SECTREE_MANAGER::instance().CreatePrivateMap(guildWarInfo.lMapIndex);
-
-	if (lMapIndex)
-	{
-		m_mapWarMap.insert(std::make_pair(lMapIndex, M2_NEW CWarMap(lMapIndex, guildWarInfo, pkInfo, dwGuildID1, dwGuildID2)));
-	}
-
-	return lMapIndex;
-}
-
-TWarMapInfo* CWarMapManager::GetWarMapInfo(long lMapIndex)
-{
-	if (lMapIndex >= 10000)
-		lMapIndex /= 10000;
-
-	auto it = m_map_kWarMapInfo.find(lMapIndex);
-	if (m_map_kWarMapInfo.end() == it)
-		return NULL;
-
-	return it->second;
-}
-
-void CWarMapManager::DestroyWarMap(CWarMap* pMap)
-{
-	long mapIdx = pMap->GetMapIndex();
-
-	sys_log(0, "WarMap::DestroyWarMap : %d", mapIdx);
-
-	m_mapWarMap.erase(pMap->GetMapIndex());
-	M2_DELETE(pMap);
-
-	SECTREE_MANAGER::instance().DestroyPrivateMap(mapIdx);
-}
-
-CWarMap* CWarMapManager::Find(long lMapIndex)
-{
-	auto it = m_mapWarMap.find(lMapIndex);
-	if (it == m_mapWarMap.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CWarMapManager::OnShutdown()
-{
-	auto it = m_mapWarMap.begin();
-	while (it != m_mapWarMap.end())
-		(it++)->second->Draw();
-}
+#include "stdafx.h"
+#include "war_map.h"
+#include "sectree_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "affect.h"
+#include "item.h"
+#include "config.h"
+#include "desc.h"
+#include "desc_manager.h"
+#include "guild_manager.h"
+#include "buffer_manager.h"
+#include "db.h"
+#include "packet.h"
+#include "locale_service.h"
+
+EVENTINFO(war_map_info)
+{
+	int iStep;
+	CWarMap* pWarMap;
+
+	war_map_info()
+		: iStep(0)
+		, pWarMap(0)
+	{
+	}
+};
+
+EVENTFUNC(war_begin_event)
+{
+	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("war_begin_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	CWarMap* pMap = info->pWarMap;
+	pMap->CheckWarEnd();
+	return PASSES_PER_SEC(10);
+}
+
+EVENTFUNC(war_end_event)
+{
+	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("war_end_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	CWarMap* pMap = info->pWarMap;
+
+	if (info->iStep == 0)
+	{
+		++info->iStep;
+		pMap->ExitAll();
+		return PASSES_PER_SEC(5);
+	}
+	else
+	{
+		pMap->SetEndEvent(NULL);
+		CWarMapManager::instance().DestroyWarMap(pMap);
+		return 0;
+	}
+}
+
+EVENTFUNC(war_timeout_event)
+{
+	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("war_timeout_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	CWarMap* pMap = info->pWarMap;
+	pMap->Timeout();
+	return 0;
+}
+
+void CWarMap::STeamData::Initialize()
+{
+	dwID = 0;
+	pkGuild = NULL;
+	iMemberCount = 0;
+	iUsePotionPrice = 0;
+	iScore = 0;
+	pkChrFlag = NULL;
+	pkChrFlagBase = NULL;
+
+	set_pidJoiner.clear();
+}
+
+CWarMap::CWarMap(long lMapIndex, const TGuildWarInfo& r_info, TWarMapInfo* pkWarMapInfo, DWORD dwGuildID1, DWORD dwGuildID2)
+{
+	m_kMapInfo = *pkWarMapInfo;
+	m_kMapInfo.lMapIndex = lMapIndex;
+
+	memcpy(&m_WarInfo, &r_info, sizeof(TGuildWarInfo));
+
+	m_TeamData[0].Initialize();
+	m_TeamData[0].dwID = dwGuildID1;
+	m_TeamData[0].pkGuild = CGuildManager::instance().TouchGuild(dwGuildID1);
+
+	m_TeamData[1].Initialize();
+	m_TeamData[1].dwID = dwGuildID2;
+	m_TeamData[1].pkGuild = CGuildManager::instance().TouchGuild(dwGuildID2);
+	m_iObserverCount = 0;
+
+	war_map_info* info = AllocEventInfo<war_map_info>();
+	info->pWarMap = this;
+
+	SetBeginEvent(event_create(war_begin_event, info, PASSES_PER_SEC(60)));
+	m_pkEndEvent = NULL;
+	m_pkTimeoutEvent = NULL;
+	m_pkResetFlagEvent = NULL;
+	m_bTimeout = false;
+	m_dwStartTime = get_dword_time();
+	m_bEnded = false;
+
+	if (GetType() == WAR_MAP_TYPE_FLAG)
+	{
+		AddFlagBase(0);
+		AddFlagBase(1);
+		AddFlag(0);
+		AddFlag(1);
+	}
+}
+
+CWarMap::~CWarMap()
+{
+	event_cancel(&m_pkBeginEvent);
+	event_cancel(&m_pkEndEvent);
+	event_cancel(&m_pkTimeoutEvent);
+	event_cancel(&m_pkResetFlagEvent);
+
+	sys_log(0, "WarMap::~WarMap : map index %d", GetMapIndex());
+
+	auto it = m_set_pkChr.begin();
+	while (it != m_set_pkChr.end())
+	{
+		LPCHARACTER ch = *(it++);
+
+		if (ch->GetDesc())
+		{
+			sys_log(0, "WarMap::~WarMap : disconnecting %s", ch->GetName());
+			DESC_MANAGER::instance().DestroyDesc(ch->GetDesc());
+		}
+	}
+
+	m_set_pkChr.clear();
+}
+
+void CWarMap::SetBeginEvent(LPEVENT pkEv)
+{
+	if (m_pkBeginEvent != NULL)
+	{
+		event_cancel(&m_pkBeginEvent);
+	}
+	if (pkEv != NULL)
+	{
+		m_pkBeginEvent = pkEv;
+	}
+}
+
+void CWarMap::SetEndEvent(LPEVENT pkEv)
+{
+	if (m_pkEndEvent != NULL)
+	{
+		event_cancel(&m_pkEndEvent);
+	}
+	if (pkEv != NULL)
+	{
+		m_pkEndEvent = pkEv;
+	}
+}
+
+void CWarMap::SetTimeoutEvent(LPEVENT pkEv)
+{
+	if (m_pkTimeoutEvent != NULL)
+	{
+		event_cancel(&m_pkTimeoutEvent);
+	}
+	if (pkEv != NULL)
+	{
+		m_pkTimeoutEvent = pkEv;
+	}
+}
+
+void CWarMap::SetResetFlagEvent(LPEVENT pkEv)
+{
+	if (m_pkResetFlagEvent != NULL)
+	{
+		event_cancel(&m_pkResetFlagEvent);
+	}
+	if (pkEv != NULL)
+	{
+		m_pkResetFlagEvent = pkEv;
+	}
+}
+
+bool CWarMap::GetTeamIndex(DWORD dwGuildID, BYTE& bIdx)
+{
+	if (m_TeamData[0].dwID == dwGuildID)
+	{
+		bIdx = 0;
+		return true;
+	}
+	else if (m_TeamData[1].dwID == dwGuildID)
+	{
+		bIdx = 1;
+		return true;
+	}
+
+	return false;
+}
+
+DWORD CWarMap::GetGuildID(BYTE bIdx)
+{
+	assert(bIdx < 2);
+	return m_TeamData[bIdx].dwID;
+}
+
+CGuild* CWarMap::GetGuild(BYTE bIdx)
+{
+	return m_TeamData[bIdx].pkGuild;
+}
+
+long CWarMap::GetMapIndex()
+{
+	return m_kMapInfo.lMapIndex;
+}
+
+BYTE CWarMap::GetType()
+{
+	return m_kMapInfo.bType;
+}
+
+DWORD CWarMap::GetGuildOpponent(LPCHARACTER ch)
+{
+	if (ch->GetGuild())
+	{
+		DWORD gid = ch->GetGuild()->GetID();
+		BYTE idx;
+
+		if (GetTeamIndex(gid, idx))
+			return m_TeamData[!idx].dwID;
+	}
+	return 0;
+}
+
+DWORD CWarMap::GetWinnerGuild()
+{
+	DWORD win_gid = 0;
+
+	if (m_TeamData[1].iScore > m_TeamData[0].iScore)
+	{
+		win_gid = m_TeamData[1].dwID;
+	}
+	else if (m_TeamData[0].iScore > m_TeamData[1].iScore)
+	{
+		win_gid = m_TeamData[0].dwID;
+	}
+
+	return (win_gid);
+}
+
+void CWarMap::UsePotion(LPCHARACTER ch, LPITEM item)
+{
+	if (m_pkEndEvent)
+		return;
+
+	if (ch->IsObserverMode())
+		return;
+
+	if (!ch->GetGuild())
+		return;
+
+	if (!item->GetProto())
+		return;
+
+	int iPrice = item->GetProto()->dwShopBuyPrice;
+
+	DWORD gid = ch->GetGuild()->GetID();
+
+	if (gid == m_TeamData[0].dwID)
+		m_TeamData[0].iUsePotionPrice += iPrice;
+	else if (gid == m_TeamData[1].dwID)
+		m_TeamData[1].iUsePotionPrice += iPrice;
+}
+
+int CWarMap::STeamData::GetAccumulatedJoinerCount()
+{
+	return set_pidJoiner.size();
+}
+
+int CWarMap::STeamData::GetCurJointerCount()
+{
+	return iMemberCount;
+}
+
+void CWarMap::STeamData::AppendMember(LPCHARACTER ch)
+{
+	set_pidJoiner.insert(ch->GetPlayerID());
+	++iMemberCount;
+}
+
+void CWarMap::STeamData::RemoveMember(LPCHARACTER ch)
+{
+	// set_pidJoiner   恝 歐   苛쨈
+	--iMemberCount;
+}
+
+struct FSendUserCount
+{
+	char buf1[30];
+	char buf2[128];
+
+	FSendUserCount(DWORD g1, int g1_count, DWORD g2, int g2_count, int observer)
+	{
+		snprintf(buf1, sizeof(buf1), "ObserverCount %d", observer);
+		snprintf(buf2, sizeof(buf2), "WarUC %u %d %u %d %d", g1, g1_count, g2, g2_count, observer);
+	}
+
+	void operator() (LPCHARACTER ch)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, buf1);
+		ch->ChatPacket(CHAT_TYPE_COMMAND, buf2);
+	}
+};
+
+void CWarMap::UpdateUserCount()
+{
+	FSendUserCount f(
+		m_TeamData[0].dwID,
+		m_TeamData[0].GetAccumulatedJoinerCount(),
+		m_TeamData[1].dwID,
+		m_TeamData[1].GetAccumulatedJoinerCount(),
+		m_iObserverCount);
+
+	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
+}
+
+void CWarMap::IncMember(LPCHARACTER ch)
+{
+	if (!ch->IsPC())
+		return;
+
+	sys_log(0, "WarMap::IncMember");
+	DWORD gid = 0;
+
+	if (ch->GetGuild())
+		gid = ch->GetGuild()->GetID();
+
+	bool isWarMember = ch->GetQuestFlag("war.is_war_member") > 0 ? true : false;
+
+	if (isWarMember && gid != m_TeamData[0].dwID && gid != m_TeamData[1].dwID)
+	{
+		ch->SetQuestFlag("war.is_war_member", 0);
+		isWarMember = false;
+	}
+
+	if (isWarMember)
+	{
+		if (gid == m_TeamData[0].dwID)
+		{
+			m_TeamData[0].AppendMember(ch);
+
+		}
+		else if (gid == m_TeamData[1].dwID)
+		{
+			m_TeamData[1].AppendMember(ch);
+
+		}
+
+		event_cancel(&m_pkTimeoutEvent);
+
+		sys_log(0, "WarMap +m %u(cur:%d, acc:%d) vs %u(cur:%d, acc:%d)",
+			m_TeamData[0].dwID, m_TeamData[0].GetCurJointerCount(), m_TeamData[0].GetAccumulatedJoinerCount(),
+			m_TeamData[1].dwID, m_TeamData[1].GetCurJointerCount(), m_TeamData[1].GetAccumulatedJoinerCount());
+	}
+	else
+	{
+		++m_iObserverCount;
+		sys_log(0, "WarMap +o %d", m_iObserverCount);
+		ch->SetObserverMode(true);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   究決求."));
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("黴 絿첩    獵 < > 튼 니."));
+	}
+
+	UpdateUserCount();
+
+	m_set_pkChr.insert(ch);
+
+	LPDESC d = ch->GetDesc();
+
+	SendWarPacket(d);
+	SendScorePacket(0, d);
+	SendScorePacket(1, d);
+}
+
+void CWarMap::DecMember(LPCHARACTER ch)
+{
+	if (!ch->IsPC())
+		return;
+
+	sys_log(0, "WarMap::DecMember");
+	DWORD gid = 0;
+
+	if (ch->GetGuild())
+		gid = ch->GetGuild()->GetID();
+
+	if (!ch->IsObserverMode())
+	{
+		if (gid == m_TeamData[0].dwID)
+			m_TeamData[0].RemoveMember(ch);
+		else if (gid == m_TeamData[1].dwID)
+			m_TeamData[1].RemoveMember(ch);
+
+		if (m_kMapInfo.bType == WAR_MAP_TYPE_FLAG)
+		{
+			CAffect* pkAff = ch->FindAffect(AFFECT_WAR_FLAG);
+
+			if (pkAff)
+			{
+				BYTE idx;
+
+				if (GetTeamIndex(pkAff->lApplyValue, idx))
+					AddFlag(idx, ch->GetX(), ch->GetY());
+
+				ch->RemoveAffect(AFFECT_WAR_FLAG);
+			}
+		}
+
+		sys_log(0, "WarMap -m %u(cur:%d, acc:%d) vs %u(cur:%d, acc:%d)",
+			m_TeamData[0].dwID, m_TeamData[0].GetCurJointerCount(), m_TeamData[0].GetAccumulatedJoinerCount(),
+			m_TeamData[1].dwID, m_TeamData[1].GetCurJointerCount(), m_TeamData[1].GetAccumulatedJoinerCount());
+
+		CheckWarEnd();
+		ch->SetQuestFlag("war.is_war_member", 0);
+	}
+	else
+	{
+		--m_iObserverCount;
+
+		sys_log(0, "WarMap -o %d", m_iObserverCount);
+		ch->SetObserverMode(false);
+	}
+
+	UpdateUserCount();
+
+	m_set_pkChr.erase(ch);
+}
+
+struct FExitGuildWar
+{
+	void operator() (LPCHARACTER ch)
+	{
+		if (ch->IsPC())
+		{
+			ch->ExitToSavedLocation();
+		}
+	}
+};
+
+void CWarMap::ExitAll()
+{
+	FExitGuildWar f;
+	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
+}
+
+void CWarMap::CheckWarEnd()
+{
+	if (m_bEnded)
+		return;
+
+	if (m_TeamData[0].iMemberCount == 0 || m_TeamData[1].iMemberCount == 0)
+	{
+		if (m_bTimeout)
+			return;
+
+		if (m_pkTimeoutEvent)
+			return;
+
+		Notice("    틜 求.");
+		Notice("1 犬 틜    湄 絳求.");
+
+		sys_log(0, "CheckWarEnd: Timeout begin %u vs %u", m_TeamData[0].dwID, m_TeamData[1].dwID);
+
+		war_map_info* info = AllocEventInfo<war_map_info>();
+		info->pWarMap = this;
+
+		SetTimeoutEvent(event_create(war_timeout_event, info, PASSES_PER_SEC(60)));
+	}
+	else
+		CheckScore();
+}
+
+int CWarMap::GetRewardGold(BYTE bWinnerIdx)
+{
+	int iRewardGold = m_WarInfo.iWarPrice;
+	iRewardGold += (m_TeamData[bWinnerIdx].iUsePotionPrice * m_WarInfo.iWinnerPotionRewardPctToWinner) / 100;
+	iRewardGold += (m_TeamData[bWinnerIdx ? 0 : 1].iUsePotionPrice * m_WarInfo.iLoserPotionRewardPctToWinner) / 100;
+	return iRewardGold;
+}
+
+void CWarMap::Draw()
+{
+	CGuildManager::instance().RequestWarOver(m_TeamData[0].dwID, m_TeamData[1].dwID, 0, 0);
+}
+
+void CWarMap::Timeout()
+{
+	SetTimeoutEvent(NULL);
+
+	if (m_bTimeout)
+		return;
+
+	if (m_bEnded)
+		return;
+
+	DWORD dwWinner = 0;
+	DWORD dwLoser = 0;
+	int iRewardGold = 0;
+
+	if (get_dword_time() - m_dwStartTime < 60000 * 5)
+	{
+		Notice("  퓸 쨘管  퓸求. (5  )");
+		dwWinner = 0;
+		dwLoser = 0;
+	}
+	else
+	{
+		BYTE iWinnerIdx = -1;
+
+		if (m_TeamData[0].iMemberCount == 0)
+			iWinnerIdx = 1;
+		else if (m_TeamData[1].iMemberCount == 0)
+			iWinnerIdx = 0;
+
+		if (iWinnerIdx == -1)
+		{
+			dwWinner = GetWinnerGuild();
+
+			if (dwWinner == m_TeamData[0].dwID)
+			{
+				iRewardGold = GetRewardGold(0);
+				dwLoser = m_TeamData[1].dwID;
+			}
+			else if (dwWinner == m_TeamData[1].dwID)
+			{
+				iRewardGold = GetRewardGold(1);
+				dwLoser = m_TeamData[0].dwID;
+			}
+
+			sys_err("WarMap: member count is not zero, guild1 %u %d guild2 %u %d, winner %u",
+				m_TeamData[0].dwID, m_TeamData[0].iMemberCount,
+				m_TeamData[1].dwID, m_TeamData[1].iMemberCount,
+				dwWinner);
+		}
+		else
+		{
+			dwWinner = m_TeamData[iWinnerIdx].dwID;
+			dwLoser = m_TeamData[iWinnerIdx == 0 ? 1 : 0].dwID;
+
+			iRewardGold = GetRewardGold(iWinnerIdx);
+		}
+	}
+
+	sys_log(0, "WarMap: Timeout %u %u winner %u loser %u reward %d map %d",
+		m_TeamData[0].dwID, m_TeamData[1].dwID, dwWinner, dwLoser, iRewardGold, m_kMapInfo.lMapIndex);
+
+	// [Security] Guild ladder anti-farming: minimum duration, level gap check, and per-pair cooldown
+	if (dwWinner)
+	{
+		const DWORD kMinDurationMs = 60000 * 3; // 3 minutes
+		const int kMaxAvgLevelDiff = 30;
+		const DWORD kPairCooldownSec = 60 * 60 * 24; // 24 hours
+
+		// Duration gate (DB treats draw as no ladder adjustment)
+		if (get_dword_time() - m_dwStartTime < kMinDurationMs)
+		{
+			Notice(LC_STRING("Guild war ended too quickly. No ladder points awarded."));
+			dwWinner = 0;
+			dwLoser = 0;
+			iRewardGold = 0;
+		}
+		else
+		{
+			// Average level gate
+			long long sum[2] = {0, 0};
+			int cnt[2] = {0, 0};
+			for (auto it = m_set_pkChr.begin(); it != m_set_pkChr.end(); ++it)
+			{
+				LPCHARACTER pk = *it;
+				if (!pk || !pk->IsPC())
+					continue;
+				CGuild* g = pk->GetGuild();
+				if (!g)
+					continue;
+				DWORD gid = g->GetID();
+				int idx = (gid == m_TeamData[0].dwID) ? 0 : ((gid == m_TeamData[1].dwID) ? 1 : -1);
+				if (idx < 0)
+					continue;
+				sum[idx] += pk->GetLevel();
+				cnt[idx] += 1;
+			}
+
+			if (cnt[0] > 0 && cnt[1] > 0)
+			{
+				int avg0 = int(sum[0] / cnt[0]);
+				int avg1 = int(sum[1] / cnt[1]);
+				int diff = avg0 - avg1;
+				if (diff < 0) diff = -diff;
+				if (diff > kMaxAvgLevelDiff)
+				{
+					Notice(LC_STRING("Guild war level gap too large. No ladder points awarded."));
+					dwWinner = 0;
+					dwLoser = 0;
+					iRewardGold = 0;
+				}
+			}
+
+			// Per guild-pair cooldown gate
+			if (dwWinner)
+			{
+				static std::map<std::pair<DWORD, DWORD>, time_t> s_lastLadderReward;
+				DWORD a = MIN(m_TeamData[0].dwID, m_TeamData[1].dwID);
+				DWORD b = MAX(m_TeamData[0].dwID, m_TeamData[1].dwID);
+				std::pair<DWORD, DWORD> key = std::make_pair(a, b);
+				const time_t now = get_global_time();
+				auto f = s_lastLadderReward.find(key);
+				if (f != s_lastLadderReward.end() && now - f->second < (time_t)kPairCooldownSec)
+				{
+					Notice(LC_STRING("Guild war ladder points for this opponent are on cooldown."));
+					dwWinner = 0;
+					dwLoser = 0;
+					iRewardGold = 0;
+				}
+				else
+				{
+					s_lastLadderReward[key] = now;
+				}
+			}
+		}
+	}
+
+	if (dwWinner)
+		CGuildManager::instance().RequestWarOver(dwWinner, dwLoser, dwWinner, iRewardGold);
+	else
+		CGuildManager::instance().RequestWarOver(m_TeamData[0].dwID, m_TeamData[1].dwID, dwWinner, iRewardGold);
+
+	m_bTimeout = true;
+}
+
+namespace
+{
+	struct FPacket
+	{
+		FPacket(const void* p, int size) : m_pvData(p), m_iSize(size)
+		{
+		}
+
+		void operator () (LPCHARACTER ch)
+		{
+			ch->GetDesc()->Packet(m_pvData, m_iSize);
+		}
+
+		const void* m_pvData;
+		int m_iSize;
+	};
+
+	struct FNotice
+	{
+		FNotice(const char* psz) : m_psz(psz)
+		{
+		}
+
+		void operator() (LPCHARACTER ch)
+		{
+			ch->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_psz);
+		}
+
+		const char* m_psz;
+	};
+};
+
+void CWarMap::Notice(const char* psz)
+{
+	FNotice f(psz);
+	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
+}
+
+void CWarMap::Packet(const void* p, int size)
+{
+	FPacket f(p, size);
+	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
+}
+
+void CWarMap::SendWarPacket(LPDESC d)
+{
+	TPacketGCGuild pack;
+	TPacketGCGuildWar pack2;
+
+	pack.header = HEADER_GC_GUILD;
+	pack.subheader = GUILD_SUBHEADER_GC_WAR;
+	pack.size = sizeof(pack) + sizeof(pack2);
+
+	pack2.dwGuildSelf = m_TeamData[0].dwID;
+	pack2.dwGuildOpp = m_TeamData[1].dwID;
+	pack2.bType = CGuildManager::instance().TouchGuild(m_TeamData[0].dwID)->GetGuildWarType(m_TeamData[1].dwID);
+	pack2.bWarState = CGuildManager::instance().TouchGuild(m_TeamData[0].dwID)->GetGuildWarState(m_TeamData[1].dwID);
+
+	d->BufferedPacket(&pack, sizeof(pack));
+	d->Packet(&pack2, sizeof(pack2));
+}
+
+void CWarMap::SendScorePacket(BYTE bIdx, LPDESC d)
+{
+	TPacketGCGuild p;
+
+	p.header = HEADER_GC_GUILD;
+	p.subheader = GUILD_SUBHEADER_GC_WAR_SCORE;
+	p.size = sizeof(p) + sizeof(DWORD) + sizeof(DWORD) + sizeof(long);
+
+	TEMP_BUFFER buf;
+	buf.write(&p, sizeof(p));
+	buf.write(&m_TeamData[bIdx].dwID, sizeof(DWORD));
+	buf.write(&m_TeamData[bIdx ? 0 : 1].dwID, sizeof(DWORD));
+	buf.write(&m_TeamData[bIdx].iScore, sizeof(long));
+
+	if (d)
+		d->Packet(buf.read_peek(), buf.size());
+	else
+		Packet(buf.read_peek(), buf.size());
+}
+
+void CWarMap::UpdateScore(DWORD g1, int score1, DWORD g2, int score2)
+{
+	BYTE idx;
+
+	if (GetTeamIndex(g1, idx))
+	{
+		if (m_TeamData[idx].iScore != score1)
+		{
+			m_TeamData[idx].iScore = score1;
+			SendScorePacket(idx);
+		}
+	}
+
+	if (GetTeamIndex(g2, idx))
+	{
+		if (m_TeamData[idx].iScore != score2)
+		{
+			m_TeamData[idx].iScore = score2;
+			SendScorePacket(idx);
+		}
+	}
+
+	CheckScore();
+}
+
+bool CWarMap::CheckScore()
+{
+	if (m_bEnded)
+		return true;
+
+	// 30   확磯.
+	if (get_dword_time() - m_dwStartTime < 30000)
+		return false;
+
+	//   체크 苛쨈.
+	if (m_TeamData[0].iScore == m_TeamData[1].iScore)
+		return false;
+
+	int iEndScore = m_WarInfo.iEndScore;
+
+	if (test_server) iEndScore /= 10;
+
+	DWORD dwWinner;
+	DWORD dwLoser;
+
+	if (m_TeamData[0].iScore >= iEndScore)
+	{
+		dwWinner = m_TeamData[0].dwID;
+		dwLoser = m_TeamData[1].dwID;
+	}
+	else if (m_TeamData[1].iScore >= iEndScore)
+	{
+		dwWinner = m_TeamData[1].dwID;
+		dwLoser = m_TeamData[0].dwID;
+	}
+	else
+		return false;
+
+	int iRewardGold = 0;
+
+	if (dwWinner == m_TeamData[0].dwID)
+		iRewardGold = GetRewardGold(0);
+	else if (dwWinner == m_TeamData[1].dwID)
+		iRewardGold = GetRewardGold(1);
+
+	sys_log(0, "WarMap::CheckScore end score %d guild1 %u score guild2 %d %u score %d winner %u reward %d",
+		iEndScore,
+		m_TeamData[0].dwID,
+		m_TeamData[0].iScore,
+		m_TeamData[1].dwID,
+		m_TeamData[1].iScore,
+		dwWinner,
+		iRewardGold);
+
+	CGuildManager::instance().RequestWarOver(dwWinner, dwLoser, dwWinner, iRewardGold);
+	return true;
+}
+
+bool CWarMap::SetEnded()
+{
+	sys_log(0, "WarMap::SetEnded %d", m_kMapInfo.lMapIndex);
+
+	if (m_pkEndEvent)
+		return false;
+
+	if (m_TeamData[0].pkChrFlag)
+	{
+		M2_DESTROY_CHARACTER(m_TeamData[0].pkChrFlag);
+		m_TeamData[0].pkChrFlag = NULL;
+	}
+
+	if (m_TeamData[0].pkChrFlagBase)
+	{
+		M2_DESTROY_CHARACTER(m_TeamData[0].pkChrFlagBase);
+		m_TeamData[0].pkChrFlagBase = NULL;
+	}
+
+	if (m_TeamData[1].pkChrFlag)
+	{
+		M2_DESTROY_CHARACTER(m_TeamData[1].pkChrFlag);
+		m_TeamData[1].pkChrFlag = NULL;
+	}
+
+	if (m_TeamData[1].pkChrFlagBase)
+	{
+		M2_DESTROY_CHARACTER(m_TeamData[1].pkChrFlagBase);
+		m_TeamData[1].pkChrFlagBase = NULL;
+	}
+
+	event_cancel(&m_pkResetFlagEvent);
+	m_bEnded = true;
+
+	war_map_info* info = AllocEventInfo<war_map_info>();
+
+	info->pWarMap = this;
+	info->iStep = 0;
+	SetEndEvent(event_create(war_end_event, info, PASSES_PER_SEC(10)));
+	return true;
+}
+
+void CWarMap::OnKill(LPCHARACTER killer, LPCHARACTER ch)
+{
+	if (m_bEnded)
+		return;
+
+	DWORD dwKillerGuild = 0;
+	DWORD dwDeadGuild = 0;
+
+	if (killer->GetGuild())
+		dwKillerGuild = killer->GetGuild()->GetID();
+
+	if (ch->GetGuild())
+		dwDeadGuild = ch->GetGuild()->GetID();
+
+	BYTE idx;
+
+	sys_log(0, "WarMap::OnKill %u %u", dwKillerGuild, dwDeadGuild);
+
+	if (!GetTeamIndex(dwKillerGuild, idx))
+		return;
+
+	if (!GetTeamIndex(dwDeadGuild, idx))
+		return;
+
+	switch (m_kMapInfo.bType)
+	{
+	case WAR_MAP_TYPE_NORMAL:
+		SendGuildWarScore(dwKillerGuild, dwDeadGuild, 1, ch->GetLevel());
+		break;
+
+	case WAR_MAP_TYPE_FLAG:
+	{
+		CAffect* pkAff = ch->FindAffect(AFFECT_WAR_FLAG);
+
+		if (pkAff)
+		{
+			if (GetTeamIndex(pkAff->lApplyValue, idx))
+				AddFlag(idx, ch->GetX(), ch->GetY());
+
+			ch->RemoveAffect(AFFECT_WAR_FLAG);
+		}
+	}
+	break;
+
+	default:
+		sys_err("unknown war map type %u index %d", m_kMapInfo.bType, m_kMapInfo.lMapIndex);
+		break;
+	}
+}
+
+void CWarMap::AddFlagBase(BYTE bIdx, DWORD x, DWORD y)
+{
+	if (m_bEnded)
+		return;
+
+	assert(bIdx < 2);
+
+	TeamData& r = m_TeamData[bIdx];
+
+	if (r.pkChrFlagBase)
+		return;
+
+	if (x == 0)
+	{
+		x = m_kMapInfo.posStart[bIdx].x;
+		y = m_kMapInfo.posStart[bIdx].y;
+	}
+
+	r.pkChrFlagBase = CHARACTER_MANAGER::instance().SpawnMob(warmap::WAR_FLAG_BASE_VNUM, m_kMapInfo.lMapIndex, x, y, 0);
+	sys_log(0, "WarMap::AddFlagBase %u %p id %u", bIdx, get_pointer(r.pkChrFlagBase), r.dwID);
+
+	r.pkChrFlagBase->SetPoint(POINT_STAT, r.dwID);
+	r.pkChrFlagBase->SetWarMap(this);
+}
+
+void CWarMap::AddFlag(BYTE bIdx, DWORD x, DWORD y)
+{
+	if (m_bEnded)
+		return;
+
+	assert(bIdx < 2);
+
+	TeamData& r = m_TeamData[bIdx];
+
+	if (r.pkChrFlag)
+		return;
+
+	if (x == 0)
+	{
+		x = m_kMapInfo.posStart[bIdx].x;
+		y = m_kMapInfo.posStart[bIdx].y;
+	}
+
+	r.pkChrFlag = CHARACTER_MANAGER::instance().SpawnMob(bIdx == 0 ? warmap::WAR_FLAG_VNUM0 : warmap::WAR_FLAG_VNUM1, m_kMapInfo.lMapIndex, x, y, 0);
+	sys_log(0, "WarMap::AddFlag %u %p id %u", bIdx, get_pointer(r.pkChrFlag), r.dwID);
+
+	r.pkChrFlag->SetPoint(POINT_STAT, r.dwID);
+	r.pkChrFlag->SetWarMap(this);
+}
+
+void CWarMap::RemoveFlag(BYTE bIdx)
+{
+	assert(bIdx < 2);
+
+	TeamData& r = m_TeamData[bIdx];
+
+	if (!r.pkChrFlag)
+		return;
+
+	sys_log(0, "WarMap::RemoveFlag %u %p", bIdx, get_pointer(r.pkChrFlag));
+
+	r.pkChrFlag->Dead(NULL, true);
+	r.pkChrFlag = NULL;
+}
+
+bool CWarMap::IsFlagOnBase(BYTE bIdx)
+{
+	assert(bIdx < 2);
+
+	TeamData& r = m_TeamData[bIdx];
+
+	if (!r.pkChrFlag)
+		return false;
+
+	const PIXEL_POSITION& pos = r.pkChrFlag->GetXYZ();
+
+	if (pos.x == m_kMapInfo.posStart[bIdx].x && pos.y == m_kMapInfo.posStart[bIdx].y)
+		return true;
+
+	return false;
+}
+
+EVENTFUNC(war_reset_flag_event)
+{
+	war_map_info* info = dynamic_cast<war_map_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("war_reset_flag_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	CWarMap* pMap = info->pWarMap;
+
+	pMap->AddFlag(0);
+	pMap->AddFlag(1);
+
+	pMap->SetResetFlagEvent(NULL);
+	return 0;
+}
+
+struct FRemoveFlagAffect
+{
+	void operator() (LPCHARACTER ch)
+	{
+		if (ch->FindAffect(AFFECT_WAR_FLAG))
+			ch->RemoveAffect(AFFECT_WAR_FLAG);
+	}
+};
+
+void CWarMap::ResetFlag()
+{
+	if (m_kMapInfo.bType != WAR_MAP_TYPE_FLAG)
+		return;
+
+	if (m_pkResetFlagEvent)
+		return;
+
+	if (m_bEnded)
+		return;
+
+	FRemoveFlagAffect f;
+	std::for_each(m_set_pkChr.begin(), m_set_pkChr.end(), f);
+
+	RemoveFlag(0);
+	RemoveFlag(1);
+
+	war_map_info* info = AllocEventInfo<war_map_info>();
+
+	info->pWarMap = this;
+	info->iStep = 0;
+	SetResetFlagEvent(event_create(war_reset_flag_event, info, PASSES_PER_SEC(10)));
+}
+
+/////////////////////////////////////////////////////////////////////////////////
+// WarMapManager
+/////////////////////////////////////////////////////////////////////////////////
+CWarMapManager::CWarMapManager()
+{
+}
+
+CWarMapManager::~CWarMapManager()
+{
+	for (std::map<long, TWarMapInfo*>::const_iterator iter = m_map_kWarMapInfo.begin(); iter != m_map_kWarMapInfo.end(); ++iter)
+	{
+		M2_DELETE(iter->second);
+	}
+
+	m_map_kWarMapInfo.clear();
+}
+
+bool CWarMapManager::LoadWarMapInfo(const char* c_pszFileName)
+{
+	TWarMapInfo* k;
+
+	k = M2_NEW TWarMapInfo;
+	k->bType = WAR_MAP_TYPE_NORMAL;
+
+	k->lMapIndex = WAR_MAP_INDEX_NORMAL;
+	k->posStart[0].x = 48 * 100 + 32000;
+	k->posStart[0].y = 52 * 100 + 0;
+	k->posStart[1].x = 183 * 100 + 32000;
+	k->posStart[1].y = 206 * 100 + 0;
+	k->posStart[2].x = 141 * 100 + 32000;
+	k->posStart[2].y = 117 * 100 + 0;
+
+	m_map_kWarMapInfo.insert(std::make_pair(k->lMapIndex, k));
+
+	k = M2_NEW TWarMapInfo;
+	k->bType = WAR_MAP_TYPE_FLAG;
+
+	k->lMapIndex = WAR_MAP_INDEX_FLAG;
+	k->posStart[0].x = 68 * 100 + 57600;
+	k->posStart[0].y = 69 * 100 + 0;
+	k->posStart[1].x = 171 * 100 + 57600;
+	k->posStart[1].y = 182 * 100 + 0;
+	k->posStart[2].x = 122 * 100 + 57600;
+	k->posStart[2].y = 131 * 100 + 0;
+
+	m_map_kWarMapInfo.insert(std::make_pair(k->lMapIndex, k));
+	return true;
+}
+
+bool CWarMapManager::IsWarMap(long lMapIndex)
+{
+	return GetWarMapInfo(lMapIndex) ? true : false;
+}
+
+bool CWarMapManager::GetStartPosition(long lMapIndex, BYTE bIdx, PIXEL_POSITION& pos)
+{
+	assert(bIdx < 3);
+
+	TWarMapInfo* pi = GetWarMapInfo(lMapIndex);
+
+	if (!pi)
+	{
+		sys_log(0, "GetStartPosition FAILED [%d] WarMapInfoSize(%d)", lMapIndex, m_map_kWarMapInfo.size());
+
+		auto it = m_map_kWarMapInfo.begin();
+		for (; it != m_map_kWarMapInfo.end(); ++it)
+		{
+			PIXEL_POSITION& cur = it->second->posStart[bIdx];
+			sys_log(0, "WarMap[%d]=Pos(%d, %d)", it->first, cur.x, cur.y);
+		}
+		return false;
+	}
+
+	pos = pi->posStart[bIdx];
+	return true;
+}
+
+long CWarMapManager::CreateWarMap(const TGuildWarInfo& guildWarInfo, DWORD dwGuildID1, DWORD dwGuildID2)
+{
+	TWarMapInfo* pkInfo = GetWarMapInfo(guildWarInfo.lMapIndex);
+	if (!pkInfo)
+	{
+		sys_err("GuildWar.CreateWarMap.NOT_FOUND_MAPINFO[%d]", guildWarInfo.lMapIndex);
+		return 0;
+	}
+
+	DWORD lMapIndex = SECTREE_MANAGER::instance().CreatePrivateMap(guildWarInfo.lMapIndex);
+
+	if (lMapIndex)
+	{
+		m_mapWarMap.insert(std::make_pair(lMapIndex, M2_NEW CWarMap(lMapIndex, guildWarInfo, pkInfo, dwGuildID1, dwGuildID2)));
+	}
+
+	return lMapIndex;
+}
+
+TWarMapInfo* CWarMapManager::GetWarMapInfo(long lMapIndex)
+{
+	if (lMapIndex >= 10000)
+		lMapIndex /= 10000;
+
+	auto it = m_map_kWarMapInfo.find(lMapIndex);
+	if (m_map_kWarMapInfo.end() == it)
+		return NULL;
+
+	return it->second;
+}
+
+void CWarMapManager::DestroyWarMap(CWarMap* pMap)
+{
+	long mapIdx = pMap->GetMapIndex();
+
+	sys_log(0, "WarMap::DestroyWarMap : %d", mapIdx);
+
+	m_mapWarMap.erase(pMap->GetMapIndex());
+	M2_DELETE(pMap);
+
+	SECTREE_MANAGER::instance().DestroyPrivateMap(mapIdx);
+}
+
+CWarMap* CWarMapManager::Find(long lMapIndex)
+{
+	auto it = m_mapWarMap.find(lMapIndex);
+	if (it == m_mapWarMap.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CWarMapManager::OnShutdown()
+{
+	auto it = m_mapWarMap.begin();
+	while (it != m_mapWarMap.end())
+		(it++)->second->Draw();
+}
