--- a/server/metin2/Source/Server/game/src/OfflineShop.cpp
+++ b/server/metin2/Source/Server/game/src/OfflineShop.cpp
@@ -2087,6 +2087,10 @@
 		return;
 	}
 
+	// Reduce duplication window: push shop DB writes (item removal / gold update) before granting the item.
+	if (db_clientdesc)
+		db_clientdesc->FlushOutput();
+
 #if defined(__SELL_HISTORY__)
 	CShopSearchManager::AddToSellHistory(GetOwnerPid(), item->GetVnum(), item->GetCount(), buyer->GetName(),
 #if defined(__ITEM_APPLY_RANDOM__
@@ -2106,6 +2110,11 @@
 #endif
 
 	buyer->SetProtectTime("offline_shop_buy", get_global_time() + 2);
+
+	// Persist buyer changes quickly (gold/inventory) to minimize crash-based inconsistencies.
+	buyer->Save();
+	if (db_clientdesc)
+		db_clientdesc->FlushOutput();
 }
 
 LPITEM COfflineShop::BuyItem(DWORD buyerPID, uint16_t shopPosition)
--- a/server/metin2/Source/Server/game/src/affect.h
+++ b/server/metin2/Source/Server/game/src/affect.h
@@ -1,5 +1,10 @@
 #ifndef __INC_AFFECT_H__

 #define __INC_AFFECT_H__

+

+

+#ifndef MAX_AFFECT_PER_CHARACTER

+#define MAX_AFFECT_PER_CHARACTER 128

+#endif

 

 class CAffect

 {


--- a/server/metin2/Source/Server/game/src/battlepass_manager.cpp
+++ b/server/metin2/Source/Server/game/src/battlepass_manager.cpp
@@ -1274,10 +1274,11 @@
 		return;

 	}

 	

-	if(get_dword_time() < pkChar->GetLastReciveExtBattlePassInfoTime())

+	const DWORD dwNow = get_dword_time();

+	if ((int)(dwNow - pkChar->GetLastReciveExtBattlePassInfoTime()) < 0)

 		return;

 	

-	pkChar->SetLastReciveExtBattlePassInfoTime(get_dword_time() + 1000);

+	pkChar->SetLastReciveExtBattlePassInfoTime(dwNow + 1000);

 	

 	{

 		// --- NORMAL


--- a/server/metin2/Source/Server/game/src/char.cpp
+++ b/server/metin2/Source/Server/game/src/char.cpp
@@ -2117,6 +2117,11 @@
 {
 	assert(GetDesc() != NULL);
 
+	// IMPORTANT: avoid dangling DESC->m_lpCharacter if buffered packets arrive after logout begins.
+	// We keep CHARACTER<->DESC association (GetDesc()) intact, but make DESC::GetCharacter() return NULL immediately.
+	LPDESC pDesc = GetDesc();
+	pDesc->BindCharacter(NULL);
+
 	sys_log(0, "DISCONNECT: %s (%s)", GetName(), c_pszReason ? c_pszReason : "unset");
 
 	if (GetShop())
@@ -637,6 +637,9 @@
 #ifdef __OFFLINE_SHOP__
 	RemoveFromViewingOfflineShops();
 #endif
+	if (m_pWarMap)
+		SetWarMap(NULL);
+
 	if (m_pkRegen)
 	{
 		if (m_pkDungeon)
@@ -3747,7 +3747,10 @@
 	if (!GetSectree())
 		return false;
 
-	if (IsPC() && IsDead())
+	if (IsDestroyed())
+		return false;
+
+	if (IsDead())
 		return false;
 
 	LPSECTREE new_tree = SECTREE_MANAGER::instance().Get(GetMapIndex(), x, y);
@@ -350,6 +350,7 @@
 	SetPosition(POS_STANDING);

 

 	m_dwPlayStartTime = m_dwLastMoveTime = get_dword_time();

+	m_dwLastDiceTime = 0;

 #if defined(__LEFT_SEAT__)

 	m_dwLastRequestTime = get_dword_time();

 #endif

@@ -4172,7 +4173,7 @@
 	m_pointsInstant.points[wPointType] = lPointValue;

 

 	//  ̵  ȳٸ ̵ ð  ٽ ؾ Ѵ.

-	if (wPointType == POINT_MOV_SPEED && get_dword_time() < m_dwMoveStartTime + m_dwMoveDuration)

+	if (wPointType == POINT_MOV_SPEED && ((int)(get_dword_time() - (m_dwMoveStartTime + m_dwMoveDuration)) < 0))

 	{

 		CalculateMoveDuration();

 	}
@@ -4172,7 +4173,7 @@
 	m_pointsInstant.points[wPointType] = lPointValue;

 

 	//  ̵  ȳٸ ̵ ð  ٽ ؾ Ѵ.

-	if (wPointType == POINT_MOV_SPEED && get_dword_time() < m_dwMoveStartTime + m_dwMoveDuration)

+	if (wPointType == POINT_MOV_SPEED && ((int)(get_dword_time() - (m_dwMoveStartTime + m_dwMoveDuration)) < 0))

 	{

 		CalculateMoveDuration();

 	}


@@ -7188,13 +7188,37 @@
 	m_pkChrStone = NULL;
 }
 
-void CHARACTER::ClearTarget()
-{
-	if (m_pkChrTarget)
-	{
-		m_pkChrTarget->m_set_pkChrTargetedBy.erase(this);
-		m_pkChrTarget = NULL;
-	}
+
+LPCHARACTER CHARACTER::GetTargetSafe()
+{
+	if (!m_pkChrTarget)
+		return nullptr;
+
+	if (m_dwTargetVID == 0)
+		return m_pkChrTarget;
+
+	LPCHARACTER pkReal = CHARACTER_MANAGER::instance().Find(m_dwTargetVID);
+	if (pkReal != m_pkChrTarget)
+	{
+		// Target disappeared or was replaced; clear locally without dereferencing a stale pointer.
+		m_pkChrTarget = nullptr;
+		m_dwTargetVID = 0;
+		return nullptr;
+	}
+
+	return m_pkChrTarget;
+}
+
+void CHARACTER::ClearTarget()
+{
+	if (m_pkChrTarget)
+	{
+		LPCHARACTER pkReal = (m_dwTargetVID ? CHARACTER_MANAGER::instance().Find(m_dwTargetVID) : nullptr);
+		if (pkReal == m_pkChrTarget)
+			pkReal->m_set_pkChrTargetedBy.erase(this);
+		m_pkChrTarget = NULL;
+		m_dwTargetVID = 0;
+	}
 
 	TPacketGCTarget p;
 
@@ -7239,10 +7263,15 @@
 		return;
 	// CASTLE
 
-	if (m_pkChrTarget)
-		m_pkChrTarget->m_set_pkChrTargetedBy.erase(this);
-
-	m_pkChrTarget = pkChrTarget;
+	if (m_pkChrTarget)
+	{
+		LPCHARACTER pkReal = (m_dwTargetVID ? CHARACTER_MANAGER::instance().Find(m_dwTargetVID) : nullptr);
+		if (pkReal == m_pkChrTarget)
+			pkReal->m_set_pkChrTargetedBy.erase(this);
+	}
+
+	m_pkChrTarget = pkChrTarget;
+	m_dwTargetVID = m_pkChrTarget ? m_pkChrTarget->GetVID() : 0;
 
 	TPacketGCTarget p;
 
@@ -7478,14 +7507,15 @@
 	}
 }
 
-void CHARACTER::CheckTarget()
-{
-	if (!m_pkChrTarget)
-		return;
-
-	if (DISTANCE_APPROX(GetX() - m_pkChrTarget->GetX(), GetY() - m_pkChrTarget->GetY()) >= 4800)
-		SetTarget(NULL);
-}
+void CHARACTER::CheckTarget()
+{
+	LPCHARACTER pkTarget = GetTargetSafe();
+	if (!pkTarget)
+		return;
+
+	if (DISTANCE_APPROX(GetX() - pkTarget->GetX(), GetY() - pkTarget->GetY()) >= 4800)
+		SetTarget(NULL);
+}
 
 void CHARACTER::SetWarpLocation(long lMapIndex, long x, long y)
 {
--- a/server/metin2/Source/Server/game/src/char.h
+++ b/server/metin2/Source/Server/game/src/char.h
@@ -1292,6 +1292,8 @@
 	DWORD GetWalkStartTime() const { return m_dwWalkStartTime; }

 	DWORD GetLastMoveTime() const { return m_dwLastMoveTime; }

 	DWORD GetLastAttackTime() const { return m_dwLastAttackTime; }

+	DWORD GetLastDiceTime() const { return m_dwLastDiceTime; }

+	void SetLastDiceTime(DWORD dwTime) { m_dwLastDiceTime = dwTime; }

 

 	void SetLastAttacked(DWORD time); //  ݹ ð  ġ 

 

@@ -1340,6 +1342,7 @@
 

 	DWORD m_dwLastMoveTime;

 	DWORD m_dwLastAttackTime;

+	DWORD m_dwLastDiceTime;

 	DWORD m_dwWalkStartTime;

 	DWORD m_dwStopTime;

 


@@ -2153,6 +2153,7 @@
 	void ClearTarget();
 	void CheckTarget();
 	LPCHARACTER GetTarget() const { return m_pkChrTarget; }
+	LPCHARACTER GetTargetSafe();
 
 	////////////////////////////////////////////////////////////////////////////////////////
 	// Safebox

--- a/server/metin2/Source/Server/game/src/char_affect.cpp
+++ b/server/metin2/Source/Server/game/src/char_affect.cpp
@@ -394,8 +394,14 @@
 	TPacketGDAddAffect p = {};

 

 	AffectContainerList::iterator it = m_list_pkAffect.begin();

+	size_t __affect_save_count = 0;

 	while (it != m_list_pkAffect.end())

 	{

+		if (++__affect_save_count > MAX_AFFECT_PER_CHARACTER)

+		{

+			sys_err("Affect save truncated: %s has %zu affects", GetName(), m_list_pkAffect.size());

+			break;

+		}

 		CAffect* pkAff = *it++;

 		if (pkAff == nullptr)

 			continue;

@@ -691,6 +697,12 @@
 		//

 		// NOTE:   type ε  Ʈ   ִ.

 		//

+		if (m_list_pkAffect.size() >= MAX_AFFECT_PER_CHARACTER)

+		{

+			sys_err("Affect overflow blocked: %s has %zu affects (type %u)", GetName(), m_list_pkAffect.size(), dwType);

+			return false;

+		}

+

 		pkAff = CAffect::Acquire();

 		m_list_pkAffect.push_back(pkAff);

 	}
--- a/server/metin2/Source/Server/game/src/char_item.cpp
+++ b/server/metin2/Source/Server/game/src/char_item.cpp
@@ -8067,7 +8067,7 @@
 

 	if (0 != g_GoldDropTimeLimitValue)

 	{

-		if (get_dword_time() < m_dwLastGoldDropTime + g_GoldDropTimeLimitValue)

+		if ((int)(get_dword_time() - (m_dwLastGoldDropTime + g_GoldDropTimeLimitValue)) < 0)

 		{

 			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 带   ϴ."));

 			return false;

@@ -8133,7 +8133,7 @@
 

 	if (0 != g_ChequeDropTimeLimitValue)

 	{

-		if (get_dword_time() < m_dwLastChequeDropTime + g_ChequeDropTimeLimitValue)

+		if ((int)(get_dword_time() - (m_dwLastChequeDropTime + g_ChequeDropTimeLimitValue)) < 0)

 		{

 			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 带   ϴ."));

 			return false;


--- a/server/metin2/Source/Server/game/src/char_state.cpp
+++ b/server/metin2/Source/Server/game/src/char_state.cpp
@@ -576,7 +576,7 @@
 #if defined(__XMAS_EVENT_2008__)

 		if (GetRaceNum() == xmas::MOB_XMAS_SANTA_VNUM) // Ÿ

 		{

-			if (get_dword_time() > m_dwPlayStartTime)

+			if ((int)(get_dword_time() - m_dwPlayStartTime) > 0)

 			{

 				int next_warp_time = 2 * 1000; // 2

 

@@ -1310,7 +1310,7 @@
 

 		m_dwStateDuration = STATE_DURATION;

 	}

-	else if (bDoMoveAlone && (get_dword_time() > m_dwLastAttackTime))

+	else if (bDoMoveAlone && ((int)(get_dword_time() - m_dwLastAttackTime) > 0))

 	{

 		// wondering -.-

 		m_dwLastAttackTime = get_dword_time() + number(5000, 12000);


--- a/server/metin2/Source/Server/game/src/cmd_general.cpp
+++ b/server/metin2/Source/Server/game/src/cmd_general.cpp
@@ -2403,6 +2403,16 @@
 

 	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));

 

+	const DWORD DICE_COOLDOWN_MS = 7000;

+	const DWORD dwNow = get_dword_time();

+	if ((int)(dwNow - ch->GetLastDiceTime()) < (int)DICE_COOLDOWN_MS)

+	{

+		const int iSecLeft = (int)(((DICE_COOLDOWN_MS - (DWORD)(dwNow - ch->GetLastDiceTime())) + 999) / 1000);

+		ch->ChatPacket(CHAT_TYPE_INFO, "Please wait %d second(s) before using /dice again.", iSecLeft);

+		return;

+	}

+	ch->SetLastDiceTime(dwNow);

+

 	if (*arg1 && *arg2)

 	{

 		start = atoi(arg1);
--- a/server/metin2/Source/Server/game/src/dungeon.cpp
+++ b/server/metin2/Source/Server/game/src/dungeon.cpp
@@ -1322,12 +1322,13 @@
 	}
 
 	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
-	pDungeon->jump_to_event_ = NULL;
-
 	if (pDungeon)
+	{
+		pDungeon->jump_to_event_ = NULL;
 		pDungeon->JumpToEliminateLocation();
+	}
 	else
-		sys_err("cannot find dungeon with map index %u", info->dungeon_id);
+		sys_err("cannot find dungeon with id %u", info->dungeon_id);
 
 	return 0;
 }
@@ -1343,10 +1344,13 @@
 	}
 
 	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
-	pDungeon->exit_all_event_ = NULL;
-
 	if (pDungeon)
+	{
+		pDungeon->exit_all_event_ = NULL;
 		pDungeon->ExitAll();
+	}
+	else
+		sys_err("cannot find dungeon with id %u", info->dungeon_id);
 
 	return 0;
 }
--- a/server/metin2/Source/Server/game/src/entity.h
+++ b/server/metin2/Source/Server/game/src/entity.h
@@ -23,6 +23,7 @@
 	void SetType(int type);
 	int GetType() const;
 	bool IsType(int type) const;
+	bool IsDestroyed() const { return m_bIsDestroyed; }
 
 	void ViewCleanup();
 	void ViewInsert(LPENTITY entity, bool recursive = true);
--- a/server/metin2/Source/Server/game/src/entity_view.cpp
+++ b/server/metin2/Source/Server/game/src/entity_view.cpp
@@ -137,8 +137,11 @@
 	}
 };
 
-void CEntity::UpdateSectree()
-{
+void CEntity::UpdateSectree()
+{
+	if (m_bIsDestroyed)
+		return;
+
 	if (!GetSectree())
 	{
 		if (IsType(ENTITY_CHARACTER))
--- a/server/metin2/Source/Server/game/src/exchange.cpp
+++ b/server/metin2/Source/Server/game/src/exchange.cpp
@@ -236,6 +236,12 @@
 	if (item_pos.IsEquipPosition())
 		return false;
 
+	if (m_pGrid && display_pos >= m_pGrid->GetSize())
+	{
+		sys_err("EXCHANGE invalid display_pos %u", display_pos);
+		return false;
+	}
+
 	LPITEM item;
 
 	if (!(item = m_pOwner->GetItem(item_pos)))
--- a/server/metin2/Source/Server/game/src/input.cpp
+++ b/server/metin2/Source/Server/game/src/input.cpp
@@ -81,6 +81,8 @@
 			iPacketLen = 1;

 		else if (!m_pPacketInfo->Get(bHeader, &iPacketLen, &c_pszName))

 		{

+			c_pszName = "UNKNOWN";

+			r_iBytesProceed = m_iBufferLeft; // flush remaining bytes to avoid log-spam loops

 			sys_err("UNKNOWN HEADER: %d, LAST HEADER: %d(len:%d), %s, REMAIN BYTES: %d, fd: %d",

 				bHeader, bLastHeader, iLastPacketLen, c_pszName, m_iBufferLeft, lpDesc->GetSocket());
--- a/server/metin2/Source/Server/game/src/input_main.cpp
+++ b/server/metin2/Source/Server/game/src/input_main.cpp
@@ -2702,6 +2702,12 @@
 		return;
 	}
 
+	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInvite))
+	{
+		sys_err("PARTY_INVITE: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInvite));
+		return;
+	}
+
 	TPacketCGPartyInvite* p = (TPacketCGPartyInvite*)c_pData;
 
 	LPCHARACTER pInvitee = CHARACTER_MANAGER::instance().Find(p->vid);
@@ -2741,6 +2747,12 @@
 		return;
 	}
 
+	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInviteAnswer))
+	{
+		sys_err("PARTY_INVITE_ANSWER: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInviteAnswer));
+		return;
+	}
+
 	TPacketCGPartyInviteAnswer* p = (TPacketCGPartyInviteAnswer*)c_pData;
 
 	LPCHARACTER pInviter = CHARACTER_MANAGER::instance().Find(p->leader_vid);
@@ -4450,11 +4450,12 @@
 			return 0;

 

 		case 2:

-			if(get_dword_time() < ch->GetLastReciveExtBattlePassOpenRanking()) {

-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NEXT_REFRESH_RANKLIST_TIME"), ((ch->GetLastReciveExtBattlePassOpenRanking() - get_dword_time()) / 1000) + 1 );

+			const DWORD dwNow = get_dword_time();

+			if ((int)(dwNow - ch->GetLastReciveExtBattlePassOpenRanking()) < 0) {

+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NEXT_REFRESH_RANKLIST_TIME"), (((int)(ch->GetLastReciveExtBattlePassOpenRanking() - dwNow)) / 1000) + 1 );

 				return 0;

 			}

-			ch->SetLastReciveExtBattlePassOpenRanking(get_dword_time() + 10000);

+			ch->SetLastReciveExtBattlePassOpenRanking(dwNow + 10000);

 			

 			for (BYTE bBattlePassType = 1; bBattlePassType <= 3 ; ++bBattlePassType)

 			{


@@ -3595,7 +3595,17 @@
 	}
 
 	sys_log(0, "MyShop count %u", p->bCount);
-	ch->OpenMyShop(p->szSign, (TShopItemTable*)(c_pData + sizeof(TPacketCGMyShop)), p->bCount);
+
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+	strlcpy(szSign, p->szSign, sizeof(szSign));
+	for (size_t i = 0; i < sizeof(szSign) && szSign[i]; ++i)
+	{
+		const unsigned char c = static_cast<unsigned char>(szSign[i]);
+		if (c < 0x20 || c == 0x7F)
+			szSign[i] = ' ';
+	}
+
+	ch->OpenMyShop(szSign, (TShopItemTable*)(c_pData + sizeof(TPacketCGMyShop)), p->bCount);
 	return (iExtraLen);
 }
 
--- a/server/metin2/Source/Server/game/src/messenger_manager.cpp
+++ b/server/metin2/Source/Server/game/src/messenger_manager.cpp
@@ -4,6 +4,7 @@
 **/
 
 #include "stdafx.h"
+#include <vector>
 #include "messenger_manager.h"
 #include "char.h"
 #include "char_manager.h"
@@ -331,11 +332,19 @@
 
 	/* ���� �������ִ� ����Ʈ ���� */
 #if defined(__MESSENGER_DETAILS__)
+	std::vector<std::string> vNames;
+	vNames.reserve(m_map_strRelation[c_strAccount].size());
 	for (const RelationData& it : m_map_strRelation[c_strAccount])
-		RemoveFromList(c_strAccount, it.first);
+		vNames.emplace_back(it.first);
+	for (const std::string& name : vNames)
+		RemoveFromList(c_strAccount, name);
 #else
+	std::vector<std::string> vNames;
+	vNames.reserve(m_map_strRelation[c_strAccount].size());
 	for (const std::string& it : m_map_strRelation[c_strAccount])
-		RemoveFromList(c_strAccount, it);
+		vNames.emplace_back(it);
+	for (const std::string& name : vNames)
+		RemoveFromList(c_strAccount, name);
 #endif
 
 	/* ������ ����Ÿ ���� */
@@ -455,8 +464,12 @@
 		get_table_postfix(), c_strAccount.c_str(), c_strAccount.c_str());
 
 	/* ���� �������ִ� ����Ʈ ���� */
+	std::vector<std::string> vNames;
+	vNames.reserve(m_map_strBlockRelation[c_strAccount].size());
 	for (const std::string& it : m_map_strBlockRelation[c_strAccount])
-		RemoveFromBlockList(c_strAccount, it);
+		vNames.emplace_back(it);
+	for (const std::string& name : vNames)
+		RemoveFromBlockList(c_strAccount, name);
 
 	/* ������ ����Ÿ ���� */
 	m_map_strBlockRelation[c_strAccount].clear();
--- a/server/metin2/Source/Server/game/src/party.cpp
+++ b/server/metin2/Source/Server/game/src/party.cpp
@@ -1778,7 +1778,7 @@
 

 		if (m_bCanUsePartyHeal)

 		{

-			if (get_dword_time() > m_dwPartyHealTime + PartyHealCoolTime)

+			if ((int)(get_dword_time() - (m_dwPartyHealTime + PartyHealCoolTime)) > 0)

 			{

 				m_bPartyHealReady = true;

 


--- a/server/metin2/Source/Server/game/src/shop.cpp
+++ b/server/metin2/Source/Server/game/src/shop.cpp
@@ -1,4 +1,5 @@
 #include "stdafx.h"

+#include <limits>

 #include "../../libgame/include/grid.h"

 #include "constants.h"

 #include "utils.h"

@@ -310,12 +311,24 @@
 	DWORD dwCheque = r_item.cheque;

 #endif

 

+	// Overflow-safe price scaling (DWORD wraps at ~4.29B)

+	uint64_t ullPrice = static_cast<uint64_t>(dwPrice);

 	if (it->second) // if other empire, price is triple

-		dwPrice *= 3;

-

-	if (ch->GetGold() < dwPrice)

-	{

-		sys_log(1, "Shop::Buy : Not enough money : %s has %lld, price %u", ch->GetName(), ch->GetGold(), dwPrice);

+		ullPrice *= 3;

+	if (ullPrice > static_cast<uint64_t>(std::numeric_limits<DWORD>::max()))

+	{

+		LogManager::instance().HackLog("SHOP_BUY_PRICE_OVERFLOW", ch);

+		return SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY;

+	}

+	DWORD dwBuyerPrice = static_cast<DWORD>(ullPrice);

+	

+	// Preserve dwPrice as buyer price for checks; dwPrice will later be reused as seller gain (after tax)

+	dwPrice = dwBuyerPrice;

+

+

+	if (ch->GetGold() < dwBuyerPrice)

+	{

+		sys_log(1, "Shop::Buy : Not enough money : %s has %lld, price %u", ch->GetName(), ch->GetGold(), dwBuyerPrice);

 		return SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY;

 	}

 

@@ -377,7 +390,7 @@
 	}

 

 	if (dwPrice)

-		ch->PointChange(POINT_GOLD, -dwPrice, false);

+		ch->PointChange(POINT_GOLD, -static_cast<long long>(dwBuyerPrice), false);

 

 #if defined(__CHEQUE_SYSTEM__)

 	if (dwCheque)

@@ -395,13 +408,19 @@
 			if (iVal > 100)

 				iVal = 100;

 

-			dwTax = dwPrice * iVal / 100;

+			{

+				const uint64_t ullTax = (static_cast<uint64_t>(dwPrice) * static_cast<uint64_t>(iVal)) / 100;

+				dwTax = static_cast<DWORD>(MIN(ullTax, static_cast<uint64_t>(dwPrice)));

+			}

 			dwPrice = dwPrice - dwTax;

 		}

 		else

 		{

 			iVal = 3;

-			dwTax = dwPrice * iVal / 100;

+			{

+				const uint64_t ullTax = (static_cast<uint64_t>(dwPrice) * static_cast<uint64_t>(iVal)) / 100;

+				dwTax = static_cast<DWORD>(MIN(ullTax, static_cast<uint64_t>(dwPrice)));

+			}

 			dwPrice = dwPrice - dwTax;

 		}

 	}

@@ -414,7 +433,10 @@
 			if (iVal > 100)

 				iVal = 100;

 

-			dwTax = dwPrice * iVal / 100;

+			{

+				const uint64_t ullTax = (static_cast<uint64_t>(dwPrice) * static_cast<uint64_t>(iVal)) / 100;

+				dwTax = static_cast<DWORD>(MIN(ullTax, static_cast<uint64_t>(dwPrice)));

+			}

 			dwPrice = dwPrice - dwTax;

 		}

 		else
--- a/server/metin2/Source/Server/liblua/src/lib/lauxlib.c
+++ b/server/metin2/Source/Server/liblua/src/lib/lauxlib.c
@@ -565,7 +565,12 @@
 		if (lua_isfunction(L, -1))
 		{
 			lua_insert(L, -2);
-			lua_call(L, 1, 0);
+			if (lua_pcall(L, 1, 0, 0) != 0)
+			{
+				/* _ALERT failed; print its error and clear stack */
+				fprintf(stderr, "%s\n", lua_tostring(L, -1));
+				lua_pop(L, 1);
+			}
 		}
 		else { /* no _ALERT function; print it on stderr */
 			fprintf(stderr, "%s\n", lua_tostring(L, -2));
