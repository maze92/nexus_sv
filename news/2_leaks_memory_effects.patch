--- /mnt/data/orig/svnclient/Client/EffectLib/EffectInstance.h	2026-02-11 20:11:54.000000000 +0000
+++ /mnt/data/work/svnclient/Client/EffectLib/EffectInstance.h	2026-02-21 22:29:33.581494335 +0000
@@ -1,116 +1,117 @@
-#pragma once
-
-#include "../EterLib/GrpObjectInstance.h"
-#include "../EterLib/Pool.h"
-#include "../MilesLib/Type.h"
-
-#include "EffectElementBaseInstance.h"
-#include "EffectData.h"
-#include "EffectMeshInstance.h"
-#include "ParticleSystemInstance.h"
-#include "SimpleLightInstance.h"
-
-class CEffectInstance : public CGraphicObjectInstance
-{
-public:
-	typedef std::vector<CEffectElementBaseInstance*> TEffectElementInstanceVector;
-
-	enum
-	{
-		ID = EFFECT_OBJECT
-	};
-
-	int GetType() const
-	{
-		return CEffectInstance::ID;
-	}
-
-	bool GetBoundingSphere(D3DXVECTOR3& v3Center, float& fRadius);
-
-	static void DestroySystem();
-
-	static CEffectInstance* New();
-	static void Delete(CEffectInstance* pkEftInst);
-
-	static void ResetRenderingEffectCount();
-	static int GetRenderingEffectCount();
-
-public:
-	CEffectInstance();
-	virtual ~CEffectInstance();
-
-	bool LessRenderOrder(CEffectInstance* pkEftInst);
-
-	void SetEffectDataPointer(CEffectData* pEffectData);
-
-	void Clear();
-	BOOL isAlive();
-	void SetActive();
-	void SetDeactive();
-	void SetGlobalMatrix(const D3DXMATRIX& c_rmatGlobal);
-	void UpdateSound();
-	void OnUpdate();
-	void OnRender();
-	void OnBlendRender() {} // Not used
-	void OnRenderToShadowMap() {} // Not used
-	void OnRenderShadow() {} // Not used
-	void OnRenderPCBlocker() {} // Not used
-
-protected:
-	void __Initialize();
-
-	void __SetParticleData(CParticleSystemData* pData);
-	void __SetMeshData(CEffectMeshScript* pMesh);
-	void __SetLightData(CLightData* pData);
-
-	virtual void OnUpdateCollisionData(const CStaticCollisionDataVector* pscdVector) {} // Not used
-	virtual void OnUpdateHeighInstance(CAttributeInstance* pAttributeInstance) {}
-	virtual bool OnGetObjectHeight(float fX, float fY, float* pfHeight) { return false; }
-
-protected:
-	BOOL m_isAlive;
-	DWORD m_dwFrame;
-	D3DXMATRIX m_matGlobal;
-
-	CEffectData* m_pkEftData;
-
-	std::vector<CParticleSystemInstance*> m_ParticleInstanceVector;
-	std::vector<CEffectMeshInstance*> m_MeshInstanceVector;
-	std::vector<CLightInstance*> m_LightInstanceVector;
-
-	NSound::TSoundInstanceVector* m_pSoundInstanceVector;
-
-	float m_fBoundingSphereRadius;
-	D3DXVECTOR3 m_v3BoundingSpherePosition;
-
-	float m_fLastTime;
-
-public:
-	static CDynamicPool<CEffectInstance> ms_kPool;
-	static int ms_iRenderingEffectCount;
-
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-public:
-	void SetID(DWORD dwID);
-	DWORD GetID() const;
-	void SetRenderState(bool bCanRender);
-	bool CanRender() const;
-
-protected:
-	DWORD m_dwID;
-	bool m_bCanRender;
-#endif
-
-protected:
-	float m_fParticleScale;
-	D3DXVECTOR3 m_v3MeshScale;
-
-public:
-	void SetParticleScale(float fParticleScale) { m_fParticleScale = fParticleScale; }
-	float GetParticleScale() { return m_fParticleScale; }
-
-	void SetMeshScale(D3DXVECTOR3 rv3MeshScale) { m_v3MeshScale = rv3MeshScale; }
-	D3DXVECTOR3 GetMeshScale() { return m_v3MeshScale; }
-
-	const D3DXMATRIX& GetGlobalMatrix() const { return m_matGlobal; };
-};
+#pragma once
+
+#include "../EterLib/GrpObjectInstance.h"
+#include "../EterLib/Pool.h"
+#include "../MilesLib/Type.h"
+
+#include "EffectElementBaseInstance.h"
+#include "EffectData.h"
+#include "EffectMeshInstance.h"
+#include "ParticleSystemInstance.h"
+#include "SimpleLightInstance.h"
+
+class CEffectInstance : public CGraphicObjectInstance
+{
+public:
+	typedef std::vector<CEffectElementBaseInstance*> TEffectElementInstanceVector;
+
+	enum
+	{
+		ID = EFFECT_OBJECT
+	};
+
+	int GetType() const
+	{
+		return CEffectInstance::ID;
+	}
+
+	bool GetBoundingSphere(D3DXVECTOR3& v3Center, float& fRadius);
+
+	static void DestroySystem();
+
+	static CEffectInstance* New();
+	static void Delete(CEffectInstance* pkEftInst);
+
+	static void ResetRenderingEffectCount();
+	static int GetRenderingEffectCount();
+
+public:
+	CEffectInstance();
+	virtual ~CEffectInstance();
+
+	bool LessRenderOrder(CEffectInstance* pkEftInst);
+
+	void SetEffectDataPointer(CEffectData* pEffectData);
+
+	void Clear();
+	BOOL isAlive();
+	void SetActive();
+	void SetDeactive();
+	void SetGlobalMatrix(const D3DXMATRIX& c_rmatGlobal);
+	void UpdateSound();
+	void OnUpdate();
+	void OnRender();
+	void OnBlendRender() {} // Not used
+	void OnRenderToShadowMap() {} // Not used
+	void OnRenderShadow() {} // Not used
+	void OnRenderPCBlocker() {} // Not used
+
+protected:
+	void __Initialize();
+
+	void __SetParticleData(CParticleSystemData* pData);
+	void __SetMeshData(CEffectMeshScript* pMesh);
+	void __SetLightData(CLightData* pData);
+
+	virtual void OnUpdateCollisionData(const CStaticCollisionDataVector* pscdVector) {} // Not used
+	virtual void OnUpdateHeighInstance(CAttributeInstance* pAttributeInstance) {}
+	virtual bool OnGetObjectHeight(float fX, float fY, float* pfHeight) { return false; }
+
+protected:
+	BOOL m_isAlive;
+	DWORD m_dwFrame;
+	D3DXMATRIX m_matGlobal;
+
+	CEffectData* m_pkEftData;
+
+	std::vector<CParticleSystemInstance*> m_ParticleInstanceVector;
+	std::vector<CEffectMeshInstance*> m_MeshInstanceVector;
+	std::vector<CLightInstance*> m_LightInstanceVector;
+
+	NSound::TSoundInstanceVector* m_pSoundInstanceVector;
+
+	float m_fBoundingSphereRadius;
+	D3DXVECTOR3 m_v3BoundingSpherePosition;
+
+	float m_fLastTime;
+	float m_fOrphanSeconds;
+
+public:
+	static CDynamicPool<CEffectInstance> ms_kPool;
+	static int ms_iRenderingEffectCount;
+
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+public:
+	void SetID(DWORD dwID);
+	DWORD GetID() const;
+	void SetRenderState(bool bCanRender);
+	bool CanRender() const;
+
+protected:
+	DWORD m_dwID;
+	bool m_bCanRender;
+#endif
+
+protected:
+	float m_fParticleScale;
+	D3DXVECTOR3 m_v3MeshScale;
+
+public:
+	void SetParticleScale(float fParticleScale) { m_fParticleScale = fParticleScale; }
+	float GetParticleScale() { return m_fParticleScale; }
+
+	void SetMeshScale(D3DXVECTOR3 rv3MeshScale) { m_v3MeshScale = rv3MeshScale; }
+	D3DXVECTOR3 GetMeshScale() { return m_v3MeshScale; }
+
+	const D3DXMATRIX& GetGlobalMatrix() const { return m_matGlobal; };
+};
--- /mnt/data/orig/svnclient/Client/EffectLib/EffectInstance.cpp	2026-02-11 20:11:54.000000000 +0000
+++ /mnt/data/work/svnclient/Client/EffectLib/EffectInstance.cpp	2026-02-21 22:29:43.236926687 +0000
@@ -1,317 +1,334 @@
-#include "StdAfx.h"
-#include "EffectInstance.h"
-#include "ParticleSystemInstance.h"
-#include "SimpleLightInstance.h"
-
-#include "../EterBase/Stl.h"
-#include "../EterLib/StateManager.h"
-#include "../MilesLib/SoundManager.h"
-
-CDynamicPool<CEffectInstance> CEffectInstance::ms_kPool;
-int CEffectInstance::ms_iRenderingEffectCount = 0;
-
-bool CEffectInstance::LessRenderOrder(CEffectInstance* pkEftInst)
-{
-	return (m_pkEftData < pkEftInst->m_pkEftData);
-}
-
-void CEffectInstance::ResetRenderingEffectCount()
-{
-	ms_iRenderingEffectCount = 0;
-}
-
-int CEffectInstance::GetRenderingEffectCount()
-{
-	return ms_iRenderingEffectCount;
-}
-
-CEffectInstance* CEffectInstance::New()
-{
-	CEffectInstance* pkEftInst = ms_kPool.Alloc();
-	return pkEftInst;
-}
-
-void CEffectInstance::Delete(CEffectInstance* pkEftInst)
-{
-	pkEftInst->Clear();
-	ms_kPool.Free(pkEftInst);
-}
-
-void CEffectInstance::DestroySystem()
-{
-	ms_kPool.Destroy();
-
-	CParticleSystemInstance::DestroySystem();
-	CEffectMeshInstance::DestroySystem();
-	CLightInstance::DestroySystem();
-}
-
-void CEffectInstance::UpdateSound()
-{
-	if (m_pSoundInstanceVector)
-	{
-		CSoundManager& rkSndMgr = CSoundManager::Instance();
-		rkSndMgr.UpdateSoundInstance(m_matGlobal._41, m_matGlobal._42, m_matGlobal._43, m_dwFrame, m_pSoundInstanceVector);
-		// NOTE : ¸ÅÆ®¸¯½º¿¡¼­ À§Ä¡¸¦ Á÷Á¢ ¾ò¾î¿Â´Ù - [levites]
-	}
-	++m_dwFrame;
-}
-
-struct FEffectUpdator
-{
-	BOOL isAlive;
-	float fElapsedTime;
-	FEffectUpdator(float fElapsedTime)
-		: isAlive(FALSE), fElapsedTime(fElapsedTime)
-	{
-	}
-	void operator () (CEffectElementBaseInstance* pInstance)
-	{
-		if (pInstance->Update(fElapsedTime))
-			isAlive = TRUE;
-	}
-};
-
-void CEffectInstance::OnUpdate()
-{
-	Transform();
-
-	FEffectUpdator f(CTimer::Instance().GetCurrentSecond() - m_fLastTime);
-	f = std::for_each(m_ParticleInstanceVector.begin(), m_ParticleInstanceVector.end(), f);
-	f = std::for_each(m_MeshInstanceVector.begin(), m_MeshInstanceVector.end(), f);
-	f = std::for_each(m_LightInstanceVector.begin(), m_LightInstanceVector.end(), f);
-	m_isAlive = f.isAlive;
-
-	m_fLastTime = CTimer::Instance().GetCurrentSecond();
-}
-
-void CEffectInstance::OnRender()
-{
-	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_NONE);
-	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_NONE);
-	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
-	STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
-	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
-	STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, FALSE);
-	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
-	STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, FALSE);
-	/////
-
-	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
-	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
-	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
-	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
-	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
-	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
-	STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);
-	std::for_each(m_ParticleInstanceVector.begin(), m_ParticleInstanceVector.end(), std::mem_fn(&CEffectElementBaseInstance::Render));
-	std::for_each(m_MeshInstanceVector.begin(), m_MeshInstanceVector.end(), std::mem_fn(&CEffectElementBaseInstance::Render));
-
-	/////
-	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MINFILTER);
-	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MAGFILTER);
-	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);
-	STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);
-	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);
-	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);
-	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);
-	STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);
-
-	++ms_iRenderingEffectCount;
-}
-
-void CEffectInstance::SetGlobalMatrix(const D3DXMATRIX& c_rmatGlobal)
-{
-	m_matGlobal = c_rmatGlobal;
-}
-
-BOOL CEffectInstance::isAlive()
-{
-	return m_isAlive;
-}
-
-void CEffectInstance::SetActive()
-{
-	std::for_each(
-		m_ParticleInstanceVector.begin(),
-		m_ParticleInstanceVector.end(),
-		std::mem_fn(&CEffectElementBaseInstance::SetActive));
-	std::for_each(
-		m_MeshInstanceVector.begin(),
-		m_MeshInstanceVector.end(),
-		std::mem_fn(&CEffectElementBaseInstance::SetActive));
-	std::for_each(
-		m_LightInstanceVector.begin(),
-		m_LightInstanceVector.end(),
-		std::mem_fn(&CEffectElementBaseInstance::SetActive));
-}
-
-void CEffectInstance::SetDeactive()
-{
-	std::for_each(
-		m_ParticleInstanceVector.begin(),
-		m_ParticleInstanceVector.end(),
-		std::mem_fn(&CEffectElementBaseInstance::SetDeactive));
-	std::for_each(
-		m_MeshInstanceVector.begin(),
-		m_MeshInstanceVector.end(),
-		std::mem_fn(&CEffectElementBaseInstance::SetDeactive));
-	std::for_each(
-		m_LightInstanceVector.begin(),
-		m_LightInstanceVector.end(),
-		std::mem_fn(&CEffectElementBaseInstance::SetDeactive));
-}
-
-void CEffectInstance::__SetParticleData(CParticleSystemData* pData)
-{
-	CParticleSystemInstance* pInstance = CParticleSystemInstance::New();
-	pInstance->SetDataPointer(pData);
-	pInstance->SetLocalMatrixPointer(&m_matGlobal);
-	pInstance->SetParticleScale(m_fParticleScale);
-
-	m_ParticleInstanceVector.push_back(pInstance);
-}
-
-void CEffectInstance::__SetMeshData(CEffectMeshScript* pMesh)
-{
-	CEffectMeshInstance* pMeshInstance = CEffectMeshInstance::New();
-	pMeshInstance->SetDataPointer(pMesh);
-	pMeshInstance->SetLocalMatrixPointer(&m_matGlobal);
-	pMeshInstance->SetMeshScale(GetMeshScale());
-
-	m_MeshInstanceVector.push_back(pMeshInstance);
-}
-
-void CEffectInstance::__SetLightData(CLightData* pData)
-{
-	CLightInstance* pInstance = CLightInstance::New();
-	pInstance->SetDataPointer(pData);
-	pInstance->SetLocalMatrixPointer(&m_matGlobal);
-
-	m_LightInstanceVector.push_back(pInstance);
-}
-
-void CEffectInstance::SetEffectDataPointer(CEffectData* pEffectData)
-{
-	m_isAlive = TRUE;
-
-	m_pkEftData = pEffectData;
-
-	m_fLastTime = CTimer::Instance().GetCurrentSecond();
-	m_fBoundingSphereRadius = pEffectData->GetBoundingSphereRadius();
-	m_v3BoundingSpherePosition = pEffectData->GetBoundingSpherePosition();
-
-	if (m_fBoundingSphereRadius > 0.0f)
-		CGraphicObjectInstance::RegisterBoundingSphere();
-
-	DWORD i;
-
-	for (i = 0; i < pEffectData->GetParticleCount(); ++i)
-	{
-		CParticleSystemData* pParticle = pEffectData->GetParticlePointer(i);
-		__SetParticleData(pParticle);
-	}
-
-	for (i = 0; i < pEffectData->GetMeshCount(); ++i)
-	{
-		CEffectMeshScript* pMesh = pEffectData->GetMeshPointer(i);
-
-		__SetMeshData(pMesh);
-	}
-
-	for (i = 0; i < pEffectData->GetLightCount(); ++i)
-	{
-		CLightData* pLight = pEffectData->GetLightPointer(i);
-
-		__SetLightData(pLight);
-	}
-
-	m_pSoundInstanceVector = pEffectData->GetSoundInstanceVector();
-}
-
-bool CEffectInstance::GetBoundingSphere(D3DXVECTOR3& v3Center, float& fRadius)
-{
-	v3Center.x = m_matGlobal._41 + m_v3BoundingSpherePosition.x;
-	v3Center.y = m_matGlobal._42 + m_v3BoundingSpherePosition.y;
-	v3Center.z = m_matGlobal._43 + m_v3BoundingSpherePosition.z;
-	fRadius = m_fBoundingSphereRadius;
-	return true;
-}
-
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-void CEffectInstance::SetID(DWORD dwID)
-{
-	m_dwID = dwID;
-}
-
-DWORD CEffectInstance::GetID() const
-{
-	return m_dwID;
-}
-
-void CEffectInstance::SetRenderState(bool bCanRender)
-{
-	m_bCanRender = bCanRender;
-}
-
-bool CEffectInstance::CanRender() const
-{
-	return m_bCanRender;
-}
-#endif
-
-void CEffectInstance::Clear()
-{
-	if (!m_ParticleInstanceVector.empty())
-	{
-		std::for_each(m_ParticleInstanceVector.begin(), m_ParticleInstanceVector.end(), CParticleSystemInstance::Delete);
-		m_ParticleInstanceVector.clear();
-	}
-
-	if (!m_MeshInstanceVector.empty())
-	{
-		std::for_each(m_MeshInstanceVector.begin(), m_MeshInstanceVector.end(), CEffectMeshInstance::Delete);
-		m_MeshInstanceVector.clear();
-	}
-
-	if (!m_LightInstanceVector.empty())
-	{
-		std::for_each(m_LightInstanceVector.begin(), m_LightInstanceVector.end(), CLightInstance::Delete);
-		m_LightInstanceVector.clear();
-	}
-
-	__Initialize();
-}
-
-void CEffectInstance::__Initialize()
-{
-	m_isAlive = FALSE;
-	m_dwFrame = 0;
-	m_pSoundInstanceVector = NULL;
-	m_fBoundingSphereRadius = 0.0f;
-	m_v3BoundingSpherePosition.x = m_v3BoundingSpherePosition.y = m_v3BoundingSpherePosition.z = 0.0f;
-
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-	m_dwID = 0;
-	m_bCanRender = true;
-#endif
-
-	m_fParticleScale = 1.0f;
-	m_v3MeshScale.x = m_v3MeshScale.y = m_v3MeshScale.z = 1.0f;
-
-	m_pkEftData = NULL;
-
-	D3DXMatrixIdentity(&m_matGlobal);
-}
-
-CEffectInstance::CEffectInstance()
-{
-	__Initialize();
-}
-
-CEffectInstance::~CEffectInstance()
-{
-	assert(m_ParticleInstanceVector.empty());
-	assert(m_MeshInstanceVector.empty());
-	assert(m_LightInstanceVector.empty());
-}
+#include "StdAfx.h"
+#include "EffectInstance.h"
+#include "ParticleSystemInstance.h"
+#include "SimpleLightInstance.h"
+
+#include "../EterBase/Stl.h"
+#include "../EterLib/StateManager.h"
+#include "../MilesLib/SoundManager.h"
+
+CDynamicPool<CEffectInstance> CEffectInstance::ms_kPool;
+int CEffectInstance::ms_iRenderingEffectCount = 0;
+
+bool CEffectInstance::LessRenderOrder(CEffectInstance* pkEftInst)
+{
+	return (m_pkEftData < pkEftInst->m_pkEftData);
+}
+
+void CEffectInstance::ResetRenderingEffectCount()
+{
+	ms_iRenderingEffectCount = 0;
+}
+
+int CEffectInstance::GetRenderingEffectCount()
+{
+	return ms_iRenderingEffectCount;
+}
+
+CEffectInstance* CEffectInstance::New()
+{
+	CEffectInstance* pkEftInst = ms_kPool.Alloc();
+	return pkEftInst;
+}
+
+void CEffectInstance::Delete(CEffectInstance* pkEftInst)
+{
+	pkEftInst->Clear();
+	ms_kPool.Free(pkEftInst);
+}
+
+void CEffectInstance::DestroySystem()
+{
+	ms_kPool.Destroy();
+
+	CParticleSystemInstance::DestroySystem();
+	CEffectMeshInstance::DestroySystem();
+	CLightInstance::DestroySystem();
+}
+
+void CEffectInstance::UpdateSound()
+{
+	if (m_pSoundInstanceVector)
+	{
+		CSoundManager& rkSndMgr = CSoundManager::Instance();
+		rkSndMgr.UpdateSoundInstance(m_matGlobal._41, m_matGlobal._42, m_matGlobal._43, m_dwFrame, m_pSoundInstanceVector);
+		// NOTE : ï¿½ï¿½Æ®ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Â´ï¿½ - [levites]
+	}
+	++m_dwFrame;
+}
+
+struct FEffectUpdator
+{
+	BOOL isAlive;
+	float fElapsedTime;
+	FEffectUpdator(float fElapsedTime)
+		: isAlive(FALSE), fElapsedTime(fElapsedTime)
+	{
+	}
+	void operator () (CEffectElementBaseInstance* pInstance)
+	{
+		if (pInstance->Update(fElapsedTime))
+			isAlive = TRUE;
+	}
+};
+
+void CEffectInstance::OnUpdate()
+{
+	Transform();
+
+	FEffectUpdator f(CTimer::Instance().GetCurrentSecond() - m_fLastTime);
+	f = std::for_each(m_ParticleInstanceVector.begin(), m_ParticleInstanceVector.end(), f);
+	f = std::for_each(m_MeshInstanceVector.begin(), m_MeshInstanceVector.end(), f);
+	f = std::for_each(m_LightInstanceVector.begin(), m_LightInstanceVector.end(), f);
+	m_isAlive = f.isAlive;
+
+	// Orphan particle/effect watchdog:
+	// Some legacy effects can miss their Stop/Clear and keep rendering at (0,0,0) forever, leaking VRAM/CPU.
+	// If an effect stays close to origin for too long, kill it defensively.
+	static const float ORPHAN_TTL_SECONDS = 20.0f;
+	const float x = m_matGlobal._41;
+	const float y = m_matGlobal._42;
+	const float z = m_matGlobal._43;
+	const float nearOrigin = (x*x + y*y + z*z) < (50.0f * 50.0f); // within ~50 units of (0,0,0)
+	if (nearOrigin)
+		m_fOrphanSeconds += (CTimer::Instance().GetCurrentSecond() - m_fLastTime);
+	else
+		m_fOrphanSeconds = 0.0f;
+
+	if (m_fOrphanSeconds >= ORPHAN_TTL_SECONDS)
+		m_isAlive = FALSE;
+
+	m_fLastTime = CTimer::Instance().GetCurrentSecond();
+}
+
+void CEffectInstance::OnRender()
+{
+	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_NONE);
+	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_NONE);
+	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
+	STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
+	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
+	STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, FALSE);
+	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
+	STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, FALSE);
+	/////
+
+	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
+	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
+	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
+	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
+	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
+	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
+	STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);
+	std::for_each(m_ParticleInstanceVector.begin(), m_ParticleInstanceVector.end(), std::mem_fn(&CEffectElementBaseInstance::Render));
+	std::for_each(m_MeshInstanceVector.begin(), m_MeshInstanceVector.end(), std::mem_fn(&CEffectElementBaseInstance::Render));
+
+	/////
+	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MINFILTER);
+	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MAGFILTER);
+	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);
+	STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);
+	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);
+	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);
+	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);
+	STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);
+
+	++ms_iRenderingEffectCount;
+}
+
+void CEffectInstance::SetGlobalMatrix(const D3DXMATRIX& c_rmatGlobal)
+{
+	m_matGlobal = c_rmatGlobal;
+}
+
+BOOL CEffectInstance::isAlive()
+{
+	return m_isAlive;
+}
+
+void CEffectInstance::SetActive()
+{
+	std::for_each(
+		m_ParticleInstanceVector.begin(),
+		m_ParticleInstanceVector.end(),
+		std::mem_fn(&CEffectElementBaseInstance::SetActive));
+	std::for_each(
+		m_MeshInstanceVector.begin(),
+		m_MeshInstanceVector.end(),
+		std::mem_fn(&CEffectElementBaseInstance::SetActive));
+	std::for_each(
+		m_LightInstanceVector.begin(),
+		m_LightInstanceVector.end(),
+		std::mem_fn(&CEffectElementBaseInstance::SetActive));
+}
+
+void CEffectInstance::SetDeactive()
+{
+	std::for_each(
+		m_ParticleInstanceVector.begin(),
+		m_ParticleInstanceVector.end(),
+		std::mem_fn(&CEffectElementBaseInstance::SetDeactive));
+	std::for_each(
+		m_MeshInstanceVector.begin(),
+		m_MeshInstanceVector.end(),
+		std::mem_fn(&CEffectElementBaseInstance::SetDeactive));
+	std::for_each(
+		m_LightInstanceVector.begin(),
+		m_LightInstanceVector.end(),
+		std::mem_fn(&CEffectElementBaseInstance::SetDeactive));
+}
+
+void CEffectInstance::__SetParticleData(CParticleSystemData* pData)
+{
+	CParticleSystemInstance* pInstance = CParticleSystemInstance::New();
+	pInstance->SetDataPointer(pData);
+	pInstance->SetLocalMatrixPointer(&m_matGlobal);
+	pInstance->SetParticleScale(m_fParticleScale);
+
+	m_ParticleInstanceVector.push_back(pInstance);
+}
+
+void CEffectInstance::__SetMeshData(CEffectMeshScript* pMesh)
+{
+	CEffectMeshInstance* pMeshInstance = CEffectMeshInstance::New();
+	pMeshInstance->SetDataPointer(pMesh);
+	pMeshInstance->SetLocalMatrixPointer(&m_matGlobal);
+	pMeshInstance->SetMeshScale(GetMeshScale());
+
+	m_MeshInstanceVector.push_back(pMeshInstance);
+}
+
+void CEffectInstance::__SetLightData(CLightData* pData)
+{
+	CLightInstance* pInstance = CLightInstance::New();
+	pInstance->SetDataPointer(pData);
+	pInstance->SetLocalMatrixPointer(&m_matGlobal);
+
+	m_LightInstanceVector.push_back(pInstance);
+}
+
+void CEffectInstance::SetEffectDataPointer(CEffectData* pEffectData)
+{
+	m_isAlive = TRUE;
+
+	m_pkEftData = pEffectData;
+
+	m_fLastTime = CTimer::Instance().GetCurrentSecond();
+	m_fBoundingSphereRadius = pEffectData->GetBoundingSphereRadius();
+	m_v3BoundingSpherePosition = pEffectData->GetBoundingSpherePosition();
+
+	if (m_fBoundingSphereRadius > 0.0f)
+		CGraphicObjectInstance::RegisterBoundingSphere();
+
+	DWORD i;
+
+	for (i = 0; i < pEffectData->GetParticleCount(); ++i)
+	{
+		CParticleSystemData* pParticle = pEffectData->GetParticlePointer(i);
+		__SetParticleData(pParticle);
+	}
+
+	for (i = 0; i < pEffectData->GetMeshCount(); ++i)
+	{
+		CEffectMeshScript* pMesh = pEffectData->GetMeshPointer(i);
+
+		__SetMeshData(pMesh);
+	}
+
+	for (i = 0; i < pEffectData->GetLightCount(); ++i)
+	{
+		CLightData* pLight = pEffectData->GetLightPointer(i);
+
+		__SetLightData(pLight);
+	}
+
+	m_pSoundInstanceVector = pEffectData->GetSoundInstanceVector();
+}
+
+bool CEffectInstance::GetBoundingSphere(D3DXVECTOR3& v3Center, float& fRadius)
+{
+	v3Center.x = m_matGlobal._41 + m_v3BoundingSpherePosition.x;
+	v3Center.y = m_matGlobal._42 + m_v3BoundingSpherePosition.y;
+	v3Center.z = m_matGlobal._43 + m_v3BoundingSpherePosition.z;
+	fRadius = m_fBoundingSphereRadius;
+	return true;
+}
+
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+void CEffectInstance::SetID(DWORD dwID)
+{
+	m_dwID = dwID;
+}
+
+DWORD CEffectInstance::GetID() const
+{
+	return m_dwID;
+}
+
+void CEffectInstance::SetRenderState(bool bCanRender)
+{
+	m_bCanRender = bCanRender;
+}
+
+bool CEffectInstance::CanRender() const
+{
+	return m_bCanRender;
+}
+#endif
+
+void CEffectInstance::Clear()
+{
+	if (!m_ParticleInstanceVector.empty())
+	{
+		std::for_each(m_ParticleInstanceVector.begin(), m_ParticleInstanceVector.end(), CParticleSystemInstance::Delete);
+		m_ParticleInstanceVector.clear();
+	}
+
+	if (!m_MeshInstanceVector.empty())
+	{
+		std::for_each(m_MeshInstanceVector.begin(), m_MeshInstanceVector.end(), CEffectMeshInstance::Delete);
+		m_MeshInstanceVector.clear();
+	}
+
+	if (!m_LightInstanceVector.empty())
+	{
+		std::for_each(m_LightInstanceVector.begin(), m_LightInstanceVector.end(), CLightInstance::Delete);
+		m_LightInstanceVector.clear();
+	}
+
+	__Initialize();
+}
+
+void CEffectInstance::__Initialize()
+{
+	m_isAlive = FALSE;
+	m_dwFrame = 0;
+	m_pSoundInstanceVector = NULL;
+	m_fBoundingSphereRadius = 0.0f;
+	m_v3BoundingSpherePosition.x = m_v3BoundingSpherePosition.y = m_v3BoundingSpherePosition.z = 0.0f;
+
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+	m_dwID = 0;
+	m_bCanRender = true;
+#endif
+
+	m_fParticleScale = 1.0f;
+	m_v3MeshScale.x = m_v3MeshScale.y = m_v3MeshScale.z = 1.0f;
+
+	m_pkEftData = NULL;
+
+	D3DXMatrixIdentity(&m_matGlobal);
+}
+
+CEffectInstance::CEffectInstance()
+{
+	m_fOrphanSeconds = 0.0f;
+	__Initialize();
+}
+
+CEffectInstance::~CEffectInstance()
+{
+	assert(m_ParticleInstanceVector.empty());
+	assert(m_MeshInstanceVector.empty());
+	assert(m_LightInstanceVector.empty());
+}
