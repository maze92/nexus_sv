diff --git a/game/src/char.cpp b/game/src/char.cpp
index eb82266..bd412fa 100644
--- a/game/src/char.cpp
+++ b/game/src/char.cpp
@@ -1344,22 +1344,22 @@ void CHARACTER::Restart(BYTE bSubCMD)
 			sys_log(0, "do_restart: restart town");
 
 #if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-			if (GetGuildDragonLair())
-			{
-				const LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(MAP_N_FLAME_DRAGON);
-				if (pSectree != NULL)
-				{
-					Show(GetMapIndex(),
-						pSectree->m_setting.iBaseX + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "x") * 100,
-						pSectree->m_setting.iBaseY + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "y") * 100, 0);
-					Stop();
-				}
-				else
-					CGuildDragonLairManager::Instance().Exit(this);
-
+			if (GetGuildDragonLair())
+			{
+				const LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(MAP_N_FLAME_DRAGON);
+				if (pSectree != NULL)
+				{
+					Show(GetMapIndex(),
+						pSectree->m_setting.iBaseX + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "x") * 100,
+						pSectree->m_setting.iBaseY + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "y") * 100, 0);
+					Stop();
+				}
+				else
+					CGuildDragonLairManager::Instance().Exit(this);
+
 				PointChange(POINT_HP, 50 - GetHP());
-				DeathPenalty(1);
-				return;
+				DeathPenalty(1);
+				return;
 			}
 #endif
 
@@ -1788,8 +1788,8 @@ void CHARACTER::UpdatePacket()
 #endif
 	pack.bPKMode = m_bPKMode;
 	pack.dwMountVnum = GetMountVnum();
-#if defined(__LEFT_SEAT__)
-	pack.bLeftSeat = IsPC() ? LeftSeat() : false;
+#if defined(__LEFT_SEAT__)
+	pack.bLeftSeat = IsPC() ? LeftSeat() : false;
 #endif
 
 #if defined(__GUILD_LEADER_GRADE_NAME__)
@@ -5942,6 +5942,40 @@ void CHARACTER::MonsterLog(const char* format, ...)
 	CHARACTER_MANAGER::instance().PacketMonsterLog(this, buf.read_peek(), buf.size());
 }
 
+
+// Defensive sanitization for text sent to clients.
+// Prevents rare client hard-freezes caused by control characters / invalid sequences for the active code page.
+static inline void __SanitizeOutgoingText(char* buf, size_t bufSize)
+{
+	if (!buf || bufSize == 0)
+		return;
+
+	size_t w = 0;
+	for (size_t r = 0; r < bufSize && buf[r] != '\0'; ++r)
+	{
+		unsigned char c = (unsigned char)buf[r];
+
+		if (c == '\n' || c == '\r' || c == '\t')
+		{
+			buf[w++] = (char)c;
+			continue;
+		}
+
+		// Keep bytes >= 0x80 intact (multi-byte codepages). Only neutralize control chars.
+		if (c < 0x20 || c == 0x7F)
+		{
+			buf[w++] = ' ';
+			continue;
+		}
+
+		buf[w++] = (char)c;
+	}
+
+	if (w >= bufSize)
+		w = bufSize - 1;
+	buf[w] = '\0';
+}
+
 void CHARACTER::ChatPacket(BYTE type, const char* format, ...)
 {
 	LPDESC d = GetDesc();
@@ -5956,6 +5990,9 @@ void CHARACTER::ChatPacket(BYTE type, const char* format, ...)
 	int len = vsnprintf(chatbuf, sizeof(chatbuf), format, args);
 	va_end(args);
 
+	__SanitizeOutgoingText(chatbuf, sizeof(chatbuf));
+	len = (int)strlen(chatbuf);
+
 	struct packet_chat pack_chat;
 
 	pack_chat.header = HEADER_GC_CHAT;
@@ -5989,6 +6026,9 @@ void CHARACTER::ChatPacket(packet_chat pack_chat, const char* format, ...)
 	int len = vsnprintf(chatbuf, sizeof(chatbuf), format, args);
 	va_end(args);
 
+	__SanitizeOutgoingText(chatbuf, sizeof(chatbuf));
+	len = (int)strlen(chatbuf);
+
 	pack_chat.header = HEADER_GC_CHAT;
 	pack_chat.size = sizeof(struct packet_chat) + len;
 	pack_chat.id = 0;
@@ -6234,35 +6274,35 @@ void CHARACTER::SetPart(BYTE bPartPos, DWORD dwVal)
 
 DWORD CHARACTER::GetPart(BYTE bPartPos) const
 {
-	assert(bPartPos < PART_MAX_NUM);
-#if defined(__HIDE_COSTUME_SYSTEM__)
-	if (bPartPos == PART_MAIN && GetHiddenCostumeByPart(PART_MAIN))
-	{
-		if (const LPITEM pArmor = GetWear(WEAR_BODY))
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			return pArmor->GetTransmutationVnum() != 0 ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
-#else
-			return pArmor->GetVnum();
-#endif
-		else
-			return 0;
-	}
-	else if (bPartPos == PART_WEAPON && GetHiddenCostumeByPart(PART_WEAPON))
-	{
-		if (const LPITEM pWeapon = GetWear(WEAR_WEAPON))
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			return pWeapon->GetTransmutationVnum() != 0 ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
-#else
-			return pWeapon->GetVnum();
-#endif
-		else
-			return 0;
-	}
-	else
-	{
-		if (GetHiddenCostumeByPart(bPartPos))
-			return 0;
-	}
+	assert(bPartPos < PART_MAX_NUM);
+#if defined(__HIDE_COSTUME_SYSTEM__)
+	if (bPartPos == PART_MAIN && GetHiddenCostumeByPart(PART_MAIN))
+	{
+		if (const LPITEM pArmor = GetWear(WEAR_BODY))
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			return pArmor->GetTransmutationVnum() != 0 ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
+#else
+			return pArmor->GetVnum();
+#endif
+		else
+			return 0;
+	}
+	else if (bPartPos == PART_WEAPON && GetHiddenCostumeByPart(PART_WEAPON))
+	{
+		if (const LPITEM pWeapon = GetWear(WEAR_WEAPON))
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			return pWeapon->GetTransmutationVnum() != 0 ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
+#else
+			return pWeapon->GetVnum();
+#endif
+		else
+			return 0;
+	}
+	else
+	{
+		if (GetHiddenCostumeByPart(bPartPos))
+			return 0;
+	}
 #endif
 	return m_pointsInstant.adwParts[bPartPos];
 }
@@ -8490,31 +8530,31 @@ void CHARACTER::ResetExp()
 #if defined(__CONQUEROR_LEVEL__)
 void CHARACTER::ResetConquerorPoint(int iLv)
 {
-	PointChange(POINT_CONQUEROR_LEVEL, MINMAX(0, iLv, gPlayerMaxConquerorLevel) - GetConquerorLevel());
-
-	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
-	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
-
-	SetRealPoint(POINT_CONQUEROR_POINT, MINMAX(0, (iLv * 4) - 4, (4 * (gPlayerMaxConquerorLevel - 1))));
-	SetPoint(POINT_CONQUEROR_POINT, GetRealPoint(POINT_CONQUEROR_POINT));
-
-	SetRealPoint(POINT_SUNGMA_STR, 0);
-	SetPoint(POINT_SUNGMA_STR, GetRealPoint(POINT_SUNGMA_STR));
-
-	SetRealPoint(POINT_SUNGMA_HP, 0);
-	SetPoint(POINT_SUNGMA_HP, GetRealPoint(POINT_SUNGMA_HP));
-
-	SetRealPoint(POINT_SUNGMA_MOVE, 0);
-	SetPoint(POINT_SUNGMA_MOVE, GetRealPoint(POINT_SUNGMA_MOVE));
-
-	SetRealPoint(POINT_SUNGMA_IMMUNE, 0);
-	SetPoint(POINT_SUNGMA_IMMUNE, GetRealPoint(POINT_SUNGMA_IMMUNE));
-
-	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
-	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
-
-	ComputePoints();
-	PointsPacket();
+	PointChange(POINT_CONQUEROR_LEVEL, MINMAX(0, iLv, gPlayerMaxConquerorLevel) - GetConquerorLevel());
+
+	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
+	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
+
+	SetRealPoint(POINT_CONQUEROR_POINT, MINMAX(0, (iLv * 4) - 4, (4 * (gPlayerMaxConquerorLevel - 1))));
+	SetPoint(POINT_CONQUEROR_POINT, GetRealPoint(POINT_CONQUEROR_POINT));
+
+	SetRealPoint(POINT_SUNGMA_STR, 0);
+	SetPoint(POINT_SUNGMA_STR, GetRealPoint(POINT_SUNGMA_STR));
+
+	SetRealPoint(POINT_SUNGMA_HP, 0);
+	SetPoint(POINT_SUNGMA_HP, GetRealPoint(POINT_SUNGMA_HP));
+
+	SetRealPoint(POINT_SUNGMA_MOVE, 0);
+	SetPoint(POINT_SUNGMA_MOVE, GetRealPoint(POINT_SUNGMA_MOVE));
+
+	SetRealPoint(POINT_SUNGMA_IMMUNE, 0);
+	SetPoint(POINT_SUNGMA_IMMUNE, GetRealPoint(POINT_SUNGMA_IMMUNE));
+
+	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
+	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
+
+	ComputePoints();
+	PointsPacket();
 
 	LogManager::instance().CharLog(this, 0, "RESET_CONQUEROR_POINT", "");
 }
@@ -8686,7 +8726,7 @@ void CHARACTER::MonsterChat(BYTE bMonsterChatType)
 
 	std::string text = quest::ScriptToString(sbuf);
 	if (text.empty())
-		return;
+		return;
 
 	TPacketGCChat pack_chat;
 	pack_chat.header = HEADER_GC_CHAT;
@@ -8979,11 +9019,11 @@ void CHARACTER::SendEquipment(LPCHARACTER pChar)
 #if defined(__CHANGE_LOOK_SYSTEM__)
 			Packet.Equips[bSlotIdx].dwTransmutationVnum = pItem->GetTransmutationVnum();
 #endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			thecore_memcpy(&Packet.Equips[bSlotIdx].RefineElement, pItem->GetRefineElement(), sizeof(Packet.Equips[bSlotIdx].RefineElement));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			thecore_memcpy(&Packet.Equips[bSlotIdx].RefineElement, pItem->GetRefineElement(), sizeof(Packet.Equips[bSlotIdx].RefineElement));
 #endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			thecore_memcpy(Packet.Equips[bSlotIdx].aApplyRandom, pItem->GetRandomApplies(), sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
+#if defined(__ITEM_APPLY_RANDOM__)
+			thecore_memcpy(Packet.Equips[bSlotIdx].aApplyRandom, pItem->GetRandomApplies(), sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
 #endif
 #if defined(__SET_ITEM__)
 			Packet.Equips[bSlotIdx].bSetValue = pItem->GetItemSetValue();
@@ -8993,16 +9033,16 @@ void CHARACTER::SendEquipment(LPCHARACTER pChar)
 		{
 			Packet.Equips[bSlotIdx].dwVnum = 0;
 			Packet.Equips[bSlotIdx].bCount = 0;
-			memset(&Packet.Equips[bSlotIdx].alSockets, 0, sizeof(Packet.Equips[bSlotIdx].alSockets));
+			memset(&Packet.Equips[bSlotIdx].alSockets, 0, sizeof(Packet.Equips[bSlotIdx].alSockets));
 			memset(&Packet.Equips[bSlotIdx].aAttr, 0, sizeof(Packet.Equips[bSlotIdx].aAttr));
 #if defined(__CHANGE_LOOK_SYSTEM__)
 			Packet.Equips[bSlotIdx].dwTransmutationVnum = 0;
 #endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			memset(&Packet.Equips[bSlotIdx].RefineElement, 0, sizeof(Packet.Equips[bSlotIdx].RefineElement));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			memset(&Packet.Equips[bSlotIdx].RefineElement, 0, sizeof(Packet.Equips[bSlotIdx].RefineElement));
 #endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			memset(&Packet.Equips[bSlotIdx].aApplyRandom, 0, sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
+#if defined(__ITEM_APPLY_RANDOM__)
+			memset(&Packet.Equips[bSlotIdx].aApplyRandom, 0, sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
 #endif
 #if defined(__SET_ITEM__)
 			Packet.Equips[bSlotIdx].bSetValue = 0;
@@ -10741,17 +10781,17 @@ EVENTFUNC(hit_buff_event)
 	const long buff_value = 30;
 	std::unordered_map<WORD, WORD> map_buff_point
 	{
-		{ POINT_HIT_BUFF_ENCHANT_FIRE, POINT_ENCHANT_FIRE },
-		{ POINT_HIT_BUFF_ENCHANT_ICE, POINT_ENCHANT_ICE },
-		{ POINT_HIT_BUFF_ENCHANT_ELEC, POINT_ENCHANT_ELECT },
-		{ POINT_HIT_BUFF_ENCHANT_WIND, POINT_ENCHANT_WIND },
-		{ POINT_HIT_BUFF_ENCHANT_DARK, POINT_ENCHANT_DARK },
-		{ POINT_HIT_BUFF_ENCHANT_EARTH, POINT_ENCHANT_EARTH },
-		{ POINT_HIT_BUFF_RESIST_FIRE, POINT_ENCHANT_FIRE },
-		{ POINT_HIT_BUFF_RESIST_ICE, POINT_RESIST_ICE },
-		{ POINT_HIT_BUFF_RESIST_ELEC, POINT_RESIST_ELEC },
-		{ POINT_HIT_BUFF_RESIST_WIND, POINT_RESIST_WIND },
-		{ POINT_HIT_BUFF_RESIST_DARK, POINT_RESIST_DARK },
+		{ POINT_HIT_BUFF_ENCHANT_FIRE, POINT_ENCHANT_FIRE },
+		{ POINT_HIT_BUFF_ENCHANT_ICE, POINT_ENCHANT_ICE },
+		{ POINT_HIT_BUFF_ENCHANT_ELEC, POINT_ENCHANT_ELECT },
+		{ POINT_HIT_BUFF_ENCHANT_WIND, POINT_ENCHANT_WIND },
+		{ POINT_HIT_BUFF_ENCHANT_DARK, POINT_ENCHANT_DARK },
+		{ POINT_HIT_BUFF_ENCHANT_EARTH, POINT_ENCHANT_EARTH },
+		{ POINT_HIT_BUFF_RESIST_FIRE, POINT_ENCHANT_FIRE },
+		{ POINT_HIT_BUFF_RESIST_ICE, POINT_RESIST_ICE },
+		{ POINT_HIT_BUFF_RESIST_ELEC, POINT_RESIST_ELEC },
+		{ POINT_HIT_BUFF_RESIST_WIND, POINT_RESIST_WIND },
+		{ POINT_HIT_BUFF_RESIST_DARK, POINT_RESIST_DARK },
 		{ POINT_HIT_BUFF_RESIST_EARTH, POINT_RESIST_EARTH },
 
 		{ POINT_HIT_BUFF_SUNGMA_STR, POINT_SUNGMA_STR },
@@ -10850,7 +10890,7 @@ void CHARACTER::SetEventRaceNum(DWORD dwRaceNum)
 
 	sys_log(0, "EVENT_RACE: %s race %u ", GetName(), dwRaceNum);
 
-	SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_SPAWN);
+	SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_SPAWN);
 	m_afAffectFlag.Set(AFF_SPAWN);
 
 	ViewReencode();
@@ -10861,35 +10901,35 @@ void CHARACTER::SetEventRaceNum(DWORD dwRaceNum)
 }
 #endif
 
-#if defined(__HIDE_COSTUME_SYSTEM__)
-void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave)
-{
-	switch (bCostumeSubType)
-	{
-		case COSTUME_BODY:
-		case COSTUME_HAIR:
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_ACCE:
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_WEAPON:
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_AURA:
-#endif
-			break;
-
-		default:
-		{
-			sys_err("CHARACTER::SetHiddenCostumePart: %s cannot hide unknown costume sub type %u",
-				GetName(), bCostumeSubType);
-			return;
-		}
-	}
-
+#if defined(__HIDE_COSTUME_SYSTEM__)
+void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave)
+{
+	switch (bCostumeSubType)
+	{
+		case COSTUME_BODY:
+		case COSTUME_HAIR:
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_ACCE:
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_WEAPON:
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_AURA:
+#endif
+			break;
+
+		default:
+		{
+			sys_err("CHARACTER::SetHiddenCostumePart: %s cannot hide unknown costume sub type %u",
+				GetName(), bCostumeSubType);
+			return;
+		}
+	}
+
 	if (IsDead() || IsWarping())
-		return;
-
+		return;
+
 	bool bAttacking = (get_dword_time() - GetLastAttackTime()) < 1500;
 	bool bMoving = (get_dword_time() - GetLastMoveTime()) < 1500;
 	bool bDelayedCMD = false;
@@ -10898,8 +10938,8 @@ void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bS
 	{
 		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have to stand still to hide your costume."));
 		return;
-	}
-
+	}
+
 	int iPulse = thecore_pulse();
 	if (iPulse - m_dwHideCostumePulse < passes_per_sec * 3)
 	{
@@ -10907,16 +10947,16 @@ void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bS
 		return;
 	}
 
-	m_dwHideCostumePulse = thecore_pulse();
+	m_dwHideCostumePulse = thecore_pulse();
 	m_bHiddenCostumePart[bCostumeSubType] = bHidden;
 
 	if (bSave)
 		SetQuestFlag(HiddenCostumePartMap[bCostumeSubType], bHidden ? 1 : 0);
 
-	UpdatePacket();
-
-	ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", bCostumeSubType, bHidden ? 1 : 0);
-}
+	UpdatePacket();
+
+	ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", bCostumeSubType, bHidden ? 1 : 0);
+}
 
 bool CHARACTER::CheckComboFlood(DWORD dwTime)
 {
@@ -10942,63 +10982,63 @@ bool CHARACTER::CheckComboFlood(DWORD dwTime)
 
 	return false;
 }
-
-bool CHARACTER::GetHiddenCostumeByPart(BYTE bPartPos) const
-{
-	switch (bPartPos)
-	{
-		case PART_MAIN:
-			if (m_bHiddenCostumePart[COSTUME_BODY] && GetWear(WEAR_COSTUME_BODY))
-				return true;
-			break;
-
-		case PART_HAIR:
-			if (m_bHiddenCostumePart[COSTUME_HAIR] && GetWear(WEAR_COSTUME_HAIR))
-				return true;
-			break;
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case PART_ACCE:
-			if (m_bHiddenCostumePart[COSTUME_ACCE] && GetWear(WEAR_COSTUME_ACCE))
-				return true;
-			break;
-#endif
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		case PART_WEAPON:
-			if (m_bHiddenCostumePart[COSTUME_WEAPON] && GetWear(WEAR_COSTUME_WEAPON))
-				return true;
-			break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-		case PART_AURA:
-			if (m_bHiddenCostumePart[COSTUME_AURA] && GetWear(WEAR_COSTUME_AURA))
-				return true;
-			break;
-#endif
-
-		default:
-			return false;
-	}
-
-	return false;
-}
-
-void CHARACTER::SetHiddenCostumeParts()
-{
-	bool bHidden = false;
-	for (const THiddenCostumePartMap::value_type& it : HiddenCostumePartMap)
-	{
-		bHidden = (GetQuestFlag(it.second) != 0 ? 1 : 0);
-		m_bHiddenCostumePart[it.first] = bHidden;
-
-		ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", it.first, static_cast<BYTE>(bHidden));
-	}
-}
-#endif
-
-#if defined(__MYSHOP_DECO__)
+
+bool CHARACTER::GetHiddenCostumeByPart(BYTE bPartPos) const
+{
+	switch (bPartPos)
+	{
+		case PART_MAIN:
+			if (m_bHiddenCostumePart[COSTUME_BODY] && GetWear(WEAR_COSTUME_BODY))
+				return true;
+			break;
+
+		case PART_HAIR:
+			if (m_bHiddenCostumePart[COSTUME_HAIR] && GetWear(WEAR_COSTUME_HAIR))
+				return true;
+			break;
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case PART_ACCE:
+			if (m_bHiddenCostumePart[COSTUME_ACCE] && GetWear(WEAR_COSTUME_ACCE))
+				return true;
+			break;
+#endif
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		case PART_WEAPON:
+			if (m_bHiddenCostumePart[COSTUME_WEAPON] && GetWear(WEAR_COSTUME_WEAPON))
+				return true;
+			break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+		case PART_AURA:
+			if (m_bHiddenCostumePart[COSTUME_AURA] && GetWear(WEAR_COSTUME_AURA))
+				return true;
+			break;
+#endif
+
+		default:
+			return false;
+	}
+
+	return false;
+}
+
+void CHARACTER::SetHiddenCostumeParts()
+{
+	bool bHidden = false;
+	for (const THiddenCostumePartMap::value_type& it : HiddenCostumePartMap)
+	{
+		bHidden = (GetQuestFlag(it.second) != 0 ? 1 : 0);
+		m_bHiddenCostumePart[it.first] = bHidden;
+
+		ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", it.first, static_cast<BYTE>(bHidden));
+	}
+}
+#endif
+
+#if defined(__MYSHOP_DECO__)
 void CHARACTER::OpenPrivateShop(BYTE bTabCount, bool bIsCashItem)
 {
 	if (bTabCount > MYSHOP_MAX_TABS)
@@ -11028,172 +11068,172 @@ void CHARACTER::OpenPrivateShop(BYTE bTabCount, bool bIsCashItem)
 		GetDesc()->BufferedPacket(&Packet, sizeof(TPacketGCShop));
 		GetDesc()->Packet(&Packet2, sizeof(TPacketGCMyPrivShopOpen));
 	}
-}
-#endif
-
-#if defined(__LEFT_SEAT__)
-EVENTFUNC(left_seat_wait_timer_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-	if (info == NULL)
-	{
-		sys_err("left_seat_wait_timer_event> <Factor> Null pointer");
-		return 0;
-	}
-
+}
+#endif
+
+#if defined(__LEFT_SEAT__)
+EVENTFUNC(left_seat_wait_timer_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+	if (info == NULL)
+	{
+		sys_err("left_seat_wait_timer_event> <Factor> Null pointer");
+		return 0;
+	}
+
 	LPCHARACTER ch = info->ch;
 	if (ch == NULL) // <Factor>
-		return 0;
-
-	if (ch->GetMyShop())
-		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-
-	if (ch->IsRunningQuest())
-		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-
-	if (get_dword_time() - ch->GetLastRequestTime() > 1000 * ch->GetLeftSeatWaitTime())
-	{
-		if (ch->LeftSeat() == false)
-		{
-			ch->SetLeftSeat(true);
-
-			if (ch->GetLeftSeatLogoutTime())
-				ch->RestartLeftSeatLogoutTimer();
-		}
-	}
-
-	return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-}
-
-void CHARACTER::RestartLeftSeatWaitTimer()
-{
-	if (m_pLeftSeatWaitTimerEvent)
-		event_cancel(&m_pLeftSeatWaitTimerEvent);
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-	info->ch = this;
-	m_pLeftSeatWaitTimerEvent = event_create(left_seat_wait_timer_event, info, PASSES_PER_SEC(LEFT_SEAT_PULSE));
-}
-
-void CHARACTER::SetLeftSeatWaitTime(BYTE bIndex)
-{
-	DWORD dwTime = 0;
-	switch (bIndex)
-	{
-		case LEFT_SEAT_TIME_10_MIN:
-			dwTime = 60 * 10;
-			break;
-		case LEFT_SEAT_TIME_30_MIN:
-			dwTime = 60 * 30;
-			break;
-		case LEFT_SEAT_TIME_90_MIN:
-			dwTime = 60 * 90;
-			break;
-		default:
-			dwTime = 60 * 10;
-			break;
-	}
-
-	//if (test_server)
-	//	dwTime = 10;
-
-	m_dwLeftSeatWaitTime = dwTime;
-	RestartLeftSeatWaitTimer();
-}
-
-EVENTFUNC(left_seat_logout_timer_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-	if (info == NULL)
-	{
-		sys_err("left_seat_logout_timer_event> <Factor> Null pointer");
-		return 0;
-	}
-
+		return 0;
+
+	if (ch->GetMyShop())
+		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+
+	if (ch->IsRunningQuest())
+		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+
+	if (get_dword_time() - ch->GetLastRequestTime() > 1000 * ch->GetLeftSeatWaitTime())
+	{
+		if (ch->LeftSeat() == false)
+		{
+			ch->SetLeftSeat(true);
+
+			if (ch->GetLeftSeatLogoutTime())
+				ch->RestartLeftSeatLogoutTimer();
+		}
+	}
+
+	return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+}
+
+void CHARACTER::RestartLeftSeatWaitTimer()
+{
+	if (m_pLeftSeatWaitTimerEvent)
+		event_cancel(&m_pLeftSeatWaitTimerEvent);
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+	info->ch = this;
+	m_pLeftSeatWaitTimerEvent = event_create(left_seat_wait_timer_event, info, PASSES_PER_SEC(LEFT_SEAT_PULSE));
+}
+
+void CHARACTER::SetLeftSeatWaitTime(BYTE bIndex)
+{
+	DWORD dwTime = 0;
+	switch (bIndex)
+	{
+		case LEFT_SEAT_TIME_10_MIN:
+			dwTime = 60 * 10;
+			break;
+		case LEFT_SEAT_TIME_30_MIN:
+			dwTime = 60 * 30;
+			break;
+		case LEFT_SEAT_TIME_90_MIN:
+			dwTime = 60 * 90;
+			break;
+		default:
+			dwTime = 60 * 10;
+			break;
+	}
+
+	//if (test_server)
+	//	dwTime = 10;
+
+	m_dwLeftSeatWaitTime = dwTime;
+	RestartLeftSeatWaitTimer();
+}
+
+EVENTFUNC(left_seat_logout_timer_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+	if (info == NULL)
+	{
+		sys_err("left_seat_logout_timer_event> <Factor> Null pointer");
+		return 0;
+	}
+
 	LPCHARACTER ch = info->ch;
 	if (ch == NULL) // <Factor>
-		return 0;
-
-	LPDESC d = ch->GetDesc();
-	if (ch->LeftSeat())
+		return 0;
+
+	LPDESC d = ch->GetDesc();
+	if (ch->LeftSeat())
 	{
 		ch->Disconnect("LEFT_SEAT");
 		if (d)
-			d->SetPhase(PHASE_CLOSE);
-	}
-
-	return 0;
-}
-
-void CHARACTER::RestartLeftSeatLogoutTimer()
-{
-	if (m_pLeftSeatLogoutTimerEvent)
-		event_cancel(&m_pLeftSeatLogoutTimerEvent);
-
-	const DWORD dwTime = GetLeftSeatLogoutTime();
-	if (dwTime == 0)
-		return;
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-	info->ch = this;
-	m_pLeftSeatLogoutTimerEvent = event_create(left_seat_logout_timer_event, info, PASSES_PER_SEC(dwTime));
-}
-
-void CHARACTER::SetLeftSeatLogoutTime(BYTE bIndex)
-{
-	DWORD dwTime = 0;
-	switch (bIndex)
-	{
-		case LEFT_SEAT_LOGOUT_TIME_30_MIN:
-			dwTime = 60 * 30;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_60_MIN:
-			dwTime = 60 * 60;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_120_MIN:
-			dwTime = 60 * 120;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_180_MIN:
-			dwTime = 60 * 180;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_OFF:
-			dwTime = 0;
-			break;
-		default:
-			dwTime = 60 * 30;
-			break;
-	}
-
-	//if (test_server)
-	//	dwTime = 10;
-
-	m_dwLeftSeatLogoutTime = dwTime;
-}
-
-void CHARACTER::DisableLeftSeatLogOutState(bool bClosePopup)
-{
-	if (bClosePopup)
-		ChatPacket(CHAT_TYPE_COMMAND, "CloseLeftSeatDialog");
-
-	if (m_pLeftSeatLogoutTimerEvent)
-		event_cancel(&m_pLeftSeatLogoutTimerEvent);
-
-	m_dwLastRequestTime = get_dword_time();
-
-	SetLeftSeat(false);
-	RestartLeftSeatWaitTimer();
-}
-
-void CHARACTER::SetLeftSeat(bool bLeftSeat)
-{
-	if (bLeftSeat)
-		ChatPacket(CHAT_TYPE_COMMAND, "OpenLeftSeatDialog");
-
-	m_bLeftSeat = bLeftSeat;
-	UpdatePacket();
-}
-#endif
-
+			d->SetPhase(PHASE_CLOSE);
+	}
+
+	return 0;
+}
+
+void CHARACTER::RestartLeftSeatLogoutTimer()
+{
+	if (m_pLeftSeatLogoutTimerEvent)
+		event_cancel(&m_pLeftSeatLogoutTimerEvent);
+
+	const DWORD dwTime = GetLeftSeatLogoutTime();
+	if (dwTime == 0)
+		return;
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+	info->ch = this;
+	m_pLeftSeatLogoutTimerEvent = event_create(left_seat_logout_timer_event, info, PASSES_PER_SEC(dwTime));
+}
+
+void CHARACTER::SetLeftSeatLogoutTime(BYTE bIndex)
+{
+	DWORD dwTime = 0;
+	switch (bIndex)
+	{
+		case LEFT_SEAT_LOGOUT_TIME_30_MIN:
+			dwTime = 60 * 30;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_60_MIN:
+			dwTime = 60 * 60;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_120_MIN:
+			dwTime = 60 * 120;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_180_MIN:
+			dwTime = 60 * 180;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_OFF:
+			dwTime = 0;
+			break;
+		default:
+			dwTime = 60 * 30;
+			break;
+	}
+
+	//if (test_server)
+	//	dwTime = 10;
+
+	m_dwLeftSeatLogoutTime = dwTime;
+}
+
+void CHARACTER::DisableLeftSeatLogOutState(bool bClosePopup)
+{
+	if (bClosePopup)
+		ChatPacket(CHAT_TYPE_COMMAND, "CloseLeftSeatDialog");
+
+	if (m_pLeftSeatLogoutTimerEvent)
+		event_cancel(&m_pLeftSeatLogoutTimerEvent);
+
+	m_dwLastRequestTime = get_dword_time();
+
+	SetLeftSeat(false);
+	RestartLeftSeatWaitTimer();
+}
+
+void CHARACTER::SetLeftSeat(bool bLeftSeat)
+{
+	if (bLeftSeat)
+		ChatPacket(CHAT_TYPE_COMMAND, "OpenLeftSeatDialog");
+
+	m_bLeftSeat = bLeftSeat;
+	UpdatePacket();
+}
+#endif
+
 #if defined(__ELEMENTAL_DUNGEON__)
 EVENTFUNC(elemental_curse_event)
 {
@@ -11213,7 +11253,7 @@ EVENTFUNC(elemental_curse_event)
 
 	// NOTE : Increase the hp reduction level every 200.000 damage.
 	int iReductionLevel = MINMAX(1, dwAccumulatedDamage / 200000, 10);
-	int iDropHP = static_cast<int>(ch->GetMaxHP() * (fReductionPct[iReductionLevel - 1] / 100.0f));
+	int iDropHP = static_cast<int>(ch->GetMaxHP() * (fReductionPct[iReductionLevel - 1] / 100.0f));
 
 	CAffect* pAffect = ch->FindAffect(AFFECT_CURSE_OF_ELEMENTAL);
 	if (pAffect == NULL || iReductionLevel > pAffect->lApplyValue)
diff --git a/game/src/input_main.cpp b/game/src/input_main.cpp
index 1234302..7687725 100644
--- a/game/src/input_main.cpp
+++ b/game/src/input_main.cpp
@@ -315,6 +315,39 @@ int ProcessTextTag(LPCHARACTER ch, const char* c_pszText, size_t len)
 	return 4;
 }
 
+
+static inline void __SanitizeNetworkText(char* buf, size_t bufSize)
+{
+	if (!buf || bufSize == 0)
+		return;
+
+	size_t w = 0;
+	for (size_t r = 0; r < bufSize && buf[r] != '\0'; ++r)
+	{
+		unsigned char c = (unsigned char)buf[r];
+
+		// Allow basic whitespace controls.
+		if (c == '\n' || c == '\r' || c == '\t')
+		{
+			buf[w++] = (char)c;
+			continue;
+		}
+
+		// Neutralize other control chars (keeps bytes >= 0x80 intact for multi-byte codepages).
+		if (c < 0x20 || c == 0x7F)
+		{
+			buf[w++] = ' ';
+			continue;
+		}
+
+		buf[w++] = (char)c;
+	}
+
+	if (w >= bufSize)
+		w = bufSize - 1;
+	buf[w] = '\0';
+}
+
 int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
 {
 	const TPacketCGWhisper* pinfo = reinterpret_cast<const TPacketCGWhisper*>(data);
@@ -498,7 +531,8 @@ int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
 
 			char buf[CHAT_MAX_LEN + 1];
 			strlcpy(buf, data + sizeof(TPacketCGWhisper), MIN(iExtraLen + 1, sizeof(buf)));
-			const size_t buflen = strlen(buf);
+						__SanitizeNetworkText(buf, sizeof(buf));
+const size_t buflen = strlen(buf);
 
 			//if (true == SpamBlockCheck(ch, buf, buflen))
 			//{
@@ -777,7 +811,8 @@ int CInputMain::Chat(LPCHARACTER ch, const char* data, size_t uiBytes)
 
 	char buf[CHAT_MAX_LEN - (CHARACTER_NAME_MAX_LEN + 3) + 1];
 	strlcpy(buf, data + sizeof(TPacketCGChat), MIN(iExtraLen + 1, sizeof(buf)));
-	const size_t buflen = strlen(buf);
+		__SanitizeNetworkText(buf, sizeof(buf));
+const size_t buflen = strlen(buf);
 
 	if (buflen > 1 && *buf == '/')
 	{

diff --git a/EterLib/GrpTextInstance.cpp b/EterLib/GrpTextInstance.cpp
index 8d6f8de..cf5b7e0 100644
--- a/EterLib/GrpTextInstance.cpp
+++ b/EterLib/GrpTextInstance.cpp
@@ -2034,13 +2034,61 @@ void CGraphicTextInstance::SetLimitWidth(float fWidth)
 	m_fLimitWidth = fWidth;
 }
 
+
+// Sanitizes text before it reaches width/layout calculation. This mitigates rare hard-locks when invalid
+// byte sequences are rendered under the active Windows code page.
+static inline void SanitizeTextForRender(std::string& s)
+{
+#if defined(_WIN32)
+	const UINT cp = GetACP();
+	for (size_t i = 0; i < s.size(); )
+	{
+		unsigned char c = (unsigned char)s[i];
+
+		// Keep basic whitespace; neutralize other control chars.
+		if (c < 0x20)
+		{
+			if (c != '\n' && c != '\r' && c != '\t')
+				s[i] = ' ';
+			++i;
+			continue;
+		}
+		if (c == 0x7F)
+		{
+			s[i] = ' ';
+			++i;
+			continue;
+		}
+
+		// For DBCS codepages (e.g., 949), ensure we never leave a dangling lead byte.
+		if (IsDBCSLeadByteEx(cp, c))
+		{
+			if (i + 1 >= s.size())
+			{
+				s[i] = '?';
+				break;
+			}
+			// Accept the pair as-is (do not attempt deep validation here).
+			i += 2;
+			continue;
+		}
+
+		++i;
+	}
+#else
+	(void)s;
+#endif
+}
+
 void CGraphicTextInstance::SetValueString(const std::string& c_stValue)
 {
 	if (0 == m_stText.compare(c_stValue))
 		return;
 
 	m_stText = c_stValue;
-	m_isUpdate = false;
+	
+	SanitizeTextForRender(m_stText);
+m_isUpdate = false;
 
 #if defined(WJ_MULTI_TEXTLINE)
 	CheckMultiLine();
@@ -2053,7 +2101,9 @@ void CGraphicTextInstance::SetValue(const char* c_szText, size_t len)
 		return;
 
 	m_stText = c_szText;
-	m_isUpdate = false;
+	
+	SanitizeTextForRender(m_stText);
+m_isUpdate = false;
 
 #if defined(WJ_MULTI_TEXTLINE)
 	CheckMultiLine();
